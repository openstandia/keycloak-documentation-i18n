msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"POT-Creation-Date: 2017-09-20 08:59+0000\n"
"PO-Revision-Date: 2017-09-20 05:24-0400\n"
"Last-Translator: wadahiro <wadahiro@gmail.com>\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: crowdin.com\n"
"X-Crowdin-Project: keycloak-documentation-i18n\n"
"X-Crowdin-Language: ja\n"
"X-Crowdin-File: /master/i18n/pot/server_admin__topics__threat__compromised-tokens.pot\n"

#. type: Title ===
#: source/server_admin/topics/threat/compromised-tokens.adoc:2
#, no-wrap
msgid "Compromised Access and Refresh Tokens"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/threat/compromised-tokens.adoc:5
#, no-wrap
msgid "There are a few things you can do to mitigate access tokens and refresh tokens from being stolen. The most important thing is to enforce SSL/HTTPS communication between {project_name} and its clients and applications. It might seem obvious, but since {project_name} does not have SSL enabled by default, an administrator might not realize that it is necessary.\n"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/threat/compromised-tokens.adoc:8
#, no-wrap
msgid "Another thing you can do to mitigate leaked access tokens is to shorten their lifespans.  You can specify this within the <<_timeouts, timeouts page>>.\n"
"Short lifespans (minutes) for access tokens for clients and applications to refresh their access tokens after a short amount of time. If an admin detects a leak, they can logout all user sessions to invalidate these refresh tokens or set up a revocation policy. Making sure refresh tokens always stay private to the client and are never transmitted ever is very important as well.\n"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/threat/compromised-tokens.adoc:11
#, no-wrap
msgid "If an access token or refresh token is compromised, the first thing you should do is go to the admin console and push a not-before revocation policy to all applications. This will enforce that any tokens issued prior to that date are now invalid. Pushing new not-before policy will also ensure that application will be forced to download new public keys from {project_name}, hence it is also useful for the case, when you think that realm signing key was compromised.\n"
"More info in the  <<realm_keys, keys chapter>>.\n"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/threat/compromised-tokens.adoc:13
#, no-wrap
msgid "You can also disable specific applications, clients, and users if you feel that any one of those entities is completely compromised.\n"
msgstr ""

