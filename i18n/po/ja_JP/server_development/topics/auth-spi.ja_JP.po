# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"Last-Translator: Kohei Tamura <ktamura.biz.80@gmail.com>, 2017\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: delimited block -
#, no-wrap
msgid "    }\n"
msgstr "}\n"

#. type: Title ====
#, no-wrap
msgid "Packaging Classes and Deployment"
msgstr "クラスとデプロイのパッケージ化"

#. type: Title ==
#, no-wrap
msgid "Authentication SPI"
msgstr "認証SPI"

#. type: Plain text
msgid ""
"Keycloak comes out of the box with a bunch of different authentication "
"mechanisms: kerberos, password, and otp.  These mechanisms may not meet all "
"of your requirements and you may want to plug in your own custom ones.  "
"Keycloak provides an authentication SPI that you can use to write new "
"plugins.  The admin console supports applying, ordering, and configuring "
"these new mechanisms."
msgstr ""
"Keycloakには、ケルベロス、パスワード、OTPなどのさまざまな認証機構が用意されています。これらの機構は、要件をすべて満たしているわけではなく、独自のカスタムプラグインを必要とする場合もあります。Keycloakは、新しいプラグインの作成に使用できる認証SPIを提供します。管理コンソールは、これらの新しい機構の適用、順序、設定をサポートしています。"

#. type: Plain text
msgid ""
"Keycloak also supports a simple registration form.  Different aspects of "
"this form can be enabled and disabled i.e.  Recaptcha support can be turned "
"off and on.  The same authentication SPI can be used to add another page to "
"the registration flow or reimplement it entirely.  There's also an "
"additional fine-grain SPI you can use to add specific validations and user "
"extensions to the built in registration form."
msgstr ""
"Keycloakでは簡単な登録フォームもサポートされます。このフォームのさまざまな要素を有効、無効にすることができます。つまり、reCAPTCHAのサポートをオフにすることができます。同じ認証SPIを使用して、他のページを登録フローに追加したり、それを完全に再実装することができます。また、追加の細かいSPIを使用して、組み込みの登録フォームに特定のバリデーションやユーザー拡張機能を追加することもできます。"

#. type: Plain text
msgid ""
"A required action in Keycloak is an action that a user has to perform after "
"he authenticates.  After the action is performed successfully, the user "
"doesn't have to perform the action again.  Keycloak comes with some built in"
" required actions like \"reset password\".  This action forces the user to "
"change their password after they have logged in.  You can write and plug in "
"your own required actions."
msgstr ""
"Keycloakでの必須アクションとは、認証後にユーザーが実行する必要のあるアクションのことです。アクションが実行された後、ユーザーはそのアクションを再実行する必要はありません。Keycloakには、\"パスワードリセット\"などの必須アクションがいくつか組み込まれています。たとえば、パスワードリセットは、ユーザーがログインした後にパスワードを変更するよう強制します。必須アクションを作成してプラグインすることができます。"

#. type: Title ===
#, no-wrap
msgid "Terms"
msgstr "用語"

#. type: Plain text
msgid ""
"To first learn about the Authentication SPI, let's go over some of the terms"
" used to describe it."
msgstr "まず最初に、認証SPIについて学ぶには、それを説明するためのいくつかの用語を確認していきます。"

#. type: Labeled list
#, no-wrap
msgid "Authentication Flow"
msgstr "認証フロー"

#. type: Plain text
msgid ""
"A flow is a container for all authentications that must happen during login "
"or registration.  If you go to the admin console authentication page, you "
"can view all the defined flows in the system and what authenticators they "
"are made up of.  Flows can contain other flows.  You can also bind a new "
"different flow for browser login, direct grant access, and registration."
msgstr ""
"フローは、ログインまたは登録中に発生する必要のある、すべての認証のためのコンテナーです。管理コンソールの認証ページに移動すると、システム内で定義されたすべてのフローと、どのようなオーセンティケーターで構成されたかが表示されます。フローには、他のフローを含めることができます。また、ブラウザーのログイン、ダイレクト・グラント・アクセス、および登録用に、新しい異なるフローをバインドすることもできます。"

#. type: Labeled list
#, no-wrap
msgid "Authenticator"
msgstr "オーセンティケーター"

#. type: Plain text
msgid ""
"An authenticator is a pluggable component that hold the logic for performing"
" the authentication or action within a flow.  It is usually a singleton."
msgstr ""
"オーセンティケーターは、フロー内で認証またはアクションを実行するためのロジックを保持する、プラグイン可能なコンポーネントです。通常は、シングルトンです。"

#. type: Labeled list
#, no-wrap
msgid "Execution"
msgstr "エグゼキューション"

#. type: Plain text
msgid ""
"An execution is an object that binds the authenticator to the flow and the "
"authenticator to the configuration of the authenticator.  Flows contain "
"execution entries."
msgstr ""
"エグゼキューションは、オーセンティケーターをフローにバインドしたり、オーセンティケーターの設定に対する認証を行うオブジェクトです。フローには、エグゼキューション・エントリーが含まれます。"

#. type: Labeled list
#, no-wrap
msgid "Execution Requirement"
msgstr "エグゼキューション要件"

#. type: Plain text
msgid ""
"Each execution defines how an authenticator behaves in a flow.  The "
"requirement defines whether the authenticator is enabled, disabled, "
"optional, required, or an alternative.  An alternative requirement means "
"that the authentiactor is optional unless no other alternative authenticator"
" is successful in the flow.  For example, cookie authentication, kerberos, "
"and the set of all login forms are all alternative.  If one of those is "
"successful, none of the others are executed."
msgstr ""
"エグゼキューションごとに、オーセンティケーターがフロー内でどのように動作するかを定義します。要件には、オーセンティケーターがenabledか、disabledか、optionalか、requiredか、またはalternativeかを定義します。alternativeの要件では、フロー内で他のalternativeのオーセンティケーターが成功しない限り、そのオーセンティケーターはoptionalであることを意味します。たとえば、Cookie認証、ケルベロス、ログイン画面のセットは、すべてalternativeです。そのうちの1つが成功した場合、他は実行されません。"

#. type: Labeled list
#, no-wrap
msgid "Authenticator Config"
msgstr "オーセンティケーター設定"

#. type: Plain text
msgid ""
"This object defines the configuration for the Authenticator for a specific "
"execution within an authentication flow.  Each execution can have a "
"different config."
msgstr ""
"このオブジェクトは、認証フロー内の特定のエグゼキューションに対してのオーセンティケーターの設定を定義します。エグゼキューションごとに異なる設定を持つことができます。"

#. type: Labeled list
#, no-wrap
msgid "Required Action"
msgstr "必須アクション"

#. type: Plain text
#, no-wrap
msgid ""
"After authentication completes, the user might have one or more one-time actions he must complete before he is allowed to login.\n"
"The user might be required to set up an OTP token generator or reset an expired password or even accept a Terms and Conditions document.         \n"
msgstr ""
"認証が完了した後、ログインが許可される前に、ユーザーは、１つ以上のワンタイム・アクションを実行しなければならない場合があります。ユーザーは、OTPトークン・ジェネレーターを設定するか、有効期限切れのパスワードをリセットするか、または利用規約に同意する必要があります。\n"

#. type: Title ===
#, no-wrap
msgid "Algorithm Overview"
msgstr "アルゴリズムの概要"

#. type: Plain text
msgid ""
"Let's talk about how this all works for browser login.  Let's assume the "
"following flows, executions and sub flows."
msgstr "これがブラウザー・ログインでどのように機能するか説明します。以下のフロー、エグゼキューション、サブフローを想定してみましょう。"

#. type: delimited block -
#, no-wrap
msgid ""
"Cookie - ALTERNATIVE\n"
"Kerberos - ALTERNATIVE\n"
"Forms Subflow - ALTERNATIVE\n"
"           Username/Password Form - REQUIRED\n"
"           OTP Password Form - OPTIONAL\n"
msgstr ""
"Cookie - ALTERNATIVE\n"
"Kerberos - ALTERNATIVE\n"
"Forms Subflow - ALTERNATIVE\n"
"           Username/Password Form - REQUIRED\n"
"           OTP Password Form - OPTIONAL\n"

#. type: Plain text
msgid ""
"In the top level of the form we have 3 executions of which all are "
"alternatively required.  This means that if any of these are successful, "
"then the others do not have to execute.  The Username/Password form is not "
"executed if there is an SSO Cookie set or a successful Kerberos login.  "
"Let's walk through the steps from when a client first redirects to keycloak "
"to authenticate the user."
msgstr ""
"フォームのトップレベルには、すべてが選択的に必要な3つのエグゼキューションがあります。これらのいずれかが成功した場合、ほかは実行する必要がないことを意味します。SSO"
" "
"Cookieセットまたはケルベロスのログインが成功した場合、Username/Passwordフォームは実行されません。クライアントが最初にKeycloakにリダイレクトし、ユーザーを認証するまでの手順を説明します。"

#. type: Plain text
msgid ""
"The OpenID Connect or SAML protocol provider unpacks relevent data, verifies"
" the client and any signatures.  It creates a AuthenticationSessionModel.  "
"It looks up what the browser flow should be, then starts executing the flow."
msgstr ""
"OpenID "
"ConnectまたはSAMLプロトコル・プロバイダーは、関連するデータを展開し、クライアントと署名を検証します。AuthenticationSessionModelを作成します。ブラウザーフローを検索し、フローの実行を開始します。"
" "

#. type: Plain text
msgid ""
"The flow looks at the cookie execution and sees that it is an alternative.  "
"It loads the cookie provider.  It checks to see if the cookie provider "
"requires that a user already be associated with the authentication session."
"  Cookie provider does not require a user.  If it did, the flow would abort "
"and the user would see an error screen.  Cookie provider then executes.  Its"
" purpose is to see if there is an SSO cookie set.  If there is one set, it "
"is validated and the UserSessionModel is verified and associated with the "
"AuthenticationSessionModel.  The Cookie provider returns a success() status "
"if the SSO cookie exists and is validated.  Since the cookie provider "
"returned success and each execution at this level of the flow is "
"ALTERNATIVE, no other execution is executed and this results in a successful"
" login.  If there is no SSO cookie, the cookie provider returns with a "
"status of attempted().  This means there was no error condition, but no "
"success either.  The provider tried, but the request just wasn't set up to "
"handle this authenticator."
msgstr ""
"このフローは、Cookieのエグゼキューションから、それがALTERNATIVEであると見なします。Cookieプロバイダーがロードされ、ユーザーがすでに認証セッションに関連付けられているかをチェックします。Cookieプロバイダーには、ユーザーは必要ありません。必要とされる場合は、そのフローが中断され、ユーザーにはエラー画面が表示されます。その後、SSO"
" Cookieセットがあるかどうかを確認することを目的として、Cookieプロバイダーが実行されます。1つのセットがある場合、そのSSO "
"CookieとUserSessionModelが検証され、AuthenticationSessionModelに関連付けられます。SSO "
"Cookieが存在し、検証が済むと、Cookieプロバイダーはsuccess()ステータスを返します。Cookieプロバイダーは成功を返すと、このフローのレベルでのそれぞれのエグゼキューションはALTERNATIVEであるため、他のエグゼキューションは実行されず、ログインに成功します。SSO"
" "
"Cookieが存在しない場合は、Cookieプロバイダーはattempted()のステータスを返します。この場合、エラー状態ではありませんが、成功でもないことを示します。プロバイダーを試してきましたが、リクエストはこのオーセンティケーターを処理するようには設定されていません。"

#. type: Plain text
msgid ""
"Next the flow looks at the Kerberos execution.  This is also an alternative."
"  The kerberos provider also does not require a user to be already set up "
"and associated with the AuthenticationSessionModel so this provider is "
"executed.  Kerberos uses the SPNEGO browser protocol.  This requires a "
"series of challenge/responses between the server and client exchanging "
"negotiation headers.  The kerberos provider does not see any negotiate "
"header, so it assumes that this is the first interaction between the server "
"and client.  It therefore creates an HTTP challenge response to the client "
"and sets a forceChallenge() status.  A forceChallenge() means that this HTTP"
" response cannot be ignored by the flow and must be returned to the client."
"  If instead the provider returned a challenge() status, the flow would hold"
" the challenge response until all other alternatives are attempted.  So, in "
"this initial phase, the flow would stop and the challenge response would be "
"sent back to the browser.  If the browser then responds with a successful "
"negotiate header, the provider associates the user with the "
"AuthenticationSession and the flow ends because the rest of the executions "
"on this level of the flow are all alternatives.  Otherwise, again, the "
"kerberos provider sets an attempted() status and the flow continues."
msgstr ""
"次に、ケルベロスのエグゼキューションのフローを見ていきます。これもまたALTERNATIVEです。ケルベロス・プロバイダーは、ユーザーがすでに設定されていて、AuthenticationSessionModelに関連付けられている必要はないので、このプロバイダーを実行できます。ケルベロスは、SPNEGOブラウザー・プロトコルを使用します。これには、サーバーとクライアントがネゴシエーション・ヘッダーを交換する一連のチャレンジまたはレスポンスが必要となります。ケルベロス・プロバイダーは、ネゴシエーション・ヘッダーを見ないため、サーバーとクライアント間の最初のやりとりであることを前提とします。したがって、クライアントへのHTTPチャレンジ・レスポンスを作成し、forceChallenge()ステータスを設定します。forceChallenge()は、フローによってHTTPレスポンスを無視できないことを意味し、クライアントに返さなければなりません。代わりにプロバイダーがchallenge()ステータスを返した場合、フローは他のすべてのALTERNATIVEが試行されるまでチャレンジ・レスポンスを保持します。したがって、この初期フェーズでは、フローが停止し、チャレンジ・レスポンスがブラウザーに返されます。ブラウザーが成功したネゴシエーション・ヘッダーで応答すると、プロバイダーはユーザーをAuthenticationSessionに関連付けし、このフローのレベルの残りのエグゼキューションはALTERNATIVEであるため、フローが終了します。それ以外の場合は、ケルベロス・プロバイダーは、attempted()を設定し、フローを続行します。"

#. type: Plain text
msgid ""
"The next execution is a subflow called Forms.  The executions for this "
"subflow are loaded and the same processing logic occurs"
msgstr ""
"次のエグゼキューションは、Formsと呼ばれるサブフローです。このサブフローのエグゼキューションがロードされ、同じ処理ロジックが発生します。"

#. type: Plain text
msgid ""
"The first execution in the Forms subflow is the UsernamePassword provider.  "
"This provider also does not require for a user to already be associated with"
" the flow.  This provider creates challenge HTTP response and sets its "
"status to challenge(). This execution is required, so the flow honors this "
"challenge and sends the HTTP response back to the browser.  This response is"
" a rendering of the Username/Password HTML page.  The user enters in their "
"username and password and clicks submit.  This HTTP request is directed to "
"the UsernamePassword provider.  If the user entered an invalid username or "
"password, a new challenge response is created and a status of "
"failureChallenge() is set for this execution.  A failureChallenge() means "
"that there is a challenge, but that the flow should log this as an error in "
"the error log.  This error log can be used to lock accounts or IP Addresses "
"that have had too many login failures.  If the username and password is "
"valid, the provider associated the UserModel with the "
"AuthenticationSessionModel and returns a status of success()"
msgstr ""
"Formsサブフローでの最初のエグゼキューションはUsernamePasswordプロバイダーです。このプロバイダーは、ユーザーがすでにフローに関連付けられている必要はありません。このプロバイダーは、チャレンジHTTPレスポンスを作成し、そのステータスをchallenge()に設定します。このエグゼキューションは必須なので、フローはこのチャレンジを優先し、ブラウザーにHTTPレスポンスを返します。このレスポンスは、Username/Password"
" "
"HTMLページのレンダリングです。ユーザーは、ユーザー名とパスワードを入力し、送信をクリックします。このHTTPリクエストは、UsernamePasswordプロバイダーに送信されます。ユーザーが無効なユーザー名またはパスワードを入力した場合、新しいチャレンジ・レスポンスが作成され、このエグゼキューションにfailureChallenge()のステータスが設定されます。failureChallenge()は、チャレンジがあることを表しますが、エラーログにerrorとして記録する必要があります。このエラーログは、ログイン失敗回数の多いアカウント、またはIPアドレスをロックするのに使用することができます。ユーザー名とパスワードが有効な場合、プロバイダーはUserModelをAuthenticationSessionModelに関連付け、success()ステータスを返します。"

#. type: Plain text
msgid ""
"The next execution is the OTP Form.  This provider requires that a user has "
"been associated with the flow.  This requirement is satisfied because the "
"UsernamePassword provider already associated the user with the flow.  Since "
"a user is required for this provider, the provider is also asked if the user"
" is configured to use this provider.  If user is not configured, and this "
"execution is required, then the flow will then set up a required action that"
" the user must perform after authentication is complete.  For OTP, this "
"means the OTP setup page.  If the execution was optional, then this "
"execution is skipped."
msgstr ""
"次のエグゼキューションは、OTPフォームです。このプロバイダーでは、ユーザーがフローに関連付けられている必要があります。UsernamePasswordプロバイダーがすでにユーザーをフローに関連付けているため、この要件は満たされます。このプロバイダーは、ユーザーが必須であることから、ユーザーがこのプロバイダーを使用するように設定されているかを求められます。ユーザーが設定されておらず、このエグゼキューションを必要とする場合、フローは認証が完了した後にユーザーが実行する必要のある必須アクションを設定します。OTPの場合、これはOTP設定ページを表します。エグゼキューションがOPTIONALの場合はスキップされます。"

#. type: Plain text
msgid ""
"After the flow is complete, the authentication processor creates a "
"UserSessionModel and associates it with the AuthenticationSessionModel.  It "
"then checks to see if the user is required to complete any required actions "
"before logging in."
msgstr ""
"フローが完了すると、認証プロセッサーはUserSessionModelを作成し、それをAuthenticationSessionModelに関連付けます。その後、ユーザーはログイン前に必須アクションを完了する必要があるかどうかを確認します。"

#. type: Plain text
msgid ""
"First, each required action's evaluateTriggers() method is called.  This "
"allows the required action provider to figure out if there is some state "
"that might trigger the action to be fired.  For example, if your realm has a"
" password expiration policy, it might be triggered by this method."
msgstr ""
"まず、それぞれの必須アクションのevaluateTriggers()メソッドが呼び出されます。これにより、必須アクション・プロバイダーは、アクションが実行されるトリガーとなる可能性があるかを判断できます。たとえば、レルムにパスワード有効期限ポリシーがある場合、このメソッドによってトリガーされる可能性があります。"

#. type: Plain text
msgid ""
"Each required action associated with the user that has its "
"requiredActionChallenge() method called.  Here the provider sets up an HTTP "
"response which renders the page for the required action.  This is done by "
"setting a challenge status."
msgstr ""
"それぞれの必須アクションが、requiredActionChallenge()メソッドが呼び出されたユーザーに関連付けられました。ここでプロバイダーは、必須アクションのページをレンダリングするHTTPレスポンスを設定します。これは、チャレンジ・ステータスを設定することで実行されます。"

#. type: Plain text
msgid ""
"If the required action is ultimately successful, then the required action is"
" removed from the user's require actions list."
msgstr "必須アクションが最終的に成功すると、ユーザーの必須アクションリストから必須アクションが削除されます。"

#. type: Plain text
#, no-wrap
msgid ""
"After all required actions have been resolved, the user is finally logged "
"in.         \n"
msgstr "すべての必須アクションが解決した後、ユーザーはようやくログインします。\n"

#. type: Title ===
#, no-wrap
msgid "Authenticator SPI Walk Through"
msgstr "オーセンティケーターSPIのウォークスルー"

#. type: Plain text
msgid ""
"In this section, we'll take a look at the Authenticator interface.  For "
"this, we are going to implement an authenticator that requires that a user "
"enter in the answer to a secret question like \"What is your mother's maiden"
" name?\".  This example is fully implemented and contained in the "
"examples/providers/authenticator directory of the demo distribution of "
"Keycloak."
msgstr ""
"このセクションでは、オーセンティケーター・インターフェイスについて説明します。これを説明するために、\"あなたの母親の旧姓は何ですか？\"のような秘密の質問にユーザーが回答を入力する必要のあるオーセンティケーターを実装していきます。この例は、完全に実装されており、Keycloakのデモ配布物のexamples/providers/authenticatorディレクトリーに含まれています。"

#. type: Plain text
msgid ""
"The classes you must implement are the "
"org.keycloak.authentication.AuthenticatorFactory and Authenticator "
"interfaces.  The Authenticator interface defines the logic.  The "
"AuthenticatorFactory is responsible for creating instances of an "
"Authenticator.  They both extend a more generic Provider and ProviderFactory"
" set of interfaces that other Keycloak components like User Federation do."
msgstr ""
"実装する必要があるクラスは、org.keycloak.authentication.AuthenticatorFactoryとオーセンティケーター・インターフェイスです。オーセンティケーター・インターフェイスはロジックを定義します。AuthenticatorFactoryは、オーセンティケーターのインスタンスの作成を担います。それらは両方とも、ユーザー・フェデレーションのような他のKeycloakコンポーネントが行う、より汎用的なプロバイダーとProviderFactoryのインターフェイスのセットを拡張します。"

#. type: Plain text
#, no-wrap
msgid ""
"You will package your classes within a single jar.\n"
"This jar must contain a file named  `org.keycloak.authentication.AuthenticatorFactory`                and must be contained in the `META-INF/services/` directory of your jar.\n"
"This file must list the fully qualified classname of each AuthenticatorFactory implementation you have in the jar.\n"
"For example: \n"
msgstr ""
"1つのjarファイル内にクラスをパッケージ化します。このjarには、 "
"`org.keycloak.authentication.AuthenticatorFactory` という名前のファイルが、jarの `META-"
"INF/services/` "
"ディレクトリーに含まれている必要があります。このファイルには、jarファイル内にある各AuthenticatorFactory実装の完全修飾クラス名が一覧化されている必要があります。たとえば、以下のとおりになります。\n"

#. type: delimited block -
#, no-wrap
msgid ""
"org.keycloak.examples.authenticator.SecretQuestionAuthenticatorFactory\n"
"org.keycloak.examples.authenticator.AnotherProviderFactory\n"
msgstr ""
"org.keycloak.examples.authenticator.SecretQuestionAuthenticatorFactory\n"
"org.keycloak.examples.authenticator.AnotherProviderFactory\n"

#. type: Plain text
msgid ""
"This services/ file is used by Keycloak to scan the providers it has to load"
" into the system."
msgstr "このサービスまたはファイルは、システムにロードする必要があるプロバイダーをKeycloakがスキャンするために使用されます。"

#. type: Plain text
msgid "To deploy this jar, just copy it to the providers directory."
msgstr "このjarをデプロイするには、これをprovidersディレクトリーにコピーするだけです。"

#. type: Title ====
#, no-wrap
msgid "Implementing an Authenticator"
msgstr "オーセンティケーターの実装"

#. type: Plain text
msgid ""
"When implementing the Authenticator interface, the first method that needs "
"to be implemented is the requiresUser() method.  For our example, this "
"method must return true as we need to validate the secret question "
"associated with the user.  A provider like kerberos would return false from "
"this method as it can resolve a user from the negotiate header.  This "
"example, however, is validating a specific credential of a specific user."
msgstr ""
"オーセンティケーター・インターフェイスを実装する場合、最初に実装する必要があるメソッドはrequiresUser()メソッドです。この例では、このメソッドは、ユーザーに関連付けられた秘密の質問を検証する必要があるため、trueを返す必要があります。ケルベロスなどのプロバイダーは、ネゴシエーション・ヘッダーからユーザーを解決することができるので、このメソッドからfalseを返します。ただし、この例では、特定のユーザーの特定のクレデンシャルを検証しています。"

#. type: Plain text
msgid ""
"The next method to implement is the configuredFor() method.  This method is "
"responsible for determining if the user is configured for this particular "
"authenticator.  For this example, we need to check if the answer to the "
"secret question has been set up by the user or not.  In our case we are "
"storing this information, hashed, within a UserCredentialValueModel within "
"the UserModel (just like passwords are stored).  Here's how we do this very "
"simple check:"
msgstr ""
"次に実装するメソッドはconfiguredFor()メソッドです。このメソッドは、ユーザーがこの特定のオーセンティケーターとして設定されているのかを判定する役割を担います。この例では、秘密の質問に対する回答がユーザーによって設定されているのかどうかを確認する必要があります。このケースでは、ハッシュ化された情報を、（パスワードが格納されているのと同じように）UserModel内のUserCredentialValueModel内に格納しています。これを簡単に確認する方法は、以下のとおりです。"

#. type: delimited block -
#, no-wrap
msgid ""
"@Override\n"
"  public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {\n"
"     return session.users().configuredForCredentialType(\"secret_question\", realm, user);\n"
"    }\n"
msgstr ""
"@Override\n"
"  public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {\n"
"     return session.users().configuredForCredentialType(\"secret_question\", realm, user);\n"
"    }\n"

#. type: Plain text
msgid ""
"The configuredForCredentialType() call queries the user to see if it "
"supports that credential type."
msgstr ""
"configuredForCredentialType()コールは、ユーザーがそのクレデンシャル・タイプをサポートしているかどうかを問い合わせます。"

#. type: Plain text
msgid ""
"The next method to implement on the Authenticator is setRequiredActions().  "
"If configuredFor() returns false and our example authenticator is required "
"within the flow, this method will be called.  It is responsible for "
"registering any required actions that must be performed by the user.  In our"
" example, we need to register a required action that will force the user to "
"set up the answer to the secret question.  We will implement this required "
"action provider later in this chapter.  Here is the implementation of the "
"setRequiredActions() method."
msgstr ""
"オーセンティケーターで実装する次のメソッドはsetRequiredActions()です。configuredFor()がfalseを返し、フロー内でサンプルのオーセンティケーターが必要な場合、このメソッドが呼び出されます。このメソッドは、ユーザーが実行する必要がある必須アクションの登録を担います。この例では、秘密の質問に対する回答をユーザーに設定させるために必須アクションを登録する必要があります。この章の後半で、この必須アクション・プロバイダーを実装していきます。setRequiredActions()メソッドの実装は次のとおりです。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {\n"
"        user.addRequiredAction(\"SECRET_QUESTION_CONFIG\");\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {\n"
"        user.addRequiredAction(\"SECRET_QUESTION_CONFIG\");\n"
"    }\n"

#. type: Plain text
msgid ""
"Now we are getting into the meat of the Authenticator implementation.  The "
"next method to implement is authenticate().  This is the initial method the "
"flow invokes when the execution is first visited.  What we want is that if a"
" user has answered the secret question already on their browser's machine, "
"then the user doesn't have to answer the question again, making that machine"
" \"trusted\".  The authenticate() method isn't responsible for processing "
"the secret question form.  Its sole purpose is to render the page or to "
"continue the flow."
msgstr ""
"今度はオーセンティケーター実装の中身に入っていきます。次に実装するメソッドはauthenticate()です。これは、エグゼキューションが最初に訪れたときにフローが呼び出す初期メソッドです。ユーザーがすでにブラウザーのマシン上で秘密の質問に回答した場合、ユーザーはその質問に再度回答する必要はなく、そのマシンを\"信頼できる\"ものにすることが望まれます。authenticate()メソッドは、秘密の質問フォームに対する処理を実装する必要はありません。その唯一の目的は、ページをレンダリングするか、フローを継続することです。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void authenticate(AuthenticationFlowContext context) {\n"
"        if (hasCookie(context)) {\n"
"           context.success();\n"
"           return;\n"
"        }\n"
"        Response challenge = loginForm(context).createForm(\"secret_question.ftl\");\n"
"        context.challenge(challenge);\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public void authenticate(AuthenticationFlowContext context) {\n"
"        if (hasCookie(context)) {\n"
"           context.success();\n"
"           return;\n"
"        }\n"
"        Response challenge = loginForm(context).createForm(\"secret_question.ftl\");\n"
"        context.challenge(challenge);\n"
"    }\n"

#. type: Plain text
msgid ""
"The hasCookie() method checks to see if there is already a cookie set on the"
" browser which indicates that the secret question has already been answered."
"  If that returns true, we just mark this execution's status as SUCCESS "
"using the AuthenticationFlowContext.success() method and returning from the "
"authentication() method."
msgstr ""
"hasCookie()は、秘密の質問に回答したことを示すCookieがすでにブラウザーに設定されているかを確認します。trueを返す場合は、authentication()メソッドから返されるAuthenticationFlowContext.success()メソッドを使用し、エグゼキューションのステータスをSUCCESSとします。"

#. type: Plain text
msgid ""
"If the hasCookie() method returns false, we must return a response that "
"renders the secret question HTML form.  AuthenticationFlowContext has a "
"form() method that initializes a Freemarker page builder with appropriate "
"base information needed to build the form.  This page builder is called "
"`org.keycloak.login.LoginFormsProvider`.  the "
"LoginFormsProvider.createForm() method loads a Freemarker template file from"
" your login theme.  Additionally you can call the "
"LoginFormsProvider.setAttribute() method if you want to pass additional "
"information to the Freemarker template.  We'll go over this later."
msgstr ""
"hasCookie()メソッドがfalseを返す場合、秘密の質問のHTMLフォームをレンダリングするレスポンスを返す必要があります。AuthenticationFlowContextには、フォームを構築するために必要となる、適切な基本情報を持つFreemarkerページビルダーを初期化するform()メソッドがあります。このページ・ビルダーは"
" `org.keycloak.login.LoginFormsProvider` "
"と呼ばれています。LoginFormsProvider.createForm()メソッドは、ログインテーマからFreemarkerテンプレート・ファイルを読み込みます。さらに、Freemarkerテンプレートに追加情報を渡す場合は、LoginFormsProvider.setAttribute()メソッドを呼び出すことができます。こちらについては後ほど説明します。"

#. type: Plain text
msgid ""
"Calling LoginFormsProvider.createForm() returns a JAX-RS Response object.  "
"We then call AuthenticationFlowContext.challenge() passing in this response."
"  This sets the status of the execution as CHALLENGE and if the execution is"
" Required, this JAX-RS Response object will be sent to the browser."
msgstr ""
"LoginFormsProvider.createForm()を呼び出すと、JAX-RS "
"Responseオブジェクトが返されます。次に、このレスポンスで渡すAuthenticationFlowContext.challenge()を呼び出します。これにより、エグゼキューションのステータスがCHALLENGEに設定され、エグゼキューションがREQUIREDの場合"
"、このJAX-RSレスポンスのオブジェクトがブラウザーに送信されます。"

#. type: Plain text
msgid ""
"So, the HTML page asking for the answer to a secret question is displayed to"
" the user and the user enteres in the answer and clicks submit.  The action "
"URL of the HTML form will send an HTTP request to the flow.  The flow will "
"end up invoking the action() method of our Authenticator implementation."
msgstr ""
"したがって、秘密の質問に対する回答を求めるHTMLページがユーザーに表示され、ユーザーが回答を入力して送信をクリックします。HTMLフォームのアクションURLは、HTTPリクエストをフローに送信します。フローは、オーセンティケーター実装のaction()メソッドを呼び出すことになります。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void action(AuthenticationFlowContext context) {\n"
"        boolean validated = validateAnswer(context);\n"
"        if (!validated) {\n"
"           Response challenge = context.form()\n"
"                                 .setError(\"badSecret\")\n"
"                                 .createForm(\"secret-question.ftl\");\n"
"           context.failureChallenge(AuthenticationFlowError.INVALID_CREDENTIALS, challenge);\n"
"           return;\n"
"        }\n"
"        setCookie(context);\n"
"        context.success();\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public void action(AuthenticationFlowContext context) {\n"
"        boolean validated = validateAnswer(context);\n"
"        if (!validated) {\n"
"           Response challenge = context.form()\n"
"                                 .setError(\"badSecret\")\n"
"                                 .createForm(\"secret-question.ftl\");\n"
"           context.failureChallenge(AuthenticationFlowError.INVALID_CREDENTIALS, challenge);\n"
"           return;\n"
"        }\n"
"        setCookie(context);\n"
"        context.success();\n"
"    }\n"

#. type: Plain text
msgid ""
"If the answer is not valid, we rebuild the HTML Form with an additional "
"error message.  We then call AuthenticationFlowContext.failureChallenge() "
"passing in the reason for the value and the JAX-RS response.  "
"failureChallenge() works the same as challenge(), but it also records the "
"failure so it can be analyzed by any attack detection service."
msgstr ""
"回答が有効でない場合、HTMLフォームを追加のエラーメッセージで再構築します。次に、原因となる値とJAX-"
"RSレスポンスを渡すAuthenticationFlowContext.failureChallenge()を呼び出します。failureChallenge()はchallenge()と同じ働きをしますが、失敗も記録するので、攻撃検出サービスによって解析できます。"

#. type: Plain text
msgid ""
"If validation is successful, then we set a cookie to remember that the "
"secret question has been answered and we call "
"AuthenticationFlowContext.success()."
msgstr ""
"検証に成功すると、秘密の質問に回答したことを記憶するCookieを設定し、AuthenticationFlowContext.success()を呼び出します。"

#. type: Plain text
msgid ""
"The last thing I want to go over is the setCookie() method.  This is an "
"example of providing configuration for the Authenticator.  In this case we "
"want the max age of the cookie to be configurable."
msgstr ""
"最後にsetCookie()メソッドを説明していきます。このメソッドは、オーセンティケーターの設定を提供する見本になります。このケースでは、Cookieの最大有効期間を設定する必要があります。"

#. type: delimited block -
#, no-wrap
msgid ""
"    protected void setCookie(AuthenticationFlowContext context) {\n"
"        AuthenticatorConfigModel config = context.getAuthenticatorConfig();\n"
"        int maxCookieAge = 60 * 60 * 24 * 30; // 30 days\n"
"        if (config != null) {\n"
"            maxCookieAge = Integer.valueOf(config.getConfig().get(\"cookie.max.age\"));\n"
msgstr ""
"    protected void setCookie(AuthenticationFlowContext context) {\n"
"        AuthenticatorConfigModel config = context.getAuthenticatorConfig();\n"
"        int maxCookieAge = 60 * 60 * 24 * 30; // 30 days\n"
"        if (config != null) {\n"
"            maxCookieAge = Integer.valueOf(config.getConfig().get(\"cookie.max.age\"));\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        }\n"
"        ... set the cookie ...\n"
"    }\n"
msgstr ""
"        }\n"
"        ... set the cookie ...\n"
"    }\n"

#. type: Plain text
msgid ""
"We obtain an AuthenticatorConfigModel from the "
"AuthenticationFlowContext.getAuthenticatorConfig() method.  If configuration"
" exists we pull the max age config out of it.  We will see how we can define"
" what should be configured when we talk about the AuthenticatorFactory "
"implementation.  The config values can be defined within the admin console "
"if you set up config definitions in your AuthenticatorFactory "
"implementation."
msgstr ""
"AuthenticationFlowContext.getAuthenticatorConfig()メソッドからAuthenticatorConfigModelを取得します。設定が存在する場合は、その設定の最大有効期間を取り出します。何を設定するべきかを定義する方法については、AuthenticatorFactoryの実装について説明する際に確認していきます。AuthenticatorFactory実装で設定の定義をした場合、管理コンソール内で設定値を定義できます。"

#. type: Title ====
#, no-wrap
msgid "Implementing an AuthenticatorFactory"
msgstr "AuthenticatorFactoryの実装"

#. type: Plain text
msgid ""
"The next step in this process is to implement an AuthenticatorFactory.  This"
" factory is responsible for instantiating an Authenticator.  It also "
"provides deployment and configuration metadata about the Authenticator."
msgstr ""
"このプロセスでの次のステップは、AuthenticatorFactoryを実装することです。このファクトリーはオーセンティケーターのインスタンス化を担当します。また、オーセンティケーターに関する配備と設定のメタデータも提供します。"

#. type: Plain text
msgid ""
"The getId() method is just the unique name of the component.  The create() "
"method is called by the runtime to allocate and process the Authenticator."
msgstr ""
"getId()メソッドは、コンポーネントの一意の名前です。create()メソッドは、オーセンティケーターを割り当てて処理するために、ランタイムによって呼び出されます。"

#. type: delimited block -
#, no-wrap
msgid ""
"public class SecretQuestionAuthenticatorFactory implements "
"AuthenticatorFactory, ConfigurableAuthenticatorFactory {\n"
msgstr ""
"public class SecretQuestionAuthenticatorFactory implements "
"AuthenticatorFactory, ConfigurableAuthenticatorFactory {\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    public static final String PROVIDER_ID = \"secret-question-authenticator\";\n"
"    private static final SecretQuestionAuthenticator SINGLETON = new SecretQuestionAuthenticator();\n"
msgstr ""
"    public static final String PROVIDER_ID = \"secret-question-authenticator\";\n"
"    private static final SecretQuestionAuthenticator SINGLETON = new SecretQuestionAuthenticator();\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public String getId() {\n"
"        return PROVIDER_ID;\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public String getId() {\n"
"        return PROVIDER_ID;\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public Authenticator create(KeycloakSession session) {\n"
"        return SINGLETON;\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public Authenticator create(KeycloakSession session) {\n"
"        return SINGLETON;\n"
"    }\n"

#. type: Plain text
msgid ""
"The next thing the factory is responsible for is specify the allowed "
"requirement switches.  While there are four different requirement types: "
"ALTERNATIVE, REQUIRED, OPTIONAL, DISABLED, AuthenticatorFactory "
"implementations can limit which requirement options are shown in the admin "
"console when defining a flow.  In our example, we're going to limit our "
"requirement options to REQUIRED and DISABLED."
msgstr ""
"ファクトリーが次に受け持つのは、許可されたスイッチの要件を指定することです。ALTERNATIVE、REQUIRED、OPTIONAL、DISABLEDの4種類の要件タイプがありますが、AuthenticatorFactoryの実装では、フローを定義する際に管理コンソールに表示されるオプションの要件を制限できます。この例では、オプションの要件をREQUIREDとDISABLEDに制限します。"

#. type: delimited block -
#, no-wrap
msgid ""
"    private static AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {\n"
"            AuthenticationExecutionModel.Requirement.REQUIRED,\n"
"            AuthenticationExecutionModel.Requirement.DISABLED\n"
"    };\n"
"    @Override\n"
"    public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {\n"
"        return REQUIREMENT_CHOICES;\n"
"    }\n"
msgstr ""
"    private static AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {\n"
"            AuthenticationExecutionModel.Requirement.REQUIRED,\n"
"            AuthenticationExecutionModel.Requirement.DISABLED\n"
"    };\n"
"    @Override\n"
"    public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {\n"
"        return REQUIREMENT_CHOICES;\n"
"    }\n"

#. type: Plain text
msgid ""
"The AuthenticatorFactory.isUserSetupAllowed() is a flag that tells the flow "
"manager whether or not Authenticator.setRequiredActions() method will be "
"called.  If an Authenticator is not configured for a user, the flow manager "
"checks isUserSetupAllowed().  If it is false, then the flow aborts with an "
"error.  If it returns true, then the flow manager will invoke "
"Authenticator.setRequiredActions()."
msgstr ""
"AuthenticatorFactory.isUserSetupAllowed()は、Authenticator.setRequiredActions()メソッドが呼び出されるかどうかをフローマネージャーに通知するフラグです。オーセンティケーターがユーザー用に設定されていない場合、フローマネージャーはisUserSetupAllowed()をチェックします。falseの場合、エラーを返して異常終了します。trueを返すと、フローマネージャーはAuthenticator.setRequiredActions()を呼び出します。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public boolean isUserSetupAllowed() {\n"
"        return true;\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public boolean isUserSetupAllowed() {\n"
"        return true;\n"
"    }\n"

#. type: Plain text
msgid ""
"The next few methods define how the Authenticator can be configured.  The "
"isConfigurable() method is a flag which specifies to the admin console on "
"whether the Authenticator can be configured within a flow.  The "
"getConfigProperties() method returns a list of ProviderConfigProperty "
"objects.  These objects define a specific configuration attribute."
msgstr ""
"次のいくつかのメソッドは、オーセンティケーターの設定方法を定義します。isConfigurable()メソッドは、オーセンティケーターをフロー内で設定することができるかを管理コンソールに指定するフラグです。getConfigProperties()メソッドは、ProviderConfigPropertyオブジェクトのリストを返します。これらのオブジェクトは、特定の設定属性を定義します。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public List<ProviderConfigProperty> getConfigProperties() {\n"
"        return configProperties;\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public List<ProviderConfigProperty> getConfigProperties() {\n"
"        return configProperties;\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    private static final List<ProviderConfigProperty> configProperties = new"
" ArrayList<ProviderConfigProperty>();\n"
msgstr ""
"    private static final List<ProviderConfigProperty> configProperties = new"
" ArrayList<ProviderConfigProperty>();\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    static {\n"
"        ProviderConfigProperty property;\n"
"        property = new ProviderConfigProperty();\n"
"        property.setName(\"cookie.max.age\");\n"
"        property.setLabel(\"Cookie Max Age\");\n"
"        property.setType(ProviderConfigProperty.STRING_TYPE);\n"
"        property.setHelpText(\"Max age in seconds of the SECRET_QUESTION_COOKIE.\");\n"
"        configProperties.add(property);\n"
"    }\n"
msgstr ""
"    static {\n"
"        ProviderConfigProperty property;\n"
"        property = new ProviderConfigProperty();\n"
"        property.setName(\"cookie.max.age\");\n"
"        property.setLabel(\"Cookie Max Age\");\n"
"        property.setType(ProviderConfigProperty.STRING_TYPE);\n"
"        property.setHelpText(\"Max age in seconds of the SECRET_QUESTION_COOKIE.\");\n"
"        configProperties.add(property);\n"
"    }\n"

#. type: Plain text
msgid ""
"Each ProviderConfigProperty defines the name of the config property.  This "
"is the key used in the config map stored in AuthenticatorConfigModel.  The "
"label defines how the config option will be displayed in the admin console."
"  The type defines if it is a String, Boolean, or other type.  The admin "
"console will display different UI inputs depending on the type.  The help "
"text is what will be shown in the tooltip for the config attribute in the "
"admin console.  Read the javadoc of ProviderConfigProperty for more detail."
msgstr ""
"それぞれのProviderConfigPropertyは、設定プロパティーの名前を定義します。これが、AuthenticatorConfigModelに格納されている設定マップで使用されるキーとなります。ラベルは、管理コンソールでどのように設定オプションが表示されるかを定義します。タイプは、そのプロパティーがString、Booleanまたはその他のタイプであるかを定義します。管理コンソールには、タイプによって異なるUI入力が表示されます。ヘルプのテキストは、管理コンソールの設定属性のツールチップに表示されるものです。詳しくは、ProviderConfigPropertyのjavadocを参照してください。"

#. type: Plain text
msgid ""
"The rest of the methods are for the admin console.  getHelpText() is the "
"tooltip text that will be shown when you are picking the Authenticator you "
"want to bind to an execution.  getDisplayType() is what text that will be "
"shown in the admin console when listing the Authenticator.  "
"getReferenceCategory() is just a category the Authenticator belongs to."
msgstr ""
"残りのメソッドは管理コンソール用です。getHelpText()は、エグゼキューションにバインドさせるオーセンティケーターを選択するときに表示されるツールチップ・テキストです。getDisplayType()は、オーセンティケーターを一覧表示する際に管理コンソールに表示されるテキストです。getReferenceCategory()は、オーセンティケーターが属するカテゴリーです。"
" "

#. type: Title ====
#, no-wrap
msgid "Adding Authenticator Form"
msgstr "オーセンティケーター・フォームの追加"

#. type: Plain text
msgid ""
"Keycloak comes with a Freemarker <<_themes,theme and template engine>>.  The"
" createForm() method you called within authenticate() of your Authenticator "
"class, builds an HTML page from a file within your login theme: secret-"
"question.ftl.  This file should be placed in the login theme with all the "
"other .ftl files you see for login."
msgstr ""
"Keycloakには、Freemarker<<_themes,テーマとエンジン・テンプレート>> "
"が付属しています。オーセンティケーター・クラスのauthenticate()内で呼び出されたcreateForm()メソッドは"
"、ログインテーマ内のsecret-"
"question.ftlファイルからHTMLページを構築します。このファイルは、ログイン時に参照するその他のすべての.ftlファイルと一緒にログインテーマに配置する必要があります。"

#. type: Plain text
msgid ""
"Let's take a bigger look at secret-question.ftl Here's a small code snippet:"
msgstr "secret-question.ftlの詳細を見ていきましょう。以下は、短いコードスニペットになります。"

#. type: delimited block -
#, no-wrap
msgid ""
"        <form id=\"kc-totp-login-form\" class=\"${properties.kcFormClass!}\" action=\"${url.loginAction}\" method=\"post\">\n"
"            <div class=\"${properties.kcFormGroupClass!}\">\n"
"                <div class=\"${properties.kcLabelWrapperClass!}\">\n"
"                    <label for=\"totp\" class=\"${properties.kcLabelClass!}\">${msg(\"loginSecretQuestion\")}</label>\n"
"                </div>\n"
msgstr ""
"        <form id=\"kc-totp-login-form\" class=\"${properties.kcFormClass!}\" action=\"${url.loginAction}\" method=\"post\">\n"
"            <div class=\"${properties.kcFormGroupClass!}\">\n"
"                <div class=\"${properties.kcLabelWrapperClass!}\">\n"
"                    <label for=\"totp\" class=\"${properties.kcLabelClass!}\">${msg(\"loginSecretQuestion\")}</label>\n"
"                </div>\n"

#. type: delimited block -
#, no-wrap
msgid ""
"                <div class=\"${properties.kcInputWrapperClass!}\">\n"
"                    <input id=\"totp\" name=\"secret_answer\" type=\"text\" class=\"${properties.kcInputClass!}\" />\n"
"                </div>\n"
"            </div>\n"
msgstr ""
"                <div class=\"${properties.kcInputWrapperClass!}\">\n"
"                    <input id=\"totp\" name=\"secret_answer\" type=\"text\" class=\"${properties.kcInputClass!}\" />\n"
"                </div>\n"
"            </div>\n"

#. type: Plain text
msgid ""
"Any piece of text enclosed in `${}` corresponds to an attribute or template "
"funtion.  If you see the form's action, you see it points to "
"`${url.loginAction}`.  This value is automatically generated when you invoke"
" the AuthenticationFlowContext.form() method.  You can also obtain this "
"value by calling the AuthenticationFlowContext.getActionURL() method in Java"
" code."
msgstr ""
"`${}` で囲まれたテキストは、属性またはテンプレートの関数に対応します。フォームのアクションが表示された場合、それは "
"`${url.loginAction}` "
"を指しています。この値は、AuthenticationFlowContext.form()メソッドを呼び出すと自動的に生成されます。JavaコードでAuthenticationFlowContext.getActionURL()メソッドを呼び出すことで、この値を取得することもできます。"

#. type: Plain text
#, no-wrap
msgid ""
"You'll also see `${properties.someValue}`.\n"
"These correspond to properties defined in your theme.properties file of our theme.\n"
" `${msg(\"someValue\")}` corresponds to the internationalized message bundles (.properties files) included with the login theme messages/ directory.\n"
"If you're just using english, you can just add the value of the `loginSecretQuestion`                value.\n"
"This should be the question you want to ask the user. \n"
msgstr ""
"`${properties.someValue}` "
"も同じく表示されます。これらは、テーマのtheme.propertiesファイルで定義されたプロパティーに対応します。 "
"`${msg(\"someValue\")}` "
"は、ログインテーマのmessages/ディレクトリーに含まれている国際化されたメッセージ・バンドル（.properties "
"files）に対応します。英語のみを使用している場合は、 `loginSecretQuestion` "
"の値を追加することができます。これがユーザーに要求する質問になります。\n"

#. type: Plain text
msgid ""
"When you call AuthenticationFlowContext.form() this gives you a "
"LoginFormsProvider instance.  If you called, "
"`LoginFormsProvider.setAttribute(\"foo\", \"bar\")`, the value of \"foo\" "
"would be available for reference in your form as `${foo}`.  The value of an "
"attribute can be any Java bean as well."
msgstr ""
"AuthenticationFlowContext.form()を呼び出すと、LoginFormsProviderインスタンスが生成されます。 "
"`LoginFormsProvider.setAttribute(\"foo\", \"bar\")` を呼び出した場合、\"foo\"の値は "
"`${foo}` という形式で参照することができます。属性の値は、Java beanでも構いません。"

#. type: Title ====
#, no-wrap
msgid "Adding Authenticator to a Flow"
msgstr "フローにオーセンティケーターを追加"

#. type: Plain text
msgid ""
"Adding an Authenticator to a flow must be done in the admin console.  If you"
" go to the Authentication menu item and go to the Flow tab, you will be able"
" to view the currently defined flows.  You cannot modify an built in flows, "
"so, to add the Authenticator we've created you have to copy an existing flow"
" or create your own.  I'm hoping the UI is intuitive enough so that you can "
"figure out for yourself how to create a flow and add the Authenticator."
msgstr ""
"フローへのオーセンティケーター追加は、管理コンソールで行う必要があります。Authenticationメニュー項目に移動してFlowタブを選択すると、現在定義されているフローが表示されます。組み込みのフローを変更することはできません。そのため、作成したオーセンティケーターを追加するには、既存のフローをコピーするか独自のフローを作成する必要があります。このUIは非常に分かりやすく作られているので、フローを作成してオーセンティケーターを追加する方法を見つけることができると思います。"

#. type: Plain text
msgid ""
"After you've created your flow, you have to bind it to the login action you "
"want to bind it to.  If you go to the Authentication menu and go to the "
"Bindings tab you will see options to bind a flow to the browser, "
"registration, or direct grant flow."
msgstr ""
"フローを作成した後、バインドさせるログイン・アクションに、そのフローをバインドする必要があります。Authenticationメニューに移動して、Bindingsタブを選択すると、フローをBrowser、Registration、またはDirect"
" Grantフローにバインドするオプションが表示されます。"

#. type: Title ===
#, no-wrap
msgid "Required Action Walkthrough"
msgstr "必須アクションのウォークスルー"

#. type: Plain text
msgid ""
"In this section we will discuss how to define a required action.  In the "
"Authenticator section you may have wondered, \"How will we get the user's "
"answer to the secret question entered into the system?\".  As we showed in "
"the example, if the answer is not set up, a required action will be "
"triggered.  This section discusses how to implement the required action for "
"the Secret Question Authenticator."
msgstr ""
"このセクションでは、必須アクションを定義する方法について説明します。オーセンティケーターのセクションでは、\"どのようにしてシステムに入力された秘密の質問に対するユーザーの回答をもらえば良いのだろう\"と疑問に思ったかもしれません。例で示したように、回答が設定されていない場合は、必須アクションがトリガーされます。このセクションでは、シークレット・クエスチョン・オーセンティケーターに必須アクションを実装する方法について説明します。"

#. type: Plain text
#, no-wrap
msgid ""
"You will package your classes within a single jar.\n"
"This jar does not have to be separate from other provider classes but it must contain a file named  `org.keycloak.authentication.RequiredActionFactory`                and must be contained in the `META-INF/services/` directory of your jar.\n"
"This file must list the fully qualified classname of each RequiredActionFactory implementation you have in the jar.\n"
"For example: \n"
msgstr ""
"1つのjarファイル内にクラスをパッケージ化します。このjarは、他のプロバイダーのクラスとは別にする必要はありませんが、  "
"`org.keycloak.authentication.RequiredActionFactory` という名前のファイルが、jarの `META-"
"INF/services/` "
"ディレクトリーに含まれている必要があります。このファイルには、jarファイル内にある各RequiredActionFactory実装の完全修飾クラス名が一覧化されている必要があります。たとえば、以下のとおりになります。\n"

#. type: delimited block -
#, no-wrap
msgid ""
"org.keycloak.examples.authenticator.SecretQuestionRequiredActionFactory\n"
msgstr ""
"org.keycloak.examples.authenticator.SecretQuestionRequiredActionFactory\n"

#. type: Title ====
#, no-wrap
msgid "Implement the RequiredActionProvider"
msgstr "RequiredActionProviderの実装"

#. type: Plain text
msgid ""
"Required actions must first implement the RequiredActionProvider interface."
"  The RequiredActionProvider.requiredActionChallenge() is the initial call "
"by the flow manager into the required action.  This method is responsible "
"for rendering the HTML form that will drive the required action."
msgstr ""
"必須アクションは、最初にRequiredActionProviderインターフェイスを実装する必要があります。RequiredActionProvider.requiredActionChallenge()は、フローマネージャーの必須アクションによる初回の呼び出しになります。このメソッドは、必須アクションを実行するHTMLフォームのレンダリングを行います。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void requiredActionChallenge(RequiredActionContext context) {\n"
"        Response challenge = context.form().createForm(\"secret_question_config.ftl\");\n"
"        context.challenge(challenge);\n"
msgstr ""
"    @Override\n"
"    public void requiredActionChallenge(RequiredActionContext context) {\n"
"        Response challenge = context.form().createForm(\"secret_question_config.ftl\");\n"
"        context.challenge(challenge);\n"

#. type: Plain text
msgid ""
"You see that RequiredActionContext has similar methods to "
"AuthenticationFlowContext.  The form() method allows you to render the page "
"from a Freemarker template.  The action URL is preset by the call to this "
"form() method.  You just need to reference it within your HTML form.  I'll "
"show you this later."
msgstr ""
"RequiredActionContextには、AuthenticationFlowContextと同じようなメソッドがあります。form()メソッドにより、Freemarkerテンプレートからページをレンダリングすることができます。アクションURLは、このform()メソッドの呼び出しにより事前に設定されるため、HTMLフォーム内で参照するだけで済みます。これについては、後ほど説明します。"

#. type: Plain text
msgid ""
"The challenge() method notifies the flow manager that a required action must"
" be executed."
msgstr "challenge()メソッドは、必須アクションを実行する必要があることをフローマネージャーに通知します。"

#. type: Plain text
msgid ""
"The next method is responsible for processing input from the HTML form of "
"the required action.  The action URL of the form will be routed to the "
"RequiredActionProvider.processAction() method"
msgstr ""
"次のメソッドは、必須アクションのHTMLフォームからの入力を処理します。フォームのアクションURLは、RequiredActionProvider.processAction()メソッドにルーティングされます。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void processAction(RequiredActionContext context) {\n"
"        String answer = (context.getHttpRequest().getDecodedFormParameters().getFirst(\"answer\"));\n"
"        UserCredentialValueModel model = new UserCredentialValueModel();\n"
"        model.setValue(answer);\n"
"        model.setType(SecretQuestionAuthenticator.CREDENTIAL_TYPE);\n"
"        context.getUser().updateCredentialDirectly(model);\n"
"        context.success();\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public void processAction(RequiredActionContext context) {\n"
"        String answer = (context.getHttpRequest().getDecodedFormParameters().getFirst(\"answer\"));\n"
"        UserCredentialValueModel model = new UserCredentialValueModel();\n"
"        model.setValue(answer);\n"
"        model.setType(SecretQuestionAuthenticator.CREDENTIAL_TYPE);\n"
"        context.getUser().updateCredentialDirectly(model);\n"
"        context.success();\n"
"    }\n"

#. type: Plain text
msgid ""
"The answer is pulled out of the form post.  A UserCredentialValueModel is "
"created and the type and value of the credential are set.  Then "
"UserModel.updateCredentialDirectly() is invoked.  Finally, "
"RequiredActionContext.success() notifies the container that the required "
"action was successful."
msgstr ""
"回答はフォームのpostから取り出されます。UserCredentialValueModelが作成され、クレデンシャルのタイプと値がセットされます。その後、UserModel.updateCredentialDirectly()が呼び出されます。最後に、RequiredActionContext.success()は、必須アクションが成功したことをコンテナーに通知します。"

#. type: Title ====
#, no-wrap
msgid "Implement the RequiredActionFactory"
msgstr "RequiredActionFactoryの実装"

#. type: Plain text
msgid ""
"This class is really simple.  It is just responsible for creating the "
"required actin provider instance."
msgstr "このクラスは非常にシンプルです。これは必須アクション・プロバイダー・インスタンスの作成を行うだけです。"

#. type: delimited block -
#, no-wrap
msgid ""
"public class SecretQuestionRequiredActionFactory implements "
"RequiredActionFactory {\n"
msgstr ""
"public class SecretQuestionRequiredActionFactory implements "
"RequiredActionFactory {\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    private static final SecretQuestionRequiredAction SINGLETON = new "
"SecretQuestionRequiredAction();\n"
msgstr ""
"    private static final SecretQuestionRequiredAction SINGLETON = new "
"SecretQuestionRequiredAction();\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public RequiredActionProvider create(KeycloakSession session) {\n"
"        return SINGLETON;\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public RequiredActionProvider create(KeycloakSession session) {\n"
"        return SINGLETON;\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public String getId() {\n"
"        return SecretQuestionRequiredAction.PROVIDER_ID;\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public String getId() {\n"
"        return SecretQuestionRequiredAction.PROVIDER_ID;\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public String getDisplayText() {\n"
"        return \"Secret Question\";\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public String getDisplayText() {\n"
"        return \"Secret Question\";\n"
"    }\n"

#. type: Plain text
msgid ""
"The getDisplayText() method is just for the admin console when it wants to "
"display a friendly name for the required action."
msgstr "getDisplayText()メソッドは、必須アクションに対して分かりやすい名前を表示させたいときに、管理コンソールで使用されます。"

#. type: Title ====
#, no-wrap
msgid "Enable Required Action"
msgstr "必須アクションの有効化"

#. type: Plain text
msgid ""
"The final thing you have to do is go into the admin console.  Click on the "
"Authentication left menu.  Click on the Required Actions tab.  Click on the "
"Register button and choose your new Required Action.  Your new required "
"action should now be displayed and enabled in the required actions list."
msgstr ""
"最後に、管理コンソールに移動する必要があります。左メニューのAuthenticationをクリックします。Required "
"Actionsタブをクリックします。Registerボタンをクリックし、新しい必須アクションを選択します。必須アクションのリストに新しい必須アクションが表示され、有効になります。"

#. type: Title ===
#, no-wrap
msgid "Modifying/Extending the Registration Form"
msgstr "登録フォームの変更または拡張"

#. type: Plain text
msgid ""
"It is entirely possible for you to implement your own flow with a set of "
"Authenticators to totally change how registration is done in Keycloak.  But "
"what you'll usually want to do is just add a little bit of validation to the"
" out of the box registration page.  An additional SPI was created to be able"
" to do this.  It basically allows you to add validation of form elements on "
"the page as well as to initialize UserModel attributes and data after the "
"user has been registered.  We'll look at both the implementation of the user"
" profile registration processing as well as the registration Google "
"Recaptcha plugin."
msgstr ""
"オーセンティケーターを使用して独自のフローを実装することは可能なため、Keycloakでの登録方法を完全に変更することができます。しかし、独自の登録ページにちょっとしたバリデーションを加えたいことも普段はあるかと思います。これを行うために追加のSPIが作成されました。このSPIは、基本的には、ページにフォーム要素のバリデーションを追加するだけでなく、ユーザー登録後にUserModel属性とデータを初期化することもできます。ユーザー・プロファイルの登録処理の実装とGoogle"
" Recaptchaプラグインの登録の両方を説明していきます。"

#. type: Title ====
#, no-wrap
msgid "Implementation FormAction Interface"
msgstr "FormActionインターフェイスの実装"

#. type: Plain text
msgid ""
"The core interface you have to implement is the FormAction interface.  A "
"FormAction is responsible for rendering and processing a portion of the "
"page.  Rendering is done in the buildPage() method, validation is done in "
"the validate() method, post validation operations are done in success().  "
"Let's first take a look at buildPage() method of the Recaptcha plugin."
msgstr ""
"実装する必要のあるコアとなるインターフェイスは、FormActionインターフェイスです。FormActionは、ページの一部のレンダリングと処理を受け待ちます。レンダリングはbuildPage()メソッド、バリデーションはvalidate()メソッド、バリデーション後の動作はsuccess()で行います。まずは、RecaptchaプラグインのbuildPage()メソッドを見ていきます。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void buildPage(FormContext context, LoginFormsProvider form) {\n"
"        AuthenticatorConfigModel captchaConfig = context.getAuthenticatorConfig();\n"
"        if (captchaConfig == null || captchaConfig.getConfig() == null\n"
"                || captchaConfig.getConfig().get(SITE_KEY) == null\n"
"                || captchaConfig.getConfig().get(SITE_SECRET) == null\n"
"                ) {\n"
"            form.addError(new FormMessage(null, Messages.RECAPTCHA_NOT_CONFIGURED));\n"
"            return;\n"
"        }\n"
"        String siteKey = captchaConfig.getConfig().get(SITE_KEY);\n"
"        form.setAttribute(\"recaptchaRequired\", true);\n"
"        form.setAttribute(\"recaptchaSiteKey\", siteKey);\n"
"        form.addScript(\"https://www.google.com/recaptcha/api.js\");\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public void buildPage(FormContext context, LoginFormsProvider form) {\n"
"        AuthenticatorConfigModel captchaConfig = context.getAuthenticatorConfig();\n"
"        if (captchaConfig == null || captchaConfig.getConfig() == null\n"
"                || captchaConfig.getConfig().get(SITE_KEY) == null\n"
"                || captchaConfig.getConfig().get(SITE_SECRET) == null\n"
"                ) {\n"
"            form.addError(new FormMessage(null, Messages.RECAPTCHA_NOT_CONFIGURED));\n"
"            return;\n"
"        }\n"
"        String siteKey = captchaConfig.getConfig().get(SITE_KEY);\n"
"        form.setAttribute(\"recaptchaRequired\", true);\n"
"        form.setAttribute(\"recaptchaSiteKey\", siteKey);\n"
"        form.addScript(\"https://www.google.com/recaptcha/api.js\");\n"
"    }\n"

#. type: Plain text
msgid ""
"The Recaptcha buildPage() method is a callback by the form flow to help "
"render the page.  It receives a form parameter which is a "
"LoginFormsProvider.  You can add additional attributes to the form provider "
"so that they can be displayed in the HTML page generated by the registration"
" Freemarker template."
msgstr ""
"Recaptcha "
"buildPage()メソッドは、ページのレンダリングを支援するフォームフローからのコールバックです。これは、LoginFormsProviderであるフォーム・パラメーターを受け取ります。フォーム・プロバイダーに追加属性を加えて、登録Freemarkerテンプレートによって生成されたHTMLページに表示させることができます。"

#. type: Plain text
msgid ""
"The code above is from the registration recaptcha plugin.  Recaptcha "
"requires some specific settings that must be obtained from configuration.  "
"FormActions are configured in the exact same was as Authenticators are.  In "
"this example, we pull the Google Recaptcha site key from configuration and "
"add it as an attribute to the form provider.  Our regstration template file "
"can read this attribute now."
msgstr ""
"上記のコードは、登録recaptchaプラグインからのものです。Recaptchaには、設定から取得する必要のある特定の設定が必要です。FormActionsは、オーセンティケーターとまったく同じように設定されています。この例では、Google"
" "
"Recaptchaの公開鍵を設定から取り出し、フォーム・プロバイダーに属性として追加します。これで、登録テンプレート・ファイルはこの属性を読み込むことができます。"

#. type: Plain text
msgid ""
"Recaptcha also has the requirement of loading a javascript script.  You can "
"do this by calling LoginFormsProvider.addScript() passing in the URL."
msgstr ""
"Recaptchaには、Javascriptの読み込み要件もあります。これを行うには、URLを渡すLoginFormsProvider.addScript()を呼び出します。"

#. type: Plain text
msgid ""
"For user profile processing, there is no additional information that it "
"needs to add to the form, so its buildPage() method is empty."
msgstr "ユーザー・プロファイルを処理する場合、フォームに加える必要がある追加情報はないため、buildPage()メソッドは空です。"

#. type: Plain text
msgid ""
"The next meaty part of this interface is the validate() method.  This is "
"called immediately upon receiving a form post.  Let's look at the "
"Recaptcha's plugin first."
msgstr ""
"このインターフェイスの次の部分は、validate()メソッドです。これは、フォームのpostを受け取ると、直後に呼び出されます。最初に、Recaptchaのプラグインを見ていきます。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void validate(ValidationContext context) {\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        List<FormMessage> errors = new ArrayList<>();\n"
"        boolean success = false;\n"
msgstr ""
"    @Override\n"
"    public void validate(ValidationContext context) {\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        List<FormMessage> errors = new ArrayList<>();\n"
"        boolean success = false;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        String captcha = formData.getFirst(G_RECAPTCHA_RESPONSE);\n"
"        if (!Validation.isBlank(captcha)) {\n"
"            AuthenticatorConfigModel captchaConfig = context.getAuthenticatorConfig();\n"
"            String secret = captchaConfig.getConfig().get(SITE_SECRET);\n"
msgstr ""
"        String captcha = formData.getFirst(G_RECAPTCHA_RESPONSE);\n"
"        if (!Validation.isBlank(captcha)) {\n"
"            AuthenticatorConfigModel captchaConfig = context.getAuthenticatorConfig();\n"
"            String secret = captchaConfig.getConfig().get(SITE_SECRET);\n"

#. type: delimited block -
#, no-wrap
msgid ""
"            success = validateRecaptcha(context, success, captcha, secret);\n"
"        }\n"
"        if (success) {\n"
"            context.success();\n"
"        } else {\n"
"            errors.add(new FormMessage(null, Messages.RECAPTCHA_FAILED));\n"
"            formData.remove(G_RECAPTCHA_RESPONSE);\n"
"            context.validationError(formData, errors);\n"
"            return;\n"
msgstr ""
"            success = validateRecaptcha(context, success, captcha, secret);\n"
"        }\n"
"        if (success) {\n"
"            context.success();\n"
"        } else {\n"
"            errors.add(new FormMessage(null, Messages.RECAPTCHA_FAILED));\n"
"            formData.remove(G_RECAPTCHA_RESPONSE);\n"
"            context.validationError(formData, errors);\n"
"            return;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        }\n"
"    }\n"
msgstr ""
"        }\n"
"    }\n"

#. type: Plain text
msgid ""
"Here we obtain the form data that the Recaptcha widget adds to the form.  We"
" obtain the Recaptcha secret key from configuration.  We then validate the "
"recaptcha.  If successful, ValidationContext.success() is called.  If not, "
"we invoke ValidationContext.validationError() passing in the formData (so "
"the user doesn't have to re-enter data), we also specify an error message we"
" want displayed.  The error message must point to a message bundle property "
"in the internationalized message bundles.  For other registration extensions"
" validate() might be validating the format of a form element, i.e.  an "
"alternative email attribute."
msgstr ""
"ここでは、Recaptchaウィジェットがフォームに追加するフォームデータを取得します。設定からRecaptchaの秘密鍵を取得します。次に、Recaptchaを検証します。成功すると、ValidationContext.success()が呼び出されます。成功しなかった場合は、formDataで渡すValidationContext.validationError()を呼び出します（ユーザーがデータを再入力する必要はありません）。また、表示するエラーメッセージを指定します。エラーメッセージは、国際化されたメッセージ・バンドルのメッセージ・バンドル・プロパティーを指し示している必要があります。他の登録拡張の場合、validate()はフォーム要素のフォーマット、つまり別の電子メール属性を検証する可能性もあります。"

#. type: Plain text
msgid ""
"Let's also look at the user profile plugin that is used to validate email "
"address and other user information when registering."
msgstr "また、登録時にメールアドレスや他のユーザー情報を検証するために使用されるユーザー・プロファイル・プラグインについても見ていきましょう。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void validate(ValidationContext context) {\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        List<FormMessage> errors = new ArrayList<>();\n"
msgstr ""
"    @Override\n"
"    public void validate(ValidationContext context) {\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        List<FormMessage> errors = new ArrayList<>();\n"

#. type: delimited block -
#, no-wrap
msgid "        String eventError = Errors.INVALID_REGISTRATION;\n"
msgstr "        String eventError = Errors.INVALID_REGISTRATION;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_FIRST_NAME)))) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_FIRST_NAME, Messages.MISSING_FIRST_NAME));\n"
"        }\n"
msgstr ""
"        if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_FIRST_NAME)))) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_FIRST_NAME, Messages.MISSING_FIRST_NAME));\n"
"        }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_LAST_NAME)))) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_LAST_NAME, Messages.MISSING_LAST_NAME));\n"
"        }\n"
msgstr ""
"        if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_LAST_NAME)))) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_LAST_NAME, Messages.MISSING_LAST_NAME));\n"
"        }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        String email = formData.getFirst(Validation.FIELD_EMAIL);\n"
"        if (Validation.isBlank(email)) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.MISSING_EMAIL));\n"
"        } else if (!Validation.isEmailValid(email)) {\n"
"            formData.remove(Validation.FIELD_EMAIL);\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.INVALID_EMAIL));\n"
"        }\n"
msgstr ""
"        String email = formData.getFirst(Validation.FIELD_EMAIL);\n"
"        if (Validation.isBlank(email)) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.MISSING_EMAIL));\n"
"        } else if (!Validation.isEmailValid(email)) {\n"
"            formData.remove(Validation.FIELD_EMAIL);\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.INVALID_EMAIL));\n"
"        }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        if (context.getSession().users().getUserByEmail(email, context.getRealm()) != null) {\n"
"            formData.remove(Validation.FIELD_EMAIL);\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.EMAIL_EXISTS));\n"
"        }\n"
msgstr ""
"        if (context.getSession().users().getUserByEmail(email, context.getRealm()) != null) {\n"
"            formData.remove(Validation.FIELD_EMAIL);\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.EMAIL_EXISTS));\n"
"        }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        if (errors.size() > 0) {\n"
"            context.validationError(formData, errors);\n"
"            return;\n"
msgstr ""
"        if (errors.size() > 0) {\n"
"            context.validationError(formData, errors);\n"
"            return;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        } else {\n"
"            context.success();\n"
"        }\n"
"    }\n"
msgstr ""
"        } else {\n"
"            context.success();\n"
"        }\n"
"    }\n"

#. type: Plain text
msgid ""
"As you can see, this validate() method of user profile processing makes sure"
" that the email, first, and last name are filled in in the form.  It also "
"makes sure that email is in the right format.  If any of these validations "
"fail, an error message is queued up for rendering.  Any fields in error are "
"removed from the form data.  Error messages are represented by the "
"FormMessage class.  The first parameter of the constructor of this class "
"takes the HTML element id.  The input in error will be highlighted when the "
"form is re-rendered.  The second parameter is a message reference id.  This "
"id must correspond to a property in one of the localized message bundle "
"files.  in the theme."
msgstr ""
"上記に示されているとおり、ユーザー・プロファイル処理のvalidate()メソッドは、電子メール、名および姓がフォームに入力されていることを確認します。また、電子メールが適切なフォーマットであることを確認します。これらのバリデーションのいずれかが失敗すると、レンダリング用にエラーメッセージがキューに入れられます。エラーのあるフィールドは、すべてフォームデータから削除されます。エラーメッセージは、FormMessageクラスによって表されます。このクラスのコンストラクターでの最初のパラメーターは、HTML要素IDが取得されます。フォームが再レンダリングされると、エラー入力がハイライトされます。2番目のパラメーターはメッセージ参照IDです。このIDは、テーマ内でローカライズされたメッセージ・バンドル・ファイルのいずれかのプロパティーに対応している必要があります。"

#. type: Plain text
msgid ""
"After all validations have been processed then, the form flow then invokes "
"the FormAction.success() method.  For recaptcha this is a no-op, so we won't"
" go over it.  For user profile processing, this method fills in values in "
"the registered user."
msgstr ""
"すべてのバリデーションが処理された後、フォームフローはFormAction.success()メソッドを呼び出します。Recapthaに対して、これは何も行わないので説明はしません。ユーザー・プロファイル処理の場合、このメソッドは登録ユーザーの値を入力します。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void success(FormContext context) {\n"
"        UserModel user = context.getUser();\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        user.setFirstName(formData.getFirst(RegistrationPage.FIELD_FIRST_NAME));\n"
"        user.setLastName(formData.getFirst(RegistrationPage.FIELD_LAST_NAME));\n"
"        user.setEmail(formData.getFirst(RegistrationPage.FIELD_EMAIL));\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public void success(FormContext context) {\n"
"        UserModel user = context.getUser();\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        user.setFirstName(formData.getFirst(RegistrationPage.FIELD_FIRST_NAME));\n"
"        user.setLastName(formData.getFirst(RegistrationPage.FIELD_LAST_NAME));\n"
"        user.setEmail(formData.getFirst(RegistrationPage.FIELD_EMAIL));\n"
"    }\n"

#. type: Plain text
msgid ""
"Pretty simple implementation.  The UserModel of the newly registered user is"
" obtained from the FormContext.  The appropriate methods are called to "
"initialize UserModel data."
msgstr ""
"とてもシンプルな実装です。新しく登録されたユーザーのUserModelは、FormContextから取得されます。適切なメソッドが呼び出され、UserModelデータが初期化されます。"

#. type: Plain text
msgid ""
"Finally, you are also required to define a FormActionFactory class.  This "
"class is implemented similarly to AuthenticatorFactory, so we won't go over "
"it."
msgstr ""
"最後に、FormActionFactoryクラスを定義する必要もあります。このクラスは、AuthenticatorFactoryと同様に実装されるため、ここでは説明はしません。"

#. type: Title ====
#, no-wrap
msgid "Packaging the Action"
msgstr "アクションのパッケージ化"

#. type: Plain text
#, no-wrap
msgid ""
"You will package your classes within a single jar.\n"
"This jar must contain a file named  `org.keycloak.authentication.FormActionFactory`                and must be contained in the `META-INF/services/` directory of your jar.\n"
"This file must list the fully qualified classname of each FormActionFactory implementation you have in the jar.\n"
"For example: \n"
msgstr ""
"1つのjarファイル内にクラスをパッケージ化します。このjarには、 "
"`org.keycloak.authentication.FormActionFactory` という名前のファイルが、jarの `META-"
"INF/services/` "
"ディレクトリーに含まれている必要があります。このファイルには、jarファイル内にある各FormActionFactory実装の完全修飾クラス名が一覧化されている必要があります。たとえば、以下のとおりになります。\n"

#. type: delimited block -
#, no-wrap
msgid ""
"org.keycloak.authentication.forms.RegistrationProfile\n"
"org.keycloak.authentication.forms.RegistrationRecaptcha\n"
msgstr ""
"org.keycloak.authentication.forms.RegistrationProfile\n"
"org.keycloak.authentication.forms.RegistrationRecaptcha\n"

#. type: Title ====
#, no-wrap
msgid "Adding FormAction to the Registration Flow"
msgstr "RegistrationフローへのFormActionの追加"

#. type: Plain text
msgid ""
"Adding an FormAction to a registration page flow must be done in the admin "
"console.  If you go to the Authentication menu item and go to the Flow tab, "
"you will be able to view the currently defined flows.  You cannot modify an "
"built in flows, so, to add the Authenticator we've created you have to copy "
"an existing flow or create your own.  I'm hoping the UI is intuitive enough "
"so that you can figure out for yourself how to create a flow and add the "
"FormAction."
msgstr ""
"登録ページフローへのFormActionの追加は管理コンソールで行う必要があります。 "
"Authenticationメニュー項目へ移動してFlowタブを選択すると、現在定義されているフローが表示されます。組み込みのフローは変更することはできません。そのため、作成したオーセンティケーターを追加するには、既存のフローをコピーするか独自のフローを作成する必要があります。このUIは非常に分かりやすく作られているので、フローを作成してFormActionを追加する方法を見つけることができると思っています。"

#. type: Plain text
msgid ""
"Basically you'll have to copy the registration flow.  Then click Actions "
"menu to the right of the Registration Form, and pick \"Add Execution\" to "
"add a new execution.  You'll pick the FormAction from the selection list.  "
"Make sure your FormAction comes after \"Registration User Creation\" by "
"using the down errors to move it if your FormAction isn't already listed "
"after \"Registration User Creation\".  You want your FormAction to come "
"after user creation because the success() method of Regsitration User "
"Creation is responsible for creating the new UserModel."
msgstr ""
"基本的には、Registrationフローをコピーする必要があります。次に、Registration "
"Formの右側にあるActionsメニューをクリックし、\"Add "
"Execution\"を選択して新しいエグゼキューションを追加します。選択リストからFormActionを選択します。FormActionが\"Registration"
" User Creation\"の後に表示されていない場合は、ダウンエラーを使用してFormActionが\"Registration User "
"Creation\"の後に来ることを確認してください。Regsitration User "
"Creationのsuccess()メソッドは、新しいUserModelの作成を受け持つため、FormActionはユーザー作成の後に表示される必要があります。"
" "

#. type: Plain text
msgid ""
"After you've created your flow, you have to bind it to registration.  If you"
" go to the Authentication menu and go to the Bindings tab you will see "
"options to bind a flow to the browser, registration, or direct grant flow."
msgstr ""
"フローを作成した後、そのフローをRegistrationにバインドする必要があります。Authenticationメニューに移動してBindingsタブを選択すると、フローをBrowser、Registration、またはDirect"
" Grantフローにバインドするオプションが表示されます。"

#. type: Title ===
#, no-wrap
msgid "Modifying Forgot Password/Credential Flow"
msgstr "パスワード忘れおよびクレデンシャル・フローの変更"

#. type: Plain text
msgid ""
"Keycloak also has a specific authentication flow for forgot password, or "
"rather credential reset initiated by a user.  If you go to the admin console"
" flows page, there is a \"reset credentials\" flow.  By default, Keycloak "
"asks for the email or username of the user and sends an email to them.  If "
"the user clicks on the link, then they are able to reset both their password"
" and OTP (if an OTP has been set up).  You can disable automatic OTP reset "
"by disabling the \"Reset OTP\" authenticator in the flow."
msgstr ""
"Keycloakには、パスワードを忘れた場合の特定の認証フロー、またはユーザーにより発行されたクレデンシャルのリセットもあります。管理コンソールのフローページに移動すると、\"Reset"
" "
"Credentials\"フローがあります。デフォルトでは、Keycloakはユーザーの電子メールまたはユーザー名を要求し、ユーザーに電子メールを送信します。ユーザーがリンクをクリックすると、パスワードとOTP（OTPが設定されている場合）の両方をリセットすることができます。フローの\"Reset"
" OTP\"オーセンティケーターを無効にすると、自動のOTPリセットを無効にすることができます。"

#. type: Plain text
msgid ""
"You can add additional functionality to this flow as well.  For example, "
"many deployments would like for the user to answer one or more secret "
"questions in additional to sending an email with a link.  You could expand "
"on the secret question example that comes with the distro and incorporate it"
" into the reset credential flow."
msgstr ""
"このフローにも機能を追加することができます。たとえば、多くのデプロイメントでは、リンク付きの電子メールを送信することに加え、ユーザーは1つ以上の秘密の質問に回答することができます。配布物に付属している秘密の質問のサンプルを拡張し、それをReset"
" Credentialフローに組み込むことができます。"

#. type: Plain text
msgid ""
"One thing to note if you are extending the reset credentials flow.  The "
"first \"authenticator\" is just a page to obtain the username or email.  If "
"the username or email exists, then the AuthenticationFlowContext.getUser() "
"will return the located user.  Otherwise this will be null.  This form *WILL"
" NOT* re-ask the user to enter in an email or username if the previous email"
" or username did not exist.  You need to prevent attackers from being able "
"to guess valid users.  So, if AuthenticationFlowContext.getUser() returns "
"null, you should proceed with the flow to make it look like a valid user was"
" selected.  I suggest that if you want to add secret questions to this flow,"
" you should ask these questions after the email is sent.  In other words, "
"add your custom authenticator after the \"Send Reset Email\" authenticator."
msgstr ""
"Reset "
"Credentialsフローを拡張する場合、1つ注意点があります。最初の\"オーセンティケーター\"は、ユーザー名または電子メールを取得するための単なるページです。ユーザー名または電子メールが存在する場合、AuthenticationFlowContext.getUser()はそのユーザーを返します。それ以外の場合はnullになります。このフォームは、以前の電子メールまたはユーザー名が存在しない場合、電子メールまたはユーザー名を入力するようにユーザーに再要求"
" *しません* "
"。攻撃者が有効なユーザーを推測できないようにする必要があるため、AuthenticationFlowContext.getUser()がnullを返す場合、有効なユーザーが選択されたかのように見せかけるために、フローを続行する必要があります。このフローに秘密の質問を追加する場合は、電子メールの送信後にこれらの質問をすることをお勧めします。つまり、\"Send"
" Reset Email\"オーセンティケーターの後に、カスタム・オーセンティケーターを追加してください。"

#. type: Title ===
#, no-wrap
msgid "Modifying First Broker Login Flow"
msgstr "First Broker Loginフローの変更"

#. type: Plain text
msgid ""
"First Broker Login flow is used during first login with some identity "
"provider.  Term `First Login` means that there is not yet existing "
"{project_name} account linked with the particular authenticated identity "
"provider account.  For more details about this flow see the `Identity "
"Brokering` chapter in link:{adminguide_link}[{adminguide_name}] ."
msgstr ""
"First Broker Loginフローは、アイデンティティー・プロバイダーに最初にログインした時に使用されます。 `First Login` "
"という用語は、特定の認証されたアイデンティティー・プロバイダー・アカウントにリンクされている{project_name}アカウントがまだ存在していないことを意味します。このフローの詳細については、link:{adminguide_link}[{adminguide_name}]の"
" `アイデンティティー・ブローカリング` の章を参照してください。"

#. type: Title ===
#, no-wrap
msgid "Authentication of clients"
msgstr "クライアントの認証"

#. type: Plain text
msgid ""
"{project_name} actually supports pluggable authentication for "
"http://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect] client "
"applications.  Authentication of client (application) is used under the hood"
" by the {project_name} adapter during sending any backchannel requests to "
"the {project_name} server (like the request for exchange code to access "
"token after successful authentication or request to refresh token).  But the"
" client authentication can be also used directly by you during `Direct "
"Access grants` (represented by OAuth2 `Resource Owner Password Credentials "
"Flow`)  or during `Service account` authentication (represented by OAuth2 "
"`Client Credentials Flow`)."
msgstr ""
"{project_name}は実際には、 http://openid.net/specs/openid-connect-core-"
"1_0.html[OpenID Connect] "
"クライアント・アプリケーションのためのプラグイン可能な認証をサポートしています。クライアント（アプリケーション）の認証は、{project_name}アダプターがバックチャネル・リクエストを{project_name}サーバーに送信中に内部で使用されます（認証が成功した後にアクセストークンに交換コードを要求したり、リフレッシュトークンを要求したりするなど）。しかし、"
" `ダイレクト・アクセス・グラント` （OAuth2により表される `Resource Owner Password Credentials Flow`"
" ）または `サービス・アカウント` 認証（OAuth2により表される `Client Credentials Flow` "
"）でクライアント認証を直接使用することも可能です。"

#. type: Plain text
msgid ""
"For more details about {project_name} adapter and OAuth2 flows see "
"link:{adapterguide_link}[{adapterguide_name}]."
msgstr ""
"{project_name}アダプターとOAuth2フローの詳細については、link:{adapterguide_link}[{adapterguide_name}]を参照してください。"

#. type: Title ====
#, no-wrap
msgid "Default implementations"
msgstr "デフォルト実装"

#. type: Plain text
msgid ""
"Actually Keycloak has 2 builtin implementations of client authentication:"
msgstr "実際、Keycloakには、以下の2つのクライアント認証の実装が組み込まれています。"

#. type: Labeled list
#, no-wrap
msgid "Traditional authentication with client_id and client_secret"
msgstr "client_idとclient_secretによる従来の認証"

#. type: Plain text
#, no-wrap
msgid ""
"This is default mechanism mentioned in the http://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect]                                or https://tools.ietf.org/html/rfc6749[OAuth2] specification and Keycloak supports it since it's early days.\n"
"The public client needs to include `client_id` parameter with it's ID in the POST request (so it's defacto not authenticated) and the confidential client needs to include `Authorization: Basic` header with the clientId and clientSecret used as username and password. \n"
msgstr ""
"これは、 http://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect] "
"または https://tools.ietf.org/html/rfc6749[OAuth2] "
"の仕様で記載されているデフォルトのメカニズムであり、Keycloakは初期段階からサポートしています。パブリック・クライアントには、POSTリクエストにIDを持つ"
" `client_id` パラメーターが含まれている必要があり（実際は認証されていません）、コンフィデンシャル・クライアントには、クライアントIDの "
"`Authorization: Basic` ヘッダーとユーザー名とパスワードとして使用されるクライアント・シークレットが含まれている必要があります。\n"

#. type: Labeled list
#, no-wrap
msgid "Authentication with signed JWT"
msgstr "署名付きJWTによる認証"

#. type: Plain text
#, no-wrap
msgid ""
"This is based on the https://tools.ietf.org/html/rfc7523[JWT Bearer Token Profiles for OAuth 2.0] specification.\n"
"The client/adapter generates the https://tools.ietf.org/html/rfc7519[JWT] and signs it with his private key.\n"
"The Keycloak then verifies the signed JWT with the client's public key and authenticates client based on it.             \n"
msgstr ""
"これは、 https://tools.ietf.org/html/rfc7523[JWT Bearer Token Profiles for OAuth"
" 2.0] 仕様に基づいています。クライアントまたはアダプターは、 https://tools.ietf.org/html/rfc7519[JWT] "
"を生成し、秘密鍵で署名します。Keycloakは、署名されたJWTをクライアントの公開鍵で検証し、それに基づいてクライアントを認証します。 \n"

#. type: Plain text
msgid ""
"See the demo example and especially the `examples/preconfigured-demo"
"/product-app` for the example application showing the application using "
"client authentication with signed JWT."
msgstr ""
"署名されたJWTでクライアント認証を使用するアプリケーションのサンプルを表示するには、デモの例と `examples/preconfigured-"
"demo/product-app` にあるサンプルを参照してください。"

#. type: Title ====
#, no-wrap
msgid "Implement your own client authenticator"
msgstr "独自のクライアント・オーセンティケーターの実装"

#. type: Plain text
msgid ""
"For plug your own client authenticator, you need to implement few interfaces"
" on both client (adapter) and server side."
msgstr ""
"独自のクライアント・オーセンティケーターをプラグインするには、クライアント（アダプター）とサーバー側の両方にいくつかのインターフェイスを実装する必要があります。"

#. type: Labeled list
#, no-wrap
msgid "Client side"
msgstr "クライアント側"

#. type: Plain text
msgid ""
"Here you need to implement "
"`org.keycloak.adapters.authentication.ClientCredentialsProvider` and put the"
" implementation either to:"
msgstr ""
"ここでは、 `org.keycloak.adapters.authentication.ClientCredentialsProvider` "
"を実装し、以下のいずれかにその実装を入れる必要があります。"

#. type: Plain text
msgid ""
"your WAR file into WEB-INF/classes . But in this case, the implementation "
"can be used just for this single WAR application"
msgstr "WEB-INF/classesのWARファイル。ただし、この場合、実装はこの単一のWARアプリケーションに対してのみ使用できます。"

#. type: Plain text
msgid "Some JAR file, which will be added into WEB-INF/lib of your WAR"
msgstr "WARのWEB-INF/libに追加されるJARファイル。"

#. type: Plain text
#, no-wrap
msgid ""
"Some JAR file, which will be used as jboss module and configured in jboss-"
"deployment-structure.xml of your WAR.                                In all "
"cases, you also need to create the file `META-"
"INF/services/org.keycloak.adapters.authentication.ClientCredentialsProvider`"
"                                either in the WAR or in your JAR. \n"
msgstr ""
"JBossモジュールとして使用され、WARのjboss-deployment-structure.xmlで設定されるJARファイル。 "
"いずれの場合も、WARまたはJARに `META-"
"INF/services/org.keycloak.adapters.authentication.ClientCredentialsProvider`"
" ファイルを作成する必要があります。\n"

#. type: Labeled list
#, no-wrap
msgid "Server side"
msgstr "サーバー側"

#. type: Plain text
#, no-wrap
msgid ""
"Here you need to implement `org.keycloak.authentication.ClientAuthenticatorFactory` and `org.keycloak.authentication.ClientAuthenticator` . You also need to add the file `META-INF/services/org.keycloak.authentication.ClientAuthenticatorFactory` with the name of the implementation classes.\n"
"See <<_auth_spi_walkthrough,authenticators>> for more details.             \n"
msgstr ""
"ここでは、 `org.keycloak.authentication.ClientAuthenticatorFactory` と "
"`org.keycloak.authentication.ClientAuthenticator` を実装する必要があります。また、 `META-"
"INF/services/org.keycloak.authentication.ClientAuthenticatorFactory` "
"ファイルに実装クラスの名前を追加する必要があります。詳細については、<<_auth_spi_walkthrough,オーセンティケーター>> "
"を参照してください。\n"
