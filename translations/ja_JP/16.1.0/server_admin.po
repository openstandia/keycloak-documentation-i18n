# 
# Translators:
# KojiNose <knose.dev@gmail.com>, 2023
# jic_m_mito <jic-m-mito@nri.co.jp>, 2023
# Yoshikazu Nojima <mail@ynojima.net>, 2023
# n.watanabe <nwatanabe.ase@gmail.com>, 2023
# Naoki Ueda, 2023
# Tsukasa Amano <t.amano@pro-japan.co.jp>, 2023
# katakura__pro <h.katakura@pro-japan.co.jp>, 2023
# Shinsuke UEDA, 2023
# Kohei Tamura <ktamura.biz.80@gmail.com>, 2023
# Hiroyuki Wada <wadahiro@gmail.com>, 2023
# 
msgid ""
msgstr ""
"Last-Translator: Hiroyuki Wada <wadahiro@gmail.com>, 2023\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid "{adminguide_name}"
msgstr "{adminguide_name}"

msgid "*{release_header_guide}* icon:angle-down[]"
msgstr "*{release_header_guide}* icon:angle-down[]"

msgid "{gettingstarted_link}[{gettingstarted_name_short}]"
msgstr "{gettingstarted_link}[{gettingstarted_name_short}]"

msgid "{installguide_link}[{installguide_name_short}]"
msgstr "{installguide_link}[{installguide_name_short}]"

msgid "{adapterguide_link}[{adapterguide_name_short}]"
msgstr "{adapterguide_link}[{adapterguide_name_short}]"

msgid "{developerguide_link}[{developerguide_name_short}]"
msgstr "{developerguide_link}[{developerguide_name_short}]"

msgid "{authorizationguide_link}[{authorizationguide_name_short}]"
msgstr "{authorizationguide_link}[{authorizationguide_name_short}]"

msgid "{upgradingguide_link}[{upgradingguide_name_short}]"
msgstr "{upgradingguide_link}[{upgradingguide_name_short}]"

msgid "{releasenotes_link}[{releasenotes_name_short}]"
msgstr "{releasenotes_link}[{releasenotes_name_short}]"

msgid ""
"Version *{project_version}* _{release_header_latest_link}[Click here for "
"latest]_"
msgstr "バージョン *{project_version}* _{release_header_latest_link}[最新はこちらをクリック]_"

msgid "{project_name} features and concepts"
msgstr "{project_name}の機能と概念"

msgid ""
"{project_name} is a single sign on solution for web apps and RESTful web "
"services.  The goal of {project_name} is to make security simple so that it "
"is easy for application developers to secure the apps and services they have"
" deployed in their organization.  Security features that developers normally"
" have to write for themselves are provided out of the box and are easily "
"tailorable to the individual requirements of your organization.  "
"{project_name} provides customizable user interfaces for login, "
"registration, administration, and account management.  You can also use "
"{project_name} as an integration platform to hook it into existing LDAP and "
"Active Directory servers.  You can also delegate authentication to third "
"party identity providers like Facebook and Google."
msgstr ""
"{project_name}はWebアプリケーションおよびRESTfulなWebサービスのためのシングル・サインオン・ソリューションです。{project_name}の目的はセキュリティーをシンプルに実現し、アプリケーション開発者が組織内にデプロイしたアプリケーションやサービスを保護することです。開発者が通常自分達自身で書かないといけないセキュリティー機能はすぐに提供され、組織内の個々の要件に合わせて簡単に調整することができます。{project_name}は、ログイン、登録、システム管理、アカウント管理のための、カスタマイズ可能なユーザー・インターフェイスを提供しています。{project_name}は、既存のLDAPやActive"
" "
"Directoryサーバーへ接続し、統合プラットフォームとして利用することもできます。また、FacebookやGoogleのようなサードパーティーのアイデンティティー・プロバイダーに対して、認証を委譲することも可能です。"

msgid "Features"
msgstr "機能"

msgid "{project_name} provides the following features:"
msgstr "{project_name}は次の機能を提供します。"

msgid "Single-Sign On and Single-Sign Out for browser applications."
msgstr "ブラウザー・アプリケーションに対するシングル・サインオンとシングル・サインアウト。"

msgid "OpenID Connect support."
msgstr "OpenID Connectのサポート。"

msgid "OAuth 2.0 support."
msgstr "OAuth 2.0のサポート。"

msgid "SAML support."
msgstr "SAMLのサポート。"

msgid ""
"Identity Brokering - Authenticate with external OpenID Connect or SAML "
"Identity Providers."
msgstr ""
"アイデンティティー・ブローカリング - 外部のOpenID ConnectもしくはSAMLに対応したアイデンティティー・プロバイダーによる認証。"

msgid ""
"Social Login - Enable login with Google, GitHub, Facebook, Twitter, and "
"other social networks."
msgstr "ソーシャル・ログイン - Google、GitHub、Facebook、Twitterや他のソーシャル・ネットワークによるログイン。"

msgid "User Federation - Sync users from LDAP and Active Directory servers."
msgstr "ユーザー・フェデレーション - LDAPやActive Directoryからのユーザー同期。"

msgid ""
"Kerberos bridge - Automatically authenticate users that are logged-in to a "
"Kerberos server."
msgstr "ケルベロス連携 - ケルベロス・サーバーにログイン済のユーザーに対する認証連携。"

msgid ""
"Admin Console for central management of users, roles, role mappings, clients"
" and configuration."
msgstr "ユーザー、ロール、ロール・マッピング、クライアントと設定を一元管理するための管理コンソール。"

msgid ""
"Account Management console that allows users to centrally manage their "
"account."
msgstr "ユーザーに自分達のアカウントを一元管理することを許可するためのアカウント管理コンソール。"

msgid ""
"Theme support - Customize all user facing pages to integrate with your "
"applications and branding."
msgstr "テーマ対応 - すべての利用者向け画面をカスタマイズでき、アプリケーションとブランディングを統合可能。"

msgid ""
"Two-factor Authentication - Support for TOTP/HOTP via Google Authenticator "
"or FreeOTP."
msgstr "二要素認証 - Google AuthenticatorやFreeOTPを使用したTOTP/HOTPのサポート。"

msgid ""
"Login flows - optional user self-registration, recover password, verify "
"email, require password update, etc."
msgstr ""
"ログイン・フロー - オプション機能のユーザー・セルフ・レジストレーション、パスワード・リカバリー、電子メールによる検証、強制パスワード変更など。"

msgid ""
"Session management - Admins and users themselves can view and manage user "
"sessions."
msgstr "セッション管理 - 管理者や利用者が自分のセッションを参照・管理することが可能。"

msgid ""
"Token mappers - Map user attributes, roles, etc. how you want into tokens "
"and statements."
msgstr "トークン・マッパー - ユーザー属性やロールなどをトークンやステートメントにどのように反映するかの指定。"

msgid "Not-before revocation policies per realm, application and user."
msgstr "レルム、アプリケーション、ユーザー単位のNot-beforeリボケーション・ポリシー。"

msgid "CORS support - Client adapters have built-in support for CORS."
msgstr "CORSのサポート - CORSに対応済みのクライアント・アダプター。"

msgid ""
"Service Provider Interfaces (SPI) - A number of SPIs to enable customizing "
"various aspects of the server. Authentication flows, user federation "
"providers, protocol mappers and many more."
msgstr ""
"サービス・プロバイダー・インターフェイス（SPI） - "
"サーバーのさまざまな側面をカスタマイズするための数多くのSPI。認証フロー、ユーザー・フェデレーション・プロバイダー、プロトコル・マッパーなどその他多数。"

msgid ""
"Client adapters for JavaScript applications, WildFly, JBoss EAP, Fuse, "
"Tomcat, Jetty, Spring, etc."
msgstr "JavaScript、WildFly、JBoss EAP、Fuse、Tomcat、Jetty、Springなどのクライアント・アダプター。"

msgid ""
"Supports any platform/language that has an OpenID Connect Relying Party "
"library or SAML 2.0 Service Provider library."
msgstr ""
"OpenID Connectのリライング・パーティー・ライブラリー、もしくは、SAML "
"2.0のサービス・プロバイダー・ライブラリーをもつ、あらゆるプラットフォーム/言語のサポート。"

msgid "Basic {project_name} operations"
msgstr "基本的な{project_name}の操作"

msgid ""
"{project_name} is a separate server that you manage on your network.  "
"Applications are configured to point to and be secured by this server.  "
"{project_name} uses open protocol standards like "
"link:https://openid.net/connect/[OpenID Connect] or "
"link:http://saml.xml.org/saml-specifications[SAML 2.0] to secure your "
"applications.  Browser applications redirect a user's browser from the "
"application to the {project_name} authentication server where they enter "
"their credentials.  This redirection is important because users are "
"completely isolated from applications and applications never see a user's "
"credentials.  Applications instead are given an identity token or assertion "
"that is cryptographically signed.  These tokens can have identity "
"information like username, address, email, and other profile data.  They can"
" also hold permission data so that applications can make authorization "
"decisions.  These tokens can also be used to make secure invocations on "
"REST-based services."
msgstr ""
"{project_name}は、あなたのネットワーク上で管理する独立したサーバーです。アプリケーションはこのサーバーを指し示すように設定され、このサーバーによってセキュリティー保護されます。{project_name}はアプリケーションをセキュリティー保護するために、"
" link:https://openid.net/connect/[OpenID Connect] や "
"link:http://saml.xml.org/saml-specifications[SAML 2.0] "
"といった標準プロトコルを採用しています。ブラウザー・アプリケーションは、ユーザーのブラウザーをアプリケーションから自分のクレデンシャルを入力する{project_name}認証サーバーにリダイレクトします。ユーザーは完全にアプリケーションから分離され、アプリケーションはユーザーのクレデンシャルを見ることも決してないため、このリダイレクトは重要です。代わりに、アプリケーションには、暗号化署名されたIDトークンまたはアサーションが与えられます。これらのトークンはユーザー名、住所、電子メール、および、その他プロファイルデータといったアイデンティティー情報を持つことができます。また、パーミッション・データを保持することも可能でアプリケーションは認可決定を行うことも可能です。これらのトークンはRESTベースのサービスに対して安全な呼び出しを行うためにも使用できます。"

msgid "Core concepts and terms"
msgstr "コアコンセプトと用語"

msgid ""
"Consider these core concepts and terms before attempting to use "
"{project_name} to secure your web applications and REST services."
msgstr ""
"{project_name}を使用して、WebアプリケーションやRESTサービスをセキュリティー保護しようとする前に、知っておくべきキーコンセプトと用語があります。"

msgid "users"
msgstr "ユーザー"

msgid ""
"Users are entities that are able to log into your system.  They can have "
"attributes associated with themselves like email, username, address, phone "
"number, and birth day.  They can be assigned group membership and have "
"specific roles assigned to them."
msgstr ""
"システムにログイン可能なエンティティーのことです。電子メール、ユーザー名、住所、電話番号、生年月日など自分自身に関連する属性を持ちます。また、グループ・メンバーシップが割り当てられたり、特定のロールが割り当てられたりします。"

msgid "authentication"
msgstr "認証"

msgid "The process of identifying and validating a user."
msgstr "ユーザーを特定し、検証するプロセスのことです。"

msgid "authorization"
msgstr "認可"

msgid "The process of granting access to a user."
msgstr "ユーザーに対してアクセスを許可するプロセスのことです。"

msgid "credentials"
msgstr "クレデンシャル"

msgid ""
"Credentials are pieces of data that {project_name} uses to verify the "
"identity of a user.  Some examples are passwords, one-time-passwords, "
"digital certificates, or even fingerprints."
msgstr ""
"クレデンシャルは、{project_name}がユーザーの身元を確認するために使用するデータの一部のことです。例として、パスワード、ワンタイムパスワード、デジタル証明書、さらには指紋などがあります。"

msgid "roles"
msgstr "ロール"

msgid ""
"Roles identify a type or category of user.  `Admin`, `user`, `manager`, and "
"`employee` are all typical roles that may exist in an organization.  "
"Applications often assign access and permissions to specific roles rather "
"than individual users as dealing with users can be too fine grained and hard"
" to manage."
msgstr ""
"ロールは、ユーザーのタイプまたはカテゴリーを識別します。 `Admin`、`user`、 `manager`、`employee` "
"はすべて、組織内に存在する典型的なロールです。アプリケーションは、ユーザーの扱いをきめ細く管理することが難しくなる場合があるため、個々のユーザーではなく、特定のロールにパーミッションを割り当てることが多いです。"

msgid "user role mapping"
msgstr "ユーザー・ロール・マッピング"

msgid ""
"A user role mapping defines a mapping between a role and a user.  A user can"
" be associated with zero or more roles.  This role mapping information can "
"be encapsulated into tokens and assertions so that applications can decide "
"access permissions on various resources they manage."
msgstr ""
"ユーザー・ロール・マッピングは、ロールとユーザーの間のマッピングを定義します。ユーザーには、0以上のロールを関連付けることができます。このロールマッピング情報を、トークンとアサーションにカプセル化して、アプリケーションが管理するさまざまなリソースに対するアクセス許可を決定できるようにします。"

msgid "composite roles"
msgstr "複合ロール"

msgid ""
"A composite role is a role that can be associated with other roles.  For "
"example a `superuser` composite role could be associated with the `sales-"
"admin` and `order-entry-admin` roles.  If a user is mapped to the "
"`superuser` role they also inherit the `sales-admin` and `order-entry-admin`"
" roles."
msgstr ""
"複合ロールは、他のロールと関連付けることができるロールです。たとえば、 `superuser` 複合ロールは `sales-admin` ロールと "
"`order-entry-admin` ロールに関連付けることができます。ユーザーが `superuser` ロールにマッピングされると、 "
"`sales-admin` ロールと `order-entry-admin` ロールも継承します。"

msgid "groups"
msgstr "グループ"

msgid ""
"Groups manage groups of users.  Attributes can be defined for a group.  You "
"can map roles to a group as well.  Users that become members of a group "
"inherit the attributes and role mappings that group defines."
msgstr ""
"グループは、ユーザーのグループを管理します。グループには、属性を定義することができます。ロールもグループにマップすることができます。グループのメンバーになったユーザーは、そのグループが定義する属性とロールのマッピングを継承します。"

msgid "realms"
msgstr "レルム"

msgid ""
"A realm manages a set of users, credentials, roles, and groups.  A user "
"belongs to and logs into a realm.  Realms are isolated from one another and "
"can only manage and authenticate the users that they control."
msgstr ""
"レルムは、ユーザー、クレデンシャル、ロール、および、グループのセットを管理します。ユーザーは属しているレルムにログインします。レルムは互いに分離されており、制御するユーザーのみを管理して、認証することができます。"

msgid "clients"
msgstr "クライアント"

msgid ""
"Clients are entities that can request {project_name} to authenticate a user."
"  Most often, clients are applications and services that want to use "
"{project_name} to secure themselves and provide a single sign-on solution.  "
"Clients can also be entities that just want to request identity information "
"or an access token so that they can securely invoke other services on the "
"network that are secured by {project_name}."
msgstr ""
"クライアントは、{project_name}にユーザーの認証を要求できるエンティティーです。多くの場合、クライアントは{project_name}を使用して自分自身を保護し、シングル・サインオン・ソリューションを提供するアプリケーションとサービスのことを指します。また、クライアントは{project_name}によって保護されているネットワーク上の他のサービスを安全に呼び出すことができるように、アイデンティティー情報やアクセストークンを要求するエンティティーになります。"

msgid "client adapters"
msgstr "クライアント・アダプター"

msgid ""
"Client adapters are plugins that you install into your application "
"environment to be able to communicate and be secured by {project_name}.  "
"{project_name} has a number of adapters for different platforms that you can"
" download.  There are also third-party adapters you can get for environments"
" that we don't cover."
msgstr ""
"クライアント・アダプターは、{project_name}による通信とセキュリティー保護を可能にするためにアプリケーション環境にインストールするプラグインです。{project_name}には、異なるプラットフォーム向けにいくつかのアダプターが用意されており、ダウンロードが可能です。また、標準ではカバーしていない環境向けのサードパーティーのアダプターもあります。"

msgid "consent"
msgstr "同意"

msgid ""
"Consent is when you as an admin want a user to give permission to a client "
"before that client can participate in the authentication process. After a "
"user provides their credentials, {project_name} will pop up a screen "
"identifying the client requesting a login and what identity information is "
"requested of the user.  User can decide whether or not to grant the request."
msgstr ""
"同意は、クライアントが認証プロセスに参加する前に、クライアントに許可を与えることを管理者がユーザーに求めることです。ユーザーがクレデンシャルを入力すると、{project_name}がログインを要求しているクライアントを識別する画面とユーザーに要求された識別情報を表示します。ユーザーは、要求を許可するかどうかを決定できます。"

msgid "client scopes"
msgstr "クライアント・スコープ"

msgid ""
"When a client is registered, you must define protocol mappers and role scope"
" mappings for that client. It is often useful to store a client scope, to "
"make creating new clients easier by sharing some common settings. This is "
"also useful for requesting some claims or roles to be conditionally based on"
" the value of `scope` parameter. {project_name} provides the concept of a "
"client scope for this."
msgstr ""
"クライアントが登録されたら、そのクライアントのプロトコル・マッパーとロールスコープのマッピングを定義する必要があります。いくつかの共通の設定を共有することで、新しいクライアントの作成を容易にするために、クライアント・スコープを保存すると便利なことがよくあります。これは、"
" `scope` "
"パラメーターの値に基づいて条件付きでクレームやロールを要求する場合にも便利です。{project_name}は、このためにクライアント・スコープの概念を提供します。"

msgid "client role"
msgstr "クライアントロール"

msgid ""
"Clients can define roles that are specific to them.  This is basically a "
"role namespace dedicated to the client."
msgstr "クライアントは、特定のロールを定義できます。これは、基本的にクライアント専用のロールの名前空間です。"

msgid "identity token"
msgstr "IDトークン"

msgid ""
"A token that provides identity information about the user.  Part of the "
"OpenID Connect specification."
msgstr "ユーザーに関する識別情報を提供するトークンです。これは、OpenID Connect仕様の一部です。"

msgid "access token"
msgstr "アクセストークン"

msgid ""
"A token that can be provided as part of an HTTP request that grants access "
"to the service being invoked on.  This is part of the OpenID Connect and "
"OAuth 2.0 specification."
msgstr ""
"サービスへのアクセスを許可するHTTPリクエストの一部として提供できるトークンです。これは、OpenID ConnectおよびOAuth "
"2.0仕様の一部です。"

msgid "assertion"
msgstr "アサーション"

msgid ""
"Information about a user.  This usually pertains to an XML blob that is "
"included in a SAML authentication response that provided identity metadata "
"about an authenticated user."
msgstr ""
"ユーザーに関する情報です。これは、通常、認証されたユーザーに関するアイデンティティー・メタデータを提供するSAML認証レスポンスに含まれるXML "
"BLOBに関係します。"

msgid "service account"
msgstr "サービス・アカウント"

msgid ""
"Each client has a built-in service account which allows it to obtain an "
"access token."
msgstr "各クライアントには、アクセストークンを取得するための組み込みサービス・アカウントがあります。"

msgid "direct grant"
msgstr "ダイレクト・グラント"

msgid ""
"A way for a client to obtain an access token on behalf of a user via a REST "
"invocation."
msgstr "クライアントがREST呼び出しを介して、ユーザーに代わってアクセストークンを取得する方法です。"

msgid "protocol mappers"
msgstr "プロトコル・マッパー"

msgid ""
"For each client you can tailor what claims and assertions are stored in the "
"OIDC token or SAML assertion.  You do this per client by creating and "
"configuring protocol mappers."
msgstr ""
"各クライアントに対して、どのクレームおよびアサーションをOIDCトークンまたはSAMLアサーションに格納するかを調整できます。クライアントごとに、プロトコル・マッパーを構成します。"

msgid "session"
msgstr "セッション"

msgid ""
"When a user logs in, a session is created to manage the login session.  A "
"session contains information like when the user logged in and what "
"applications have participated within single-sign on during that session.  "
"Both admins and users can view session information."
msgstr ""
"ユーザーがログインすると、ログイン・セッションを管理するためのセッションが作成されます。セッションには、ユーザーがログインした時刻や、そのセッション中にシングル・サインオンに参加したアプリケーションなどの情報が含まれています。管理者とユーザーの両方がセッション情報を表示できます。"

msgid "user federation provider"
msgstr "ユーザー・フェデレーション・プロバイダー"

msgid ""
"{project_name} can store and manage users.  Often, companies already have "
"LDAP or Active Directory services that store user and credential "
"information.  You can point {project_name} to validate credentials from "
"those external stores and pull in identity information."
msgstr ""
"{project_name}はユーザーを保存および管理できます。多くの企業では、ユーザー情報とクレデンシャル情報を保存するLDAPまたはActive "
"Directoryサービスがすでに用意されています。外部ストアからのクレデンシャル情報を検証し、アイデンティティー情報を取得するように、{project_name}を設定できます。"

msgid "identity provider"
msgstr "アイデンティティー・プロバイダー"

msgid ""
"An identity provider (IDP) is a service that can authenticate a user.  "
"{project_name} is an IDP."
msgstr "アイデンティティー・プロバイダー（IDP）は、ユーザーを認証できるサービスです。{project_name}はIDPです。"

msgid "identity provider federation"
msgstr "アイデンティティー・プロバイダー・フェデレーション"

msgid ""
"{project_name} can be configured to delegate authentication to one or more "
"IDPs.  Social login via Facebook or Google+ is an example of identity "
"provider federation.  You can also hook {project_name} to delegate "
"authentication to any other OpenID Connect or SAML 2.0 IDP."
msgstr ""
"{project_name}は、1つ以上のIDPに認証を委任するように設定できます。FacebookやGoogle+を介したソーシャル・ログインは、アイデンティティー・プロバイダー・フェデレーションの一例です。{project_name}をフックして、他のOpenID"
" ConnectまたはSAML 2.0 IDPに認証を委任することもできます。"

msgid "identity provider mappers"
msgstr "アイデンティティー・プロバイダー・マッパー"

msgid ""
"When doing IDP federation you can map incoming tokens and assertions to user"
" and session attributes.  This helps you propagate identity information from"
" the external IDP to your client requesting authentication."
msgstr ""
"IDPフェデレーションを実行するときに、受信したトークンやアサーションにユーザー属性やセッション属性をマップできます。これは外部IDPから認証を要求するクライアントへアイデンティティー情報を伝播させるのに役立ちます。"

msgid "required actions"
msgstr "必須アクション"

msgid ""
"Required actions are actions a user must perform during the authentication "
"process.  A user will not be able to complete the authentication process "
"until these actions are complete.  For example, an admin may schedule users "
"to reset their passwords every month.  An `update password` required action "
"would be set for all these users."
msgstr ""
"必須アクションは、ユーザーが認証プロセス中に実行する必要があるアクションです。これらのアクションが完了するまで、ユーザーは認証プロセスを完了できません。たとえば、管理者は、すべてのユーザーに対して、"
" `update password` の必須アクションを設定し、毎月パスワードをリセットするようにユーザーへ要求することができます。"

msgid "authentication flows"
msgstr "認証フロー"

msgid ""
"Authentication flows are work flows a user must perform when interacting "
"with certain aspects of the system.  A login flow can define what credential"
" types are required.  A registration flow defines what profile information a"
" user must enter and whether something like reCAPTCHA must be used to filter"
" out bots.  Credential reset flow defines what actions a user must do before"
" they can reset their password."
msgstr ""
"認証フローは、システムの特定の側面と対話するときにユーザーが実行する必要があるワークフローです。ログインフローでは、必要なクレデンシャル・タイプを定義します。登録フローでは、ユーザーが入力する必要のあるプロファイル情報と、reCAPTCHAを使用してボットをフィルタリングする必要があるかどうかを定義します。クレデンシャル・リセットフローは、ユーザーがパスワードをリセットする前に実行する必要があるアクションを定義します。"

msgid "events"
msgstr "イベント"

msgid "Events are audit streams that admins can view and hook into."
msgstr "イベントは、管理者が表示したり、フックしたりすることができる監査ストリームです。"

msgid "themes"
msgstr "テーマ"

msgid ""
"Every screen provided by {project_name} is backed by a theme.  Themes define"
" HTML templates and stylesheets which you can override as needed."
msgstr ""
"{project_name}によって提供されるすべての画面にはテーマが付いています。テーマは必要に応じて上書きできるHTMLテンプレートとスタイルシートを定義します。"

msgid "Creating the first administrator"
msgstr "最初の管理者の作成"

msgid ""
"After installing {project_name}, you need an administrator account that can "
"act as a _super_ admin with full permisions to manage all parts of "
"{project_name}. With this account, you can log into the {project_name} Admin"
" Console where you create realms and users and register applications that "
"are secured by {project_name}."
msgstr ""
"{project_name} をインストールした後、{project_name}のすべての部分を管理するための完全なパーミッションを持つ _super_"
" "
"管理者として動作する管理者アカウントが必要です。このアカウントでは、{project_name}の管理コンソールにログインできます。管理者コンソールにログインして、レルムやユーザーを作成したり、{project_name}で保護されたアプリケーションを登録したりすることができます。"

msgid "Prerequisites"
msgstr "前提条件"

msgid ""
"Perform the installation and configuration tasks defined in the "
"link:{installguide_link}[{installguide_name}] to the point that the "
"{project_name} server is running."
msgstr ""
"link:{installguide_link}[{installguide_name}] "
"で定義されているインストールと設定のタスクを、{project_name}サーバーが稼働するまで実行します。"

msgid "Creating the account on the local host"
msgstr "ローカルホストでのアカウント作成"

msgid "If your server is accessible from `localhost`, perform these steps."
msgstr "サーバーが `localhost` からアクセスできる場合は、以下の手順を実行してください。"

msgid "Procedure"
msgstr "手順"

msgid "In a web browser, go to the http://localhost:8080/auth URL."
msgstr "Webブラウザーで、http://localhost:8080/auth URLにアクセスします。"

msgid "Supply a username and password that you can recall."
msgstr "思い出せるユーザー名とパスワードを入力してください。"

msgid "Welcome page"
msgstr "ウェルカムページ"

msgid "image:{project_images}/initial-welcome-page.png[Welcome Page]"
msgstr "image:{project_images}/initial-welcome-page.png[Welcome Page]"

msgid "Creating the account remotely"
msgstr "リモートでのアカウント作成"

msgid ""
"If you cannot access the server from a `localhost` address, or just want to "
"start {project_name} from the command line, use the `.../bin/add-user-"
"keycloak` script."
msgstr ""
"`localhost` アドレスからサーバーにアクセスできない場合や、コマンドラインから{project_name}を起動したい場合は、 "
"`.../bin/add-user-keycloak` スクリプトを使用してください。"

msgid "Add-user-keycloak script"
msgstr "Add-user-keycloak script"

msgid "image:{project_images}/add-user-script.png[]"
msgstr "image:{project_images}/add-user-script.png[]"

msgid ""
"The parameters are a little different depending if you are using the "
"standalone operation mode or domain operation mode.  For standalone mode, "
"here is how you use the script."
msgstr ""
"スタンドアローン動作モードまたはドメイン動作モードを使用している場合、パラメーターは少し異なります。スタンドアローン・モードの場合のスクリプトの使用方法を次に示します。"

msgid "Linux/Unix"
msgstr "Linux/Unix"

msgid "$ .../bin/add-user-keycloak.sh -r master -u <username> -p <password>"
msgstr "$ .../bin/add-user-keycloak.sh -r master -u <username> -p <password>"

msgid "Windows"
msgstr "Windows"

msgid "> ...\\bin\\add-user-keycloak.bat -r master -u <username> -p <password>"
msgstr "> ...\\bin\\add-user-keycloak.bat -r master -u <username> -p <password>"

msgid ""
"For domain mode, you have to point the script to one of your server hosts "
"using the `-sc` switch."
msgstr "ドメインモードでは、 `-sc` スイッチを使ってスクリプトをサーバーホストの1つに向ける必要があります。"

msgid ""
"$ .../bin/add-user-keycloak.sh --sc domain/servers/server-one/configuration "
"-r master -u <username> -p <password>"
msgstr ""
"$ .../bin/add-user-keycloak.sh --sc domain/servers/server-one/configuration "
"-r master -u <username> -p <password>"

msgid ""
"> ...\\bin\\add-user-keycloak.bat --sc domain/servers/server-"
"one/configuration -r master -u <username> -p <password>"
msgstr ""
"> ...\\bin\\add-user-keycloak.bat --sc domain/servers/server-"
"one/configuration -r master -u <username> -p <password>"

msgid "Configuring realms"
msgstr "レルムの設定"

msgid ""
"Once you have an administrative account for the Admin Console, you can "
"configure realms. A realm is a space where you manage objects, including "
"users, applications, roles, and groups.  A user belongs to and logs into a "
"realm.   One {project_name} deployment can define, store, and manage as many"
" realms as there is space for in the database."
msgstr ""
"管理コンソール用に管理者アカウントを作成すると、レルムを設定することができます。レルムとは、ユーザー、アプリケーション、ロール、グループなどのオブジェクトを管理するための空間です。ユーザーはレルムに所属し、ログインします。1"
" つの{project_name}のデプロイメントで、データベースの空き容量と同じ数のレルムを定義、保存、管理できます。"

msgid "Using the Admin Console"
msgstr "管理コンソールの使用"

msgid ""
"You configure realms and perform most administrative tasks in the "
"{project_name} Admin Console."
msgstr "レルムを設定し、ほとんどの管理作業は{project_name}の管理コンソールで行います。"

msgid ""
"You need an administrator account.  See xref:creating-first-"
"admin_{context}[Creating the first administrator]."
msgstr ""
"管理者アカウントが必要です。 xref:creating-first-admin_{context}[最初の管理者を作成する] を参照してください。"

msgid "Go the the URL for the Admin Console."
msgstr "管理コンソールのURLにアクセスします。"

msgid ""
"For example, for localhost, use this URL: http://localhost:8080/auth/admin/"
msgstr "たとえば、ローカルホストの場合、http://localhost:8080/auth/admin/のURLを使用します。"

msgid "Login page"
msgstr "ログインページ"

msgid "image:{project_images}/login-page.png[Login page]"
msgstr "image:{project_images}/login-page.png[Login page]"

msgid ""
"Enter the username and password you created on the Welcome Page or the `add-"
"user-keycloak` script in the bin directory. This action displays the Admin "
"Console."
msgstr ""
"ウェルカムページで作成したユーザー名とパスワード、またはbinディレクトリーにある `add-user-keycloak` "
"スクリプトを入力します。このアクションは、管理コンソールを表示します。"

msgid "Admin Console"
msgstr "管理コンソール"

msgid "image:{project_images}/admin-console.png[Admin Console]"
msgstr "image:{project_images}/admin-console.png[Admin Console]"

msgid "Note the menus and other options that you can use:"
msgstr "使えるメニューや他のオプションをメモします。"

msgid ""
"Click the menu labeled *Master* to pick a realm you want to manage or to "
"create a new one."
msgstr "*Master* と書かれたメニューをクリックして、管理したいレルムを選択するか、新しいレルムを作成します。"

msgid "Click the top right list to view your account or log out."
msgstr "右上のリストをクリックすると、自分のアカウントを確認したり、ログアウトしたりできます。"

msgid ""
"Hover over a question mark *?* icon to show a tooltip text that describes "
"that field. The image above shows the tooltip in action."
msgstr ""
"クエスチョン・マーク *?* "
"のアイコンにカーソルを合わせると、そのフィールドを説明するツールチップ・テキストが表示されます。上の画像は、ツールチップの動作を示しています。"

msgid "The master realm"
msgstr "masterレルム"

msgid "In the Admin Console, two types of realms exist:"
msgstr "管理コンソールには、2種類のレルムが存在します。"

msgid ""
"`Master realm` - This realm was created for you when you first started "
"{project_name}. It contains the administrator account you created at the "
"first login.  Use the _master_ realm only to create and manage the realms in"
" your system."
msgstr ""
"`Master realm` - "
"このレルムは{project_name}を最初に起動したときに作成されたものです。最初のログイン時に作成した管理者アカウントが含まれています。 "
"_master_ レルムは、システム内のレルムの作成と管理にのみ使用してください。"

msgid ""
"`Other realms` - These realms are created by the administrator in the master"
" realm. In these realms, administrators manage the users in your "
"organization and the applications they need. The applications are owned by "
"the users."
msgstr ""
"`Other realms` - "
"これらのレルムは、masterレルムの管理者によって作成されます。これらのレルムでは、管理者は組織内のユーザーと、そのユーザーが必要とするアプリケーションを管理します。アプリケーションはユーザーによって所有されます。"

msgid "Realms and applications"
msgstr "レルムとアプリケーション"

msgid "image:images/master_realm.png[Realms and applications]"
msgstr "image:images/master_realm.png[Realms and applications]"

msgid ""
"Realms are isolated from one another and can only manage and authenticate "
"the users that they control. Following this security model helps prevent "
"accidental changes and follows the tradition of permitting user accounts "
"access to only those privileges and powers necessary for the successful "
"completion of their current task."
msgstr ""
"レルムは互いに隔離されており、自分が管理しているユーザーのみを管理、認証することができます。このセキュリティー・モデルに従うことで、誤った変更を防ぐことができます。また、ユーザー・アカウントには、現在のタスクを正常に完了するために必要な特権と権限のみへのアクセスを許可するという伝統に従っています。"

msgid "Additional resources"
msgstr "追加のリソース"

msgid ""
"See <<_per_realm_admin_permissions, Dedicated Realm Admin Consoles>> if you "
"want to disable the _master_ realm and define administrator accounts within "
"any new realm you create. Each realm has its own dedicated Admin Console "
"that you can log into with local accounts."
msgstr ""
"_master_ "
"レルムを無効にして、新しく作成するレルムに管理者アカウントを定義したい場合は、<<_per_realm_admin_permissions, "
"Dedicated Realm Admin "
"Consoles>>を参照してください。各レルムには専用の管理コンソールがあり、ローカル・アカウントでログインすることができます。"

msgid "Creating a realm"
msgstr "レルムの作成"

msgid ""
"You create a realm to provide a management space where you can create users "
"and give them permissions to use applications. At first login, you are "
"typically in the _master_ realm, the top-level realm from which you create "
"other realms."
msgstr ""
"レルムを作成することで、ユーザーを作成し、アプリケーションを使用するためのパーミッションを与えることができる管理空間を提供することができます。最初のログインでは、通常"
" _master_ レルム（他のレルムを作成する際の最上位レルム）に入ります。"

msgid ""
"When deciding what realms you need, consider the kind of isolation you want "
"to have for your users and applications.  For example, you might create a "
"realm for the employees of your company and a separate realm for your "
"customers. Your employees would log into the employee realm and only be able"
" to visit internal company applications.  Customers would log into the "
"customer realm and only be able to interact with customer-facing apps."
msgstr ""
"どのようなレルムが必要かを決定するには、ユーザーとアプリケーションをどのように分離したいかを検討します。たとえば、会社の従業員用のレルムと、顧客用の別のレルムを作成するとします。"
"  "
"従業員は従業員用のレルムにログインし、社内のアプリケーションにのみアクセスできるようにします。顧客は顧客用レルムにログインし、顧客向けアプリケーションにのみアクセスできるようにします。"

msgid "Point to the top of the left pane."
msgstr "左ペインの上部をマウスオーバーします。"

msgid "Click *Add Realm*."
msgstr " *Add Realm* をクリックします。"

msgid "Add realm menu"
msgstr "レルムメニューの追加"

msgid "image:{project_images}/add-realm-menu.png[Add realm menu]"
msgstr "image:{project_images}/add-realm-menu.png[Add realm menu]"

msgid "Enter a name for the realm."
msgstr "レルムの名前を入力します。"

msgid "Click *Create*."
msgstr "*Create* をクリックします。"

msgid "Create realm"
msgstr "レルムを作成する"

msgid "image:{project_images}/create-realm.png[Create realm]"
msgstr "image:{project_images}/create-realm.png[Create realm]"

msgid ""
"The current realm is now set to the realm you just created.  You can switch "
"between managing different realms by pointing to the top left corner to "
"click *Select Realm*."
msgstr ""
"現在のレルムは、先ほど作成したレルムに設定されています。左上をマウスオーバーして *Select Realm* "
"をクリックすることで、異なるレルムの管理に切り替えることができます。"

msgid ""
"Alternatively you can import a JSON document that defines your new realm. "
"For more detail, see the xref:assembly-exporting-importing_{context}[Export "
"and Import] chapter."
msgstr ""
"あるいは、新しいレルムを定義したJSONドキュメントをインポートすることもできます。詳細は xref:assembly-exporting-"
"importing_{context}[エクスポートとインポート] の章を参照してください。"

msgid "Configuring SSL for a realm"
msgstr "レルムにSSLを設定する"

msgid ""
"Each realm has an associated SSL Mode, which defines the SSL/HTTPS "
"requirements for interacting with the realm. Browsers and applications that "
"interact with the realm honor the SSL/HTTPS requirements defined by the SSL "
"Mode or they cannot interact with the server."
msgstr ""
"各レルムには、そのレルムと通信するためのSSL/HTTPSの要件を定義する、SSLモードが関連付けられています。レルムとやりとりするブラウザーやアプリケーションは、SSLモードによって定義されたSSL/HTTPSの要件を守らなければ、サーバーとやりとりすることができません。"

msgid ""
"{project_name} generates a self-signed certificate the first time it runs.  "
"Please note that self-signed certificates are not secure, and should only be"
" used for testing purposes.  It is highly recommended that you install a CA-"
"signed certificate on the {project_name} server itself or on a reverse proxy"
" in front of the {project_name} server.  See the "
"link:{installguide_link}[{installguide_name}]."
msgstr ""
"{project_name}は、初回実行時に自己署名証明書を生成します。自己署名証明書は安全ではないため、テスト目的でのみ使用してください。CA署名付き証明書を{project_name}サーバー自体、または{project_name}サーバーの前にあるリバース・プロキシーにインストールすることを強くお勧めします。"
" {installguide_link}[{installguide_name}] を参照してください。"

msgid "Click *Realm Settings* in the menu."
msgstr "メニューの *Realm Settings* をクリックします。"

msgid "Click the *Login* tab."
msgstr "*Login* タブをクリックします。"

msgid "Login tab"
msgstr "ログインタブ"

msgid "image:{project_images}/login-tab.png[Login tab]"
msgstr "image:{project_images}/login-tab.png[Login tab]"

msgid "Set *Require SSL* to one of the following SSL modes:"
msgstr "*Require SSL*を以下のSSLモードのいずれかに設定してください。"

msgid ""
"external requests:: Users can interact with {project_name} without SSL so "
"long as they stick to private IP addresses such as `localhost`, `127.0.0.1`,"
" `10.x.x.x`, `192.168.x.x`, and `172.16.x.x`. If you try to access "
"{project_name} without SSL from a non-private IP address, you will get an "
"error."
msgstr ""
"external requests:: `localhost` 、 `127.0.0.1` 、 `10.x.x.x` 、 `192.168.x.x` 、"
" `172.16.x.x` "
"のようなプライベートIPアドレスに固定する限り、ユーザーはSSL無しで{project_name}と対話できます。非プライベートIPアドレスからSSL無しで{project_name}にアクセスしようとすると、エラーが発生します。"

msgid ""
"none:: {project_name} does not require SSL.  This choice applies only in "
"development when you are experimenting and do not plan to support this "
"deployment."
msgstr ""
"none:: "
"{project_name}はSSLを必要としません。この選択は、開発時に実験的に使用し、このデプロイメントのサポートを予定していない場合にのみ適用されます。"

msgid "all requests:: {project_name} requires SSL for all IP addresses."
msgstr "all requests:: {project_name}はすべてのIPアドレスに対してSSLを要求します。"

msgid "Clearing server caches"
msgstr "サーバー・キャッシュのクリア"

msgid ""
"{project_name} caches everything it can in memory within the limits of your "
"JVM and the limits you have configured.  If the {project_name} database is "
"modified by a third party, such as a DBA, outside the scope of the server's "
"REST APIs or Admin Console, parts of the in-memory cache could be stale.  "
"You can clear the realm cache, user cache or cache of external public keys, "
"such as Public keys of  external clients or Identity providers, which "
"{project_name} may use to verify signatures of particular external entity."
msgstr ""
"{project_name}は、JVMの制限と設定した制限の範囲内で、メモリー内にできる限りのものをキャッシュしています。DBAなどの第三者が、サーバーのREST"
" "
"APIや管理コンソールの範囲外で{project_name}のデータベースを変更した場合、メモリー内キャッシュの一部が古くなっている可能性があります。レルムキャッシュ、ユーザー・キャッシュ、外部公開鍵キャッシュ（外部クライアントやアイデンティティー・プロバイダーの公開鍵など、{project_name}が特定の外部エンティティーの署名を検証するために使用する可能性があるもの）をクリアすることができます。"

msgid "Click the *Cache* tab."
msgstr "*Cache* タブをクリックします。"

msgid "Click *Clear* for the cache you want to evict."
msgstr "退去させたいキャッシュの *Clear* ボタンをクリックします。"

msgid "Cache tab"
msgstr "Cacheタブ"

msgid "image:{project_images}/cache-tab.png[Cache tab]"
msgstr "image:{project_images}/cache-tab.png[Cache tab]"

msgid "Configuring email for a realm"
msgstr "レルムに電子メールを設定する"

msgid ""
"{project_name} sends emails to users to verify their email addresses, when "
"they forget their passwords, or when an administrator needs to receive "
"notifications about a server event. To enable {project_name} to send emails,"
" you provide {project_name} with your SMTP server settings."
msgstr ""
"{project_name}は、ユーザーが電子メールアドレスを確認するとき、パスワードを忘れたとき、あるいは管理者がサーバーイベントに関する通知を受け取る必要があるときに、電子メールを送信します。{project_name}が電子メールを送信できるようにするには、{project_name}にSMTPサーバーの設定を提供します。"

msgid "Click the *Email* tab."
msgstr "*Email* タブをクリックします。"

msgid "Email tab"
msgstr "Emailタブ"

msgid "image:{project_images}/email-tab.png[Email Tab]"
msgstr "image:{project_images}/email-tab.png[Emailタブ]"

msgid "Fill in the fields and toggle the switches as needed."
msgstr "必要に応じてフィールドに入力し、スイッチを切り替えてください。"

msgid "Host"
msgstr "ホスト"

msgid "*Host* denotes the SMTP server hostname used for sending emails."
msgstr "*Host* は、電子メール送信時に使用するSMTPサーバーのホスト名を示します。"

msgid "Port"
msgstr "Port"

msgid "*Port* denotes the SMTP server port."
msgstr "*Port* はSMTPサーバーのポートを示します。"

msgid "From"
msgstr "From"

msgid ""
"*From* denotes the address used for the *From* SMTP-Header for the emails "
"sent."
msgstr "*From* は、送信されるメールの *From* SMTPヘッダーに使用されるアドレスです。"

msgid "From Display Name"
msgstr "From Display Name"

msgid ""
"*From Display Name* allows to configure a user friendly email address "
"aliases (optional). If not set the plain *From* email address will be "
"displayed in email clients."
msgstr ""
"*From Display Name* "
"では、ユーザーフレンドリーなメールアドレスのエイリアスを設定できます（オプション）。設定されていない場合、電子メールクライアントでは通常の *From*"
" メールアドレスが表示されます。"

msgid "Reply To"
msgstr "Reply To"

msgid ""
"*Reply To* denotes the address used for the *Reply-To* SMTP-Header for the "
"mails sent (optional). If not set the plain *From* email address will be "
"used."
msgstr ""
"*Reply To* は、送信されるメールの *Reply-To* "
"SMTPヘッダーに使用されるアドレスを示します（オプション）。設定されていない場合は、通常の *From* 電子メールアドレスが使用されます。"

msgid "Reply To Display Name"
msgstr "Reply To Display Name"

msgid ""
"*Reply To Display Name* allows to configure a user friendly email address "
"aliases (optional). If not set the plain *Reply To* email address will be "
"displayed."
msgstr ""
"*Reply To Display "
"Name*では、ユーザー・フレンドリーなメールアドレスのエイリアスを設定することができます（オプション）。設定されていない場合は、通常の *Reply "
"To* のメールアドレスが表示されます。"

msgid "Envelope From"
msgstr "Envelope From"

msgid ""
"*Envelope From* denotes the "
"https://en.wikipedia.org/wiki/Bounce_address[Bounce Address] used for the "
"*Return-Path* SMTP-Header for the mails sent (optional)."
msgstr ""
"*Envelope From* は、送信されるメールの *Return-Path* SMTPヘッダーに使用される "
"https://en.wikipedia.org/wiki/Bounce_address[Bounce Address] を示します（オプション）。"

msgid "Enable SSL and Enable StartTSL"
msgstr "SSLの有効化とStartTSLの有効化"

msgid ""
"Toggle one of these switches to *ON* to support sending emails for "
"recovering usernames and passwords, especially if the SMTP server is on an "
"external network. You will most likely need to change the *Port* to 465, the"
" default port for SSL/TLS."
msgstr ""
"特にSMTPサーバーが外部ネットワーク上にある場合は、これらのスイッチの1つを *ON* "
"に切り替えて、ユーザー名とパスワードを回復するための電子メールの送信をサポートします。ほとんどの場合、 *Port* "
"をSSL/TLSのデフォルトポートである465に変更する必要があります。"

msgid "Enable Authentication"
msgstr "認証の有効化"

msgid ""
"Set this switch to *ON* if your SMTP server requires authentication. When "
"prompted, supply the *Username* and *Password*. The value of the *Password* "
"field can refer a value from an external <<_vault-administration,vault>>."
msgstr ""
"SMTPサーバーで認証が必要な場合は、このスイッチを *ON* に設定してください。プロンプトが表示されたら、 *Username* と "
"*Password* を入力してください。 *Password* フィールドの値は、外部の<<_vault-"
"administration,ボールト>>からの値を参照することができます。"

msgid "Configuring themes and internationalization"
msgstr "テーマと国際化の設定"

msgid ""
"For a given realm, you can change the appearance of any UI, including the "
"language that appears, in {project_name} by using themes."
msgstr ""
"あるレルムに対して、{project_name}では、テーマを使うことで、表示される言語も含めて、あらゆるUIの見た目を変更することができます。"

msgid "Click *Realm Setting* in the menu."
msgstr "メニューの *Realm Settings* をクリックします。"

msgid "Click the *Themes* tab."
msgstr "*Themes*タブをクリックします。"

msgid "Themes tab"
msgstr "Themesタブ"

msgid "image:{project_images}/themes-tab.png[Themes tab]"
msgstr "image:{project_images}/themes-tab.png[Themes tab]"

msgid "Pick the theme you want for each UI category and click *Save*."
msgstr "UIカテゴリーごとに必要なテーマを選び、 *Save* をクリックします。"

msgid "Login Theme"
msgstr "Login Theme"

msgid ""
"Username password entry, OTP entry, new user registration, and other similar"
" screens related to login."
msgstr "ユーザー名・パスワード入力、OTP入力、新規ユーザー登録、その他ログインに関連する画面。"

msgid "Account Theme"
msgstr "Account Theme"

msgid "Each user has an User Account Management UI."
msgstr "各ユーザーのアカウント管理UI。"

msgid "Admin Console Theme"
msgstr "Admin Console Theme"

msgid "The skin of the {project_name} Admin Console."
msgstr "{project_name}管理コンソールのスキン。"

msgid "Email Theme"
msgstr "Email Theme"

msgid ""
"Whenever {project_name} has to send out an email, it uses templates defined "
"in this theme to craft the email."
msgstr "{project_name}が電子メールを送信する場合に、このテーマで定義されたテンプレートを使用して電子メールを作成します。"

msgid ""
"The link:{developerguide_link}[{developerguide_name}] describes how to "
"create a new theme or modify existing ones."
msgstr ""
"link:{developerguide_link}[{developerguide_name}]では、新しいテーマを作成したり、既存のテーマを変更する方法について説明しています。"

msgid "Enabling internationalization"
msgstr "国際化の有効化"

msgid ""
"Every UI screen is internationalized in {project_name}.  The default "
"language is English, but you can choose which locales you want to support "
"and what the default locale will be."
msgstr ""
"{project_name}では、すべてのUI画面が国際化されます。デフォルトの言語は英語ですが、どのロケールに対応するか、またどれをデフォルトのロケールにするかを選択できます。"

msgid "Click the *Theme* tab."
msgstr "*Themes* タブをクリックします。"

msgid "Set *Internationalization* to *ON*."
msgstr "*Internationalization* を *ON* に設定します。"

msgid ""
"The next time a user logs in, that user can choose a language on the login "
"page to use for the login screens, Account Console, and Admin Console."
msgstr "次回ログイン時に、ログイン画面、アカウントコンソール、管理コンソールで使用する言語を選択できます。"

msgid ""
"The link:{developerguide_link}[{developerguide_name}] explains how you can "
"offer additional languages. All internationalized texts which are provided "
"by the theme can be overwritten by realm-specific texts on the "
"*Localization* tab."
msgstr ""
"link:{developerguide_link}[{developerguide_name}] "
"では、追加の言語を提供する方法について説明しています。テーマによって提供されるすべての国際化テキストは、*Localization* "
"タブでレルム固有のテキストに上書きすることができます。"

msgid "User locale selection"
msgstr "ユーザーロケールの選択"

msgid ""
"A locale selector provider suggests the best locale on the information "
"available. However, it is often unknown who the user is. For this reason, "
"the previously authenticated user's locale is remembered in a persisted "
"cookie."
msgstr ""
"ロケール・セレクター・プロバイダーは、入手した情報から最適なロケールを提案します。しかし、ユーザーが誰であるかは不明なことが多いため、以前に認証されたユーザーのロケールを永続化されたCookieに記憶させます。"

msgid ""
"The logic for selecting the locale uses the first of the following that is "
"available:"
msgstr "ロケールを選択するためのロジックは、以下の利用可能な最初のものが使用されます。"

msgid ""
"User selected - when the user has selected a locale using the drop-down "
"locale selector"
msgstr "ユーザーが選択 - ユーザーがドロップダウン・ロケール・セレクターを使用してロケールを選択した場合"

msgid ""
"User profile - when there is an authenticated user and the user has a "
"preferred locale set"
msgstr "ユーザー・プロファイル - 認証されたユーザーがいて、そのユーザーが優先ロケールを設定している場合"

msgid ""
"Client selected - passed by the client using for example ui_locales "
"parameter"
msgstr "クライアントによる選択 - たとえばui_localesパラメーターを使用してクライアントから渡された場合"

msgid "Cookie - last locale selected on the browser"
msgstr "Cookie - ブラウザーで最後に選択されたロケール"

msgid "Accepted language - locale from *Accept-Language* header"
msgstr "Accepted language - *Accept-Language* ヘッダーから取得したロケール"

msgid "Realm default"
msgstr "レルムのデフォルト"

msgid "If none of the above, fall back to English"
msgstr "上記のいずれでもない場合、英語にフォールバックします"

msgid ""
"When a user is authenticated an action is triggered to update the locale in "
"the persisted cookie mentioned earlier. If the user has actively switched "
"the locale through the locale selector on the login pages the users locale "
"is also updated at this point."
msgstr ""
"ユーザーが認証されると、前述の永続化されたCookieのロケールを更新するアクションがトリガーされます。ユーザーがログインページのロケール・セレクターを介してアクティブにロケールを切り替えた場合、ユーザーロケールもこの時点で更新されます。"

msgid ""
"If you want to change the logic for selecting the locale, you have an option"
" to create custom `LocaleSelectorProvider`. For details, please refer to the"
" link:{developerguide_link}#_locale_selector[{developerguide_name}]. When a "
"user is authenticated, an action is triggered to update the locale in the "
"persisted cookie mentioned earlier. If the user has actively switched the "
"locale through the locale selector on the login pages, the user's locale is "
"also updated at this point."
msgstr ""
"ロケールを選択するロジックを変更したい場合は、カスタムの `LocaleSelectorProvider` を作成するオプションがあります。詳しくは "
"link:{developerguide_link}#_locale_selector[{developerguide_name}] "
"を参照してください。ユーザーが認証されると、先ほどの永続化されたCookieのロケールを更新するためのアクションが発生します。ユーザーがログインページのロケール・セレクターでロケールを積極的に切り替えていた場合、この時点でユーザーのロケールも更新されます。"

msgid ""
"If you want to change the logic for selecting the locale, you have an option"
" to create a custom `LocaleSelectorProvider`. For details, see the "
"link:{developerguide_link}#_locale_selector[{developerguide_name}]."
msgstr ""
"ロケールを選択するロジックを変更したい場合は、カスタムの `LocaleSelectorProvider` を作成するオプションがあります。詳しくは "
"link:{developerguide_link}#_locale_selector[{developerguide_name}] "
"を参照してください。"

msgid "Controlling login options"
msgstr "ログイン・オプションの制御"

msgid "{project_name} includes several built-in login page features."
msgstr "{project_name}には、いくつかのログインページ機能が組み込まれています。"

msgid "Enabling forgot password"
msgstr "パスワード忘れを有効にする"

msgid ""
"If you enable `Forgot Password`, users can reset their login credentials if "
"they forget their passwords or lose their OTP generator."
msgstr ""
"`Forgot Password` "
"を有効にすると、ユーザーがパスワードを忘れたり、OTPジェネレーターを紛失した場合に、ログイン・クレデンシャルをリセットすることができます。"

msgid "image:{project_images}/login-tab.png[Login Tab]"
msgstr "image:{project_images}/login-tab.png[Login Tab]"

msgid "Toggle *Forgot Password* to *ON*."
msgstr "*Forgot Password* を *ON* に切り替えてください。"

msgid "A `forgot password` link displays in your login pages."
msgstr "ログインページに `forgot password` というリンクが表示される。"

msgid "Forgot password link"
msgstr "パスワード忘れリンク"

msgid "image:{project_images}/forgot-password-link.png[Forgot Password Link]"
msgstr "image:{project_images}/forgot-password-link.png[Forgot Password Link]"

msgid ""
"Click this link to bring users where they can enter their username or email "
"address and receive an email with a link to reset their credentials."
msgstr ""
"このリンクをクリックすると、ユーザーはユーザー名またはメールアドレスを入力し、クレデンシャルをリセットするためのリンクが記載されたメールを受け取ることができます。"

msgid "Forgot password page"
msgstr "パスワード忘れページ"

msgid "image:{project_images}/forgot-password-page.png[Forgot Password Page]"
msgstr "image:{project_images}/forgot-password-page.png[Forgot Password Page]"

msgid ""
"The text sent in the email is configurable. See "
"link:{developerguide_link}[{developerguide_name}] for more information."
msgstr ""
"電子メールで送信されるテキストは設定可能です。詳しくはlink:{developerguide_link}[{developerguide_name}]を参照してください。"

msgid ""
"When users click the email link, {project_name} asks them to update their "
"password, and if they have set up an OTP generator, {project_name} asks them"
" to reconfigure the OTP generator.  Depending on security requirements of "
"your organization, you may not want users to reset their OTP generator "
"through email."
msgstr ""
"ユーザーがメールのリンクをクリックすると、{project_name}のパスワードを更新するように求められ、OTPジェネレーターを設定している場合は、{project_name}のOTPジェネレーターを再設定するように求められます。"
"  組織のセキュリティー要件によっては、ユーザーに電子メールでOTPジェネレーターをリセットさせたくない場合もあります。"

msgid "To change this behavior, perform these steps:"
msgstr "この動作を変更するには、以下の手順を実行します。"

msgid "Click *Authentication* in the menu."
msgstr "メニューの *Authentication* をクリックします。"

msgid "Click the *Flows* tab."
msgstr "*Flows* タブをクリックします。"

msgid "Select the *Reset Credentials* flow."
msgstr "*Reset Credentials* フローを選択します。"

msgid "Reset credentials flow"
msgstr "リセット・クレデンシャル・フロー"

msgid ""
"image:{project_images}/reset-credentials-flow.png[Reset Credentials Flow]"
msgstr ""
"image:{project_images}/reset-credentials-flow.png[Reset Credentials Flow]"

msgid ""
"If you do not want to reset the OTP, set the `Reset OTP` requirement to "
"*Disabled*."
msgstr "OTPをリセットしたくない場合は、 `Reset OTP` の要件を *Disabled* に設定してください。"

msgid "Click the *Required Actions* tab. Ensure _Update Password_ is enabled."
msgstr "*Required Actions* タブをクリックします。 _Update Password_ が有効になっていることを確認します。"

msgid "Enabling Remember Me"
msgstr "Remember Meの有効化"

msgid ""
"A logged-in user closing their browser destroys their session, and that user"
" must log in again. You can set {project_name} to keep the user's login "
"session open if that user clicks the _Remember Me_ checkbox upon login. This"
" action turns the login cookie from a session-only cookie to a persistence "
"cookie."
msgstr ""
"ログインしたユーザーがブラウザーを閉じると、セッションが破棄され、再度ログインする必要があります。{project_name}を設定すると、ログイン時に"
" _Remember Me_ "
"のチェックボックスをクリックした場合に、ユーザーのログインセッションを維持することができます。このアクションは、ログインCookieをセッションのみのCookieから永続的なCookieに変えます。"

msgid "Toggle the *Remember Me* switch to *ON*."
msgstr "*Remember Me* スイッチを *ON* にする。"

msgid "image:{project_images}/login-tab.png[]"
msgstr "image:{project_images}/login-tab.png[]"

msgid ""
"When you save this setting, a `remember me` checkbox displays on the realm's"
" login page."
msgstr "この設定を保存すると、レルムのログインページに `remember me` のチェックボックスが表示されます。"

msgid "Remember Me"
msgstr "Remember Me"

msgid "image:{project_images}/remember-me.png[]"
msgstr "image:{project_images}/remember-me.png[]"

msgid "Configuring realm keys"
msgstr "レルム鍵の設定"

msgid ""
"The authentication protocols that are used by {project_name} require "
"cryptographic signatures and sometimes encryption.  {project_name} uses "
"asymmetric key pairs, a private and public key, to accomplish this."
msgstr ""
"{project_name}で使用される認証プロトコルは暗号化署名を必要とし、時には暗号化を必要とします。{project_name}は、これに対応するために秘密鍵と公開鍵の鍵ペアを使用します。"

msgid ""
"{project_name} has a single active keypair at a time, but can have several "
"passive keys as well. The active keypair is used to create new signatures, "
"while the passive keypairs can be used to verify previous signatures. This "
"makes it possible to regularly rotate the keys without any downtime or "
"interruption to users."
msgstr ""
"{project_name}は一度に1つのアクティブな鍵ペアを持ちますが、複数のパッシブな鍵も持つこともできます。アクティブな鍵ペアを使用して新しい署名を作成する一方で、パッシブな鍵ペアを使用して以前の署名を検証することができます。これにより、ダウンタイムやユーザーの中断を招くことなく、鍵を定期的にローテーションさせることができます。"

msgid ""
"When a realm is created a key pair and a self-signed certificate is "
"automatically generated."
msgstr "レルムが作成されると、鍵ペアと自己署名証明書が自動的に生成されます。"

msgid "Select the realm in the Admin Console."
msgstr "管理コンソールでレルムを選択します。"

msgid "Click *Realm settings*."
msgstr "*Realm settings* をクリックします。"

msgid "Click *Keys*."
msgstr "*Keys* をクリックします。"

msgid "Click *Passive* to view passive keys."
msgstr "パッシブ鍵を表示するには、 *Passive* をクリックします。"

msgid "Click *Disabled* to view disabled keys."
msgstr "無効な鍵を表示するには、 *Disabled* をクリックします。"

msgid ""
"A keypair can have the status `Active`, but still not be selected as the "
"currently active keypair for the realm. The selected active pair which is "
"used for signatures is selected based on the first key provider sorted by "
"priority that is able to provide an active keypair."
msgstr ""
"鍵ペアのステータスが `Active` "
"であっても、そのレルムで現在アクティブな鍵ペアとして選択されないことがあります。署名に使用されるアクティブな鍵ペアは、アクティブな鍵ペアを提供できる、 "
"優先順位の高い最初の鍵プロバイダーに基づき選択されます。"

msgid "Rotating keys"
msgstr "鍵のローテーション"

msgid ""
"We recommend that you regularly rotate keys. To do so, start by creating new"
" keys with a higher priority than the existing active keys. Or create new "
"keys with the same priority and making the previous keys passive."
msgstr ""
"定期的に鍵をローテーションすることをお勧めします。そのためには、既存のアクティブな鍵よりも高い優先順位を持つ新しい鍵を作成することから始めます。または、同じ優先順位の新しい鍵を作成し、以前の鍵をパッシブにします。"

msgid ""
"Once new keys are available all new tokens and cookies will be signed with "
"the new keys. When a user authenticates to an application the SSO cookie is "
"updated with the new signature. When OpenID Connect tokens are refreshed new"
" tokens are signed with the new keys. This means that over time all cookies "
"and tokens will use the new keys and after a while the old keys can be "
"removed."
msgstr ""
"新しい鍵が利用可能になると、新しいトークンとCookieはすべて新しい鍵で署名されます。ユーザーがアプリケーションを認証すると、SSO "
"Cookieは新しい署名で更新されます。OpenID "
"Connectトークンをリフレッシュすると、新しいトークンが新しい鍵で署名されます。つまり、すべてのトークンとCookieが新しい鍵を使用するようになるため、しばらく経つと古い鍵を削除することができます。"

msgid ""
"The frequency of deleting old keys is a tradeoff between security and making"
" sure all cookies and tokens are updated. Consider creating new keys every "
"three to six months and deleting old keys one to two months after you create"
" the new keys. If a user was inactive in the period between the new keys "
"being added and the old keys being removed, that user will have to re-"
"authenticate."
msgstr ""
"古い鍵を削除する頻度は、セキュリティーとすべてのCookieとトークンの更新を確認することとのトレードオフになります。新しい鍵は3〜6カ月ごとに作成し、古い鍵は新しい鍵を作成してから1〜2カ月後に削除することを検討してください。新しい鍵が追加されてから古い鍵が削除されるまでの間にユーザーが活動していなかった場合、そのユーザーは再認証を行う必要があります。"

msgid ""
"Rotating keys also applies to offline tokens. To make sure they are updated,"
" the applications need to refresh the tokens before the old keys are "
"removed."
msgstr ""
"鍵のローテーションは、オフライントークンにも適用されます。確実に更新されるように、アプリケーションは古い鍵が削除される前にトークンをリフレッシュする必要があります。"

msgid "Adding a generated keypair"
msgstr "鍵ペアの追加"

msgid "Click the *Keys* tab."
msgstr "*Keys* タブをクリックします。"

msgid "Click the *Providers* tab."
msgstr "*Providers* タブをクリックします。"

msgid "Click *Add keystore* and select *rsa-generated*."
msgstr "*Add keystore* をクリックし、 *rsa-generated* を選択します。"

msgid ""
"Enter a number in the *Priority* field. This number determines if the new "
"key pair becomes the active key pair."
msgstr "*Priority* の欄に数字を入力します。この番号によって、新しい鍵ペアがアクティブな鍵ペアになるかどうかが決まります。"

msgid "Select a value for *keysize*."
msgstr "*keysize* の値を選択します。"

msgid "Click *Save*."
msgstr "*Save* をクリックします。"

msgid ""
"This action will generated a new keypair including a self-signed "
"certificate."
msgstr "この操作により、自己署名入り証明書を含む新しいキーペアが生成されます。"

msgid ""
"Changing the priority for a provider will not cause the keys to be re-"
"generated, but if you want to change the keysize you can edit the provider "
"and new keys will be generated."
msgstr ""
"プロバイダーの優先順位を変更しても鍵は再生成されませんが、鍵のサイズを変更したい場合は、プロバイダーを編集して新しい鍵を生成することができます。"

msgid "Adding an existing keypair and certificate"
msgstr "既存の鍵ペアと証明書の追加"

msgid ""
"To add a keypair and certificate obtained elsewhere select `Providers` and "
"choose `rsa` from the dropdown. You can change the priority to make sure the"
" new keypair becomes the active keypair."
msgstr ""
"他で取得した鍵ペアと証明書を追加するには、 `Providers` を選択し、ドロップダウンから `rsa` "
"を選択します。優先順位を変更することで、新しい鍵ペアをアクティブな鍵ペアにすることができます。"

msgid "A private key file. The file must be PEM formatted."
msgstr "秘密鍵のファイルです。PEM形式のファイルである必要があります。"

msgid "Click *Add keystore* and select *rsa*."
msgstr "*Add keystore* をクリックし、 *rsa* を選択します。"

msgid ""
"Click *Select file* beside *Private RSA Key* to upload the private key file."
msgstr "*Private RSA Key*の横にある *Select file* をクリックして、秘密鍵ファイルをアップロードします。"

msgid ""
"If you have a signed certificate for your private key,  click *Select file* "
"beside *X509 Certificate* to upload the certificate file. {project_name} "
"autmatically generates a self-signed certificate if you do not upload a "
"certificate."
msgstr ""
"秘密鍵の署名付き証明書がある場合は、 *X509 Certificate* の横にある *Select file* "
"をクリックして、証明書ファイルをアップロードしてください。証明書をアップロードしない場合、{project_name}は自動的に自己署名証明書を生成します。"

msgid "Loading keys from a Java Keystore"
msgstr "Javaキーストアから鍵をロードする"

msgid ""
"To add a keypair and certificate stored in a Java Keystore file on the host "
"select `Providers` and choose `java-keystore` from the dropdown. You can "
"change the priority to make sure the new keypair becomes the active keypair."
msgstr ""
"ホスト上のJavaキーストア・ファイルに格納されている鍵ペアと証明書を追加するには、 `Providers` を選択し、ドロップダウンから `java-"
"keystore` を選択します。優先順位を変更して、新しい鍵ペアをアクティブにすることができます。"

msgid ""
"For the associated certificate chain to be loaded it must be imported to the"
" Java Keystore file with the same `Key Alias` used to load the keypair."
msgstr ""
"関連する証明書チェーンを読み込むためには、キーペアを読み込むために使用したのと同じ `Key Alias` "
"を使って、JavaのKeystoreファイルにインポートする必要があります。"

msgid "Click *Add keystore* and select *java-keystore*."
msgstr "*Add keystore* をクリックし、 *java-keystore* を選択します。"

msgid "Enter a value for *Keystore*."
msgstr "*Keystore* に値を入力します。"

msgid "Enter a value for *Keystore Password*."
msgstr "*Keystore Password* に値を入力します。"

msgid "Enter a value for *Key Alias*."
msgstr "*Key Alias* に値を入力します。"

msgid "Enter a value for *Key Password*."
msgstr "*Key Password* に値を入力します。"

msgid "Making keys passive"
msgstr "鍵をパッシブにする"

msgid "Click Realm settings."
msgstr "Realm settingsをクリックします。"

msgid "Click the *Active* tab."
msgstr "*Active* タブをクリックします。"

msgid "Click the provider of the key you want to make passive."
msgstr "パッシブ化したい鍵のプロバイダーをクリックします。"

msgid "Toggle *Active* to *OFF*."
msgstr "*Active* を *OFF* に切り替えます。"

msgid "Disabling keys"
msgstr "鍵の無効化"

msgid "Toggle *Enabled* to *OFF*."
msgstr "*Enabled* を *OFF* に切り替えます。"

msgid "Compromised keys"
msgstr "鍵の漏洩"

msgid ""
"{project_name} has the signing keys stored just locally and they are never "
"shared with the client applications, users or other entities. However, if "
"you think that your realm signing key was compromised, you should first "
"generate new keypair as described above and then immediately remove the "
"compromised keypair."
msgstr ""
"{project_name}は、署名鍵をローカルにのみ保存し、クライアント・アプリケーションやユーザーまたは他のエンティティーと共有することはありません。しかし、レルムの署名鍵が漏洩したと思われる場合は、まず上記のように新しい鍵ペアを生成し、漏洩した鍵ペアを直ちに削除する必要があります。"

msgid "Alternatively, you can delete the provider from the `Providers` table."
msgstr "また、 `Providers` テーブルからプロバイダーを削除することもできます。"

msgid "Click *Clients* in the menu."
msgstr "メニューの *Clients* をクリックします。"

msgid "Click *security-admin-console*."
msgstr "*security-admin-console* をクリックします。"

msgid "Click the *Revocation* tab."
msgstr "*Revocation* タブをクリックします。"

msgid "Click *Set to now*."
msgstr "*Set to now* をクリックします。"

msgid "Click *Push*."
msgstr "*Push* クリックします。"

msgid ""
"Pushing the not-before policy ensures that client applications do not accept"
" the existing tokens signed by the compromised key. The client application "
"is forced to download new key pairs from {project_name} also so the tokens "
"signed by the compromised key will be invalid."
msgstr ""
"not-"
"beforeポリシーをプッシュすることで、クライアント・アプリケーションは、漏洩した鍵によって署名された既存のトークンを受け入れないようにすることができます。クライアント・アプリケーションは、{project_name}から新しいキーペアをダウンロードすることを強制されるので、漏洩した鍵によって署名されたトークンは無効となります。"

msgid ""
"REST and confidential clients must set *Admin URL* so {project_name} can "
"send clients the pushed not-before policy request."
msgstr ""
"RESTとコンフィデンシャル・クライアントは、{project_name}がプッシュされたnot-"
"beforeポリシー・リクエストをクライアントに送信できるように、 *Admin URL* を設定する必要があります。"

msgid "Using external storage"
msgstr "外部ストレージの使用"

msgid ""
"Organizations can have databases containing information, passwords, and "
"other credentials. Typically, you cannot migrate existing data storage to a "
"{project_name} deployment so {project_name} can federate existing external "
"user databases. {project_name} supports LDAP and Active Directory, but you "
"can also code extensions for any custom user database by using the "
"{project_name} User Storage SPI."
msgstr ""
"組織は、情報、パスワード、およびその他のクレデンシャルを含むデータベースを持つことができます。通常、既存のデータストレージを{project_name}の配備に移行することはできないため、{project_name}では既存の外部ユーザー・データベースを連携させることができます。{project_name}はLDAPとActive"
" "
"Directoryをサポートしていますが、{project_name}のユーザー・ストレージSPIを使用して任意のカスタム・ユーザー・データベース用の拡張機能をコード化することもできます。"

msgid ""
"When a user attempts to log in, {project_name} examines that user's storage "
"to find that user. If {project_name} does not find the user, {project_name} "
"iterates over each User Storage provider for the realm until it finds a "
"match. Data from the external data storage then maps into a standard user "
"model the {project_name} runtime consumes. This user model then maps to OIDC"
" token claims and SAML assertion attributes."
msgstr ""
"ユーザーがログインしようとすると、{project_name}はそのユーザーのストレージを調べて、そのユーザーを見つけます。{project_name}がユーザーを見つけられなかった場合、{project_name}は一致するユーザーが見つかるまで、レルムの各ユーザー・ストレージのプロバイダーを繰り返し検索します。外部データストレージからのデータは、{project_name}のランタイムが消費する標準的なユーザーモデルにマップされます。このユーザーモデルは、OIDCのトークンクレームとSAMLのアサーション属性にマッピングされます。"

msgid ""
"External user databases rarely have the data necessary to support all the "
"features of {project_name}, so the User Storage Provider can opt to store "
"items locally in {project_name} user data storage. Providers can import "
"users locally and sync periodically with external data storage. This "
"approach depends on the capabilities of the provider and the configuration "
"of the provider.  For example, your external user data storage may not "
"support OTP. The OTP can be handled and stored by {project_name}, depending "
"on the provider."
msgstr ""
"外部のユーザー・データベースが{project_name}の全機能をサポートするために必要なデータを持っていることは稀なので、ユーザー・ストレージ・プロバイダーは{project_name}のローカルのユーザー・データ・ストレージにアイテムを保存することを選択することができます。プロバイダーは、ローカルにユーザーをインポートし、外部データストレージと定期的に同期することができます。この方法は、プロバイダーの機能とプロバイダーの設定に依存します。たとえば、外部のユーザー・データ・ストレージがOTPをサポートしていない場合があります。プロバイダーによっては、OTPを{project_name}で処理し、保存することができます。"

msgid "Adding a provider"
msgstr "プロバイダーの追加"

msgid "To add a storage provider, perform the following procedure:"
msgstr "ストレージ・プロバイダーを追加するには、次の手順を実行します。"

msgid "Click *User Federation* in the menu."
msgstr "メニューの *User Federation* をクリックします。"

msgid "User federation"
msgstr "ユーザー・フェデレーション"

msgid "image:{project_images}/user-federation.png[User federation]"
msgstr "image:{project_images}/user-federation.png[User federation]"

msgid ""
"Select the provider type from the *Add Provider* list. {project_name} brings"
" you to that provider's configuration page."
msgstr ""
"プロバイダーの種類を *Add Provider* のリストから選択します。{project_name}は、そのプロバイダーの設定画面を表示します。"

msgid "Dealing with provider failures"
msgstr "プロバイダー障害への対応"

msgid ""
"If a User Storage Provider fails, you may not be able to log in and view "
"users in the Admin Console. {project_name} does not detect failures when "
"using a Storage Provider to look up a user, so it cancels the invocation. If"
" you have a Storage Provider with a high priority that fails during user "
"lookup, the login or user query fails with an exception and will not fail "
"over to the next configured provider."
msgstr ""
"ユーザー・ストレージ・プロバイダーに障害が発生すると、管理コンソールにログインしてユーザーを表示できなくなる場合があります。{project_name}は、ストレージ・プロバイダーを使用してユーザーを検索するときに失敗を検出しないため、呼び出しをキャンセルします。優先度の高いストレージ・プロバイダーがユーザー検索中に失敗すると、ログインまたはユーザークエリーが例外的に失敗し、次に設定されたプロバイダーにフェイルオーバーされなくなります。"

msgid ""
"{project_name} searches the local {project_name} user database first to "
"resolve users before any LDAP or custom User Storage Provider. Consider "
"creating an administrator account stored in the local {project_name} user "
"database in case of problems connecting to your LDAP and back ends."
msgstr ""
"{project_name}は、LDAPやカスタムのユーザー・ストレージ・プロバイダーよりも先に、ローカルの{project_name}ユーザー・データベースを検索して、ユーザーを解決します。LDAP"
" "
"やバックエンドへの接続に問題がある場合に備えて、ローカルの{project_name}ユーザー・データベースに保存される管理者アカウントの作成を検討してください。"

msgid ""
"Each LDAP and custom User Storage Provider has an `enable` toggle on its "
"Admin Console page. Disabling the User Storage Provider skips the provider "
"when performing queries, so you can view and log in with user accounts in a "
"different provider with lower priority. If your provider uses an `import` "
"strategy and is disabled, imported users are still available for lookup in "
"read-only mode."
msgstr ""
"LDAPとカスタムのそれぞれのユーザー・ストレージ・プロバイダーには、管理コンソール画面で `enable` "
"のトグルがあります。ユーザー・ストレージ・プロバイダーを無効にすると、クエリーを実行するときにプロバイダーをスキップするので、より低い優先度で別のプロバイダーにあるユーザー・アカウントを表示したりログインしたりすることができます。プロバイダーが"
" `import` 戦略を使用していて無効化されている場合、インポートされたユーザーは読み取り専用モードで検索可能です。"

msgid ""
"When a Storage Provider lookup fails, {project_name} does not fail over "
"because user databases often have duplicate usernames or duplicate emails "
"between them. Duplicate usernames and emails can cause problems because the "
"user loads from one external data store when the admin expects them to load "
"from another data store."
msgstr ""
"ストレージ・プロバイダーの検索に失敗した場合、{project_name}はフェイルオーバーしません。なぜなら、ユーザー・データベースには、ユーザー名や電子メールが重複していることが多いからです。ユーザー名や電子メールの重複は、管理者が別のデータストアから読み込むことを想定しているのに、ユーザがある外部データストアから読み込むために問題を引き起こす可能性があります。"

msgid "Lightweight Directory Access Protocol (LDAP) and Active Directory"
msgstr "LDAP（Lightweight Directory Access Protocol）とActive Directory"

msgid ""
"{project_name} includes an LDAP/AD provider. You can federate multiple "
"different LDAP servers in one {project_name} realm and map LDAP user "
"attributes into the {project_name} common user model."
msgstr ""
"{project_name}には、LDAP/ADプロバイダーが含まれています。複数の異なるLDAPサーバーを1つの{project_name}のレルムで連携させ、LDAPのユーザー属性を{project_name}共通ユーザーモデルにマッピングすることが可能です。"

msgid ""
"By default, {project_name} maps the username, email, first name, and last "
"name of the user account, but you can also configure additional "
"<<_ldap_mappers,mappings>>. {project_name}'s LDAP/AD provider supports "
"password validation using LDAP/AD protocols and storage, edit, and "
"synchronization modes."
msgstr ""
"デフォルトでは、{project_name}はユーザー・アカウントのユーザー名、電子メール、名、姓をマップしますが、追加の<<_ldap_mappers,マッピング>>を設定することもできます。{project_name}のLDAP/ADプロバイダーは、LDAP/ADプロトコルと保存、編集、同期モードを使用してパスワード検証をサポートしています。"

msgid "Configuring federated LDAP storage"
msgstr "連携したLDAPストレージの設定"

msgid ""
"Select _ldap_ from the *Add Provider* list. {project_name} brings you to the"
" LDAP configuration page."
msgstr "*Add Provider* の一覧から _ldap_ を選択します。{project_name}でLDAPの設定画面になります。"

msgid "Storage mode"
msgstr "ストレージモード"

msgid ""
"{project_name} imports users from LDAP into the local {project_name} user "
"database. This copy of the user database synchronizes on-demand or through a"
" periodic background task. An exception exists for synchronizing passwords. "
"{project_name} never imports passwords. Password validation always occurs on"
" the LDAP server."
msgstr ""
"{project_name}は、LDAP "
"からローカルの{project_name}ユーザー・データベースにユーザーをインポートします。このユーザー・データベースのコピーは、オンデマンドまたは定期的なバックグラウンド・タスクによって同期されます。パスワードの同期については例外が存在します。{project_name}は決してパスワードをインポートしません。パスワードの検証は常にLDAPサーバー上で行われます。"

msgid ""
"The advantage of synchronization is that all {project_name} features work "
"efficiently because any required extra per-user data is stored locally. The "
"disadvantage is that each time {project_name} queries a specific user for "
"the first time, {project_name} performs a corresponding database insert."
msgstr ""
"同期の利点は、ユーザーごとに必要な追加のデータがローカルに保存されるため、すべての{project_name}の機能が効率的に動作することです。欠点は、{project_name}が特定のユーザーに初めて問い合わせるたびに、{project_name}が対応するデータベースの挿入を実行することです。"

msgid ""
"You can synchronize the import with your LDAP server. Import synchronization"
" is unnecessary when LDAP mappers always read particular attributes from the"
" LDAP rather than the database."
msgstr ""
"インポートをLDAPサーバーと同期させることができます。LDAPマッパーが常にデータベースではなくLDAPから特定の属性を読み取る場合、インポートの同期は不要です。"

msgid ""
"You can use LDAP with {project_name} without importing users into the "
"{project_name} user database. The LDAP server backs up the common user model"
" that the {project_name} runtime uses. If LDAP does not support data that a "
"{project_name} feature requires, that feature will not work. The advantage "
"of this approach is that you do not have the resource usage of importing and"
" synchronizing copies of LDAP users into the {project_name} user database."
msgstr ""
"{project_name}のユーザー・データベースにユーザーをインポートすることなく、{project_name}でLDAPを使用することができます。LDAP"
" "
"サーバーは、{project_name}のランタイムが使用する共通ユーザーモデルをバックアップします。ある{project_name}の機能が必要とするデータをLDAPがサポートしていない場合、その機能は動作しません。この方法の利点は、LDAPユーザーのコピーを{project_name}ユーザー・データベースにインポートして同期させるというリソース利用がないことです。"

msgid ""
"The *Import Users* switch on the LDAP configuration page controls this "
"storage mode. To import users, toggle this switch to *ON*."
msgstr ""
"LDAP設定ページの *Import Users* スイッチは、このストレージモードを制御します。ユーザーをインポートするには、このスイッチを *ON*"
" に切り替えます。"

msgid ""
"If you disable *Import Users*, you cannot save user profile attributes into "
"the {project_name} database. Also, you cannot save metadata except for user "
"profile metadata mapped to the LDAP. This metadata can include role "
"mappings, group mappings, and other metadata based on the LDAP mappers' "
"configuration."
msgstr ""
"*Import Users* を無効にすると、ユーザー・プロフィールの属性を "
"{project_name}のデータベースに保存することができなくなります。また、LDAPにマッピングされたユーザー・プロフィール・メタデータ以外のメタデータを保存することもできま"
" せん。このメタデータには、ロールマッピング、グループマッピング、およびLDAPマッパーの設定に基づくその他のメタデータを含めることができます。"

msgid ""
"When you attempt to change the non-LDAP mapped user data, the user update is"
" not possible. For example, you cannot disable the LDAP mapped user unless "
"the user's `enabled` flag maps to an LDAP attribute."
msgstr ""
"LDAPにマッピングされていないユーザーデータを変更しようとすると、ユーザーの更新ができなくなります。たとえば、ユーザーの `enabled` "
"フラグがLDAP属性にマップされていない限り、LDAPにマップされたユーザーを無効にすることはできません。"

msgid "Edit mode"
msgstr "編集モード"

msgid ""
"Users and admins can modify user metadata, users through the <<_account-"
"service, Account Console>>, and administrators through the Admin Console. "
"The `Edit Mode` configuration on the LDAP configuration page defines the "
"user's LDAP update privileges."
msgstr ""
"ユーザのメタデータは、ユーザーは<<_account-service, "
"アカウント・コンソール>>から、管理者は管理コンソールから修正することができます。LDAP設定ページの `Edit Mode` "
"の設定は、ユーザーのLDAP更新権限を定義します。"

msgid "READONLY"
msgstr "READONLY"

msgid ""
"You cannot change the username, email, first name, last name, and other "
"mapped attributes. {project_name} shows an error anytime a user attempts to "
"update these fields. Password updates are not supported."
msgstr ""
"ユーザー名、電子メール、姓、名、その他のマッピングされた属性は変更できません。ユーザーがこれらのフィールドを更新しようとすると、いつでも "
"{project_name} エラーが表示されます。パスワードの更新はサポートされていません。"

msgid "WRITABLE"
msgstr "WRITABLE"

msgid ""
"You cannot change the username, email, first name, last name, and other "
"mapped attributes and passwords and synchronize them automatically with the "
"LDAP store."
msgstr "ユーザー名、電子メール、姓、名などのマッピングされた属性やパスワードを変更し、LDAPストアと自動的に同期させることはできません。"

msgid "UNSYNCED"
msgstr "UNSYNCED"

msgid ""
"{project_name} stores changes to the username, email, first name, last name,"
" and passwords in {project_name} local storage, so the administrator must "
"synchronize this data back to LDAP. In this mode, {project_name} deployments"
" can update user metadata on read-only LDAP servers. This option also "
"applies when importing users from LDAP into the local {project_name} user "
"database."
msgstr ""
"{project_name}は、ユーザー名、電子メール、名、姓、パスワードの変更を "
"{project_name}のローカル・ストレージに保存するため、管理者はこのデータをLDAPに同期して戻さなければなりません。このモードでは、{project_name}が読み取り専用のLDAPサーバー上のユーザー・メタデータを更新することができます。このオプションは、LDAPからローカルの{project_name}のユーザー・データベースにユーザーをインポートする場合にも適用されます。"

msgid ""
"When {project_name} creates the LDAP provider, {project_name} also creates a"
" set of initial <<_ldap_mappers,LDAP mappers>>. {project_name} configures "
"these mappers based on a combination of the *Vendor*, *Edit Mode*, and "
"*Import Users* switches. For example, when edit mode is UNSYNCED, "
"{project_name} configures the mappers to read a particular user attribute "
"from the database and not from the LDAP server. However, if you later change"
" the edit mode, the mapper's configuration does not change because it is "
"impossible to detect if the configuration changes changed in UNSYNCED mode. "
"Decide the *Edit Mode* when creating the LDAP provider. This note applies to"
" *Import Users* switch also."
msgstr ""
"{project_name}がLDAPプロバイダーを作成するとき、{project_name}は初期<<_ldap_mappers,LDAPマッパー>>のセットも作成します。{project_name}"
" は、 *Vendor* 、 *Edit Mode* 、および *Import Users* "
"スイッチの組み合わせに基づいて、これらのマッパーを構成します。たとえば、編集モードがUNSYNCEDの場合、{project_name}は、特定のユーザー属性をLDAPサーバーからではなく、データベースから読み取るようにマッパーを構成します。しかし、後で編集モードを変更した場合、UNSYNCEDモードでは設定の変更を検出することができないため、マッパーの設定は変更されません。LDAPプロバイダー作成時に"
" *Edit Mode* を決定してください。この注意事項は、 *Import Users* スイッチにも適用されます。"

msgid "Other configuration options"
msgstr "その他の設定オプション"

msgid "Console Display Name"
msgstr "Console Display Name"

msgid "The name of the provider to display in the admin console."
msgstr "管理コンソールに表示するプロバイダー名です。"

msgid "Priority"
msgstr "Priority"

msgid "The priority of the provider when looking up users or adding a user."
msgstr "ユーザーを検索するとき、またはユーザーを追加するときのプロバイダーの優先順位です。"

msgid "Sync Registrations"
msgstr "Sync Registrations"

msgid ""
"Toggle this switch to *ON* if you want new users created by {project_name} "
"added to LDAP."
msgstr "{project_name}で作成した新規ユーザーをLDAPに追加したい場合は、このスイッチを *ON* に切り替えてください。"

msgid "Allow Kerberos authentication"
msgstr "Allow Kerberos authentication"

msgid ""
"Enable Kerberos/SPNEGO authentication in the realm with user data "
"provisioned from LDAP. For more information, see the <<_kerberos,Kerberos "
"section>>."
msgstr ""
"LDAPからプロビジョニングされたユーザーデータでレルム内のKerberos/SPNEGO認証を有効にします。詳細については、<<_kerberos,Kerberosのセクション>>を参照してください。"

msgid "Other options"
msgstr "その他のオプション"

msgid ""
"Hover the mouse pointer over the tooltips in the Admin Console to see more "
"details about these options."
msgstr "管理コンソールのツールチップにマウスポインターを合わせると、これらのオプションの詳細が表示されます。"

msgid "Connecting to LDAP over SSL"
msgstr "SSLでLDAPに接続する"

msgid ""
"When you configure a secure connection URL to your LDAP store (for "
"example,`ldaps://myhost.com:636`), {project_name} uses SSL to communicate "
"with the LDAP server. Configure a truststore on the {project_name} server "
"side so that {project_name} can trust the SSL connection to LDAP."
msgstr ""
"LDAPストアへのセキュアな接続URL (例: `ldaps://myhost.com:636` ) "
"を設定すると、{project_name}はLDAPサーバーとの通信にSSLを使用します。{project_name}がLDAPへのSSL接続を信頼できるように、{project_name}サーバー側でトラストストアを設定します。"

msgid ""
"Configure the global truststore for {project_name} with the Truststore SPI. "
"For more information about configuring the global truststore, see the "
"link:{installguide_link}[{installguide_name}]. If you do not configure the "
"Truststore SPI, the truststore falls back to the default mechanism provided "
"by Java, which can be the file supplied by the `javax.net.ssl.trustStore` "
"system property or the cacerts file from the JDK if the system property is "
"unset."
msgstr ""
"Truststore "
"SPIを使用して{project_name}のグローバル・トラストストアを設定します。グローバル・トラストストアの設定の詳細については、 "
"link:{installguide_link}[{installguide_name}] "
"を参照してください。これは、`javax.net.ssl.trustStore` "
"システム・プロパティーが提供するファイル、またはシステム・プロパティーが未設定の場合はJDKのcacertsファイルです。"

msgid ""
"The `Use Truststore SPI` configuration property, in the LDAP federation "
"provider configuration, controls the truststore SPI. By default, "
"{project_name} sets the property to `Only for ldaps`, which is adequate for "
"most deployments.  {project_name} uses the Truststore SPI if the connection "
"URL to LDAP starts with `ldaps` only."
msgstr ""
"LDAPフェデレーション・プロバイダーの設定にある `Use Truststore SPI` "
"の設定プロパティーは、トラストストアのSPIを制御します。デフォルトでは、{project_name}はこのプロパティーを `Only for "
"ldaps` に設定しており、ほとんどの配備で適切な値になっています。{project_name}は、LDAPへの接続URLが `ldaps` "
"のみで始まっている場合、Truststore SPI を使用します。"

msgid "Synchronizing LDAP users to {project_name}"
msgstr "LDAPユーザーを{project_name}に同期させる。"

msgid ""
"If you set the *Import Users* option, the LDAP Provider handles importing "
"LDAP users into the {project_name} local database. The first time a user "
"logs in, the LDAP provider imports the LDAP user into the {project_name} "
"database and validates the LDAP password. This first time a user logs in is "
"the only time {project_name} imports the user. If you click the *Users*  "
"menu in the Admin Console and click the *View all users* button, you only "
"see the LDAP users authenticated at least once by {project_name}. "
"{project_name} imports users this way, so this operation does not trigger an"
" import of the entire LDAP user database."
msgstr ""
"*ImportUsers*オプションを設定すると、LDAPプロバイダーはLDAPユーザーの{project_name}ローカル・データベースへのインポートを処理するようになります。ユーザーが初めてログインするとき、LDAPプロバイダーはLDAPユーザーを{project_name}データベースにインポートし、LDAPパスワードを検証します。{project_name}がユーザーをインポートするのは、この初回ログイン時のみです。管理コンソールの"
" *Users* メニューをクリックし、 *View all users* "
"ボタンをクリックすると、{project_name}によって少なくとも一度は認証されたLDAPユーザーだけが表示されます。{project_name}はこの方法でユーザーをインポートするため、この操作によってLDAPユーザーデータベース全体のインポートが開始されることはありません。"

msgid ""
"If you want to sync all LDAP users into the {project_name} database, "
"configure and enable the *Sync Settings* on the LDAP provider configuration "
"page."
msgstr ""
"すべてのLDAPユーザーを{project_name}データベースに同期させたい場合は、LDAPプロバイダーの設定ページで *Sync "
"Settings* を設定し、有効にしてください。"

msgid "Two types of synchronization exist:"
msgstr "同期には次の2つのタイプが存在します。"

msgid "Periodic Full sync"
msgstr "定期的な完全同期"

msgid ""
"This type synchronizes all LDAP users into the {project_name} database. The "
"LDAP users already in {project_name}, but different in LDAP, directly update"
" in the {project_name} database."
msgstr ""
"このタイプは、すべてのLDAPユーザーを{project_name} "
"データベースに同期させます。すでに{project_name}にあるLDAPユーザーのうち、LDAPと異なるユーザーは、{project_name}のデータベースに直接更新されます。"

msgid "Periodic Changed users sync"
msgstr "定期的な変更ユーザーの同期"

msgid ""
"When synchronizing, {project_name} creates or updates users created or "
"updated after the last sync only."
msgstr "同期時に{project_name}が作成または更新するのは、前回の同期以降に作成または更新されたユーザーだけです。"

msgid ""
"The best way to synchronize is to click *Synchronize all users* when you "
"first create the LDAP provider, then set up periodic synchronization of "
"changed users."
msgstr ""
"LDAPプロバイダーを最初に作成する際に、 *Synchronize all users* "
"をクリックし、変更されたユーザーを定期的に同期させるように設定するのが最も良い方法です。"

msgid "LDAP mappers"
msgstr "LDAPマッパー"

msgid ""
"LDAP mappers are `listeners` triggered by the LDAP Provider. They provide "
"another extension point to LDAP integration. LDAP mappers are triggered "
"when:"
msgstr ""
"LDAPマッパーはLDAPプロバイダーによって起動される `listeners` "
"です。LDAPマッパーはLDAP統合のためのもう一つの拡張ポイントを提供します。LDAPマッパーは以下のような場合に起動されます。"

msgid "Users log in by using LDAP."
msgstr "ユーザーはLDAPを利用してログインします。"

msgid "Users initially register."
msgstr "ユーザーの初期登録。"

msgid "The Admin Console queries a user."
msgstr "管理コンソールがユーザーに問い合わせをします。"

msgid ""
"When you create an LDAP Federation provider, {project_name} automatically "
"provides a set of `mappers` for this provider. This set is changeable by "
"users, who can also develop mappers or update/delete existing ones."
msgstr ""
"LDAPフェデレーションプロバイダーを作成すると、{project_name}は自動的にこのプロバイダー用の `mappers` "
"セットを提供します。このセットはユーザーが変更可能であり、ユーザーはマッパーを開発したり、既存のマッパーを更新・削除したりすることができます。"

msgid "User Attribute Mapper"
msgstr "User Attribute Mapper"

msgid ""
"This mapper specifies which LDAP attribute maps to the attribute of the "
"{project_name} user. For example, you can configure the `mail` LDAP "
"attribute to the `email` attribute in the {project_name} database. For this "
"mapper implementation, a one-to-one mapping always exists."
msgstr ""
"このマッパーは、どのLDAP属性を{project_name}のユーザー属性にマッピングするかを指定します。たとえば、`mail` "
"というLDAP属性を{project_name}データベースの `email` "
"属性に設定することができます。このマッパーの実装では、常に一対一のマッピングが存在します。"

msgid "FullName Mapper"
msgstr "フルネーム・マッパー"

msgid ""
"This mapper specifies the full name of the user. {project_name} saves the "
"name in an LDAP attribute (usually `cn`) and maps the name to the "
"`firstName` and `lastname` attributes in the {project_name} database. Having"
" `cn` to contain the full name of the user is common for LDAP deployments."
msgstr ""
"このマッパーはユーザーのフルネームを指定します。{project_name}はその名前をLDAP属性 (通常は `cn`` ) "
"に保存し、その名前を{project_name}のデータベース内の `firstName` と `lastname` "
"属性にマップします。ユーザーのフルネームを `cn` に格納することは、LDAP の配備では一般的なことです。"

msgid ""
"When you register new users in {project_name} and `Sync Registrations` is ON"
" for the LDAP provider, the fullName mapper permits falling back to the "
"username. This fallback is  useful when using Microsoft Active Directory "
"(MSAD). The common setup for MSAD is to configure the `cn` LDAP attribute as"
" fullName and, at the same time, use the `cn` LDAP attribute as the `RDN "
"LDAP Attribute` in the LDAP provider configuration. With this setup, "
"{project_name} falls back to the username. For example, if you create "
"{project_name} user \"john123\" and leave firstName and lastName empty, then"
" the fullname mapper saves \"john123\" as the value of the `cn` in LDAP. "
"When you enter \"John Doe\" for firstName and lastName later, the fullname "
"mapper updates LDAP `cn` to the \"John Doe\" value as falling back to the "
"username is unnecessary."
msgstr ""
"{project_name}で新規ユーザーを登録する際、LDAPプロバイダーの `Sync Registrations` がオンになっていると、 "
"fullName マッパーはユーザー名へのフォールバックを許可します。このフォールバックはMicrosoft Active Directory "
"(MSAD)を使用するときに便利です。MSADの一般的な設定は、`cn` LDAP属性をfullNameとして設定し、同時にLDAPプロバイダーの設定で"
" `cn` LDAP属性を `RDN LDAP "
"Attribute`として使用することです。この設定では、{project_name}はユーザー名にフォールバックします。たとえば、{project_name}でユーザー\"john123\"を作成し、firstNameとlastNameを空にした場合、フルネームマッパーはLDAPの"
" `cn` の値として\"john123\"を保存します。後でfirstNameとlastNameに\"John "
"Doe\"を入力すると、ユーザ名にフォールバックする必要がないため、フルネームマッパーはLDAPの `cn` を \"John Doe\" "
"の値に更新します。"

msgid "Hardcoded Attribute Mapper"
msgstr "Hardcoded Attribute Mapper"

msgid ""
"This mapper adds a hardcoded attribute value to each {project_name} user "
"linked with LDAP. This mapper can also force values for the `enabled` or "
"`emailVerified` user properties."
msgstr ""
"このマッパーはLDAPとリンクしている各{project_name}ユーザーにハードコードされた属性値を追加します。このマッパーは `enabled` "
"や `emailVerified` というユーザー・プロパティーに値を強制することもできます。"

msgid "Role Mapper"
msgstr "ロールマッパー"

msgid ""
"This mapper configures role mappings from LDAP into {project_name} role "
"mappings. A single role mapper can map LDAP roles (usually groups from a "
"particular branch of the LDAP tree) into roles corresponding to a specified "
"client's realm roles or client roles. You can configure more Role mappers "
"for the same LDAP provider. For example, you can specify that role mappings "
"from groups under `ou=main,dc=example,dc=org` map to realm role mappings, "
"and role mappings from groups under `ou=finance,dc=example,dc=org` map to "
"client role mappings of client `finance`."
msgstr ""
"このマッパーは、LDAPから取得したロールマッピングを{project_name}のロールマッピングに設定します。1つのロールマッパーで、LDAPロール（通常はLDAPツリーの特定のブランチのグループ）を、指定されたクライアントのレルムロールまたはクライアントロールに対応するロールにマッピングすることができます。同じLDAPプロバイダーに対して、より多くのロールマッパーを設定することができます。たとえば、"
" `ou=main,dc=example,dc=org` のグループからのロールマッピングはレルムロールマッピングにマッピングし、 "
"`ou=finance,dc=example,dc=org` のグループからのロールマッピングはクライアント`finance` "
"のクライアント・ロールマッピングにマッピングすると指定することができます。"

msgid "Hardcoded Role Mapper"
msgstr "ハードコードされたロールマッパー"

msgid ""
"This mapper grants a specified {project_name} role to each {project_name} "
"user from the LDAP provider."
msgstr ""
"このマッパーは、LDAPプロバイダーからの各{project_name}ユーザーに対して、指定された{project_name}ロールを付与します。"

msgid "Group Mapper"
msgstr "グループマッパー"

msgid ""
"This mapper maps LDAP groups from a branch of an LDAP tree into groups "
"within {project_name}. This mapper also propagates user-group mappings from "
"LDAP into user-group mappings in {project_name}."
msgstr ""
"このマッパーは、LDAPツリーのブランチから{project_name}内のグループにLDAPグループをマッピングします。このマッパーはまた、LDAP "
"からのユーザー・グループ・マッピングを {project_name} 内のユーザー・グループ・マッピングに伝搬させます。"

msgid "MSAD User Account Mapper"
msgstr "MSADユーザー・アカウント・マッパー"

msgid ""
"This mapper is specific to Microsoft Active Directory (MSAD). It can "
"integrate the MSAD user account state into the {project_name} account state,"
" such as enabled account or  expired password. This mapper uses the "
"`userAccountControl`, and `pwdLastSet` LDAP attributes, specific to MSAD and"
" are not the LDAP standard. For example, if the value of `pwdLastSet` is "
"`0`, the {project_name} user must update their password. The result is an "
"UPDATE_PASSWORD required action added to the user. If the value of  "
"`userAccountControl` is `514` (disabled account), the {project_name} user is"
" disabled."
msgstr ""
"このマッパーは Microsoft Active Directory "
"(MSAD)に特化したものです。MSADのユーザー・アカウントの状態を、有効なアカウントや期限切れのパスワードのような{project_name}のアカウントの状態に統合することができます。このマッパーは"
" `userAccountControl` と `pwdLastSet` "
"というLDAP属性を使用しますが、これはMSADに特有の属性で、LDAPの標準的なものではありません。たとえば、`pwdLastSet` の値が `0`"
" "
"の場合、{project_name}のユーザーはパスワードを更新する必要があります。その結果、UPDATE_PASSWORD必須アクションがそのユーザーに追加されます。"
" `userAccountControl` の値が `514` "
"（アカウント無効）の場合、{project_name}のユーザーはアカウント無効となります。"

msgid "Certificate Mapper"
msgstr "Certificate Mapper"

msgid ""
"This mapper maps X.509 certificates. {project_name} uses it in conjunction "
"with X.509 authentication and `Full certificate in PEM format` as an "
"identity source. This mapper behaves similarly to the `User Attribute "
"Mapper`, but {project_name} can filter for an LDAP attribute storing a PEM "
"or DER format certificate. Enable `Always Read Value From LDAP` with this "
"mapper."
msgstr ""
"このマッパーはX.509の証明書をマッピングします。{project_name}はX.509認証と`Full certificate in PEM "
"format`と組み合わせてアイデンティティー・ソースとして使用します。このマッパーは `User Attribute Mapper` "
"と同様の動作をしますが、{project_name}はPEMまたはDER形式の証明書を格納したLDAP属性をフィルタリングすることができます。このマッパーでは"
" `Always Read Value From LDAP` を有効にしてください。"

msgid ""
"User Attribute mappers that map basic {project_name} user attributes, such "
"as username, firstname, lastname, and email, to corresponding LDAP "
"attributes. You can extend these and provide your own additional attribute "
"mappings. The Admin Console provides tooltips to help with configuring the "
"corresponding mappers."
msgstr ""
"ユーザー属性マッパー。ユーザー名、名、姓、電子メールなどの基本的な "
"{project_name}のユーザー属性を、対応するLDAP属性にマッピングします。これらを拡張して、独自の属性マッピングを追加することができます。管理コンソールは、対応するマッパーの設定を支援するツールチップを提供します。"

msgid "Password hashing"
msgstr "パスワードハッシュ"

msgid ""
"When {project_name} updates a password, {project_name} sends the password in"
" plain-text format. This action is different from updating the password in "
"the built-in {project_name} database, where {project_name} hashes and salts "
"the password before sending it to the database. For LDAP, {project_name} "
"relies on the LDAP server to hash and salt the password."
msgstr ""
"{project_name}がパスワードを更新するとき、{project_name}はパスワードをプレーンテキスト形式で送信します。この動作は、組み込みの{project_name}データベースでパスワードを更新する場合、{project_name}がパスワードをデータベースに送信する前にハッシュとソルトを行う場合とは異なります。LDAPの場合、{project_name}はLDAPサーバに依存して、パスワードをハッシュし、ソルトします。"

msgid ""
"By default, LDAP servers such as MSAD, RHDS, or FreeIPA hash and salt "
"passwords. Other LDAP servers such as OpenLDAP or ApacheDS store the "
"passwords in plain-text unless you use the _LDAPv3 Password Modify Extended "
"Operation_ as described in "
"https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3[RFC3062]. "
"Enable the LDAPv3 Password Modify Extended Operation in the LDAP "
"configuration page. See the documentation of your LDAP server for more "
"details."
msgstr ""
"デフォルトでは、MSAD、RHDS、FreeIPAなどのLDAPサーバーは、パスワードをハッシュおよびソルトします。OpenLDAPやApacheDSなどの他のLDAPサーバーは、"
" https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3[RFC3062] "
"で説明されている _LDAPv3 Password Modify Extended Operation_ "
"を使用しない限り、パスワードをプレーンテキストで保存します。LDAP設定ページでLDAPv3 Password Modify Extended "
"Operationを有効にしてください。詳細は、LDAPサーバーのドキュメントを参照してください。"

msgid ""
"Always verify that user passwords are properly hashed and not stored as "
"plaintext by inspecting a changed directory entry using `ldapsearch` and "
"base64 decode the `userPassword` attribute value."
msgstr ""
"`ldapsearch` を使用して変更されたディレクトリー・エントリーを検査し、`userPassword` "
"属性値をbase64デコードすることにより、ユーザーパスワードが適切にハッシュ化され、プレーンテキストとして保存されていないことを常に確認してください。"

msgid "Troubleshooting"
msgstr "トラブルシューティング"

msgid ""
"It is useful to increase the logging level to TRACE for the category "
"`org.keycloak.storage.ldap`. You increase this level in the logging"
msgstr ""
"カテゴリー `org.keycloak.storage.ldap` のロギングレベルをTRACEに上げると便利です。ロギングでこのレベルを上げます。"

msgid ""
"It is useful to increase the logging level to TRACE for the category "
"`org.keycloak.storage.ldap`. You increase this level in the logging "
"subsystem in the `standalone(-ha).xml` file. With this setting, many logging"
" messages are sent to the `server.log` file in the `TRACE` level, including "
"the logging for all queries to the LDAP server and the parameters, which "
"were used to send the queries. When you are creating any LDAP question on "
"user forum or JIRA, consider attaching the server log with enabled TRACE "
"logging. If it is too big, the good alternative is to include just the "
"snippet from server log with the messages, which were added to the log "
"during the operation, which causes the issues to you."
msgstr ""
"カテゴリー `org.keycloak.storage.ldap` のログレベルをTRACEに上げると便利です。 "
"`standalone(-ha).xml` "
"ファイルのロギング・サブシステムでこのレベルを上げます。この設定では、LDAPサーバーへのすべてのクエリーのログと、クエリーの送信に使用されたパラメーターを含む、多くのログメッセージが"
" `TRACE` レベルで `server.log` "
"ファイルに送信されます。ユーザー・フォーラムまたはJIRAでLDAPの質問を作成する場合は、TRACEログを有効にしてサーバーログを添付することを検討してください。大きすぎる場合は、問題が発生する操作の際にログに追加されたメッセージとサーバーログのスニペットだけを含めることをお勧めします。"

msgid ""
"When you create LDAP provider, message appear in the server log in the INFO "
"level starting with:"
msgstr "LDAPプロバイダーを作成すると、サーバーログに次のINFOレベルでメッセージが表示されます。"

msgid "Creating new LDAP Store for the LDAP storage provider: ..."
msgstr "Creating new LDAP Store for the LDAP storage provider: ..."

msgid ""
"It shows the configuration of your LDAP provider. Before you are asking the "
"questions or reporting bugs, it will be nice to include this message to show"
" your LDAP configuration. Eventually feel free to replace some config "
"changes, which you do not want to include, with some placeholder values. One"
" example is `bindDn=some-placeholder` . For `connectionUrl`, feel free to "
"replace it as well, but it is generally useful to include at least the "
"protocol, which was used (`ldap` vs `ldaps`)`. Similarly it can be useful to"
" include the details for configuration of your LDAP mappers, which are "
"displayed with the message like this at the DEBUG level:"
msgstr ""
"LDAPプロバイダーの設定が表示されます。質問したりバグを報告したりする前に、このメッセージを含めてLDAPの設定を表示するとよいでしょう。最終的には、含めたくない設定の変更をいくつかのプレースホルダー値で自由に置き換えてください。"
" 一例は `bindDn=some-placeholder` です。 `connectionUrl` "
"についても、同様に自由に置き換えることができますが、少なくとも使用されたプロトコル ( `ldap` と `ldaps` ) "
"を含めることは一般的に役立ちます。同様に、DEBUGレベルで次のようなメッセージとともに表示されるLDAPマッパーの設定の詳細を含めると便利です。"

msgid "Mapper for provider: XXX, Mapper name: YYY, Provider: ZZZ ..."
msgstr "Mapper for provider: XXX, Mapper name: YYY, Provider: ZZZ ..."

msgid "Note those messages are displayed just with the enabled DEBUG logging."
msgstr "これらのメッセージは、DEBUGロギングが有効になっている場合にのみ表示されることに注意してください。"

msgid ""
"For tracking the performance or connection pooling issues, consider setting "
"the value of property `Connection Pool Debug Level` of"
msgstr ""
"パフォーマンスやコネクション・プーリングの問題を追跡するために、 `Connection Pool Debug Level` "
"というプロパティーを設定することを検討してください。"

msgid ""
"For tracking the performance or connection pooling issues, consider setting "
"the value of property `Connection Pool Debug Level` of the LDAP provider to "
"value `all`. This will add lots of additional messages to server log with "
"the included logging for the LDAP connection pooling. This can be used to "
"track the issues related to connection pooling or performance."
msgstr ""
"パフォーマンスまたは接続プーリングの問題を追跡するには、LDAPプロバイダーのプロパティー `Connection Pool Debug Level` "
"の値を `all` "
"に設定することを検討してください。これにより、サーバーログにLDAP接続プーリングのログが含む多くのメッセージが追加されます。これは、接続プーリングまたはパフォーマンスに関連する問題を追跡するために使用できます。"

msgid ""
"After changing the configuration of connection pooling, you may need to "
"restart the Keycloak server to enforce re-initialization of the LDAP "
"provider connection."
msgstr ""
"接続プーリングの設定を変更した後、LDAPプロバイダー接続の再初期化を強制するために、Keycloakサーバーを再起動する必要がある場合があります。"

msgid ""
"If no more messages appear for connection pooling even after server restart,"
" it can indicate that connection pooling does not work with your LDAP "
"server."
msgstr ""
"サーバーを再起動しても接続プールに関するメッセージが表示されない場合は、接続プールがLDAPサーバーで機能していないことを示している可能性があります。"

msgid ""
"For the case of reporting LDAP issue, you may consider to attach some part "
"of your LDAP tree with the target data, which causes issues in your "
"environment. For example if login of some user takes lot of time, you can "
"consider attach his LDAP entry showing count of `member` attributes of "
"various \"group\" entries. In this case, it might be useful to add if those "
"group entries are mapped to some Group LDAP mapper (or Role LDAP Mapper) in "
"{project_name} etc."
msgstr ""
"LDAPの問題を報告する場合、あなたの環境で問題を起こす可能性がある対象のデータとLDAPツリーの一部を添付することを検討してください。たとえば、あるユーザーのログインに時間がかかる場合、様々な\"group\"エントリーの"
" `member` "
"属性の数を示すLDAPエントリーを添付することを検討できます。この場合、これらのグループ・エントリーが{project_name}のグループLDAPマッパー"
" (またはロールLDAPマッパー) などにマップされるように追加すると有益かもしれません。"

msgid ""
"For the case of reporting LDAP issue, you may consider to attach some part "
"of your LDAP tree with the target data, which causes issues in your "
"environment. For example if login of some user takes lot of time, you can "
"consider attach his LDAP entry showing count of `member` attributes of "
"various \"group\" entries. In this case, it might be useful to add if those "
"group entries are mapped to some Group LDAP mapper (or Role LDAP Mapper) in "
"{project_name} and so on."
msgstr ""
"LDAPの問題を報告する場合、LDAPツリーの一部をターゲット・データと一緒に添付することが考えられます。たとえば、あるユーザーのログインに時間がかかる場合、様々な\"group\"エントリーの"
" `member` "
"属性の数を示す彼のLDAPエントリーを添付することを検討できます。この場合、これらのグループ・エントリーが{project_name}などのグループLDAPマッパー（またはロールLDAPマッパー）にマップされているかどうかを追加すると便利でしょう。"

msgid "SSSD and FreeIPA Identity Management integration"
msgstr "SSSDとFreeIPAのアイデンティティー管理の統合"

msgid ""
"{project_name} includes the "
"https://fedoraproject.org/wiki/Features/SSSD[System Security Services Daemon"
" (SSSD)] plugin. SSSD is part of the Fedora and Red Hat Enterprise Linux "
"(RHEL), and it provides access to multiple identities and authentication "
"providers. SSSD also provides benefits such as failover and offline support."
" For more information, see https://access.redhat.com/documentation/en-"
"us/red_hat_enterprise_linux/7/html/system-"
"level_authentication_guide/sssd[the Red Hat Enterprise Linux Identity "
"Management documentation]."
msgstr ""
"{project_name}には https://fedoraproject.org/wiki/Features/SSSD[System "
"Security Services Daemon (SSSD)] プラグインが含まれています。SSSDは FedoraとRed Hat "
"Enterprise Linux (RHEL)に含まれており、複数のアイデンティティーと認証プロバイダーへのアクセスを提供します。また、SSSD "
"はフェイルオーバーやオフラインのサポートなどの利点も提供します。詳細については、 "
"https://access.redhat.com/documentation/en-"
"us/red_hat_enterprise_linux/7/html/system-"
"level_authentication_guide/sssd[Red Hat Enterprise Linux Identity "
"Managementのドキュメント] を参照してください。"

msgid ""
"SSSD integrates with the FreeIPA identity management (IdM) server, providing"
" authentication and access control. With this integration, {project_name} "
"can authenticate against privileged access management (PAM) services and "
"retrieve user data from SSSD. For more information about using Red Hat "
"Identity Management in Linux environments, see "
"https://access.redhat.com/documentation/en-"
"us/red_hat_enterprise_linux/7/html/linux_domain_identity_authentication_and_policy_guide/index[the"
" Red Hat Enterprise Linux Identity Management documentation]."
msgstr ""
"SSSDはFreeIPA Identity Management (IDM) "
"serverと統合され、認証とアクセス・コントロールを提供します。この統合により、{project_name}は特権アクセス管理 (PAM) "
"サービスに対して認証を行い、SSSDからユーザーデータを取得することができます。Linux環境でのRed Hat Identity "
"Managementの使用に関する詳細は、 https://access.redhat.com/documentation/en-"
"us/red_hat_enterprise_linux/7/html/linux_domain_identity_authentication_and_policy_guide/index[the"
" Red Hat Enterprise Linux Identity Managementのドキュメント] を参照してください。"

msgid ""
"image:{project_images}/keycloak-sssd-freeipa-integration-overview.png[]"
msgstr ""
"image:{project_images}/keycloak-sssd-freeipa-integration-overview.png[]"

msgid ""
"{project_name} and SSSD communicate through read-only D-Bus interfaces. For "
"this reason, the way to provision and update users is to use the FreeIPA/IdM"
" administration interface. By default, the interface imports the username, "
"email, first name, and last name."
msgstr ""
"{project_name}とSSSDは、読み取り専用のD-"
"Busインターフェイスで通信します。このため、ユーザーの設定や更新はFreeIPA/IdMの管理インターフェイスで行うことになります。デフォルトでは、このインターフェイスはユーザー名、電子メール、名、姓をインポートします。"

msgid ""
"{project_name} registers groups and roles automatically but does not "
"synchronize them. Any changes made by the {project_name} administrator in "
"{project_name} do not synchronize with SSSD."
msgstr ""
"{project_name}はグループとロールを自動的に登録しますが、同期を取りません。{project_name}の管理者が{project_name}で行った変更は、SSSDと同期されません。"

msgid "FreeIPA/IdM server"
msgstr "FreeIPA/IdMサーバー"

msgid ""
"The https://hub.docker.com/r/freeipa/freeipa-server/[FreeIPA Docker image] "
"is available in Docker Hub. To set up the FreeIPA server, see the "
"https://www.freeipa.org/page/Quick_Start_Guide[FreeIPA documentation]."
msgstr ""
"https://hub.docker.com/r/freeipa/freeipa-server/[FreeIPA Dockerイメージ]は、Docker"
" Hubで公開されています。FreeIPAサーバーのセットアップは、 "
"https://www.freeipa.org/page/Quick_Start_Guide[FreeIPAのドキュメント] を参照してください。"

msgid "Run your FreeIPA server using this command:"
msgstr "このコマンドを使用してFreeIPAサーバーを実行します。"

msgid ""
" docker run --name freeipa-server-container -it \\\n"
" -h server.freeipa.local -e PASSWORD=YOUR_PASSWORD \\\n"
" -v /sys/fs/cgroup:/sys/fs/cgroup:ro \\\n"
" -v /var/lib/ipa-data:/data:Z freeipa/freeipa-server"
msgstr ""
" docker run --name freeipa-server-container -it \\\n"
" -h server.freeipa.local -e PASSWORD=YOUR_PASSWORD \\\n"
" -v /sys/fs/cgroup:/sys/fs/cgroup:ro \\\n"
" -v /var/lib/ipa-data:/data:Z freeipa/freeipa-server"

msgid ""
"The parameter `-h` with `server.freeipa.local` represents the FreeIPA/IdM "
"server hostname. Change `YOUR_PASSWORD` to a password of your own."
msgstr ""
"The parameter `-h` with `server.freeipa.local` represents the FreeIPA/IdM "
"server hostname. Change `YOUR_PASSWORD` to a password of your own."

msgid "After the container starts, change the `/etc/hosts` file to include:"
msgstr "コンテナーの起動後、 `/etc/hosts` を次のように変更します。"

msgid "x.x.x.x     server.freeipa.local"
msgstr "x.x.x.x     server.freeipa.local"

msgid "If you do not make this change, you must set up a DNS server."
msgstr "この変更を行わない場合は、DNSサーバーを設定する必要があります。"

msgid ""
"Use the following command to enroll your Linux server in the IPA domain so "
"that the SSSD federation provider starts and runs on {project_name}:"
msgstr ""
"以下のコマンドでLinuxサーバーをIPAドメインに登録し、SSSDフェデレーション・プロバイダーが{project_name}上で起動・実行されるようにします。"

msgid " ipa-client-install --mkhomedir -p admin -w password"
msgstr " ipa-client-install --mkhomedir -p admin -w password"

msgid ""
"Run the following command on the client to verify the installation is "
"working:"
msgstr "クライアントで以下のコマンドを実行し、インストールが正常に行われることを確認します。"

msgid " kinit admin"
msgstr " kinit admin"

msgid "Enter your password."
msgstr "パスワードを入力してください。"

msgid "Add users to the IPA server using this command:"
msgstr "このコマンドを使用して、IPAサーバーにユーザーを追加します。"

msgid ""
"$ ipa user-add <username> --first=<first name> --last=<surname> "
"--email=<email address> --phone=<telephoneNumber> --street=<street> \\      "
"--city=<city> --state=<state> --postalcode=<postal code> --password"
msgstr ""
"$ ipa user-add <username> --first=<first name> --last=<surname> "
"--email=<email address> --phone=<telephoneNumber> --street=<street> \\      "
"--city=<city> --state=<state> --postalcode=<postal code> --password"

msgid "Force set the user's password using kinit."
msgstr "kinitを使用してユーザーのパスワードを強制的に設定します。"

msgid " kinit <username>"
msgstr " kinit <username>"

msgid "Enter the following to restore normal IPA operation:"
msgstr "以下を入力すると、IPAの正常な動作に戻ります。"

msgid ""
"kdestroy -A\n"
"kinit admin"
msgstr ""
"kdestroy -A\n"
"kinit admin"

msgid "SSSD and D-Bus"
msgstr "SSSDとD-Bus"

msgid ""
"The federation provider obtains the data from SSSD using D-BUS. It "
"authenticates the data using PAM."
msgstr "フェデレーション・プロバイダーはD-BUSを用いてSSSDからデータを取得し、PAMを用いてデータを認証します。"

msgid "Install the sssd-dbus RPM."
msgstr "sssd-dbusのRPMをインストールします。"

msgid "$ sudo yum install sssd-dbus"
msgstr "$ sudo yum install sssd-dbus"

msgid "Run the provisioning script available from the Keycloak distribution:"
msgstr "Keycloakの配布ファイルから入手可能なプロビジョニング・スクリプトを実行します。"

msgid "  $ bin/federation-sssd-setup.sh"
msgstr "  $ bin/federation-sssd-setup.sh"

msgid ""
"This provisioning script makes the following changes to "
"`/etc/sssd/sssd.conf`:"
msgstr "このプロビジョニング・スクリプトは `/etc/sssd/sssd.conf` に以下の変更を加えます。"

msgid ""
"  [domain/your-hostname.local]\n"
"  ...\n"
"  ldap_user_extra_attrs = mail:mail, sn:sn, givenname:givenname, telephoneNumber:telephoneNumber\n"
"  ...\n"
"  [sssd]\n"
"  services = nss, sudo, pam, ssh, ifp\n"
"  ...\n"
"  [ifp]\n"
"  allowed_uids = root, yourOSUsername\n"
"  user_attributes = +mail, +telephoneNumber, +givenname, +sn"
msgstr ""
"  [domain/your-hostname.local]\n"
"  ...\n"
"  ldap_user_extra_attrs = mail:mail, sn:sn, givenname:givenname, telephoneNumber:telephoneNumber\n"
"  ...\n"
"  [sssd]\n"
"  services = nss, sudo, pam, ssh, ifp\n"
"  ...\n"
"  [ifp]\n"
"  allowed_uids = root, yourOSUsername\n"
"  user_attributes = +mail, +telephoneNumber, +givenname, +sn"

msgid "Run `dbus-send` to ensure the setup is successful."
msgstr "セットアップが成功したことを確認するために、 `dbus-send` を実行します。"

msgid ""
"sudo dbus-send --print-reply --system --dest=org.freedesktop.sssd.infopipe "
"/org/freedesktop/sssd/infopipe org.freedesktop.sssd.infopipe.GetUserGroups "
"string:john"
msgstr ""
"sudo dbus-send --print-reply --system --dest=org.freedesktop.sssd.infopipe "
"/org/freedesktop/sssd/infopipe org.freedesktop.sssd.infopipe.GetUserGroups "
"string:john"

msgid ""
"If the setup is successful, you see the user's group. If this command "
"returns a timeout or an error, the federation provider running on "
"{project_name} cannot retrieve any data. This error usually happens because "
"the server is not enrolled in the FreeIPA IdM server, or does not have "
"permission to access the SSSD service."
msgstr ""
"設定が成功すると、そのユーザーのグループが表示されます。このコマンドがタイムアウトまたはエラーを返した場合、{project_name}で動作しているフェデレーション・プロバイダーはデータを取得することができません。このエラーは通常、サーバーが"
" FreeIPA IdMサーバーに登録されていないか、SSSDサービスにアクセスするパーミッションを持っていないために発生します。"

msgid ""
"If you do not have permission to access the SSSD service, ensure that the "
"user running the {project_name} server is in the `/etc/sssd/sssd.conf` file "
"in the following section:"
msgstr ""
"SSSDサービスにアクセスするパーミッションがない場合、{project_name} サーバーを実行しているユーザーが "
"`/etc/sssd/sssd.conf` ファイルに以下のように記述されていることを確認します．"

msgid ""
"[ifp]\n"
"allowed_uids = root, your_username"
msgstr ""
"[ifp]\n"
"allowed_uids = root, your_username"

msgid "Enabling the SSSD federation provider"
msgstr "SSSDフェデレーション・プロバイダーの有効化"

msgid ""
"{project_name} uses DBus-Java to communicate at a low level with D-Bus. "
"D-Bus depends on the http://www.matthew.ath.cx/projects/java/[Unix Sockets "
"Library]."
msgstr ""
"{project_name}はDBus-Javaを使ってD-Busと低レベルで通信します。D-Bus は "
"http://www.matthew.ath.cx/projects/java/[Unix Sockets Library] に依存しています。"

msgid ""
"You can find an RPM for this library in https://github.com/keycloak/libunix-"
"dbus-java/releases[the keycloak repository]. Before installing this RPM, "
"check the RPM signature using this command:"
msgstr ""
"このライブラリーのRPMは、 https://github.com/keycloak/libunix-dbus-"
"java/releases[Keycloakのリポジトリー]で見つけることができます。このRPMをインストールする前に、このコマンドでRPMの署名を確認してください。"

msgid ""
"  $ rpm -K libunix-dbus-java-0.8.0-1.fc24.x86_64.rpm\n"
"  libunix-dbus-java-0.8.0-1.fc24.x86_64.rpm:\n"
"    Header V4 RSA/SHA256 Signature, key ID 84dc9914: OK\n"
"    Header SHA1 digest: OK (d17bb7ebaa7a5304c1856ee4357c8ba4ec9c0b89)\n"
"    V4 RSA/SHA256 Signature, key ID 84dc9914: OK\n"
"    MD5 digest: OK (770c2e68d052cb4a4473e1e9fd8818cf)"
msgstr ""
"  $ rpm -K libunix-dbus-java-0.8.0-1.fc24.x86_64.rpm\n"
"  libunix-dbus-java-0.8.0-1.fc24.x86_64.rpm:\n"
"    Header V4 RSA/SHA256 Signature, key ID 84dc9914: OK\n"
"    Header SHA1 digest: OK (d17bb7ebaa7a5304c1856ee4357c8ba4ec9c0b89)\n"
"    V4 RSA/SHA256 Signature, key ID 84dc9914: OK\n"
"    MD5 digest: OK (770c2e68d052cb4a4473e1e9fd8818cf)"

msgid "Install the RPM using this command:"
msgstr "このコマンドでRPMをインストールします。"

msgid "$ sudo yum install libunix-dbus-java-0.8.0-1.fc24.x86_64.rpm"
msgstr "$ sudo yum install libunix-dbus-java-0.8.0-1.fc24.x86_64.rpm"

msgid ""
"{project_name} uses JNA to authenticate with PAM. Ensure you have the JAN "
"package installed."
msgstr "{project_name}は、JNAを使用してPAMで認証しています。JANパッケージがインストールされていることを確認してください。"

msgid "$ sudo yum install jna\n"
msgstr "$ sudo yum install jna\n"

msgid "Use the `sssctl user-checks` command to validate your setup:"
msgstr "設定を確認するには、 `ssctl user-checks` コマンドを使用します。"

msgid "  $ sudo sssctl user-checks admin -s keycloak"
msgstr "  $ sudo sssctl user-checks admin -s keycloak"

msgid "Configuring a federated SSSD store"
msgstr "フェデレーションされたSSSDストアの設定"

msgid "After the installation, configure a federated SSSD store."
msgstr "インストール後、フェデレーションされたSSSDストアを設定します。"

msgid ""
"From the *Add Provider* list select _sssd_. {project_name} brings you to the"
" sssd configuration page."
msgstr "*Add Provider* の一覧から _sssd_ を選択します。{project_name}で、sssdの設定ページに移動します。"

msgid ""
"You can now authenticate against {project_name} using FreeIPA/IdM "
"credentials."
msgstr "これで、FreeIPA/IdMのクレデンシャルを使って {project_name}に対する認証ができるようになりました。"

msgid "Custom providers"
msgstr "カスタム・プロバイダー"

msgid ""
"{project_name} does have a Service Provider Interface (SPI) for User Storage"
" Federation to develop custom providers. You can find documentation on "
"developing customer providers in the "
"link:{developerguide_link}[{developerguide_name}]."
msgstr ""
"{project_name}には、ユーザー・ストレージ・フェデレーション用のカスタム・プロバイダーを開発するためのService Provider "
"Interface (SPI)があります。カスタム・プロバイダーの開発に関するドキュメントは、 "
"link:{developerguide_link}[{developerguide_name}] にあります。"

msgid "Managing users"
msgstr "ユーザーの管理"

msgid ""
"From the Admin Console, you have a wide range of actions you can perform to "
"manage users."
msgstr "管理コンソールから、ユーザーを管理するために実行できるアクションは多岐にわたります。"

msgid "Searching for a user"
msgstr "ユーザーの検索"

msgid ""
"Search for a user to view detailed information about the user, such as the "
"user's groups and roles."
msgstr "ユーザーを検索すると、そのユーザーのグループやロールなどの詳細情報が表示されます。"

msgid "Prerequisite"
msgstr "前提条件"

msgid "You are in the realm where the user exists."
msgstr "ユーザーが存在するレルムにいます。"

msgid "Click *Users* in the main menu. This *Users* page is displayed."
msgstr "メインメニューの *Users* をクリックします。この *Users* ページが表示されます。"

msgid ""
"Type the full name, last name, first name, or email address of the user you "
"want to search for in the search box. The search returns all users who match"
" your criteria."
msgstr ""
"検索ボックスに、検索したいユーザーの氏名、姓、名、Eメールアドレスのいずれかを入力します。検索では、条件に一致するすべてのユーザーが返されます。"

msgid ""
"Alternatively, you can click *View all users* to list every user in the "
"system."
msgstr "また、 *View all users* をクリックすると、システム内の全ユーザーを一覧表示することもできます。"

msgid ""
"This action searches only the local {project_name} database and not the "
"federated database, such as LDAP. The backends for federated databases do "
"not have a pagination mechanism that enables searching for users."
msgstr ""
"このアクションは、ローカル{project_name}のデータベースのみを検索し、LDAPなどの連携データベースは検索しません。連携データベースのバックエンドには、ユーザーを検索するためのページネーション機構がありません。"

msgid ""
"To search users from a federated backend, the user list must be synced into "
"the {project_name} database. Adjust the search criteria to sync the backend "
"users to the {project_name} database."
msgstr ""
"連携バックエンドからユーザーを検索するには、ユーザーリストを{project_name}のデータベースに同期させる必要があります。検索条件を調整して、バックエンドのユーザーを{project_name}のデータベースに同期させます。"

msgid "Alternatively, click the *User Federation* in the left menu."
msgstr "または、左メニューの *User Federation* をクリックします。"

msgid ""
"To apply changes to a selected user, click *Sync changed users* on the page "
"with your federation provider."
msgstr ""
"選択したユーザーに変更を適用するには、フェデレーション・プロバイダーと\n"
"のページで *Sync changed users* をクリックします。"

msgid ""
"To apply changes to all users in the database, click *Sync all users* on the"
" page with your federation provider."
msgstr ""
"データベース内のすべてのユーザーに変更を適用するには、フェデレーション・プロバイダーのページで *Sync all users* をクリックします。"

msgid ""
"For more information on user federation, see <<_user-storage-federation,User"
" Federation>>."
msgstr ""
"ユーザー・フェデレーションについては、<<_user-storage-federation,ユーザー・フェデレーション>を参照してください。"

msgid "Creating a user"
msgstr "ユーザーの作成"

msgid ""
"You create users in the realm where you intend to have applications needed "
"by those users. Avoid creating users in the master realm, which is only "
"intended for creating other realms."
msgstr ""
"ユーザーは、そのユーザーが必要とするアプリケーションを持つ予定のレルムに作成します。他のレルムを作成するためだけのmasterレルムにユーザーを作成することは避けてください。"

msgid "You are in a realm other than the master realm."
msgstr "masterレルム以外のレルムを選択します。"

msgid "Click *Users* in the menu."
msgstr "メニューの *Users* をクリックします。"

msgid "Click *Add User*."
msgstr "*Add User* をクリックします。"

msgid "Enter the details for the new user."
msgstr "新しいユーザーの詳細を入力します。"

msgid "*Username* is the only required field."
msgstr "*Username* は唯一の必須項目です。"

msgid ""
"Click *Save*. After saving the details, the *Management* page for the new "
"user is displayed."
msgstr "*Save* をクリックします。詳細を保存すると、新しいユーザーの *Management* ページが表示されます。"

msgid "Deleting a user"
msgstr "ユーザーの削除"

msgid ""
"You can delete a user, who no longer needs access to applications. If a user"
" is deleted, the user profile and data is also deleted."
msgstr ""
"アプリケーションへのアクセスが不要になったユーザーを削除することができます。ユーザーを削除すると、ユーザー・プロフィールやデータも削除されます。"

msgid "Click *Users* in the menu. The *Users* page is displayed."
msgstr "メニューの *Users* をクリックします。 *Users* ページが表示されます。"

msgid "Click *View all users* to find a user to delete."
msgstr "*View all users* をクリックして、削除するユーザーを探します。"

msgid "Alternatively, you can use the search bar to find a user."
msgstr "または、検索バーを使ってユーザーを探すこともできます。"

msgid ""
"Click *Delete* next to the user you want to remove and confirm deletion."
msgstr "削除したいユーザーの横にある *Delete* をクリックし、削除を確認します。"

msgid "Enabling account deletion by users"
msgstr "ユーザーによるアカウント削除の有効化"

msgid ""
"End users and applications can delete their accounts in the Account Console "
"if you enable this capability in the Admin Console. Once you enable this "
"capability, you can give that capability to specific users."
msgstr ""
"管理コンソールでこの機能を有効にすると、エンドユーザーやアプリケーションはアカウント・コンソールでアカウントを削除することができます。この機能を有効にすると、その機能を特定のユーザーに与えることができます。"

msgid "Enabling the Delete Account Capability"
msgstr "アカウント削除機能の有効化"

msgid "You enable this capability on the *Required Actions* tab."
msgstr "この機能を有効にするには、 *Required Actions* タブで設定します。"

msgid "Click the *Required Actions* tab."
msgstr "*Required Actions* タブをクリックします。"

msgid "Select *Enabled* on the *Delete Account* row."
msgstr "*Delete Account*の行で *Enabled* を選択します。"

msgid "Delete account on required actions tab"
msgstr "必須アクションタブでのアカウント削除"

msgid "image:images/enable-delete-account-action.png[]"
msgstr "image:images/enable-delete-account-action.png[]"

msgid "Giving a user the *delete-account* role"
msgstr "ユーザーに *delete-account* ロールを与える"

msgid "You can give specific users a role that allows account deletion."
msgstr "特定のユーザーにアカウントの削除を許可するロールを与えることができます。"

msgid "Select a user."
msgstr "ユーザーを選択します。"

msgid "Click the *Role Mappings* tab."
msgstr "*Role Mappings* タブをクリックします。"

msgid "From the *Client Roles* list, select *account*."
msgstr "*Client Roles* のリストから *account* を選択します。"

msgid "Under *Available Roles*, select *delete-account*."
msgstr "*Available Roles* の下で、 *delete-account* を選択します。"

msgid "Click *Add selected*."
msgstr "*Add selected* をクリックします。"

msgid "Delete-account role"
msgstr "Delete-accountロール"

msgid "image:images/delete-account-client-role.png[delete-account role]"
msgstr "image:images/delete-account-client-role.png[delete-account role]"

msgid "Deleting your account"
msgstr "アカウントの削除"

msgid ""
"Once you have the *delete-account* role, you can delete your own account."
msgstr "*delete-account* ロールを取得すると、自分のアカウントを削除できるようになります。"

msgid "Log into the Account Console."
msgstr "アカウントコンソールにログインします。"

msgid "At the bottom of the *Personal Info* page, click *Delete Account*."
msgstr "Delete-accountページの下部にある *Delete Account* をクリックします。"

msgid "Delete account page"
msgstr "アカウント削除ページ"

msgid "image:images/delete-account-page.png[]"
msgstr "image:images/delete-account-page.png[]"

msgid "Enter your credentials and confirm the deletion."
msgstr "クレデンシャルを入力し、削除を確認します。"

msgid "Delete confirmation"
msgstr "削除の確認"

msgid "image:images/delete-account-confirm.png[]"
msgstr "image:images/delete-account-confirm.png[]"

msgid ""
"This action is irreversible. All your data in {project_name} will be "
"removed."
msgstr "このアクションは不可逆的です。{project_name}にあるデータはすべて削除されます。"

msgid "Configuring user attributes"
msgstr "ユーザー属性の設定"

msgid ""
"User attributes provide a customized experience for each user. You can "
"create a personalized identity for each user in the console by configuring "
"user attributes."
msgstr ""
"ユーザー属性は、各ユーザーにカスタマイズされた体験を提供します。ユーザー属性を設定することで、コンソールで各ユーザーにパーソナライズされたアイデンティティーを作成することができます。"

msgid "Users"
msgstr "Users"

msgid "image:{project_images}/user-attributes.png[]"
msgstr "image:{project_images}/user-attributes.png[]"

msgid "Select a user to manage."
msgstr "管理するユーザーを選択します。"

msgid "Click the *Attributes* tab."
msgstr "*Attributes* タブをクリックします。"

msgid "Enter the attribute name in the *Key* field."
msgstr "*Key* フィールドに属性名を入力します。"

msgid "Enter the attribute value in the *Value* field."
msgstr "*Value* フィールドに属性値を入力します。"

msgid "Click *Add*."
msgstr "*Add* をクリックします。"

msgid ""
"Some read-only attributes are not supposed to be updated by the "
"administrators. This includes attributes that are read-only by design like "
"for example `LDAP_ID`, which is filled automatically by the LDAP provider. "
"Some other attributes should be read-only for typical user administrators "
"due to security reasons. See the details in the "
"xref:_read_only_user_attributes[Mitigating security threats] chapter."
msgstr ""
"読み取り専用の属性の中には、管理者が更新してはいけないものがあります。これには、たとえば、 `LDAP_ID` "
"のように、LDAPプロバイダーが自動的に入力するような、設計上読み取り専用になっている属性が含まれます。他のいくつかの属性は、セキュリティー上の理由から、典型的なユーザー管理者のために読み取り専用にする必要があります。詳細は"
" xref:_read_only_user_attributes[セキュリティー上の脅威の軽減] の章を参照してください。"

msgid "User credentials"
msgstr "ユーザー・クレデンシャル"

msgid "You can manage credentials of a user in the *Credentials* tab."
msgstr "ユーザーのクレデンシャルは、 *Credentials* タブで管理できます。"

msgid "Credential management"
msgstr "クレデンシャル管理"

msgid "image:{project_images}/user-credentials.png[]"
msgstr "image:{project_images}/user-credentials.png[]"

msgid "This tab includes the following fields:"
msgstr "このタブには以下のフィールドがあります。"

msgid "Position"
msgstr "Position"

msgid ""
"The arrow buttons in the *Position* column allow you to shift the priority "
"of the credential for the user. The topmost credential has the highest "
"priority. The priority determines which credential is displayed first after "
"a user logs in."
msgstr ""
"*Position* "
"列の矢印ボタンで、ユーザーに対するクレデンシャルの優先順位を変更することができます。一番上のクレデンシャルが最も高い優先度になります。この優先順位によって、ユーザーがログインした後にどのクレデンシャルが最初に表示されるかが決まります。"

msgid "Type"
msgstr "Type"

msgid ""
"This column displays the type of credential, for example *password* or "
"*OTP*."
msgstr "この欄には、\"password\"や\"OTP\"など、クレデンシャルの種類が表示されます。"

msgid "User Label"
msgstr "User Label"

msgid ""
"This is an assignable label to recognize the credential when presented as a "
"selection option during login. It can be set to any value to describe the "
"credential."
msgstr ""
"これは、ログイン時の選択オプションとして提示されたときにクレデンシャルを認識するための割り当てることができるラベルです。クレデンシャルを説明するために任意の値を設定することができます。"

msgid "Data"
msgstr "Data"

msgid ""
"This is the non-confidential technical information about the credential. It "
"is hidden, by default. You can click *Show data...* to display the data for "
"a credential."
msgstr ""
"これは、クレデンシャルに関する非機密の技術情報です。デフォルトでは非表示になっています。 *Show data...* "
"をクリックすると、クレデンシャルのデータを表示することができます。"

msgid "Actions"
msgstr "Actions"

msgid ""
"This column has two actions. Click *Save* to record the value or the user "
"field. Click *Delete* to remove the credential."
msgstr ""
"この列には2つのアクションがあります。 *Save* をクリックすると、ユーザー・フィールドの値が記録されます。クレデンシャルを削除するには、 "
"*Delete* をクリックします。"

msgid ""
"You cannot configure other types of credentials for a specific user in the "
"admin console; that task is the user's responsibility."
msgstr "特定のユーザーに対して、他のタイプのクレデンシャルを管理コンソールで設定することはできません。"

msgid ""
"You can delete the credentials of a user in the event a user loses an OTP "
"device or if credentials have been compromised. You can only delete "
"credentials of a user in the *Credentials* tab."
msgstr ""
"ユーザーがOTPデバイスを紛失した場合や、クレデンシャルが漏洩した場合に、ユーザーのクレデンシャルを削除することができます。ユーザーのクレデンシャルの削除は、"
" *Credentials* タブでのみ可能です。"

msgid "Setting a password for a user"
msgstr "ユーザーのパスワードの設定"

msgid ""
"If a user does not have a password, or if the password has been deleted, the"
" *Set Password* section is displayed."
msgstr "ユーザーがパスワードを持っていない場合、またはパスワードを削除した場合は、 *Set Password* のセクションが表示されます。"

msgid ""
"If a user already has a password, it can be reset in the *Reset Password* "
"section."
msgstr "すでにパスワードが設定されている場合は、 *Reset Password* の項目で再設定することができます。"

msgid "Click the *Credentials* tab."
msgstr "認証情報」タブをクリックします。"

msgid "Type a new password in the *Set Password* section."
msgstr "*Set Password* のセクションに新しいパスワードを入力します。"

msgid "Click *Set Password*."
msgstr "*Set Password* をクリックします。"

msgid ""
"If *Temporary* is *ON*, the user must change the password at the first "
"login. To allow users to keep the password supplied, set *Temporary* to "
"*OFF.*  The user must click *Set Password* to change the password."
msgstr ""
"*Temporary* が *ON* "
"の場合、ユーザーは初回ログイン時にパスワードを変更する必要があります。ユーザーがパスワードを保持できるようにするには、 *Temporary* を "
"*OFF* に設定し、ユーザーが *Set Password* をクリックしてパスワードを変更する必要があります。"

msgid ""
"Alternatively, you can send an email to the user that requests the user "
"reset the password."
msgstr "または、ユーザーにパスワードの再設定を依頼する電子メールを送信することもできます。"

msgid "Navigate to the *Reset Actions* list under *Credential Reset*."
msgstr "*Credential Reset* の下にある *Reset Actions* リストに移動します。"

msgid "Select *Update Password* from the list."
msgstr "リストから *Update Password* を選択します。"

msgid ""
"Click *Send Email*. The sent email contains a link that directs the user to "
"the *Update Password* window."
msgstr ""
"*Send Email* をクリックします。送信された電子メールには、ユーザーを *Update Password* "
"ウィンドウに誘導するリンクが含まれています。"

msgid ""
"Optionally, you can set the validity of the email link. This is set to the "
"default preset in the *Tokens* tab in *Realm Settings*."
msgstr ""
"オプションで、メールリンクの有効期限を設定することができます。これは、 *Realm Settings* の *Tokens* "
"タブにあるデフォルトのプリセットに設定されています。"

msgid "Creating an OTP"
msgstr "OTPの作成"

msgid ""
"If OTP is conditional in your realm, the user must navigate to "
"{project_name} Account Console to reconfigure a new OTP generator. If OTP is"
" required, then the user must reconfigure a new OTP generator when logging "
"in."
msgstr ""
"OTPが条件付きである場合、ユーザーは{project_name}に移動する必要があります。アカウントコンソールで新しいOTPジェネレーターを再設定してください。OTPが必要な場合、ユーザーはログイン時に新しいOTPジェネレーターを再設定する必要があります。"

msgid ""
"Alternatively, you can send an email to the user that requests the user "
"reset the OTP generator. The following procedure also applies if the user "
"already has an OTP credential."
msgstr ""
"または、ユーザーにOTPジェネレーターのリセットを要求するメールを送信することもできます。次の手順は、ユーザーがすでに OTP "
"クレデンシャルを持っている場合にも適用されます。"

msgid "You are logged in to the appropriate realm."
msgstr "適切なレルムにログインしている。"

msgid "Click *Users* in the main menu. The *Users* page is displayed."
msgstr "メインメニューの*Users*をクリックします。ユーザー」ページが表示されます。"

msgid "Navigate to the *Reset Actions* list."
msgstr "Reset Actions*のリストに移動します。"

msgid "Click *Configure OTP*."
msgstr "OTPを設定する］をクリックします。"

msgid ""
"Click *Send Email*. The sent email contains a link that directs the user to "
"the *OTP setup page*."
msgstr "メール送信*をクリックします。送信されたメールには、ユーザーを*OTP設定ページ*に誘導するリンクが含まれています。"

msgid "Required actions"
msgstr "必須アクション"

msgid ""
"You can set the actions that a user must perform at the first login. These "
"actions are required after the user provides credentials. After the first "
"login, these actions are no longer required. You add required actions on the"
" *Details* tab of that user."
msgstr ""
"初回ログイン時にユーザーが実行しなければならないアクションを設定することができます。これらのアクションは、ユーザーがクレデンシャルを提供した後に必要となります。最初のログイン後、これらのアクションは必要なくなります。必須アクションは、そのユーザーの"
" *Details* タブで追加します。"

msgid "The following are examples of required action types:"
msgstr "以下は、必須アクションの種類の例です。"

msgid "Update Password"
msgstr "Update Password"

msgid "The user must change their password."
msgstr "ユーザーはパスワードを変更する必要があります。"

msgid "Configure OTP"
msgstr "Configure OTP"

msgid ""
"The user must configure a one-time password generator on their mobile device"
" using either the Free OTP or Google Authenticator application."
msgstr ""
"ユーザーはFree "
"OTPまたはGoogleオーセンティケーター・アプリケーションを使用して、モバイルデバイスにワンタイム・パスワード・ジェネレーターを設定する必要があります。"

msgid "Verify Email"
msgstr "Verify Email"

msgid ""
"The user must verify their email account. An email will be sent to the user "
"with a validation link that they must click. Once this workflow is "
"successfully completed, the user will be allowed to log in."
msgstr ""
"ユーザーは、自分のEメールアカウントを確認する必要があります。検証用リンクが記載された電子メールがユーザーに送信されますので、クリックしてください。このワークフローが正常に完了すると、ユーザーはログインできるようになります。"

msgid "Update Profile"
msgstr "Update Profile"

msgid ""
"The user must update profile information, such as name, address, email, and "
"phone number."
msgstr "ユーザーは、名前、住所、電子メール、電話番号などのプロフィール情報を更新する必要があります。"

msgid "Setting required actions for one user"
msgstr "一人のユーザーに対する必須アクションの設定"

msgid "You can set the actions that are required for any user."
msgstr "どのユーザーに対しても必須アクションを設定できます。"

msgid "Select a user from the list."
msgstr "一覧からユーザーを選択します。"

msgid "Navigate to the *Required User Actions* list."
msgstr "*Required User Actions* の一覧に移動します。"

msgid "image:{project_images}/user-required-action.png[]"
msgstr "image:{project_images}/user-required-action.png[]"

msgid "Select all the actions you want to add to the account."
msgstr "アカウントに追加したいアクションをすべて選択します。"

msgid "Click the *X* next to the action name to remove it."
msgstr "アクション名の横にある *X* をクリックすると、削除されます。"

msgid "Click *Save* after you select which actions to add."
msgstr "追加するアクションを選択したら、 *Save* をクリックします。"

msgid "Setting required actions for all users"
msgstr "全ユーザーへの必須アクションの設定"

msgid ""
"You can specify what actions are required before the first login of all new "
"users. The requirements apply to a user created by the *Add User* button on "
"the *Users* page or the *Register* link on the login page."
msgstr ""
"すべての新規ユーザーの初回ログイン前に必要なアクションを指定することができます。この条件は、 *Users* ページの *Add User* "
"ボタン、またはログインページの *Register* リンクで作成されたユーザーに適用されます。"

msgid ""
"Click the checkbox in the *Default Action* column for one or more required "
"actions. When a new user logs in for the first time, the selected actions "
"must be executed."
msgstr ""
"1つ以上の必須アクションの *Default Action* "
"列のチェックボックスをクリックします。新規ユーザーの初回ログイン時には、選択したアクションを実行する必要があります。"

msgid "Enabling terms and conditions as a required action"
msgstr "必須アクションとしての利用規約の有効化"

msgid ""
"You can enable a required action that new users must accept the terms and "
"conditions before logging in to {project_name} for the first time."
msgstr ""
"新規ユーザーが{project_name}に初めてログインする前に、利用規約に同意しなければならないという必須アクションを有効にすることができます。"

msgid "Enable the *Terms and Conditions* action."
msgstr "*Terms and Conditions* のアクションを有効にします。"

msgid "Edit the `terms.ftl` file in the base login theme."
msgstr "ベースとなるログインテーマ内の `terms.ftl` ファイルを編集します。"

msgid ""
"For more information on extending and creating themes, see the "
"link:{developerguide_link}[{developerguide_name}]."
msgstr ""
"テーマの拡張と作成の詳細については、 link:{developerguide_link}[{developerguide_name}] "
"を参照してください。"

msgid "User impersonation"
msgstr "ユーザーの成り代わり"

msgid ""
"An administrator with the appropriate permissions can impersonate a user. "
"For example, if a user experiences a bug in an application, an administrator"
" can impersonate the user to investigate or duplicate the issue."
msgstr ""
"適切なパーミッションを持つ管理者は、ユーザーに成りすますことができます。たとえば、あるユーザーがアプリケーションのバグに遭遇した場合、管理者はそのユーザーに成りすまして問題を調査したり、再現したりすることができます。"

msgid ""
"Any user with the `impersonation` role in the realm can impersonate a user."
msgstr "レルム内で `impersonation` ロールを持つすべてのユーザーが、あるユーザーになりすますことができます。"

msgid "Image:{project_images}/user-details.png[]"
msgstr "Image:{project_images}/user-details.png[]"

msgid ""
"If the administrator and the user are in the same realm, then the "
"administrator will be logged out and automatically logged in as the user "
"being impersonated."
msgstr "管理者とユーザーが同じレルムにいる場合は、管理者がログアウトし、成りすましをされるユーザーとして自動的にログインします。"

msgid ""
"If the administrator and user are in different realms, the administrator "
"will remain logged in, and additionally will be logged in as the user in "
"that user's realm."
msgstr "管理者とユーザーが異なるレルムにいる場合、管理者はログインしたままで、さらにそのユーザーのレルムのユーザーとしてログインします。"

msgid ""
"In both instances, the *User Account Management* page of the impersonated "
"user is displayed."
msgstr "いずれの場合も、なりすましたユーザーの *User Account Management* ページが表示されます。"

msgid ""
"You can access the *Impersonate* button from the *Details* tab on the "
"*Users* page."
msgstr "*Impersonate* ボタンは、 *Users* ページの *Details* タブからアクセスできます。"

msgid ""
"For more information on assigning administration permissions, see the "
"<<_admin_permissions,Admin Console Access Control>> chapter."
msgstr "管理パーミッションの割り当てについては、<<_admin_permissions,管理コンソールのアクセス制御>>の章を参照してください。"

msgid "User registration"
msgstr "ユーザー登録"

msgid ""
"You can use {project_name} as a third-party authorization server to manage "
"application users, including users who self-register. If you enable self-"
"registration, the login page displays a registration link so that user can "
"create an account."
msgstr ""
"{project_name} "
"をサードパーティー認可サーバーとして使用して、自己登録したユーザーを含むアプリケーションのユーザーを管理することができます。自己登録を有効にすると、ログインページに登録リンクが表示され、ユーザーがアカウントを作成できるようになります。"

msgid "Registration link"
msgstr "登録リンク"

msgid "image:{project_images}/registration-link.png[]"
msgstr "image:{project_images}/registration-link.png[]"

msgid ""
"A user must add profile information to the registration form to complete "
"registration. The registration form can be customized by removing or adding "
"the fields that must be completed by a user."
msgstr ""
"ユーザーが登録を完了するには、登録フォームにプロファイルル情報を追加する必要があります。登録フォームは、ユーザーが入力しなければならないフィールドを削除または追加することでカスタマイズできます。"

msgid ""
"For more information on customizing user registration, see the "
"link:{developerguide_link}[{developerguide_name}]."
msgstr ""
"ユーザー登録のカスタマイズについては、 link:{developerguide_link}[{developerguide_name}] "
"を参照してください。"

msgid "Enabling user registration"
msgstr "ユーザー登録の有効化"

msgid "Enable users to self-register."
msgstr "ユーザーの自己登録を有効にします。"

msgid "Click *Realm Settings* in the main menu."
msgstr "メインメニューの *Realm Settings* をクリックします。"

msgid "Toggle *User Registration* to *ON*."
msgstr "*User Registration* を *ON* に切り替えます。"

msgid ""
"After you enable this setting, a *Register* link displays on the login page "
"of the Admin Console."
msgstr "この設定を有効にすると、管理コンソールのログインページに *Register* リンクが表示されます。"

msgid "Registering as a new user"
msgstr "新規ユーザーとして登録する"

msgid ""
"As a new user, you must complete a registration form to log in for the first"
" time. You add profile information and a password to register."
msgstr "新規ユーザーとして初めてログインするには、登録フォームに記入する必要があります。プロフィール情報とパスワードを入力して登録します。"

msgid "Registration form"
msgstr "登録フォーム"

msgid "image:{project_images}/registration-form.png[]"
msgstr "image:{project_images}/registration-form.png[]"

msgid "User registration is enabled."
msgstr "ユーザー登録が可能です。"

msgid ""
"Click the *Register* link on the login page. The registration page is "
"displayed."
msgstr "ログインページの *Register* のリンクをクリックすると、登録ページが表示されます。"

msgid "Enter the user profile information."
msgstr "ユーザー・プロフィール情報を入力します。"

msgid "Enter the new password."
msgstr "新しいパスワードを入力します。"

msgid "Enabling reCAPTCHA"
msgstr "reCAPTCHAの有効化"

msgid ""
"To safeguard registration against bots, {project_name} has integration with "
"Google reCAPTCHA."
msgstr "ボットからの登録を保護するために、{project_name}はGoogle reCAPTCHA と統合しています。"

msgid ""
"Once reCAPTCHA is enabled, you can edit `register.ftl` in your login theme "
"to configure the placement and styling of the reCAPTCHA button on the "
"registration page."
msgstr ""
"reCAPTCHAを有効にすると、ログインテーマ内の `register.ftl` "
"を編集して、登録ページでのreCAPTCHAボタンの配置とスタイルを設定することができます。"

msgid "Enter the following URL in a browser:"
msgstr "ブラウザーで次のURLを入力します。"

msgid "https://developers.google.com/recaptcha/"
msgstr "https://developers.google.com/recaptcha/"

msgid ""
"Create an API key to get your reCAPTCHA site key and secret. Note the "
"reCAPTCHA site key and secret for future use in this procedure."
msgstr ""
"APIキーを作成し、reCAPTCHAサイトのキーとシークレットを取得します。この手順で使用するため、reCAPTCHAサイトのキーとシークレットをメモしておいてください。"

msgid "The localhost works by default. You do not have to specify a domain."
msgstr "localhostはデフォルトで動作します。ドメインは指定する必要はありません。"

msgid "Navigate to the {project_name} admin console."
msgstr "{project_name}の管理コンソールに移動します。"

msgid "Select *Registration* from the drop down menu."
msgstr "ドロップダウンメニューから *Registration* を選択します。"

msgid "Set the *reCAPTCHA* requirement to *Required*. This enables reCAPTCHA."
msgstr "*reCAPTCHA* の要件を *Required* に設定します。これにより、reCAPTCHAが有効になります。"

msgid "Click *Actions* to the right of the reCAPTCHA flow entry."
msgstr "reCAPTCHAフローの項目の右側にある *Actions* をクリックします。"

msgid "Click the *Config* link."
msgstr "*Config* のリンクをクリックします。"

msgid "Recaptcha config page"
msgstr "Recaptchaの設定ページ"

msgid "image:{project_images}/recaptcha-config.png[]"
msgstr "image:{project_images}/recaptcha-config.png[]"

msgid ""
"Enter the *Recaptcha Site Key* generated from the Google reCAPTCHA website."
msgstr "Google reCAPTCHAのウェブサイトから生成された *Recaptcha Site Key* を入力してください。"

msgid ""
"Enter the *Recaptcha Secret* generated from the Google reCAPTCHA website."
msgstr "Google reCAPTCHAのウェブサイトから生成された *Recaptcha Secret* を入力してください。"

msgid "Authorize Google to use the registration page as an iframe."
msgstr "Googleが登録ページをiframeとして使用することを認可します。"

msgid ""
"In {project_name}, websites cannot include a login page dialog in an iframe."
" This restriction is to prevent clickjacking attacks. You need to change the"
" default HTTP response headers that is set in {project_name}."
msgstr ""
"{project_name}では、Webサイトがiframe内にログインページのダイアログを含めることができません。この制限は、クリックジャッキング攻撃を防止するためのものです。{project_name}で設定されているデフォルトのHTTPレスポンス・ヘッダーを変更する必要があります。"

msgid "Click the *Security Defenses* tab."
msgstr "*Security Defenses* タブをクリックします。"

msgid ""
"Enter `https://www.google.com` in the field for the *X-Frame-Options* "
"header."
msgstr "*X-Frame-Options* ヘッダーのフィールドに `https://www.google.com` と入力します。"

msgid ""
"Enter `https://www.google.com` in the field for the *Content-Security-"
"Policy* header."
msgstr ""
"*Content-Security-Policy* ヘッダーのフィールドに `https://www.google.com` と入力します。"

msgid "Personal data collected by {project_name}"
msgstr "{project_name}によって収集された個人データ"

msgid "By default, {project_name} collects the following data:"
msgstr "デフォルトでは、{project_name}は次のデータを収集します。"

msgid ""
"Basic user profile data, such as the user email, first name, and last name."
msgstr "ユーザーの電子メール、姓、名前などの基本的なユーザー・プロフィール・データ"

msgid ""
"Basic user profile data used for social accounts and references to the "
"social account when using a social login."
msgstr ""
"ソーシャル・ログインに使用するときにソーシャル・アカウントとソーシャル・アカウントへの参照に使用される基本的なユーザー・プロフィール・データ"

msgid ""
"Device information collected for audit and security purposes, such as the IP"
" address, operating system name, and the browser name."
msgstr "IPアドレス、オペレーティング・システム名、ブラウザー名など、監査とセキュリティーの目的で収集されたデバイス情報"

msgid ""
"The information collected in {project_name} is highly customizable. The "
"following guidelines apply when making customizations:"
msgstr "{project_name}で収集された情報は高度にカスタマイズできます。カスタマイズを行う場合は、次のガイドラインが適用されます。"

msgid ""
"Registration and account forms can contain custom fields, such as birthday, "
"gender, and nationality.  An administrator can configure {project_name} to "
"retrieve data from a social provider or a user storage provider such as "
"LDAP."
msgstr ""
"登録およびアカウント・フォームには、誕生日、性別、国籍などのカスタム・フィールドを含めることができます。管理者は、{project_name}を設定して、ソーシャル・プロバイダーまたはLDAPなどのユーザー・ストレージ・プロバイダーからそのデータを取得できます。"

msgid ""
"{project_name} collects user credentials, such as password, OTP codes, and "
"WebAuthn public keys. This information is encrypted and saved in a database,"
" so it is not visible to {project_name} administrators. Each type of "
"credential can include non-confidential metadata that is visible to "
"administrators such as the algorithm that is used to hash the password and "
"the number of hash iterations used to hash the password."
msgstr ""
"{project_name}は、パスワード、OTPコード、WebAuthn公開鍵などのユーザー・クレデンシャルを収集します。この情報は暗号化されてデータベースに保存されるため、{project_name}管理者には表示されません。クレデンシャルの各タイプには、パスワードのハッシュに使用されるアルゴリズムやパスワードのハッシュに使用されるハッシュ反復回数など、管理者に表示される非機密メタデータを含めることができます。"

msgid ""
"With authorization services and UMA support enabled, {project_name} can hold"
" information about some objects for which a particular user is the owner."
msgstr ""
"認可サービスとUMAサポートを有効にすると、{project_name}は、特定のユーザーがオーナーであるいくつかのオブジェクトに関する情報を保持することができます。"

msgid "User Profile"
msgstr "ユーザー・プロフィール"

msgid ""
"In {project_name} a user is associated with a set of attributes. These "
"attributes are used to better describe and identify users within "
"{project_name} as well as to pass over additional information about them to "
"applications."
msgstr ""
"{project_name}では、ユーザーは一連の属性と関連付けられています。これらの属性は、{project_name}内のユーザーをより適切に説明、識別するため、また、アプリケーションにユーザーに関する追加情報を渡すために使用されます。"

msgid ""
"A user profile defines a well-defined schema for representing user "
"attributes and how they are managed within a realm. By providing a "
"consistent view over user information, it allows administrators to control "
"the different aspects on how attributes are managed as well as to make a lot"
" easier to extend {project_name} to support additional attributes."
msgstr ""
"ユーザー・プロフィールは、ユーザー属性を表現するための明確なスキーマを定義し、それらがレルム内でどのように管理されるかを定義するものです。ユーザー情報を一貫して表示することで、管理者は属性の管理方法を様々な角度から制御することができます。また、{project_name}を拡張して追加の属性をサポートすることも容易になります。"

msgid "Among other capabilities, user profile enables administrators to:"
msgstr "他の機能の中でも、ユーザー・プロフィールを使用すると、管理者は次のことができます。"

msgid "Define a schema for user attributes"
msgstr "ユーザー属性のスキーマを定義します"

msgid ""
"Define whether an attribute is required based on contextual information "
"(e.g.: if required only for users, or admins, or both, or depending on the "
"scope being requested.)"
msgstr ""
"コンテキスト情報に基づいて、属性が必要かどうかを定義します（例：ユーザーだけ必要か、管理者だけか、両方か、要求されるスコープに依存するか。）"

msgid ""
"Define specific permissions for viewing and editing user attributes, making "
"possible to adhere to strong privacy requirements where some attributes can "
"not be seen or be changed by third-parties (including administrators)"
msgstr ""
"第三者（管理者を含む）がユーザー属性を参照・変更できないような強いプライバシー要件に対応することができるように、ユーザー属性の参照・編集用のパーミッションを定義します"

msgid ""
"Dynamically enforce user profile compliance so that user information is "
"always updated and in compliance with the metadata and rules associated with"
" attributes"
msgstr "ユーザー情報が常に更新され、属性に関連するメタデータやルールに準拠するように、ユーザー・プロフィールのコンプライアンスを動的に強化します"

msgid ""
"Define validation rules on a per-attribute basis by leveraging the built-in "
"validators or writing custom ones"
msgstr "組み込みのバリデーターを活用したり、カスタムのバリデーターを作成することで、属性ごとに検証ルールを定義します"

msgid ""
"Dynamically render forms that users interact with like registration, update "
"profile, brokering, and personal information in the account console, "
"according to the attribute definitions and without any need to manually "
"change themes."
msgstr ""
"アカウント・コンソールの登録、プロフィールの更新、ブローカリング、個人情報など、ユーザーが操作するフォームを、属性定義に従って動的にレンダリングし、テーマを手動で変更する必要がありません。"

msgid ""
"The User Profile capabilities are backed by the User Profile SPI. By "
"default, these capabilities are disabled and realms are configured to use a "
"default configuration that keeps backward compatibility with the legacy "
"behavior."
msgstr ""
"ユーザー・プロフィールの機能は、ユーザー・プロフィールSPIによってバックアップされています。デフォルトでは、これらの機能は無効化されており、レルムはレガシー動作との後方互換性を保つためにデフォルトの構成を使用するように設定されています。"

msgid ""
"The legacy behavior is about keeping the default constraints used by "
"{project_name} when managing users root attributes such as username, email, "
"first and last name, without any restriction on how custom attributes are "
"managed. Regarding user flows such as registration, profile update, "
"brokering, and managing accounts through the account console, users are "
"restricted to use the attributes aforementioned with the possibility to "
"change theme templates to support additional attributes."
msgstr ""
"レガシーな動作は、ユーザー名、電子メール、姓名などのユーザーのルート属性を管理する際に{project_name}で使用されるデフォルトの制約を維持することであり、カスタム属性を管理する方法については何の制約もありません。登録、プロフィール更新、ブローカリング、アカウント・コンソールによるアカウント管理などのユーザーフローについては、ユーザーは前述の属性を使用するように制限され、テーマ・テンプレートを変更して追加の属性をサポートすることが可能です。"

msgid ""
"If you are already using {project_name}, the legacy behavior is what you "
"have been using so far."
msgstr "すでに{project_name}を使用している場合は、これまで使用していたレガシーな動作となります。"

msgid ""
"Differently than the legacy behavior, the declarative provider gives you a "
"lot more flexibility to define the user profile configuration to a realm "
"through the administration console and a well-defined JSON schema."
msgstr ""
"レガシーな動作とは異なり、Declarativeプロバイダーでは、管理コンソールと明確に定義されたJSONスキーマを通じて、レルムに対するユーザー・プロフィールの構成をより柔軟に定義することができます。"

msgid ""
"In the next sections, we'll be looking at how to use the declarative "
"provider to define your own user profile configuration."
msgstr "次のセクションでは、Declarativeプロバイダを使用して独自のユーザー・プロフィール構成を定義する方法について見ていきます。"

msgid ""
"In the future, the legacy behavior will no longer be supported in "
"{project_name}. Ideally, you should start looking at the new capabilities "
"provided by the User Profile and migrate your realms accordingly."
msgstr ""
"将来的には、{project_name}ではレガシーな動作はサポートされなくなります。理想的には、ユーザー・プロフィールによって提供される新しい機能に目を向け始め、それに従ってレルムを移行すべきです。"

msgid "Enabling the User Profile"
msgstr "ユーザー・プロフィールを有効にする"

msgid ""
"{tech_feature_name} is *Technology Preview* and is not fully supported. This"
" feature is disabled by default."
msgstr ""
"{tech_feature_name}は、 *テクノロジー・プレビュー* "
"であり、完全にはサポートされていません。この機能はデフォルトで無効になっています。"

msgid ""
"To enable start the server with `-Dkeycloak.profile=preview` or "
"`{tech_feature_setting}` . For more details see "
"link:{installguide_profile_link}[{installguide_profile_name}]."
msgstr ""
"有効にするには、 `-Dkeycloak.profile=preview` または `{tech_feature_setting}` "
"でサーバーを起動します。詳細はlink:{installguide_profile_link}[{installguide_profile_name}]を参照してください。"

msgid ""
"In addition to enabling the `declarative_user_profile` feature, you should "
"enable User Profile for a realm. To do that, click on the `Realm Settings` "
"link on the left side menu and turn on the `User Profile Enabled` switch."
msgstr ""
"`declarative_user_profile` "
"機能を有効にすることに加えて、レルムに対してユーザー・プロフィールを有効にする必要があります。これを行うには、左サイドメニューの `Realm "
"Settings` リンクをクリックし、 `User Profile Enabled` スイッチをオンにします。"

msgid "image:images/user-profile-enabling.png[]"
msgstr "image:images/user-profile-enabling.png[]"

msgid ""
"Once you enable it and click on the `Save` button, you can access the `User "
"Profile` tab from where you can manage the configuration for user "
"attributes."
msgstr ""
"この機能を有効にし、 `Save` ボタンをクリックすると、 `User Profile` "
"タブにアクセスすることができ、ここからユーザー属性の設定を管理できるようになります。"

msgid ""
"By enabling the user profile for a realm, {project_name} is going to impose "
"additional constraints on how attributes are managed based on the user "
"profile configuration. In summary, here is the list of what you should "
"expect when the feature is enabled:"
msgstr ""
"レルムのユーザー・プロフィールを有効にすることで、{project_name}はユーザー・プロフィールの構成に基づいて、属性を管理する方法について追加の制約を課そうとします。まとめると、この機能が有効になった際に期待されることは以下の通りです。"

msgid ""
"From an administration point of view, the `Attributes` tab at the user "
"details page will only show the attributes defined in the user profile "
"configuration. The conditions defined on a per-attribute basis will also be "
"taken into account when managing attributes."
msgstr ""
"管理者視点では、ユーザー詳細ページの `Attributes` "
"タブには、ユーザー・プロフィールの構成で定義された属性のみが表示されます。また、属性ごとに定義された条件も、属性を管理する際に考慮されます。"

msgid ""
"User facing forms like registration, update profile, brokering, and personal"
" info in the account console, are going to be rendered dynamically based on "
"the user profile configuration. For that, {project_name} is going to rely on"
" different templates to render these forms dynamically."
msgstr ""
"登録、プロフィールの更新、ブローカリング、アカウント・コンソールの個人情報などのユーザー向けフォームは、ユーザー・プロフィールの構成に基づいて動的にレンダリングされる予定です。そのため、{project_name}"
" はこれらのフォームを動的にレンダリングするために、異なるテンプレートに依存する予定です。"

msgid ""
"In the next topics, we'll be exploring how to manage the user profile "
"configuration and how it affects your realm."
msgstr "次のトピックでは、ユーザー・プロフィールの構成を管理する方法と、それがレルムにどのような影響を与えるかを探ります。"

msgid "Managing the User Profile"
msgstr "ユーザー・プロフィールの管理"

msgid ""
"The user profile configuration is managed on a per-realm basis. For that, "
"click on the `Realm Settings` link on the left side menu and then click on "
"the `User Profile` tab."
msgstr ""
"ユーザー・プロフィールの設定は、レルム単位で管理されます。そのためには、左サイドメニューの `Realm Settings` "
"リンクをクリックし、`User Profile` タブをクリックします。"

msgid "User Profile Tab"
msgstr "User Profileタブ"

msgid "image:images/user-profile-tab.png[]"
msgstr "image:images/user-profile-tab.png[]"

msgid ""
"In the `Attributes` sub-tab you have a list of the attributes currently "
"associated with the user profile. By default, the configuration is created "
"based on the user root attributes and each attribute is configured with some"
" defaults in terms of validation and permissioning."
msgstr ""
"`Attributes` "
"サブタブには、ユーザー・プロフィールに現在関連付けられている属性のリストが表示されます。デフォルトでは、ユーザーのルート属性に基づいて作成され、各属性はバリデーションとパーミッションの観点からいくつかのデフォルト設定がされています。"

msgid ""
"In the `Attribute Groups` sub-tab you can manage attribute groups. An "
"attribute group allows you to correlate attributes so that they are "
"displayed together when rendering user facing forms."
msgstr ""
"`Attribute Groups` "
"のサブタブでは、属性グループを管理することができます。属性グループは、ユーザー向けフォームをレンダリングする際に、属性を関連付けて表示することができます。"

msgid ""
"For now, attribute groups are only used for rendering purposes but in the "
"future they should also enable defining top-level configurations to the "
"attributes they are linked to."
msgstr ""
"今のところ、属性グループはレンダリングの目的にのみ使用されていますが、将来的には、リンク先の属性にトップレベルの設定を定義することも可能になる予定です。"

msgid ""
"In the `JSON Editor` sub-tab you can view and edit the configuration using a"
" well-defined JSON schema. Any change you make when at any other tab are "
"reflected in the JSON configuration shown at this tab."
msgstr ""
"`JSON Editor` "
"サブタブでは、明確に定義されたJSONスキーマを使用して設定を表示および編集することができます。他のタブで行った変更は、このタブで表示されるJSON設定に反映されます。"

msgid ""
"In the next section, you are going to learn how to manage the configuration "
"from the `Attributes` sub-tab."
msgstr "次のセクションでは、 `Attributes` サブタブで設定を管理する方法を学びます。"

msgid "Managing Attributes"
msgstr "属性の管理"

msgid ""
"At the `Attributes` sub-tab you can create, edit, and delete the attributes "
"associated with the user profile."
msgstr "`Attributes` サブタブでは、ユーザー・プロフィールに関連する属性の作成、編集、削除を行うことができます。"

msgid ""
"To define a new attribute and associate it with the user profile, click on "
"the `Create` button in the top-right corner of the attribute listing."
msgstr "新しい属性を定義してユーザー・プロフィールと関連付けるには、属性一覧の右上にある `Create` ボタンをクリックします。"

msgid "Attribute Configuration"
msgstr "属性の設定"

msgid "image:images/user-profile-create-attribute.png[]"
msgstr "image:images/user-profile-create-attribute.png[]"

msgid "When configuring the attribute you can define the following settings:"
msgstr "属性を設定する際に、以下の設定を定義することができます。"

msgid "Name"
msgstr "名前"

msgid "The name of the attribute."
msgstr "属性の名前です。"

msgid "Display name"
msgstr "Display name"

msgid ""
"A user-friendly name for the attribute, mainly used when rendering user-"
"facing forms. It supports internationalization so that values can be loaded "
"from message bundles."
msgstr ""
"主にユーザー向けのフォームをレンダリングする際に使用される、属性のユーザー・フレンドリーな名前です。国際化をサポートしており、メッセージ・バンドルから値を読み込むことができます。"

msgid "Attribute Group"
msgstr "Attribute Group"

msgid "The attribute group to which the attribute belongs to, if any."
msgstr "属性が属する属性グループがある場合、そのグループを設定します。"

msgid "Enabled when scope"
msgstr "Enabled when scope"

msgid ""
"Allows you to define a list of scopes to dynamically enable an attribute. If"
" not set, the attribute is always enabled and its constraints are always "
"enforced when managing user profiles as well as when rendering user-facing "
"forms. Otherwise, the same constraints only apply when any of the scopes in "
"the list is requested by clients."
msgstr ""
"属性を動的に有効にするためのスコープのリストを定義できるようにします。設定されていない場合、属性は常に有効であり、ユーザー・プロフィールの管理およびユーザー向けフォームのレンダリング時にその制約が常に適用されます。そうでない場合は、リスト内のスコープのいずれかがクライアントから要求されたときにのみ、同じ制約が適用されます。"

msgid "Required"
msgstr "Required"

msgid ""
"Set the attribute as required. If not enabled, the attribute is optional. "
"Otherwise, the attribute must be provided by users and administrators with "
"the possibility to also make the attribute required only for users or "
"administrators as well as based on the scopes requested by clients."
msgstr ""
"属性を必須として設定します。有効ではない場合、その属性はオプションです。それ以外の場合、属性はユーザーと管理者によって提供されなければなりません。また、クライアントが要求するスコープに基づいて、ユーザーまたは管理者のみに属性を必須とすることも可能です。"

msgid "Permission"
msgstr "Permission"

msgid ""
"In this section, you can define read and write permissions for users and "
"administrators."
msgstr "このセクションでは、ユーザーと管理者の参照と書き込みのパーミッションを定義することができます。"

msgid "Validation"
msgstr "Validation"

msgid ""
"In this section, you can define the validations that will be performed when "
"managing the attribute value. {project_name} provides a set of built-in "
"validators you can choose from with the possibility to add your own."
msgstr ""
"このセクションでは、属性値を管理する際に実行されるバリデーションを定義することができます。{project_name}は組み込みのバリデータのセットを提供し、そこから選んで独自のバリデータを追加することができます。"

msgid "Annotation"
msgstr "Annotation"

msgid ""
"In this section, you can associate annotations to the attribute. Annotations"
" are mainly useful to pass over additional metadata to frontends for "
"rendering purposes."
msgstr ""
"このセクションでは、属性にアノテーションを関連付けることができます。アノテーションは主に、レンダリング目的でフロントエンドに追加のメタデータを渡すのに便利です。"

msgid "Managing Permissions"
msgstr "パーミッションの管理"

msgid ""
"In the `Permission` section, you can define the level of access users and "
"administrators have to read and write to an attribute."
msgstr "`Permission` セクションでは、ユーザーと管理者が属性に対して読み書きできるアクセスレベルを定義することができます。"

msgid "Attribute Permission"
msgstr "属性のパーミッション"

msgid "image:images/user-profile-permission.png[]"
msgstr "image:images/user-profile-permission.png[]"

msgid "For that, you can use the following settings:"
msgstr "そのために、以下のような設定を行います。"

msgid "Can user view?"
msgstr "Can user view?"

msgid ""
"If enabled, users can view the attribute. Otherwise, users don't have access"
" to the attribute."
msgstr "有効にすると、ユーザーはその属性を参照することができます。そうでなければ、ユーザーはその属性にアクセスできません。"

msgid "Can user edit?"
msgstr "Can user edit?"

msgid ""
"If enabled, users can view and edit the attribute. Otherwise, users don't "
"have access to write to the attribute."
msgstr "有効にすると、ユーザーはその属性を表示および編集することができます。そうでない場合、ユーザーはその属性に書き込むアクセス権を持ちません。"

msgid "Can admin view?"
msgstr "Can admin view?"

msgid ""
"If enabled, administrators can view the attribute. Otherwise, administrators"
" don't have access to the attribute."
msgstr "有効にすると、管理者はその属性を参照することができます。そうでなければ、管理者はその属性にアクセスできません。"

msgid "Can admin edit?"
msgstr "Can admin edit?"

msgid ""
"If enabled, administrators can view and edit the attribute. Otherwise, "
"administrators don't have access to write to the attribute."
msgstr "有効にすると、管理者はその属性を表示および編集することができます。そうでない場合、管理者はその属性に書き込むアクセス権を持ちません。"

msgid ""
"When you create an attribute, no permission is set to the attribute. "
"Effectively, the attribute won't be accessible by either users or "
"administrators. Once you create the attribute, make sure to set the "
"permissions accordingly to that the attribute is only visible by the target "
"audience."
msgstr ""
"属性を作成すると、その属性には何のパーミッションも設定されません。事実上、ユーザーも管理者もその属性にアクセスすることはできません。属性を作成したら、その属性が対象者のみに表示されるように、適宜パーミッションを設定するようにしてください。"

msgid ""
"Permissioning has a direct impact on how and who can manage the attribute, "
"as well as on how the attribute is rendered in user-facing forms."
msgstr "パーミッションは、属性の管理方法と管理者、およびユーザー向けフォームでの属性の表示方法に直接的な影響を及ぼします。"

msgid ""
"For instance, by marking an attribute as only viewable by users, the "
"administrators won't have access to the attribute when managing users "
"through the administration console (neither from the User API). Also, users "
"won't be able to change the attribute when updating their profiles. An "
"interesting configuration if user attributes are fetched from an existing "
"identity store (federation) and you just want to make attributes visible to "
"users without any possibility to update the attribute other than through the"
" source identity store."
msgstr ""
"たとえば、ある属性をユーザーしか参照できないように設定すると、管理者は管理コンソールからユーザーを管理する際に、その属性にアクセスできなくなります（User"
" "
"APIからもアクセスできなくなります）。また、ユーザーは自分のプロフィールを更新する際に、その属性を変更することができなくなります。ユーザー属性が既存のアイデンティティー・ストア（フェデレーション）から取得され、ソース・アイデンティティー・ストアを介する以外に属性を更新する可能性がなく、ユーザーに属性を単に表示したい場合、興味深い構成となります。"

msgid ""
"Similarly, you can also mark an attribute as writable only for "
"administrators with read-only access for users. In this case, only "
"administrators are going to be allowed to manage the attribute."
msgstr ""
"同様に、ある属性を管理者のみ書き込み可能で、ユーザーは読み取り専用にすることもできます。この場合、管理者だけがその属性を管理できるようになります。"

msgid ""
"Depending on your privacy requirements, you might also want attributes "
"inaccessible to administrators but with read-write permissions for users."
msgstr "プライバシーに関する要件によっては、管理者はアクセスできないが、ユーザーには読み書き権限がある属性が必要な場合もあります。"

msgid ""
"Make sure to set the correct permissions whenever you add a new attribute to"
" the user profile configuration."
msgstr "ユーザー・プロフィールの設定に新しい属性を追加する場合は、必ず正しいパーミッションを設定してください。"

msgid "Managing validations"
msgstr "バリデーションの管理"

msgid ""
"In the `Validation` section, you can choose from different forms of "
"validation to make sure the attribute value conforms to specific rules."
msgstr ""
"`Validation` "
"セクションでは、属性値が特定のルールに適合していることを確認するために、さまざまな形式のバリデーションを選択することができます。"

msgid "Attribute Validation"
msgstr "属性のバリデーション"

msgid "image:images/user-profile-validation.png[]"
msgstr "image:images/user-profile-validation.png[]"

msgid "{project_name} provides different validators out of the box:"
msgstr "{project_name}はすぐに利用できる異なるバリデーターを提供します。"

msgid "Description"
msgstr "説明"

msgid "Configuration"
msgstr "設定"

msgid "length"
msgstr "length"

msgid ""
"Check the length of a string value based on a minimum and maximum length."
msgstr "文字列値の長さを最小値と最大値で確認します。"

msgid ""
"*min*: an integer to define the minimum allowed length.\n"
"\n"
"*max*: an integer to define the maximum allowed length.\n"
"\n"
"*trim-disabled*: a boolean to define whether the value is trimmed prior to validation."
msgstr ""
"*min* ：許容される最小の長さを定義する整数です。\n"
"\n"
"*max* ：許容される最大の長さを指定する整数です。\n"
"\n"
"*trim-disabled* ：バリデーション前に値をトリミングするかどうかを定義するBoolean値です。"

msgid "integer"
msgstr "integer"

msgid ""
"Check if the value is an integer and within a lower and/or upper range. If "
"no range is defined, the validator only checks whether the value is a valid "
"number."
msgstr ""
"値が整数であり、下限および/または上限の範囲内にあるかどうかを確認します。範囲が定義されていない場合は、値が有効な数値であるかどうかだけをチェックします。"

msgid ""
"*min*: an integer to define the lower range.\n"
"\n"
"*max*: an integer to define the upper range."
msgstr ""
"*min* ：下限の範囲を指定する整数です。\n"
"\n"
"*max* ：上限の範囲を指定する整数です。"

msgid "double"
msgstr "double"

msgid ""
"Check if the value is a double and within a lower and/or upper range. If no "
"range is defined, the validator only checks whether the value is a valid "
"number."
msgstr ""
"値がdoubleであり、下限および/または上限の範囲内であるかどうかを確認します。範囲を指定しなかった場合、バリデータは値が有効な数値であるかどうかだけをチェックします。"

msgid "uri"
msgstr "uri"

msgid "Check if the value is a valid URI."
msgstr "値が有効なURIであるかどうかを確認します。"

msgid "None"
msgstr "なし"

msgid "pattern"
msgstr "pattern"

msgid "Check if the value matches a specific RegEx pattern."
msgstr "値が特定の正規表現パターンにマッチするかどうかを確認します。"

msgid ""
"*pattern*: the RegEx pattern to use when validating values.\n"
"\n"
"*error-message*: the key of the error message in i18n bundle. If not set a generic message is used."
msgstr ""
"*pattern* ：値を検証する際に使用する正規表現パターン。\n"
"\n"
"*error-message* ：国際化バンドルでのエラーメッセージのキーを設定します。設定されていない場合、汎用メッセージが使用されます。"

msgid "email"
msgstr "email"

msgid "Check if the value has a valid e-mail format."
msgstr "値が有効な電子メール形式であるかどうかを確認します。"

msgid "local-date"
msgstr "local-date"

msgid ""
"Check if the value has a valid format based on the realm and/or user locale."
msgstr "値がレルムおよび/あるいはユーザーのロケールに基づいた有効な形式であるかどうかを確認します。"

msgid "person-name-prohibited-characters"
msgstr "person-name-prohibited-characters"

msgid ""
"Check if the value is a valid person name as an additional barrier for "
"attacks such as script injection. The validation is based on a default RegEx"
" pattern that blocks characters not common in person names."
msgstr ""
"スクリプト・インジェクションなどの攻撃に対する追加の防壁として、値が有効な人名であるかどうかをチェックします。この検証は、人名に一般的でない文字をブロックするデフォルトの正規表現パターンに基づいています。"

msgid ""
"*error-message*: the key of the error message in i18n bundle. If not set a "
"generic message is used."
msgstr ""
"*error-message* ：国際化バンドルでのエラーメッセージのキーを設定します。設定されていない場合、汎用メッセージが使用されます。"

msgid "username-prohibited-characters"
msgstr "username-prohibited-characters"

msgid ""
"Check if the value is a valid username as an additional barrier for attacks "
"such as script injection. The validation is based on a default RegEx pattern"
" that blocks characters not common in usernames."
msgstr ""
"スクリプト・インジェクションなどの攻撃に対する追加の防壁として、値が有効なユーザー名であるかどうかをチェックします。この検証は、ユーザー名に一般的でない文字をブロックするデフォルトの正規表現パターンに基づいています。"

msgid "options"
msgstr "オプション"

msgid ""
"Check if the value is from the defined set of allowed values. Useful to "
"validate values entered through select and multiselect fields."
msgstr ""
"値が定義された許容値のセットから外れていないかどうかをチェックします。セレクト・フィールドやマルチセレクト・フィールドで入力された値を検証するのに便利です。"

msgid "*options*: array of strings containing allowed values."
msgstr "*options*: 許可された値を含む文字列の配列。"

msgid "Managing annotations"
msgstr "アノテーションの管理"

msgid ""
"In order to pass additional information to frontends, attributes can be "
"decorated with annotations to dictate how attributes are rendered. This "
"capability is mainly useful when extending {project_name} themes to render "
"pages dynamically based on the annotations associated with attributes. This "
"mechanism is used for example to "
"link:#_configurin_form_input_field_for_attribute[configure Form input filed "
"for attribute]."
msgstr ""
"フロントエンドに追加情報を渡すために、属性にアノテーションを付与し、属性のレンダリング方法を指定することができます。この機能は主に{project_name}のテーマを拡張して、属性に関連付けられたアノテーションに基づいてページを動的にレンダリングする際に役立ちます。この仕組みは、たとえば"
" link:#_configurin_form_input_field_for_attribute[属性のForm入力フィールドを設定する] "
"に使われています。"

msgid "Attribute Annotation"
msgstr "属性のアノテーション"

msgid "image:images/user-profile-annotation.png[]"
msgstr "image:images/user-profile-annotation.png[]"

msgid "Managing Attribute Groups"
msgstr "属性グループの管理"

msgid ""
"At the `Attribute Groups` sub-tab you can create, edit, and delete attribute"
" groups. An attribute group allows you to define a container for correlated "
"attributes so that they are rendered together when at the user-facing forms."
msgstr ""
"`Attribute Groups` "
"サブタブでは、属性グループの作成、編集、削除を行うことができます。属性グループは、関連する属性のコンテナーを定義することができ、ユーザー向けフォームに表示される際に一緒に表示されます。"

msgid "Attribute Group List"
msgstr "属性グループ一覧"

msgid "image:images/user-profile-attribute-group-list.png[]"
msgstr "image:images/user-profile-attribute-group-list.png[]"

msgid ""
"You can't delete attribute groups that are bound to attributes. For that, "
"you should first update the attributes to remove the binding."
msgstr "属性にバインドされている属性グループを削除することはできません。そのためには、まず属性を更新してバインディングを削除する必要があります。"

msgid ""
"To create a new group, click on the `Create` button in the top-right corner "
"of the attribute groups listing."
msgstr "新しいグループを作成するには、属性グループ一覧の右上にある `Create`  ボタンをクリックします。"

msgid "Attribute Group Configuration"
msgstr "属性グループの設定"

msgid "image:images/user-profile-create-attribute-group.png[]"
msgstr "image:images/user-profile-create-attribute-group.png[]"

msgid "When configuring the group you can define the following settings:"
msgstr "グループを構成する際に、以下の設定を定義することができます。"

msgid "The name of the group."
msgstr "グループ名です。"

msgid ""
"A user-friendly name for the group, mainly used when rendering user-facing "
"forms. It supports internationalization so that values can be loaded from "
"message bundles."
msgstr ""
"主にユーザー向けのフォームをレンダリングする際に使用される、グループのユーザー・フレンドリーな名前です。国際化をサポートしており、メッセージ・バンドルから値を読み込むことができます。"

msgid "Display description"
msgstr "Display description"

msgid ""
"A user-friendly text that will be displayed as a tooltip when rendering "
"user-facing forms."
msgstr "ユーザー向けフォームをレンダリングする際に、ツールチップとして表示されるユーザー・フレンドリーなテキストです。"

msgid "Using the JSON configuration"
msgstr "JSON設定の使用"

msgid ""
"The user profile configuration is stored using a well-defined JSON schema. "
"You can choose from editing the user profile configuration directly by "
"clicking on the `JSON Editor` sub-tab."
msgstr ""
"ユーザー・プロフィールの設定は、明確に定義されたJSONスキーマを使用して保存されます。 `JSON Editor` "
"サブタブをクリックすることで、ユーザー・プロフィールの設定を直接編集することができます。"

msgid "JSON Configuration"
msgstr "JSON設定"

msgid "image:images/user-profile-json-config.png[]"
msgstr "image:images/user-profile-json-config.png[]"

msgid "The JSON schema is defined as follows:"
msgstr "JSONスキーマは以下のように定義されています。"

msgid ""
"{\n"
"  \"attributes\": [\n"
"    {\n"
"      \"name\": \"myattribute\",\n"
"      \"required\": {\n"
"        \"roles\": [ \"user\", \"admin\" ],\n"
"        \"scopes\": [ \"foo\", \"bar\" ]\n"
"      },\n"
"      \"permissions\": {\n"
"        \"view\": [ \"admin\", \"user\" ],\n"
"        \"edit\": [ \"admin\", \"user\" ]\n"
"      },\n"
"      \"validations\": {\n"
"        \"email\": {},\n"
"        \"length\": {\n"
"          \"max\": 255\n"
"        }\n"
"      },\n"
"      \"annotations\": {\n"
"        \"myannotation\": \"myannotation-value\"\n"
"      }\n"
"    }\n"
"  ],\n"
"  \"groups\": [\n"
"    {\n"
"      \"name\": \"personalInfo\",\n"
"      \"displayHeader\": \"Personal Information\"\n"
"    }\n"
"  ]\n"
"}"
msgstr ""
"{\n"
"  \"attributes\": [\n"
"    {\n"
"      \"name\": \"myattribute\",\n"
"      \"required\": {\n"
"        \"roles\": [ \"user\", \"admin\" ],\n"
"        \"scopes\": [ \"foo\", \"bar\" ]\n"
"      },\n"
"      \"permissions\": {\n"
"        \"view\": [ \"admin\", \"user\" ],\n"
"        \"edit\": [ \"admin\", \"user\" ]\n"
"      },\n"
"      \"validations\": {\n"
"        \"email\": {},\n"
"        \"length\": {\n"
"          \"max\": 255\n"
"        }\n"
"      },\n"
"      \"annotations\": {\n"
"        \"myannotation\": \"myannotation-value\"\n"
"      }\n"
"    }\n"
"  ],\n"
"  \"groups\": [\n"
"    {\n"
"      \"name\": \"personalInfo\",\n"
"      \"displayHeader\": \"Personal Information\"\n"
"    }\n"
"  ]\n"
"}"

msgid "The schema supports as many attributes as you need."
msgstr "スキーマは必要な数だけ属性をサポートします。"

msgid ""
"For each attribute you should define a `name` and, optionally, the "
"`required`, `permission`, and the `annotations` settings."
msgstr ""
"各属性には `name` と、オプションで `required` 、 `permission` 、 `annotations` "
"の設定を定義する必要があります。"

msgid "Required property"
msgstr "必須プロパティー"

msgid ""
"The `required` setting defines whether an attribute is required. "
"{project_name} allows you to set an attribute as required based on different"
" conditions."
msgstr ""
"`required` "
"設定は、属性が必須であるかどうかを定義します。{project_name}では、様々な条件に基づいて属性を必須とすることができます。"

msgid ""
"When the `required` setting is defined as an empty object, the attribute is "
"always required."
msgstr "`required` 設定が空のオブジェクトとして定義されている場合、その属性は常に必須となります。"

msgid ""
"{\n"
"  \"attributes\": [\n"
"    {\n"
"      \"name\": \"myattribute\",\n"
"      \"required\": {}\n"
"  ]\n"
"}"
msgstr ""
"{\n"
"  \"attributes\": [\n"
"    {\n"
"      \"name\": \"myattribute\",\n"
"      \"required\": {}\n"
"  ]\n"
"}"

msgid ""
"On the other hand, you can choose to make the attribute required only for "
"users, or administrators, or both. As well as mark the attribute as required"
" only in case a specific scope is requested when the user is authenticating "
"in {project_name}."
msgstr ""
"一方、ユーザー、管理者、またはその両方に対してのみ属性を必須とすることも可能です。また、ユーザーが{project_name}で認証する際に、特定のスコープを要求された場合のみ、この属性を必須とすることもできます。"

msgid ""
"To mark an attribute as required for a user and/or administrator, set the "
"`roles` property as follows:"
msgstr "ユーザーや管理者に必要な属性をマークするには、 `roles` プロパティーを次のように設定します。"

msgid ""
"{\n"
"  \"attributes\": [\n"
"    {\n"
"      \"name\": \"myattribute\",\n"
"      \"required\": {\n"
"        \"roles\": [\"user\"]\n"
"      }\n"
"  ]\n"
"}"
msgstr ""
"{\n"
"  \"attributes\": [\n"
"    {\n"
"      \"name\": \"myattribute\",\n"
"      \"required\": {\n"
"        \"roles\": [\"user\"]\n"
"      }\n"
"  ]\n"
"}"

msgid ""
"The `roles` property expects an array whose values can be either `user` or "
"`admin`, depending on whether the attribute is required by the user or the "
"administrator, respectively."
msgstr ""
"`roles` プロパティーには、値が `user` または `admin` "
"である配列を指定します。これは、その属性がユーザーまたは管理者のどちらに必須とされるかによります。"

msgid ""
"Similarly, you can choose to make the attribute required when a set of one "
"or more scopes is requested by a client when authenticating a user. For "
"that, you can use the `scopes` property as follows:"
msgstr ""
"同様に、ユーザー認証の際にクライアントから1つ以上のスコープのセットが要求された場合に、その属性を必須にすることも可能です。そのためには、次のように "
"`scopes` プロパティを使用します。"

msgid ""
"{\n"
"  \"attributes\": [\n"
"    {\n"
"      \"name\": \"myattribute\",\n"
"      \"required\": {\n"
"        \"scopes\": [\"foo\"]\n"
"      }\n"
"  ]\n"
"}"
msgstr ""
"{\n"
"  \"attributes\": [\n"
"    {\n"
"      \"name\": \"myattribute\",\n"
"      \"required\": {\n"
"        \"scopes\": [\"foo\"]\n"
"      }\n"
"  ]\n"
"}"

msgid ""
"The `scopes` property is an array whose values can be any string "
"representing a client scope."
msgstr "`scopes` プロパティーは配列で、その値にはクライアント・スコープを表す任意の文字列を指定することができます。"

msgid "Permissions property"
msgstr "パーミッション・プロパティー"

msgid ""
"The attribute-level `permissions` property can be used to define the read "
"and write permissions to an attribute. The permissions are set based on "
"whether these operations can be performed on the attribute by a user, or "
"administrator, or both."
msgstr ""
"属性レベルの `permissions` "
"プロパティーを使用して、属性に対する参照と書き込み権限を定義することができます。パーミッションは、ユーザー、管理者、またはその両方が属性に対してこれらの操作を実行できるかどうかに基づいて設定されます。"

msgid ""
"{\n"
"  \"attributes\": [\n"
"    {\n"
"      \"name\": \"myattribute\",\n"
"      \"permissions\": {\n"
"        \"view\": [\"admin\"],\n"
"        \"edit\": [\"user\"]\n"
"      }\n"
"  ]\n"
"}"
msgstr ""
"{\n"
"  \"attributes\": [\n"
"    {\n"
"      \"name\": \"myattribute\",\n"
"      \"permissions\": {\n"
"        \"view\": [\"admin\"],\n"
"        \"edit\": [\"user\"]\n"
"      }\n"
"  ]\n"
"}"

msgid ""
"Both `view` and `edit` properties expect an array whose values can be either"
" `user` or `admin`, depending on whether the attribute is viewable or "
"editable by the user or the administrator, respectively."
msgstr ""
"`view` と `edit` の両プロパティーは、その値が `user` または `admin` "
"である配列を期待します。これは、その属性がユーザーまたは管理者のどちらによって参照または編集可能であるかによります。"

msgid ""
"When the `edit` permission is granted, the `view` permission is implicitly "
"granted."
msgstr "`edit` パーミッションが付与されると、`view` パーミッションも暗黙のうちに付与されます。"

msgid "Annotations property"
msgstr "アノテーション・プロパティー"

msgid ""
"The attribute-level `annotation` property can be used to associate "
"additional metadata to attributes. Annotations are mainly useful for passing"
" over additional information about attributes to frontends rendering user "
"attributes based on the user profile configuration. Each annotation is a "
"key/value pair."
msgstr ""
"属性レベルの `annotation` "
"プロパティ＝は、属性に追加のメタデータを関連付けるために使用することができます。アノテーションは主に、ユーザー・プロフィールの設定に基づいてユーザー属性をレンダリングするフロントエンドに、属性に関する追加情報を渡すのに便利です。各アノテーションはキーと値のペアで構成されます。"

msgid ""
"{\n"
"  \"attributes\": [\n"
"    {\n"
"      \"name\": \"myattribute\",\n"
"      \"annotations\": {\n"
"        \"foo\": [\"foo-value\"],\n"
"        \"bar\": [\"bar-value\"]\n"
"      }\n"
"  ]\n"
"}"
msgstr ""
"{\n"
"  \"attributes\": [\n"
"    {\n"
"      \"name\": \"myattribute\",\n"
"      \"annotations\": {\n"
"        \"foo\": [\"foo-value\"],\n"
"        \"bar\": [\"bar-value\"]\n"
"      }\n"
"  ]\n"
"}"

msgid "Using dynamic forms"
msgstr "動的フォームの使用"

msgid ""
"One of the main capabilities of User Profile is the possibility to "
"dynamically render user-facing forms based on attributes metadata. When you "
"have the feature enabled to your realm, forms like registration and update "
"profile are rendered using specific theme templates to dynamically render "
"pages based on the user profile configuration."
msgstr ""
"ユーザー・プロフィールの主な機能の1つは、属性のメタデータに基づいてユーザー向けのフォームを動的にレンダリングする可能性です。この機能をレルムで有効にすると、登録やプロフィールの更新などのフォームが特定のテーマ・テンプレートを使ってレンダリングされ、ユーザー・プロフィールの設定に基づいたページが動的にレンダリングされます。"

msgid ""
"That said, you shouldn't need to customize templates at all if the default "
"rendering mechanisms serves to your needs. In case you still need "
"customizations to themes, here are the templates you should be looking at:"
msgstr ""
"ですから、デフォルトのレンダリング機構がニーズに合っていれば、テンプレートをカスタマイズする必要は全くありません。それでもなお、テーマのカスタマイズが必要な場合は、以下のテンプレートを参照してください。"

msgid "Template"
msgstr "テンプレート"

msgid "base/login/update-user-profile.ftl"
msgstr "base/login/update-user-profile.ftl"

msgid "The template that renders the update profile page."
msgstr "プロフィールの更新ページをレンダリングするテンプレートです。"

msgid "base/login/register-user-profile.ftl"
msgstr "base/login/register-user-profile.ftl"

msgid "The template that renders the registration page."
msgstr "登録ページをレンダリングするテンプレートです。"

msgid "base/login/idp-review-user-profile.ftl"
msgstr "base/login/idp-review-user-profile.ftl"

msgid ""
"The template that renders the page to review/update the user profile when "
"federating users through brokering."
msgstr "ブローカリングによるユーザー連携時に、ユーザー・プロフィールの確認・更新ページをレンダリングするテンプレートです。"

msgid "base/login/user-profile-commons.ftl"
msgstr "base/login/user-profile-commons.ftl"

msgid ""
"The template that renders input fields in forms based on attributes "
"configuration. Used from all three page templates described above. New input"
" types can be implemented here."
msgstr ""
"属性の設定に基づいて、フォームの入力フィールドをレンダリングするテンプレートです。前述の3つのページテンプレートすべてから使用されます。新しい入力タイプをここに実装することができます。"

msgid "The default rendering mechanism provides the following capabilities:"
msgstr "デフォルトのレンダリング機構は、以下の機能を提供します。"

msgid "Dynamically display fields based on the permissions set to attributes."
msgstr "属性に設定されたパーミッションに基づき、フィールドを動的に表示します。"

msgid ""
"Dynamically render markers for required fields based on the constraints set "
"to the attributes."
msgstr "属性に設定された制約に基づき、必須フィールドのマーカーを動的にレンダリングします。"

msgid ""
"Dynamically render field input type (text, date, number, select, "
"multiselect) set to an attribute."
msgstr "属性に設定されたフィールド入力タイプ（テキスト、日付、数字、セレクト、マルチセレクト）を動的にレンダリングします。"

msgid ""
"Dynamically render read-only fields depending on the permissions set to an "
"attribute."
msgstr "属性に設定されたパーミッションに応じて、読み取り専用のフィールドを動的にレンダリングします。"

msgid "Dynamically order fields depending on the order set to the attributes."
msgstr "属性に設定された順序に応じて、フィールドを動的に順序付けします。"

msgid "Dynamically group fields that belong to a same attribute group."
msgstr "同じ属性グループに属するフィールドを動的にグループ化することができます。"

msgid "Ordering attributes"
msgstr "属性の順序付け"

msgid ""
"The attributes order is set by clicking on the up and down arrows when at "
"the attribute listing page."
msgstr "属性の順序は、属性一覧ページで上下の矢印をクリックすることで設定します。"

msgid "Ordering Attributes"
msgstr "属性の順序付け"

msgid "image:images/user-profile-attribute-list-order.png[]"
msgstr "image:images/user-profile-attribute-list-order.png[]"

msgid ""
"The order you set in this page is respected when fields are rendered in "
"dynamic forms."
msgstr "このページで設定した順序は、動的なフォームでフィールドがレンダリングされる際に利用されます。"

msgid "Grouping attributes"
msgstr "属性のグループ化"

msgid ""
"When dynamic forms are rendered, they will try to group together attributes "
"that belong to a same attribute group."
msgstr "動的なフォームがレンダリングされる際、同じ属性グループに属する属性をグループ化しようとします。"

msgid "Dynamic Update Profile Form"
msgstr "動的なプロフィールの更新フォーム"

msgid "image:images/user-profile-update-profile.png[]"
msgstr "image:images/user-profile-update-profile.png[]"

msgid ""
"When attributes are linked to an attribute group, the attribute order is "
"also important to make sure attributes within the same group are close "
"together, within a same group header. Otherwise, if attributes within a "
"group do not have a sequential order you might have the same group header "
"rendered multiple times in the dynamic form."
msgstr ""
"属性が属性グループにリンクされている場合、同じグループ内の属性が同じグループヘッダー内で近接していることを確認するために、属性の順序も重要です。そうしないと、グループ内の属性に順序がない場合、同じグループヘッダーがダイナミックフォームに複数回レンダリングされる可能性があります。"

msgid "Configuring Form input filed for Attributes"
msgstr "属性のためのフォーム入力ファイルの設定"

msgid ""
"{project_name} provides built-in annotations to configure which input type "
"will be used for the attribute in dynamic forms and other aspects of it's "
"visualization."
msgstr ""
"{project_name}は、動的なフォームで属性に使用される入力タイプを設定するためのアノテーションを内蔵しており、属性の視覚化の他の側面を提供しています。"

msgid "Available annotations are:"
msgstr "利用可能なアノテーションは以下です。"

msgid "inputType"
msgstr "inputType"

msgid ""
"Type of the form input field. Available types are described in a table "
"below."
msgstr "フォームの入力フィールドのタイプ。利用可能なタイプを以下の表に示します。"

msgid "inputHelperTextBefore"
msgstr "inputHelperTextBefore"

msgid ""
"Helper text rendered before (above) the input field. Direct text or internationalization pattern (like `${i18n.key}`) can be used here.\n"
"Text is NOT html escaped when rendered into the page, so you can use html tags here to format the text, but you also have to correctly escape html control characters."
msgstr ""
"入力フィールドの前（上）に表示されるヘルパーテキストです。ここでは直接テキストや国際化パターン（ `${i18n.key}` "
"など）を使用することができます。 "
"テキストはページにレンダリングされるときにはhtmlエスケープされないので、htmlタグを使ってテキストをフォーマットすることができますが、html制御文字も正しくエスケープしなければなりません。"

msgid "inputHelperTextAfter"
msgstr "inputHelperTextAfter"

msgid ""
"Helper text rendered after (under) the input field. Direct text or internationalization pattern (like `${i18n.key}`) can be used here.\n"
"Text is NOT html escaped when rendered into the page, so you can use html tags here to format the text, but you also have to correctly escape html control characters."
msgstr ""
"入力フィールドの後（下）に表示されるヘルパーテキストです。ここでは直接テキストや国際化パターン（ `${i18n.key}` "
"など）を使用することができます。テキストはページにレンダリングされるときにはhtmlエスケープされないので、htmlタグを使ってテキストをフォーマットすることができますが、html制御文字も正しくエスケープしなければなりません。"

msgid "inputOptionsFromValidation"
msgstr "inputOptionsFromValidation"

msgid ""
"Annotation for select and multiselect types. Optional name of custom "
"attribute validation to get input options from. See "
"link:#_managing_options_for_select_fields[detailed description] below."
msgstr ""
"selectおよびmultiselectタイプのためのアノテーション。入力オプションを取得するカスタム属性検証の名前（オプション）。以下の "
"link:#_managing_options_for_select_fields[詳細な説明] を参照してください。"

msgid "inputOptionLabelsI18nPrefix"
msgstr "inputOptionLabelsI18nPrefix"

msgid ""
"Annotation for select and multiselect types. Internationalization key prefix"
" to render options in UI. See "
"link:#_managing_options_for_select_fields[detailed description] below."
msgstr ""
"selectおよびmultiselectタイプのアノテーション。UIでオプションを表示するための国際化キーのプレフィックス。以下の "
"link:#_managing_options_for_select_fields[detailed description] を参照してください。"

msgid "inputOptionLabels"
msgstr "inputOptionLabels"

msgid ""
"Annotation for select and multiselect types. Optional map to define UI "
"labels for options (directly or using internationalization). See "
"link:#_managing_options_for_select_fields[detailed description] below."
msgstr ""
"selectおよびmultiselectタイプのためのアノテーション。オプションマップで、オプションのUIラベルを定義します（直接または国際化を使用して）。以下の"
" link:#_managing_options_for_select_fields[詳細な説明] を参照してください。"

msgid "inputTypePlaceholder"
msgstr "inputTypePlaceholder"

msgid ""
"HTML input `placeholder` attribute applied to the field - specifies a short hint that describes the expected value of an input field (e.g. a sample value\n"
"or a short description of the expected format). The short hint is displayed in the input field before the user enters a value."
msgstr ""
"HTMLの入力 `placeholder` 属性がフィールドに適用されます - "
"入力フィールドに期待される値を記述する短いヒントを指定します（例：サンプル値または期待される書式の短い説明）。短いヒントは、ユーザーが値を入力する前に入力フィールドに表示されます。"

msgid "inputTypeSize"
msgstr "inputTypeSize"

msgid ""
"HTML input `size` attribute applied to the field - specifies the width, in characters, of an single line input field. For fields based on HTML `select` type\n"
"it specifies number of rows with options shown. May not work, depending on css in used theme!"
msgstr ""
"フィールドに適用されるHTMLのinputの `size` 属性 - 単一行の入力フィールドの幅を文字数で指定します。HTMLの `select` "
"タイプに基づくフィールドの場合、オプションが表示される行数を指定します。 使用するテーマのCSSによっては、動作しない場合があります。"

msgid "inputTypeCols"
msgstr "inputTypeCols"

msgid ""
"HTML input `cols` attribute applied to the field - specifies the width, in "
"characters, for `textarea` type. May not work, depending on css in used "
"theme!"
msgstr ""
"フィールドに適用されるHTMLのinputの `cols` 属性 - `textarea` "
"タイプの幅を文字数で指定します。使用しているテーマのCSSによっては動作しない場合があります。"

msgid "inputTypeRows"
msgstr "inputTypeRows"

msgid ""
"HTML input `rows` attribute applied to the field - specifies the height, in characters, for `textarea` type. For select fields it specifies number\n"
"of rows with options shown. May not work, depending on css in used theme!"
msgstr ""
"HTMLのinputの `rows` 属性がフィールドに適用されます - `textarea` "
"型の高さを文字数で指定します。セレクト・フィールドの場合、オプションが表示される行数を指定します。使用するテーマの CSS "
"によっては動作しない場合があります。"

msgid "inputTypePattern"
msgstr "inputTypePattern"

msgid ""
"HTML input `pattern` attribute applied to the field providing client side validation - specifies a regular expression that an input field's value\n"
"is checked against. Useful for single line inputs."
msgstr ""
"HTMLのinputの `pattern` 属性は、クライアント・サイドのバリデーションを行うフィールドに適用されます - "
"入力フィールドの値を正規表現で指定すると照合されます。一行入力に便利です。"

msgid "inputTypeMaxLength"
msgstr "inputTypeMaxLength"

msgid ""
"HTML input `maxlength` attribute applied to the field providing client side validation - maximal length of the text which can be entered into the input\n"
"field. Useful for text fields."
msgstr ""
"HTMLのinputの `maxlength` 属性は、クライアントサイドのバリデーションを行うフィールドに適用されます。 - "
"入力フィールドに入力可能なテキストの最大長。テキストフィールドに便利です。"

msgid "inputTypeMinLength"
msgstr "inputTypeMinLength"

msgid ""
"HTML input `minlength` attribute applied to the field providing client side validation - minimal length of the text which can be entered into the input\n"
"field. Useful for text fields."
msgstr ""
"HTMLのinputの `minlength` 属性は、クライアントサイドのバリデーションを行うフィールドに適用されます。 - "
"入力フィールドに入力可能なテキストの最少長。テキストフィールドに便利です。"

msgid "inputTypeMax"
msgstr "inputTypeMax"

msgid ""
"HTML input `max` attribute applied to the field providing client side validation - maximal value which can be entered into the input field.\n"
"Useful for numeric fields."
msgstr ""
"HTMLのinputの `max` 属性は、フィールドに適用し、クライアント・サイドのバリデーションを行います。 - "
"入力フィールドに入力できる最大値。数値フィールドに入力できる最大値。"

msgid "inputTypeMin"
msgstr "inputTypeMin"

msgid ""
"HTML input `min` attribute applied to the field providing client side validation - minimal value which can be entered into the input field.\n"
"Useful for numeric fields."
msgstr ""
"HTMLのinputの `min` 属性は、フィールドに適用し、クライアント・サイドのバリデーションを行います。 - "
"入力フィールドに入力できる最小値。数値フィールドに入力できる最大値。"

msgid "inputTypeStep"
msgstr "inputTypeStep"

msgid ""
"HTML input `step` attribute applied to the field - Specifies the interval "
"between legal numbers in an input field. Useful for numeric fields."
msgstr ""
"HTMLのinputの `step` 属性がフィールドに適用されます - 入力フィールドで有効な数値の間隔を指定します。数値フィールドに便利です。"

msgid ""
"Field types use HTML form field tags and attributes applied to them - they "
"behave based on the HTML specifications and browser support for them."
msgstr ""
"フィールドタイプは、HTMLのフォーム・フィールドのタグや属性を適用したもので、HTMLの仕様やブラウザーのサポートに基づいた動作をします。"

msgid "Visual rendering also depends on css styles applied in the used theme."
msgstr "視覚的なレンダリングは、使用するテーマで適用されるCSSスタイルにも依存します。"

msgid "Available `inputType` annotation values:"
msgstr "利用可能な `inputType` アノテーションの値。"

msgid "HTML tag used"
msgstr "使用するHTMLタグ"

msgid "text"
msgstr "text"

msgid "Single line text input."
msgstr "一行のテキスト入力。"

msgid "input"
msgstr "input"

msgid "textarea"
msgstr "textarea"

msgid "Multiple line text input."
msgstr "複数行のテキスト入力が可能。"

msgid "select"
msgstr "select"

msgid ""
"Common single select input. See "
"link:#_managing_options_for_select_fields[description how to configure "
"options] below."
msgstr ""
"一般的な単一選択入力です。以下の link:#_managing_options_for_select_fields[オプションの設定方法の説明] "
"を参照してください。"

msgid "select-radiobuttons"
msgstr "select-radiobuttons"

msgid ""
"Single select input through group of radio buttons. See "
"link:#_managing_options_for_select_fields[description how to configure "
"options] below."
msgstr ""
"ラジオボタンによる単一選択入力。以下の link:#_managing_options_for_select_fields[オプションの設定方法の説明]"
" を参照してください。"

msgid "group of input"
msgstr "入力のグループ"

msgid "multiselect"
msgstr "multiselect"

msgid ""
"Common multiselect input. See "
"link:#_managing_options_for_select_fields[description how to configure "
"options] below."
msgstr ""
"一般的な複数選択入力です。以下の link:#_managing_options_for_select_fields[オプションの設定方法の説明] "
"を参照してください。"

msgid "multiselect-checkboxes"
msgstr "multiselect-checkboxes"

msgid ""
"Multiselect input through group of checkboxes. See "
"link:#_managing_options_for_select_fields[description how to configure "
"options] below."
msgstr ""
"チェックボックスのグループによる多項目入力。以下の "
"link:#_managing_options_for_select_fields[オプションの設定方法の説明] を参照してください。"

msgid "html5-email"
msgstr "html5-email"

msgid "Single line text input for email address based on HTML 5 spec."
msgstr "HTML5仕様に基づく、メールアドレス用の1行テキスト入力。"

msgid "html5-tel"
msgstr "html5-tel"

msgid "Single line text input for phone number based on HTML 5 spec."
msgstr "HTML 5仕様に基づく電話番号の1行テキスト入力。"

msgid "html5-url"
msgstr "html5-url"

msgid "Single line text input for URL based on HTML 5 spec."
msgstr "HTML5仕様に基づくURLの1行テキスト入力。"

msgid "html5-number"
msgstr "html5-number"

msgid ""
"Single line input for number (integer or float depending on `step`) based on"
" HTML 5 spec."
msgstr "HTML5仕様に基づく数値（ `step` に依存する整数または浮動小数点）の一行入力です。"

msgid "html5-range"
msgstr "html5-range"

msgid "Slider for number entering based on HTML 5 spec."
msgstr "HTML5仕様に基づく数字入力用スライダー。"

msgid "html5-datetime-local"
msgstr "html5-datetime-local"

msgid "Date Time input based on HTML 5 spec."
msgstr "HTML5仕様に基づく日付時刻入力。"

msgid "html5-date"
msgstr "html5-date"

msgid "Date input based on HTML 5 spec."
msgstr "HTML5仕様に基づく日付入力。"

msgid "html5-month"
msgstr "html5-month"

msgid "Month input based on HTML 5 spec."
msgstr "HTML5仕様に基づく月入力。"

msgid "html5-week"
msgstr "html5-week"

msgid "Week input based on HTML 5 spec."
msgstr "HTML5仕様に基づく週間入力。"

msgid "html5-time"
msgstr "html5-time"

msgid "Time input based on HTML 5 spec."
msgstr "HTML5仕様に基づく時刻入力。"

msgid "Defining options for select and multiselect fields"
msgstr "単一選択・複数選択フィールドのオプションの定義"

msgid ""
"Options for select and multiselect fields are taken from validation applied "
"to the attribute to be sure validation and field options presented in UI are"
" always consistent. By default, options are taken from built-in `options` "
"validation."
msgstr ""
"単一選択と複数選択のフィールドのオプションは、UIに表示されるバリデーションとフィールドのオプションが常に一貫していることを確認するために、属性に適用されるバリデーションから取得されます。デフォルトでは、オプションは組み込みの"
" `options` のバリデーションから取得されます。"

msgid ""
"You can use various ways to provide nice human readable labels for select "
"and multiselect options. The simplest case is when attribute values are same"
" as UI labels. No any extra configuration is necessary in this case."
msgstr ""
"選択項目や複数選択項目に対して、人間が読みやすいラベルを提供するには、さまざまな方法があります。最も単純なケースは、属性値が UI "
"ラベルと同じである場合です。この場合、特別な設定は必要ありません。"

msgid "Option values same as UI labels"
msgstr "オプション値はUIラベルと同じ"

msgid "image:images/user-profile-select-options-simple.png[]"
msgstr "image:images/user-profile-select-options-simple.png[]"

msgid ""
"When attribute value is kind of ID not suitable for UI, you can use simple "
"internationalization support provided by `inputOptionLabelsI18nPrefix` "
"annotation. It defines prefix for internationalization keys, option value is"
" dot appended to this prefix."
msgstr ""
"属性値がUIに適さないIDのような場合、 `inputOptionLabelsI18nPrefix` "
"アノテーションが提供する簡単な国際化サポートを使用することができます。これは国際化キーのプレフィックスを定義し、オプションの値はこのプレフィックスにドットで追加されます。"

msgid "Simple internationalization for UI labels using i18n key prefix"
msgstr "国際化キープレフィックスを用いたUIラベルの簡易国際化機能"

msgid "image:images/user-profile-select-options-simple-i18n.png[]"
msgstr "image:images/user-profile-select-options-simple-i18n.png[]"

msgid ""
"Localized UI label texts for option value have to be provided by "
"`userprofile.jobtitle.sweng` and `userprofile.jobtitle.swarch` keys then, "
"using common localization mechanism."
msgstr ""
"オプション値のためのローカライズされたUIラベルテキストは、共通のローカライゼーション機構を使用して、 "
"`userprofile.jobtitle.sweng` と `userprofile.jobtitle.swarch` "
"キーで提供されなければなりません。"

msgid ""
"You can also use `inputOptionLabels` annotation to provide labels for "
"individual options. It contains map of labels for option - key in the map is"
" option value (defined in validation), and value in the map is UI label text"
" itself or its internationalization pattern (like `${i18n.key}`) for that "
"option."
msgstr ""
"また、`inputOptionLabels` アノテーションを使用して、個々のオプションのラベルを提供することができます。マップのキーはオプションの値 "
"(バリデーションで定義) で、マップの値はそのオプションのUIラベルテキストそのもの、またはその国際化パターン ( `${i18n.key}` "
"のような) です。"

msgid ""
"You have to use User Profile `JSON Editor` to enter map as "
"`inputOptionLabels` annotation value."
msgstr ""
"ユーザー・プロフィールの `JSON Editor` を使用して、 `inputOptionLabels` "
"アノテーションの値としてマップを入力する必要があります。"

msgid ""
"Example of directly entered labels for individual options without "
"internationalization:"
msgstr "国際化を行わず、個々のオプションにラベルを直接入力した例。"

msgid ""
"\"attributes\": [\n"
"...\n"
"{\n"
"  \"name\": \"jobTitle\",\n"
"  \"validations\": {\n"
"    \"options\": {\n"
"      \"options\":[\n"
"        \"sweng\",\n"
"        \"swarch\"\n"
"      ]\n"
"    }\n"
"  },\n"
"  \"annotations\": {\n"
"    \"inputType\": \"select\",\n"
"    \"inputOptionLabels\": {\n"
"      \"sweng\": \"Software Engineer\",\n"
"      \"swarch\": \"Software Architect\"\n"
"    }\n"
"  }\n"
"}\n"
"...\n"
"]"
msgstr ""
"\"attributes\": [\n"
"...\n"
"{\n"
"  \"name\": \"jobTitle\",\n"
"  \"validations\": {\n"
"    \"options\": {\n"
"      \"options\":[\n"
"        \"sweng\",\n"
"        \"swarch\"\n"
"      ]\n"
"    }\n"
"  },\n"
"  \"annotations\": {\n"
"    \"inputType\": \"select\",\n"
"    \"inputOptionLabels\": {\n"
"      \"sweng\": \"Software Engineer\",\n"
"      \"swarch\": \"Software Architect\"\n"
"    }\n"
"  }\n"
"}\n"
"...\n"
"]"

msgid "Example of the internationalized labels for individual options:"
msgstr "個々のオプションの国際化されたラベルの例。"

msgid ""
"\"attributes\": [\n"
"...\n"
"{\n"
"  \"name\": \"jobTitle\",\n"
"  \"validations\": {\n"
"    \"options\": {\n"
"      \"options\":[\n"
"        \"sweng\",\n"
"        \"swarch\"\n"
"      ]\n"
"    }\n"
"  },\n"
"  \"annotations\": {\n"
"    \"inputType\": \"select-radiobuttons\",\n"
"    \"inputOptionLabels\": {\n"
"      \"sweng\": \"${jobtitle.swengineer}\",\n"
"      \"swarch\": \"${jobtitle.swarchitect}\"\n"
"    }\n"
"  }\n"
"}\n"
"...\n"
"]"
msgstr ""
"\"attributes\": [\n"
"...\n"
"{\n"
"  \"name\": \"jobTitle\",\n"
"  \"validations\": {\n"
"    \"options\": {\n"
"      \"options\":[\n"
"        \"sweng\",\n"
"        \"swarch\"\n"
"      ]\n"
"    }\n"
"  },\n"
"  \"annotations\": {\n"
"    \"inputType\": \"select-radiobuttons\",\n"
"    \"inputOptionLabels\": {\n"
"      \"sweng\": \"${jobtitle.swengineer}\",\n"
"      \"swarch\": \"${jobtitle.swarchitect}\"\n"
"    }\n"
"  }\n"
"}\n"
"...\n"
"]"

msgid ""
"Localized texts have to be provided by `jobtitle.swengineer` and "
"`jobtitle.swarchitect` keys then, using common localization mechanism."
msgstr ""
"ローカライズされたテキストは、共通のローカライズ機構を使用して `jobtitle.swengineer` と "
"`jobtitle.swarchitect` のキーで提供される必要があります。"

msgid ""
"Custom validator can be used to provide options thanks to "
"`inputOptionsFromValidation` attribute annotation. This validation have to "
"have `options` config providing array of options. Internationalization works"
" the same way as for options provided by built-in `options` validation."
msgstr ""
"カスタム・バリデーターは `inputOptionsFromValidation` "
"属性アノテーションのおかげで、オプションを提供するために使用することができます。このバリデーションでは、オプションの配列を提供する `options` "
"の設定が必要です。国際化は、組み込みの `options` のバリデーションで提供されるオプションと同じように動作します。"

msgid "Options provided by custom validator"
msgstr "カスタム・バリデーターが提供するオプション"

msgid "image:images/user-profile-select-options-custom-validator.png[]"
msgstr "image:images/user-profile-select-options-custom-validator.png[]"

msgid "Forcing User Profile compliance"
msgstr "ユーザー・プロフィールの強制遵守"

msgid ""
"In order to make sure user profiles are in compliance with the "
"configuration, administrators may use the `VerifyProfile` required action to"
" eventually force users to update their profiles when authenticating to "
"{project_name}."
msgstr ""
"ユーザーのプロフィールが設定に準拠していることを確認するために、管理者は `VerifyProfile` "
"必須アクションを使用して、最終的に{project_name}で認証する際にユーザーのプロフィールを強制的に更新させることができます。"

msgid ""
"The `VerifyProfile` action is similar to the `UpdateProfile` action. "
"However, it leverages all the capabilities provided by the user profile to "
"automatically enforce compliance with the user profile configuration."
msgstr ""
"`VerifyProfile` アクションは `UpdateProfile` "
"アクションと似ています。しかし、ユーザー・プロフィールが提供するすべての機能を利用して、ユーザー・プロフィールの設定に自動的に準拠するようにします。"

msgid ""
"When enabled, the `VerifyProfile` action is going to perform the following "
"steps when the user is authenticating:"
msgstr "`VerifyProfile` アクションを有効にすると、ユーザー認証の際に次のような処理を行います。"

msgid ""
"Check whether the user profile is fully compliant with the user profile "
"configuration set to the realm."
msgstr "ユーザー・プロフィールがレルムに設定されたユーザー・プロフィールの構成に完全に準拠しているかどうかを確認します。"

msgid ""
"If not, perform an additional step during the authentication so that the "
"user can update any missing or invalid attribute."
msgstr "そうでない場合は、認証時に追加のステップを実行し、ユーザーが不足または無効な属性を更新できるようにします。"

msgid ""
"If the user profile is compliant with the configuration, no additional step "
"is performed, and the user continues with the authentication process."
msgstr "ユーザー・プロフィールが設定に適合している場合、追加のステップは実行されず、ユーザーは認証プロセスを続行します。"

msgid ""
"By default, the `VerifyProfile` action is disabled. To enabled it, click on "
"the `Authentication` link on the left side menu and then click on the "
"`Required Actions` tab. At this tab, click on the `Register` button and "
"select the `VerifyProfile` action."
msgstr ""
"デフォルトでは、 `VerifyProfile` アクションは無効になっています。有効にするには、左サイドメニューの `Authentication` "
"リンクをクリックし、`Required Actions` タブをクリックします。このタブで `Register` ボタンをクリックし、 "
"`VerifyProfile` アクションを選択します。"

msgid "Registring the VerifyProfile Required Action"
msgstr "VerifyProfile必須アクションの登録"

msgid "image:images/user-profile-register-verify-profile-action.png[]"
msgstr "image:images/user-profile-register-verify-profile-action.png[]"

msgid "Migrating to User Profile"
msgstr "ユーザー・プロフィールへの移行"

msgid ""
"Before enabling the User Profile capabilities to a realm, there are some "
"important considerations you should be aware of. By providing a single place"
" to manage attribute metadata, the feature is very strict about the "
"attributes that can be set to users and how they are managed."
msgstr ""
"レルムに対してユーザー・プロフィール機能を有効にする前に、注意すべき重要な点がいくつかあります。属性メタデータを管理するための単一の場所を提供することで、この機能はユーザーに設定できる属性とその管理方法について非常に厳格なものとなっています。"

msgid ""
"In terms of user management, administrators are able to manage only the "
"attributes defined in the user profile configuration. Any other attribute "
"set to the user and not yet defined in the user profile configuration won't "
"be accessible. It is recommended to update your user profile configuration "
"with all the user attributes you want to expose either to users or "
"administrators."
msgstr ""
"ユーザー管理に関しては、管理者はユーザー・プロフィールの構成で定義された属性のみを管理することができます。ユーザーに設定された他の属性で、まだユーザー・プロフィール構成で定義されていないものは、アクセスできません。ユーザーまたは管理者のいずれかに公開したい、すべてのユーザー属性を定義したユーザー・プロフィール構成に更新することをお勧めします。"

msgid ""
"The same recommendation applies for those accessing the User REST API to "
"query user information."
msgstr "ユーザー情報を照会するためにUser REST APIにアクセスする場合にも、同様の推奨事項が適用されます。"

msgid ""
"In regards to {project_name} internal user attributes such as `LDAP_ID`, "
"`LDAP_ENTRY_DN`, or `KERBEROS_PRINCIPAL`, if you want to be able to access "
"those attributes you should have them as attributes in your user profile "
"configuration. The recommendation is to mark these attributes as viewable "
"only to administrators so that you can look at them when managing the user "
"attributes through the administration console or querying users via User "
"API."
msgstr ""
"`LDAP_ID` 、 `LDAP_ENTRY_DN` 、 `KERBEROS_PRINCIPAL` "
"などの{project_name}内部ユーザー属性に関して、これらの属性にアクセスしたい場合は、ユーザー・プロフィール構成に属性として設定する必要があります。推奨は、これらの属性を管理者のみ参照可能とし、管理コンソールでユーザー属性を管理する際や、User"
" APIでユーザーを照会する際に参照できるようにすることです。"

msgid ""
"In regards to theming, if you already have customizations to the legacy "
"templates (those hardcoded with user root attributes) your custom templates "
"won't be used when rendering user-facing forms but the new templates that "
"render these forms dynamically. Ideally, you should avoid having any "
"customizations to templates and try to stick with the behavior provided by "
"these new templates to dynamically render forms for you. If they are still "
"not enough to address your requirements, you can either customize them or "
"provide us with any feedback so that we discuss whether it makes sense to "
"enhance the new templates."
msgstr ""
"テーマに関して、従来のテンプレート（ユーザーのルート属性でハードコードされたもの）をカスタマイズしている場合、ユーザー向けのフォームをレンダリングする際に、そのカスタム・テンプレートは使われず、これらのフォームを動的にレンダリングする新しいテンプレートが使用されます。理想的には、テンプレートのカスタマイズを避け、新しいテンプレートが提供する動的にフォームをレンダリングする動作を維持するようにします。それでも不十分な場合は、テンプレートをカスタマイズするか、新しいテンプレートを強化するかどうかを検討しますので、ご意見をお聞かせください。"

msgid "Managing user sessions"
msgstr "ユーザー・セッションの管理"

msgid ""
"When users log into realms, {project_name} maintains a user session for each"
" user and remembers each client visited by the user within the session. "
"Realm administrators can perform multiple actions on each user session:"
msgstr ""
"ユーザーがレルムにログインすると、{project_name}は各ユーザーのユーザー・セッションを維持し、セッション内でユーザーがアクセスした各クライアントを記憶します。レルム管理者は、各ユーザー・セッションに対して以下のような複数のアクションを実行することができます。"

msgid "View login statistics for the realm."
msgstr "レルムのログイン統計情報を表示する。"

msgid "View active users and where they logged in."
msgstr "アクティブなユーザーとログインした場所を表示する。"

msgid "Log a user out of their session."
msgstr "ユーザーをセッションからログアウトさせる。"

msgid "Revoke tokens."
msgstr "トークンを失効させる。"

msgid "Set up token timeouts."
msgstr "トークンのタイムアウトを設定する。"

msgid "Set up session timeouts."
msgstr "セッションのタイムアウトを設定する。"

msgid "Administering sessions"
msgstr "セッションの管理"

msgid ""
"To see a top-level view of the active clients and sessions in "
"{project_name}, click *Sessions* from the menu."
msgstr ""
"{project_name}でアクティブなクライアントとセッションのトップレベルのビューを表示するには、メニューから *Sessions* "
"をクリックします。"

msgid "Sessions"
msgstr "Sessions"

msgid "image:{project_images}/sessions.png[Sessions]"
msgstr "image:{project_images}/sessions.png[Sessions]"

msgid "The *Logout all* Operation"
msgstr "*Logout all* の操作"

msgid ""
"You can log out all users in the realm by clicking the *Logout all* button."
msgstr "*Logout all* ボタンをクリックすると、レルム内のすべてのユーザーをログアウトすることができます。"

msgid ""
"When you click the *Logout all* button, all SSO cookies become invalid, and "
"clients requesting authentication within active browser sessions must log in"
" again. {project_name} notifies clients by using the {project_name} OIDC "
"client adapter of the logout event. Client types such as SAML do not receive"
" a back-channel logout request."
msgstr ""
"*Logout all* "
"ボタンをクリックすると、すべてのSSOクッキーが無効になり、アクティブなブラウザー・セッション内で認証を要求しているクライアントは再度ログインする必要があります。{project_name}は、OIDCクライアント・アダプターを使用して、ログアウト・イベントをクライアントに通知します。SAMLなどのクライアント・タイプは、バックチャネルのログアウト・リクエストを受信しません。"

msgid ""
"Clicking *Logout all* does not revoke outstanding access tokens. Outstanding"
" tokens must expire naturally. For clients using the {project_name} OIDC "
"client adapter, you can push a <<_revocation-policy, revocation policy>> to "
"revoke the token, but this does not work for other adapters."
msgstr ""
"*Logout all* "
"をクリックしても、未使用のアクセストークンは無効化されません。未使用のトークンは自然に失効する必要があります。OIDCクライアント・アダプターを使用しているクライアントの場合、<<_revocation-"
"policy, 無効化ポリシー>>をプッシュしてトークンを無効化させることができますが、他のアダプターの場合はうまくいきません。"

msgid "Application navigation"
msgstr "アプリケーション・ナビゲーション"

msgid ""
"On the `Sessions` page, you can click on each client to go to that client's "
"`Sessions` tab. Click the *Show Sessions* button there to see which users "
"are in the application."
msgstr ""
"`Sessions` ページで、各クライアントをクリックすると、そのクライアントの`Sessions` タブに移動することができます。そこにある "
"*Show Sessions* ボタンをクリックすると、どのユーザーがアプリケーションに参加しているかがわかります。"

msgid "Application sessions"
msgstr "アプリケーション・セッション"

msgid "image:{project_images}/application-sessions.png[]"
msgstr "image:{project_images}/application-sessions.png[]"

msgid "User navigation"
msgstr "ユーザー・ナビゲーション"

msgid ""
"If you go to the `Sessions` tab of an individual user, you can also view the"
" user's session information."
msgstr "個々のユーザーの `Sessions` タブを開くと、そのユーザーのセッション情報を見ることもできます。"

msgid "User Sessions"
msgstr "ユーザー・セッション"

msgid "image:{project_images}/user-sessions.png[]"
msgstr "image:{project_images}/user-sessions.png[]"

msgid "Revocation policies"
msgstr "失効ポリシー"

msgid ""
"If your system is compromised, you can revoke all active sessions and access"
" tokens by clicking the `Sessions` screen *Revocation* tab."
msgstr ""
"システムが侵害された場合、 `Sessions` 画面の *Revocation* "
"タブをクリックすることで、すべてのアクティブなセッションとアクセストークンを取り消すことができます。"

msgid "Revocation"
msgstr "失効"

msgid "image:{project_images}/revocation.png[]"
msgstr "image:{project_images}/revocation.png[]"

msgid ""
"You can specify a time and date where sessions or tokens issued before that "
"time and date are invalid using this console. Click *Set to now* to set the "
"policy to the current time and date. Click *Push* to push this revocation "
"policy to any registered OIDC client with the {project_name} OIDC client "
"adapter."
msgstr ""
"このコンソールを使って、その日時以前に発行されたセッションやトークンが無効になる日時を指定することができます。 *Set to now* "
"をクリックすると、ポリシーが現在の日時に設定されます。 *Push*をクリックすると、{project_name} "
"OIDCクライアント・アダプターで登録されたOIDCクライアントにこの失効ポリシーがプッシュされます。"

msgid "Session and token timeouts"
msgstr "セッションとトークンのタイムアウト"

msgid ""
"{project_name} includes control of the session, cookie, and token timeouts "
"through the *Tokens* tab in the *Realm Settings* menu."
msgstr ""
"{project_name}には、 *Realm Settings* メニューの *Tokens* "
"タブによる、セッション、Cookie、トークンのタイムアウトの制御が含まれています。"

msgid "Tokens tab"
msgstr "Tokensタブ"

msgid "image:{project_images}/tokens-tab.png[]"
msgstr "image:{project_images}/tokens-tab.png[]"

msgid "Default Signature Algorithm"
msgstr "デフォルトの署名アルゴリズム"

msgid ""
"The default algorithm used to assign tokens for the realm.\n"
"\n"
"[[_revoke-refresh-token]]"
msgstr ""
"レルムにトークンを割り当てるために使用するデフォルトのアルゴリズム。\n"
"\n"
"[[_revoke-refresh-token]]"

msgid "Revoke Refresh Token"
msgstr "Revoke Refresh Token"

msgid ""
"When *ON*, {project_name} revokes refresh tokens and issues another token "
"that the client must use. This action applies to OIDC clients performing the"
" refresh token flow."
msgstr ""
"*ON* "
"の場合、{project_name}はリフレッシュトークンを取り消し、クライアントが使用しなければならない別のトークンを発行します。このアクションは、リフレッシュトークン・フローを実行するOIDCクライアントに適用されます。"

msgid "SSO Session Idle"
msgstr "SSO Session Idle"

msgid ""
"This setting is for OIDC clients only. If a user is inactive for longer than"
" this timeout, the user session is invalidated. This timeout value resets "
"when clients request authentication or send a refresh token request. "
"{project_name} adds a window of time to the idle timeout before the session "
"invalidation takes effect. See the <<_idle_timeouts_note, note>> later in "
"this section."
msgstr ""
"この設定は、OIDCクライアントのみです。このタイムアウト時間を超えてユーザーがアクティブでない場合、そのユーザーセッションは無効になります。このタイムアウト値は、クライアントが認証を要求するか、リフレッシュトークン・リクエストを送信するとリセットされます。{project_name}は、セッションが無効化になるまでの時間を、アイドル・タイムアウトに追加します。このセクションの後の<<_idle_timeouts_note,"
" 注意事項>>を参照してください。"

msgid "SSO Session Max"
msgstr "SSO Session Max"

msgid "The maximum time before a user session expires."
msgstr "ユーザーセッションが失効するまでの最大時間。"

msgid "SSO Session Idle Remember Me"
msgstr "SSO Session Idle Remember Me"

msgid ""
"This setting is similar to the standard SSO Session Idle configuration but "
"specific to logins with *Remember Me* enabled. Users can specify longer "
"session idle timeouts when they click *Remember Me* when logging in. This "
"setting is an optional configuration and, if its value is not greater than "
"zero, it uses the same idle timeout as the SSO Session Idle configuration."
msgstr ""
"この設定は、標準のSSOセッション・アイドルの設定と似ていますが、 *Remember Me* "
"を有効にしたログインに固有のものです。ユーザーは、ログイン時に *Remember Me* "
"をクリックすると、より長いセッションアイドルのタイムアウトを指定することができます。この設定はオプションで、値が0より大きくない場合は、SSOセッション・アイドルの設定と同じアイドル・タイムアウトが使用されます。"

msgid "SSO Session Max Remember Me"
msgstr "SSO Session Max Remember Me"

msgid ""
"This setting is similar to the standard SSO Session Max but specific to *Remember Me* logins. Users can specify longer sessions when they click *Remember Me* when logging in. This setting is an optional configuration and, if its value is not greater than zero, it uses the same session lifespan as the SSO Session Max configuration.\n"
"\n"
"[[_offline-session-idle]]"
msgstr ""
"この設定は、標準のSSO Session Maxに似ていますが、 *Remember Me* ログインに固有のものです。ユーザーは、ログイン時に *Remember Me* をクリックすると、より長いセッションを指定できます。この設定はオプションで、値が0より大きくない場合、SSO Session Maxの設定と同じセッション寿命が使用されます。\n"
"\n"
"[[_offline-session-idle]]"

msgid "Offline Session Idle"
msgstr "Offline Session Idle"

msgid ""
"This setting is for <<_offline-access, offline access>>. The amount of time the session remains idle before {project_name} revokes its offline token. {project_name} adds a window of time to the idle timeout before the session invalidation takes effect. See the <<_idle_timeouts_note, note>> later in this section.\n"
"\n"
"[[_offline-session-max-limited]]"
msgstr ""
"この設定は<<_offline-access, オフライン・アクセス>>のためのものです。{project_name} がオフライン トークンを無効にするまでに、セッションがアイドル状態のままである時間を指定します。{project_name}は、セッションが無効になるまでのアイドル・タイムアウトに時間のウィンドウを追加します。このセクションの後の<<_idle_timeouts_note, 注意事項>>を参照してください。\n"
"\n"
"[[_offline-session-max-limited]]"

msgid "Offline Session Max Limited"
msgstr "Offline Session Max Limited"

msgid ""
"This setting is for <<_offline-access, offline access>>. If this flag is *ON*, Offline Session Max can control the maximum time the offline token remains active, regardless of user activity. Client Offline Session Idle and Client Offline Session Max are enabled.\n"
"\n"
"[[_offline-session-max]]"
msgstr ""
"この設定は、<<_offline-access, オフライン・アクセス>>のためのものです。このフラグが *ON* の場合、Offline Session Maxは、ユーザーの活動に関係なく、オフライントークンがアクティブである最大時間を制御することができます。Client Offline Session Idleおよび Client Offline Session Max が有効になります。\n"
"\n"
"[[_offline-session-max]]"

msgid "Offline Session Max"
msgstr "Offline Session Max"

msgid ""
"This setting is for <<_offline-access, offline access>>, and it is the "
"maximum time before {project_name} revokes the corresponding offline token. "
"This option controls the maximum amount of time the offline token remains "
"active, regardless of user activity."
msgstr ""
"この設定は<<_offline-access, "
"オフライン・アクセス>>,に対するもので、{project_name}が対応するオフライントークンを取り消すまでの最大時間です。このオプションは、ユーザーの活動に関係なく、オフライントークンが有効であり続ける最大時間を制御します。"

msgid "Client Offline Session Idle"
msgstr "Offline Session Idle"

msgid ""
"This setting is for <<_offline-access, offline access>>. If a user is "
"inactive for longer than this timeout, offline token requests bump the idle "
"timeout. This setting specifies a shorter idle timeout of an offline token "
"than the offline session idle. Users can override this setting for "
"individual clients. This setting is an optional configuration and, when set "
"to zero, uses the same idle timeout in the Offline Session Idle "
"configuration."
msgstr ""
"この設定は<<_offline-access, "
"オフライン・アクセス>>のためのものです。ユーザーがこのタイムアウトより長く非アクティブの場合、オフライントークン・リクエストはアイドル・タイムアウトになります。この設定は、オフライントークンのアイドル・タイムアウトをオフライン・セッションのアイドルよりも短くするものです。ユーザーは、個々のクライアントに対してこの設定をオーバーライドできます。この設定はオプションで、0に設定すると、オフライン・セッション・アイドルの設定と同じアイドル・タイムアウトが使用されます。"

msgid "Client Offline Session Max"
msgstr "Offline Session Idle"

msgid ""
"This setting is for <<_offline-access, offline access>>. The maximum time "
"before an offline token expires and invalidates. This setting specifies a "
"shorter token timeout than an offline session timeout, but users can "
"override it for individual clients. This setting is an optional "
"configuration and, when set to zero, uses the same idle timeout in the "
"Offline Session Max configuration."
msgstr ""
"この設定は<<_offline-access, "
"オフライン・アクセス>>のためのものです。オフライントークンの有効期限が切れて無効になるまでの最大時間です。この設定は、オフラインセッション・タイムアウトよりも短いトークン・タイムアウトを指定しますが、ユーザーが個々のクライアントに対してオーバーライドすることができます。この設定はオプションで、0に設定すると、Offline"
" Session Maxの設定と同じアイドル・タイムアウトが使用されます。"

msgid "Client Session Idle"
msgstr "Client Session Idle"

msgid ""
"If the user is inactive for longer than this timeout, refresh token requests"
" bump the idle timeout. This setting specifies a shorter idle timeout of "
"refresh tokens than the session idle timeout, but users can override it for "
"individual clients. This setting is an optional configuration and, when set "
"to zero, uses the same idle timeout in the SSO Session Idle configuration."
msgstr ""
"ユーザーがこのタイムアウトより長く非アクティブの場合、リフレッシュトークン・リクエストはアイドル・タイムアウトになります。この設定では、リフレッシュトークンのアイドル・タイムアウトをセッション・アイドル・タイムアウトよりも短く指定しますが、ユーザーが個々のクライアントに対してオーバーライドすることができます。この設定はオプションで、0に設定すると、SSO"
" Session Idleの設定と同じアイドル・タイムアウトが使用されます。"

msgid "Client Session Max"
msgstr "Client Session Max"

msgid ""
"The maximum time before a refresh token expires and invalidates. This "
"setting specifies a shorter timeout of refresh tokens than the session "
"timeout, but users can override it for individual clients. This setting is "
"an optional configuration and, when set to zero, uses the same idle timeout "
"in the SSO Session Max configuration."
msgstr ""
"リフレッシュトークンが期限切れで無効になるまでの最大時間。この設定は、セッション・タイムアウトよりも短いリフレッシュトークンのタイムアウトを指定しますが、ユーザーが個々のクライアントに対してオーバーライドすることができます。この設定はオプションで、0に設定すると、SSO"
" Session Maxの設定のアイドル・タイムアウトと同じものが使用されます。"

msgid "Access Token Lifespan"
msgstr "Access Token Lifespan"

msgid ""
"When {project_name} creates an OIDC access token, this value controls the "
"lifetime of the token."
msgstr "{project_name}がOIDCのアクセストークンを作成する際に、この値でトークンの有効期間を制御します。"

msgid "Access Token Lifespan For Implicit Flow"
msgstr "Access Token Lifespan For Implicit Flow"

msgid ""
"With the Implicit Flow, {project_name} does not provide a refresh token. A "
"separate timeout exists for access tokens created by the Implicit Flow."
msgstr ""
"インプリシット・フローでは、{project_name}はリフレッシュトークンを提供しません。インプリシット・フローで作成されたアクセストークンには、別途タイムアウトが存在します。"

msgid "Client login timeout"
msgstr "Client login timeout"

msgid ""
"The maximum time before clients must finish the Authorization Code Flow in "
"OIDC."
msgstr "クライアントがOIDCの認可コードフローを終了するまでの最大時間。"

msgid "Login timeout"
msgstr "Login timeout"

msgid ""
"The total time a logging in must take. If authentication takes longer than "
"this time, the user must start the authentication process again."
msgstr "ログインにかかる合計時間です。認証にこの時間以上かかる場合は、再度認証を開始する必要があります。"

msgid "Login action timeout"
msgstr "Login action timeout"

msgid ""
"The Maximum time users can spend on any one page during the authentication "
"process."
msgstr "認証プロセスにおいて、ユーザーが1つのページに滞在できる最大時間。"

msgid "User-Initiated Action Lifespan"
msgstr "User-Initiated Action Lifespan"

msgid ""
"The maximum time before a user's action permission expires. Keep this value "
"short because users generally react to self-created actions quickly."
msgstr ""
"ユーザーのアクション・パーミッションが失効するまでの最大時間です。一般的に、ユーザーは自分で作成したアクションにすぐに反応するため、この値は短くしてください。"

msgid "Default Admin-Initiated Action Lifespan"
msgstr "Default Admin-Initiated Action Lifespan"

msgid ""
"The maximum time before an action permission sent to a user by an "
"administrator expires. Keep this value long to allow administrators to send "
"e-mails to offline users. An administrator can override the default timeout "
"before issuing the token."
msgstr ""
"管理者がユーザーに送信したアクション・パーミッションが期限切れになるまでの最大時間です。オフラインのユーザーに管理者がメールを送信できるように、この値は長くしてください。管理者はトークンを発行する前に、デフォルトのタイムアウトをオーバーライドすることができます。"

msgid "Override User-Initiated Action Lifespan"
msgstr "Override User-Initiated Action Lifespan"

msgid ""
"Specifies independent timeouts per individual operation (for example, e-mail"
" verification, forgot password, user actions, and Identity Provider E-mail "
"Verification). This value defaults to the value configured at _User-"
"Initiated Action Lifespan_."
msgstr ""
"個々の操作ごとに独立したタイムアウトを指定します（たとえば、電子メール検証、パスワード忘れ、ユーザーアクション、アイデンティティー・プロバイダーの電子メール検証など）。この値のデフォルトは、"
" _User-Initiated Action Lifespan_ で設定された値です。"

msgid ""
"For idle timeouts, a two-minute window of time exists that the session is "
"active. For example, when you have the timeout set to 30 minutes, it will be"
" 32 minutes before the session expires."
msgstr ""
"アイドル・タイムアウトの場合、セッションがアクティブである2分間のウィンドウが存在します。たとえば、タイムアウトを30分に設定した場合、セッションが終了するのは32分後となります。"

msgid ""
"This action is necessary for some scenarios in cluster and cross-data center"
" environments where the token refreshes on one cluster node a short time "
"before the expiration and the other cluster nodes incorrectly consider the "
"session as expired because they have not yet received the message about a "
"successful refresh from the refreshing node."
msgstr ""
"このアクションは、クラスターおよびクロス・データセンター環境において、あるクラスターノードで有効期限より少し前にトークンがリフレッシュされ、他のクラスターノードがリフレッシュノードからリフレッシュ成功のメッセージをまだ受け取っていないため、誤ってセッションを期限切れと見なす場合に必要です。"

msgid "Offline access"
msgstr "オフライン・アクセス"

msgid ""
"During https://openid.net/specs/openid-connect-"
"core-1_0.html#OfflineAccess[offline access] logins, the client application "
"requests an offline token instead of a refresh token. The client application"
" saves this offline token and can use it for future logins if the user logs "
"out. This action is useful if your application needs to perform offline "
"actions on behalf of the user even when the user is not online. For example,"
" a regular data backup."
msgstr ""
"https://openid.net/specs/openid-connect-"
"core-1_0.html#OfflineAccess[オフライン・アクセス] "
"ログイン時、クライアント・アプリケーションはリフレッシュトークンの代わりにオフライントークンを要求します。クライアント・アプリケーションはこのオフライントークンを保存し、ユーザーがログアウトした場合、次回以降のログインに使用できます。このアクションは、ユーザーがオンラインでないときでも、アプリケーションでユーザーに代わってオフライン・アクションを実行する必要がある場合に便利です。たとえば、定期的なデータのバックアップなどです。"

msgid ""
"The client application is responsible for persisting the offline token in "
"storage and then using it to retrieve new access tokens from the "
"{project_name} server."
msgstr ""
"クライアント・アプリケーションは、オフライントークンをストレージに永続化し、それを使用して{project_name}サーバーから新しいアクセストークンを取得する責任を負います。"

msgid ""
"The difference between a refresh token and an offline token is that an "
"offline token never expires and is not subject to the `SSO Session Idle` "
"timeout and `SSO Session Max` lifespan. The offline token is valid after a "
"user logout or server restart. You must use the offline token for a refresh "
"token action at least once per thirty days or for the value of the "
"<<_offline-session-idle, Offline Session Idle>>."
msgstr ""
"リフレッシュトークンとオフライントークンの違いは、オフライントークンは有効期限がなく、 `SSO Session Idle` タイムアウトと `SSO "
"Session Max` "
"ライフタイムの対象外であることです。オフライントークンは、ユーザーによるログアウトやサーバーの再起動後も有効です。オフライントークンは、少なくとも30日間に1回、トークン更新アクションに使用するか、<<_offline-"
"session-idle,  Offline Session Idle>>の値に対して使用する必要があります。"

msgid ""
"If you enable <<_offline-session-max-limited, Offline Session Max Limited>>,"
" offline tokens expire after 60 days even if you use the offline token for a"
" refresh token action. You can change this value, <<_offline-session-max, "
"Offline Session Max>>, in the Admin Console."
msgstr ""
"<<_offline-session-max-limited, Offline Session Max "
"Limited>>を有効にすると、オフライントークンをトークン更新アクションに使用した場合でも、オフライントークンは60日後に失効します。この値は、管理コンソールの<<_offline-"
"session-max, Offline Session Max>>で変更することができます。"

msgid ""
"If you enable the <<_revoke-refresh-token, Revoke Refresh Token>> option, "
"you can use each offline token once only. After refresh, you must store the "
"new offline token from the refresh response instead of the previous one."
msgstr ""
"<<_revoke-refresh-token, Revoke Refresh "
"Token>>オプションを有効にすると、1つのオフライントークンは1回だけ使用することができます。リフレッシュ後は、以前のオフライントークンではなく、リフレッシュ時のレスポンスから新しいオフライントークンを保存する必要があります。"

msgid ""
"Users can view and revoke offline tokens that {project_name} grants them in "
"the <<_account-service, User Account Console>>. Administrators can revoke "
"offline tokens for individual users in the Admin Console in the `Consents` "
"tab. Administrators can view all offline tokens issued in the `Offline "
"Access` tab of each client. Administrators can revoke offline tokens by "
"setting a <<_revocation-policy, revocation policy>>."
msgstr ""
"ユーザーは、{project_name}が自分に付与したオフライン・トークンを<<_account-service, "
"ユーザー・アカウント・コンソール>>で表示したり取り消したりすることができます。管理者は、管理コンソールの `Consents` "
"タブで、個々のユーザーのオフライントークンを取り消すことができます。管理者は、各クライアントの `Offline Access` "
"タブで発行されたすべてのオフライントークンを確認できます。管理者は、<<_revocation-policy, "
"失効ポリシー>>を設定することでオフライントークンを失効させることができます。"

msgid ""
"To issue an offline token, users must have the role mapping for the realm-"
"level `offline_access` role. Clients must also have that role in their "
"scope. Clients must add an `offline_access` client scope as an `Optional "
"client scope` to the role, which is done by default."
msgstr ""
"オフライントークンを発行するには、ユーザーはレルムレベルの `offline_access` "
"ロールのロールマッピングを持っている必要があります。また、クライアントはそのロールをスコープに持つ必要があります。クライアントは、`offline_access`"
" クライアント・スコープを `Optional client scope` としてロールに追加しなければなりませんが、これはデフォルトで行われます。"

msgid ""
"Clients can request an offline token by adding the parameter "
"`scope=offline_access` when sending their authorization request to "
"{project_name}. The {project_name} OIDC client adapter automatically adds "
"this parameter when you use it to access your application's secured URL "
"(such as, $$http://localhost:8080/customer-"
"portal/secured?scope=offline_access$$). The Direct Access Grant and Service "
"Accounts support offline tokens if you include `scope=offline_access` in the"
" authentication request body."
msgstr ""
"クライアントは、{project_name}に認可リクエストを送る際に `scope=offline_access` "
"というパラメーターを追加することで、オフライントークンを要求することができます。{project_name}は、オフライントークンを要求することができます。OIDCクライアント・アダプターを使用してアプリケーションのセキュリティーで保護されたURL（$$http://localhost:8080/customer-"
"portal/secured?scope=offline_access$$など）にアクセスすると、このパラメーターが自動的に追加されます。Direct "
"Access Grant and Service Accountsでは、認証リクエストのボディーに `scope=offline_access` "
"を含めるとオフライントークンをサポートします。"

msgid "Offline sessions preloading"
msgstr "オフライン・セッションの事前読み込み"

msgid ""
"In addition to {jdgserver_name} caches, offline sessions are stored in a "
"database which means they will be available even after server restart. By "
"default, the offline sessions are preloaded from the database into the "
"{jdgserver_name} caches during the server startup. However this approach has"
" a drawback if there are many offline sessions to be preloaded. It can "
"significantly slow down the server startup time."
msgstr ""
"{jdgserver_name}キャッシュに加えて、オフライン・セッションはデータベースに保存されます。つまり、サーバーの再起動後もオフライン・セッションを利用できます。デフォルトでは、オフライン・セッションは、サーバーの起動時にデータベースから{jdgserver_name}キャッシュにプリロードされます。ただし、プリロードするオフライン・セッションが多数ある場合、このアプローチには欠点があります。サーバーの起動時間が大幅に遅くなる可能性があります。"

msgid ""
"To overcome this problem, {project_name} can be configured to fetch offline "
"sessions into the {jdgserver_name} caches on demand. It can be achieved by "
"setting `preloadOfflineSessionsFromDatabase` property in `userSessions` SPI "
"to `false`."
msgstr ""
"この問題を克服するために、{project_name}は、オフライン・セッションをオンデマンドで{jdgserver_name}キャッシュにフェッチするように設定できます。これは、"
" `userSessions` SPIの `preloadOfflineSessionsFromDatabase` プロパティーを `false` "
"に設定することで実現できます。"

msgid ""
"The following example shows how to configure lazy offline sessions loading."
msgstr "次の例は、遅延オフライン・セッション・ローディングを設定する方法を示しています。"

msgid ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:1.1\">\n"
"    ...\n"
"    <spi name=\"userSessions\">\n"
"        <default-provider>infinispan</default-provider>\n"
"        <provider name=\"infinispan\" enabled=\"true\">\n"
"            <properties>\n"
"                <property name=\"preloadOfflineSessionsFromDatabase\" value=\"false\"/>\n"
"            </properties>\n"
"        </provider>\n"
"    </spi>\n"
"    ...\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:1.1\">\n"
"    ...\n"
"    <spi name=\"userSessions\">\n"
"        <default-provider>infinispan</default-provider>\n"
"        <provider name=\"infinispan\" enabled=\"true\">\n"
"            <properties>\n"
"                <property name=\"preloadOfflineSessionsFromDatabase\" value=\"false\"/>\n"
"            </properties>\n"
"        </provider>\n"
"    </spi>\n"
"    ...\n"
"</subsystem>"

msgid "Equivalent configuration using CLI commands:"
msgstr "CLIコマンドを使用した同等の設定は以下になります。"

msgid ""
"/subsystem=keycloak-server/spi=userSessions:add(default-provider=infinispan)\n"
"/subsystem=keycloak-server/spi=userSessions/provider=infinispan:add(properties={preloadOfflineSessionsFromDatabase => \"false\"},enabled=true)"
msgstr ""
"/subsystem=keycloak-server/spi=userSessions:add(default-provider=infinispan)\n"
"/subsystem=keycloak-server/spi=userSessions/provider=infinispan:add(properties={preloadOfflineSessionsFromDatabase => \"false\"},enabled=true)"

msgid "Transient sessions"
msgstr "トランジェント・セッション"

msgid ""
"You can conduct transient sessions in {project_name}. When using transient "
"sessions, {project_name} does not create a user session after successful "
"authentication. {project_name} creates a temporary, transient session for "
"the scope of the current request that successfully authenticates the user. "
"{project_name} can run <<_protocol-mappers, protocol mappers>> using "
"transient sessions after authentication."
msgstr ""
"{project_name}では、トランジェント・セッションを使用することができます。トランジェント・セッションを使用する場合、{project_name}は認証に成功した後にユーザー・セッションを作成しません。{project_name}は、ユーザー認証に成功した現在のリクエストのスコープに一時的なトランジェント・セッションを作成します。{project_name}は、認証後にトランジェント・セッションを使用して<<_protocol-"
"mappers, プロトコル・マッパー>>を実行することができます。"

msgid ""
"During transient sessions, the client application cannot refresh tokens, "
"introspect tokens, or validate a specific session. Sometimes these actions "
"are unnecessary, so you can avoid the additional resource use of persisting "
"user sessions. This session saves performance, memory, and network "
"communication (in cluster and cross-data center environments) resources."
msgstr ""
"トランジェント・セッションの間、クライアント・アプリケーションはトークンのリフレッシュ、トークンのイントロスペクト、または特定のセッションの検証を行うことができません。これらのアクションが不要な場合もあるため、ユーザー・セッションを永続化することによるリソースの追加使用を避けることができます。このセッションは、パフォーマンス、メモリー、およびネットワーク通信（クラスターおよびクロス・データセンター環境）のリソースを節約します。"

msgid "Assigning permissions and access using roles and groups"
msgstr "ロールやグループを使用したパーミッションやアクセスの割り当て"

msgid ""
"Roles and groups have a similar purpose, which is to give users access and "
"permissions to use applications. Groups are a collection of users to which "
"you apply roles and attributes. Roles define specific applications "
"permissions and access control."
msgstr ""
"ロールとグループは、アプリケーションを使用するためのアクセスやパーミッションをユーザーに与えるという、似たような目的を持っています。グループは、ロールや属性を適用するユーザーの集合体です。ロールは、特定のアプリケーションのパーミッションとアクセス・コントロールを定義します。"

msgid ""
"A role typically applies to one type of user. For example, an organization "
"may include `admin`, `user`, `manager`, and `employee` roles. An application"
" can assign access and permissions to a role and then assign multiple users "
"to that role so the users have the same access and permissions. For example,"
" the Admin Console has roles that give permission to users to access "
"different parts of the Admin Console."
msgstr ""
"ロールは通常、1種類のユーザーに適用されます。たとえば、ある組織では　 `admin` 、 `user` 、 `manager` 、 そして "
"`employee` "
"というロールがあります。アプリケーションはロールにアクセスやパーミッションを割り当て、複数のユーザーをそのロールに割り当てて、ユーザーが同じアクセスやパーミッションを持てるようにすることができます。たとえば、管理コンソールには、管理コンソールのさまざまな部分にアクセスするためのパーミッションをユーザーに与えるロールがあります。"

msgid ""
"There is a global namespace for roles and each client also has its own "
"dedicated namespace where roles can be defined."
msgstr "ロールのためのグローバルな名前空間があり、各クライアントもロールを定義できる専用の名前空間を持っています。"

msgid "Creating a realm role"
msgstr "レルムロールの作成"

msgid ""
"Realm-level roles are a namespace for defining your roles. To see the list "
"of roles, click *Roles* in the menu."
msgstr "レルムレベルのロールは、ロールを定義するための名前空間です。ロールの一覧を表示するには、メニューの *Roles* をクリックします。"

msgid "image:{project_images}/roles.png[]"
msgstr "image:{project_images}/roles.png[]"

msgid "Click *Add Role*."
msgstr "*Add Role* をクリックします。"

msgid "Enter a *Role Name*."
msgstr "*Role Name* を入力します。"

msgid "Enter a *Description*."
msgstr "*Description* を入力します。"

msgid "Add role"
msgstr "ロールの追加"

msgid "image:{project_images}/role.png[Add role]"
msgstr "image:{project_images}/role.png[Add role]"

msgid ""
"The *description* field can be localizable by specifying a substitution "
"variable with `$\\{var-name}` strings. The localized value is configured to "
"your theme within the themes property files. See the "
"link:{developerguide_link}[{developerguide_name}] for more details."
msgstr ""
"*description* フィールドは、置換変数に `$${var-name}}` "
"という文字列を指定することでローカライズすることができます。ローカライズされた値は、テーマのプロパティー・ファイルの中で、あなたのテーマに設定されます。詳しくは"
" link:{developerguide_link}[{developerguide_name}] を参照してください。"

msgid "Client roles"
msgstr "クライアントロール"

msgid ""
"Client roles are namespaces dedicated to clients. Each client gets its own "
"namespace. Client roles are managed under the *Roles* tab for each client. "
"You interact with this UI the same way you do for realm-level roles."
msgstr ""
"クライアントロールは、クライアント専用の名前空間です。各クライアントは独自の名前空間を取得します。クライアントロールは、個々のクライアントの "
"*Roles* タブで管理されます。レルムレベルのロールと同じ方法で、このUIとやりとりします。"

msgid "Converting a role to a composite role"
msgstr "ロールを複合ロールに変換する"

msgid ""
"Any realm or client level role can become a _composite role_. A _composite "
"role_ is a role that has one or more additional roles associated with it. "
"When a composite role is mapped to a user, the user gains the roles "
"associated with the composite role.  This inheritance is recursive so users "
"also inherit any composite of composites. However, we recommend that "
"composite roles are not overused."
msgstr ""
"レルムレベルまたはクライアントレベルのロールはすべて、 _複合ロール_ "
"にすることができます。複合ロールとは、1つ以上のロールを関連付けたロールのことです。複合ロールがユーザーにマップされると、そのユーザーは複合ロールに関連付けられたロールを継承します。この継承は再帰的であるため、ユーザーは複合ロールの複合ロールをも継承します。ただし、複合ロールは使いすぎないようにすることをお勧めします。"

msgid "Click *Roles* in the menu."
msgstr "メニューの *Roles* をクリックします。"

msgid "Click the role that you want to convert."
msgstr "変換するロールをクリックします。"

msgid "Toggle *Composite Roles* to *ON*."
msgstr "*Composite Roles* を *ON* にします。"

msgid "Composite role"
msgstr "複合ロール"

msgid "image:{project_images}/composite-role.png[Composite role]"
msgstr "image:{project_images}/composite-role.png[Composite role]"

msgid ""
"The role selection UI is displayed on the page and you can associate realm "
"level and client level roles to the composite role you are creating."
msgstr "ロールを選択するUIが表示され、作成中の複合ロールにレルムレベルとクライアントレベルのロールを関連付けることができます。"

msgid ""
"In this example, the *employee* realm-level role is associated with the "
"*developer* composite role.  Any user with the *developer* role also "
"inherits the *employee* role."
msgstr ""
"この例では、 *employee* レルムレベルロールは *developer* 複合ロールと関連付けられています。 *developer* "
"ロールを持つユーザーは、 *employee* ロールも継承します。"

msgid ""
"When creating tokens and SAML assertions, any composite also has its "
"associated roles added to the claims and assertions of the authentication "
"response sent back to the client."
msgstr ""
"トークンおよびSAMLアサーションを作成する場合、どの複合ロールでも、関連するロールがクライアントに返される認証レスポンスのクレームおよびアサーションに追加されます。"

msgid "Assigning role mappings"
msgstr "ロールマッピングの割り当て"

msgid ""
"You can assign role mappings to a user through the *Role Mappings* tab for "
"that user."
msgstr "ロールマッピングは、そのユーザーの *Role Mappings* タブで割り当てることができます。"

msgid ""
"Click the user that you want to perform a role mapping on. If the user is "
"not displayed, click *View all users*."
msgstr ""
"ロールマッピングを行いたいユーザーをクリックします。ユーザーが表示されていない場合は、 *View all users* をクリックします。"

msgid ""
"Click the role you want to assign to the user in the *Available Roles* box."
msgstr "*Available Roles* のボックスで、ユーザーに割り当てるロールをクリックします。"

msgid "Role mappings"
msgstr "ロールマッピング"

msgid "image:{project_images}/user-role-mappings.png[Role mappings]"
msgstr "image:{project_images}/user-role-mappings.png[Role mappings]"

msgid ""
"In the preceding example, we are assigning the composite role *developer* to"
" a user. That role was created in the <<_composite-roles, Composite Roles>> "
"topic."
msgstr ""
"この例では、あるユーザーに対して複合ロール *developer* を割り当てています。このロールは<<_composite-roles, "
"複合ロール>>のトピックで作成されました。"

msgid "Effective role mappings"
msgstr "効果的なロールマッピング"

msgid ""
"image:{project_images}/effective-role-mappings.png[Effective role mappings]"
msgstr ""
"image:{project_images}/effective-role-mappings.png[Effective role mappings]"

msgid ""
"When the *developer* role is assigned, the *employee* role associated with "
"the *developer* composite is displayed in the *Effective Roles* box. "
"*Effective Roles* are the roles explicitly assigned to users and roles that "
"are inherited from composites."
msgstr ""
"*developer* ロールが割り当てられると、 *developer* コンポジットに関連付けられた *employee* ロールが "
"*Effective Roles* ボックスに表示されます。 *Effective Roles* "
"とは、ユーザーに明示的に割り当てられたロールと、複合ロールから継承されたロールのことです。"

msgid "Using default roles"
msgstr "デフォルトロールの使用"

msgid ""
"Use default roles to automatically assign user role mappings when a user is "
"created or imported through <<_identity_broker, Identity Brokering>>."
msgstr ""
"デフォルトロールを使用すると、<<_identity_broker, "
"アイデンティティー・ブローカリング>>でユーザーを作成またはインポートしたときに、ユーザー・ロール・マッピングを自動的に割り当てることができます。"

msgid "Click *Roles* in the menu"
msgstr "メニューの *Roles* をクリックします。"

msgid "Click the *Default Roles* tab."
msgstr "*Default Roles* タブをクリックします。"

msgid "Default roles"
msgstr "デフォルトロール"

msgid "image:{project_images}/default-roles.png[Default roles]"
msgstr "image:{project_images}/default-roles.png[Default roles]"

msgid "This screenshot shows that some _default roles_ already exist."
msgstr "このスクリーン・ショットは、いくつかの _default roles_ が既に存在していることを示しています。"

msgid "Role scope mappings"
msgstr "ロール・スコープ・マッピング"

msgid ""
"On creation of an OIDC access token or SAML assertion, the user role "
"mappings become claims within the token or assertion.  Applications use "
"these claims to make access decisions on the resources controlled by the "
"application.  {project_name} digitally signs access tokens and applications "
"re-use them to invoke remotely secured REST services.  However, these tokens"
" have an associated risk. An attacker can obtain these tokens and use their "
"permissions to compromise your networks. To prevent this situation, use "
"_Role Scope Mappings_."
msgstr ""
"OIDCのアクセストークンまたはSAMLのアサーションの作成時に、ユーザー・ロール・マッピングはトークンまたはアサーション内のクレームとなります。アプリケーションはこれらのクレームを使用して、アプリケーションによって制御されるリソースへのアクセスを決定します。{project_name}はアクセストークンにデジタル署名を行い、アプリケーションはそれを再利用してリモートでセキュリティー保護されたRESTサービスを呼び出します。しかし、これらのトークンにはリスクが伴います。攻撃者はこれらのトークンを入手し、そのパーミッションを使用してネットワークを侵害することができます。このような状況を防ぐには、_ロール・スコープ・マッピング_"
" を使用します。"

msgid ""
"_Role Scope Mappings_ limit the roles declared inside an access token.  When"
" a client requests a user authentication, the access token they receive "
"contains only the role mappings that are explicitly specified for the "
"client's scope.  The result is that you limit the permissions of each "
"individual access token instead of giving the client access to all the users"
" permissions."
msgstr ""
"_ロール・スコープ・マッピング_ は、アクセストークン内で宣言されるロールを制限します。クライアントがユーザーに認証を要求すると、 "
"受け取ったアクセストークンには、クライアントのスコープに対して "
"明示的に指定されたロールマッピングのみが含まれます。その結果、クライアントにすべてのユーザー・パーミッションへのアクセスを与える代わりに、個々のアクセストークンのパーミッションを制限することになります。"

msgid ""
"By default, each client gets all the role mappings of the user. You can view"
" the role mappings in the *Scope* tab of each client."
msgstr ""
"デフォルトでは、各クライアントはユーザーのすべてのロールマッピングを取得します。ロールマッピングは各クライアントの *Scope* タブで確認できます。"

msgid "Full scope"
msgstr "Full scope"

msgid "image:{project_images}/full-client-scope.png[Full scope]"
msgstr "image:{project_images}/full-client-scope.png[Full scope]"

msgid ""
"By default, the effective roles of scopes are every declared role in the "
"realm. To change this default behavior, toggle *Full Scope Allowed* to *ON* "
"and declare the specific roles you want in each client.  You can also use "
"<<_client_scopes, client scopes>> to define the same role scope mappings for"
" a set of clients."
msgstr ""
"デフォルトでは、スコープの有効なロールはレルム内で宣言されたすべてのロールになります。このデフォルトの動作を変更するには、*Full Scope "
"Allowed* を *ON* に切り替えて、各クライアントで必要な特定のロールを宣言します。また、<<_client_scopes, "
"クライアント・スコープ>> を使用して、一連のクライアントに対して同じロール・スコープ・マッピングを定義できます。"

msgid "Partial scope"
msgstr "Partial scope"

msgid "image:{project_images}/client-scope.png[Partial scope]"
msgstr "image:{project_images}/client-scope.png[Partial scope]"

msgid "Groups"
msgstr "グループ"

msgid ""
"Groups in {project_name} manage a common set of attributes and role mappings"
" for each user. Users can be members of any number of groups and inherit the"
" attributes and role mappings assigned to each group."
msgstr ""
"{project_name}のグループは、各ユーザーの属性とロールマッピングの共通セットを管理します。ユーザーは任意の数のグループのメンバーになることができ、各グループに割り当てられた属性とロールマッピングを継承します。"

msgid "To manage groups, click *Groups* in the menu."
msgstr "グループを管理するには、メニューの *Groups* をクリックします。"

msgid "image:{project_images}/groups.png[]"
msgstr "image:{project_images}/groups.png[]"

msgid ""
"Groups are hierarchical. A group can have multiple subgroups but a group can"
" have only one parent. Subgroups inherit the attributes and role mappings "
"from their parent. Users inherit the attributes and role mappings from their"
" parent as well."
msgstr ""
"グループは階層構造になっています。グループは複数のサブグループを持つことができますが、1つのグループは1つの親を持つことができるだけです。サブグループは、親グループの属性とロールマッピングを継承します。ユーザーは、その親から属性とロールマッピングを継承します。"

msgid ""
"If you have a parent group and a child group, and a user that belongs only "
"to the child group, the user in the child group inherits the attributes and "
"role mappings of both the parent group and the child group."
msgstr ""
"親グループと子グループがあり、子グループにのみ所属するユーザーがいる場合、子グループのユーザーは、親グループと子グループの両方の属性とロールマッピングを継承します。"

msgid ""
"The following example includes a top-level *Sales* group and a child *North "
"America* subgroup."
msgstr "次の例では、トップレベルの *Sales* グループと子グループの *North America* サブグループが含まれています。"

msgid "To add a group:"
msgstr "グループを追加するには、以下のようにします。"

msgid "Click the group."
msgstr "グループをクリックします。"

msgid "Click *New*."
msgstr "*New* をクリックします。"

msgid "Select the *Groups* icon in the tree to make a top-level group."
msgstr "ツリーの *Groups* アイコンを選択し、トップレベルのグループを作成します。"

msgid "Enter a group name in the *Create Group* screen."
msgstr "*Create Group* 画面で、グループ名を入力する。"

msgid "The group management page is displayed."
msgstr "グループ管理ページが表示されます。"

msgid "Group"
msgstr "グループ"

msgid "image:{project_images}/group.png[]"
msgstr "image:{project_images}/group.png[]"

msgid ""
"Attributes and role mappings you define are inherited by the groups and "
"users that are members of the group."
msgstr "定義した属性とロールマッピングは、グループのメンバーであるグループとユーザーに継承されます。"

msgid "To add a user to a group:"
msgstr "ユーザーをグループに追加するには、以下のようにします。"

msgid "Click *Groups*."
msgstr "*Groups* をクリックします。"

msgid "User groups"
msgstr "ユーザーグループ"

msgid "image:{project_images}/user-groups.png[]"
msgstr "image:{project_images}/user-groups.png[]"

msgid "Select a group from the *Available Groups* tree."
msgstr "*Available Groups* ツリーからグループを選択します。"

msgid "Click *Join*."
msgstr "*Join* をクリックします。"

msgid "To remove a group from a user:"
msgstr "ユーザーからグループを削除するには、以下のようにします。"

msgid "Select the group from the *Group Membership* tree."
msgstr "*Group Membership* ツリーからグループを選択します。"

msgid "Click *Leave*."
msgstr "*Leave* をクリックします。"

msgid ""
"In this example, the user _jimlincoln_ is in the _North America_ group.  You"
" can see _jimlincoln_ displayed under the *Members* tab for the group."
msgstr ""
"この例では、ユーザー_jimlincoln_ は _North America_ グループに所属しています。グループの *Members* タブに "
"_jimlincoln_ が表示されているのが確認できます。"

msgid "Group membership"
msgstr "グループ・メンバーシップ"

msgid "image:{project_images}/group-membership.png[]"
msgstr "image:{project_images}/group-membership.png[]"

msgid "Groups compared to roles"
msgstr "グループとロールの比較"

msgid ""
"Groups and roles have some similarities and differences. In {project_name}, "
"groups are a collection of users to which you apply roles and attributes. "
"Roles define types of users and applications assign permissions and access "
"control to roles."
msgstr ""
"グループとロールには、いくつかの類似点と相違点があります。{project_name}では、グループはユーザーの集まりで、これにロールと属性を適用します。ロールはユーザーの種類を定義し、アプリケーションはロールにパーミッションとアクセス・コントロールを割り当てます。"

msgid ""
"<<_composite-roles,Composite Roles>> are similar to Groups as they provide "
"the same functionality. The difference between them is conceptual. Composite"
" roles apply the permission model to a set of services and applications. Use"
" composite roles to manage applications and services."
msgstr ""
"<<_composite-"
"roles,複合ロール>>は、同じ機能を提供するため、グループと似ています。両者の違いは概念的なものです。複合ロールは、一連のサービスおよびアプリケーションにパーミッション・モデルを適用します。アプリケーションとサービスを管理するには、複合ロールを使用します。"

msgid ""
"Groups focus on collections of users and their roles in an organization. Use"
" groups to manage users."
msgstr "グループは、組織内のユーザーとそのロールの集合体にフォーカスします。ユーザーを管理するには、グループを使用します。"

msgid "Using default groups"
msgstr "デフォルト・グループの使用"

msgid ""
"To automatically assign group membership to any users who is created or who "
"is imported through <<_identity_broker, Identity Brokering>>, you use "
"default groups."
msgstr ""
"作成されたユーザーや<<_identity_broker, "
"アイデンティティー・ブローカリング>>でインポートされたユーザーに自動的にグループメンバーを割り当てるには、デフォルト・グループを使用します。"

msgid "Click *Groups* in the menu."
msgstr "メニューの *Groups* をクリックします。"

msgid "Click the *Default Groups* tab."
msgstr "*Default Groups* タブをクリックします。"

msgid "Default groups"
msgstr "デフォルト・グループ"

msgid "image:{project_images}/default-groups.png[Default groups]"
msgstr "image:{project_images}/default-groups.png[Default groups]"

msgid "This screenshot shows that some _default groups_ already exist."
msgstr "このスクリーン・ショットは、いくつかの _default groups_ が既に存在していることを示しています。"

msgid "Configuring authentication"
msgstr "認証の設定"

msgid ""
"This chapter covers several authentication topics. These topics include:"
msgstr "この章では、いくつかの認証に関するトピックを取り上げます。これらのトピックは以下のとおりです。"

msgid "Enforcing strict password and One Time Password (OTP) policies."
msgstr "厳格なパスワードとワンタイム・パスワード（OTP）ポリシーの実施"

msgid "Managing different credential types."
msgstr "異なるクレデンシャル・タイプの管理"

msgid "Logging in with Kerberos."
msgstr "Kerberosによるログイン"

msgid "Disabling and enabling built-in credential types."
msgstr "組み込みのクレデンシャル・タイプの無効化および有効化"

msgid "Password policies"
msgstr "パスワードポリシー"

msgid ""
"When {project_name} creates a realm, it does not associate password policies"
" with the realm. You can set a simple password with no restrictions on its "
"length, security, or complexity. Simple passwords are unacceptable in "
"production environments. {project_name} has a set of password policies "
"available through the Admin Console."
msgstr ""
"{project_name}がレルムを作成するとき、パスワード・ポリシーをレルムに関連付けません。長さ、セキュリティー、複雑さに制限のない単純なパスワードを設定できます。単純なパスワードは、プロダクション環境では受け入れられません。{project_name}には、管理コンソールで利用可能なパスワード・ポリシーのセットがあります。"

msgid "Click the *Password Policy* tab."
msgstr "*Password Policy* タブをクリックします。"

msgid "Select the policy to add in the *Add policy* drop-down box."
msgstr "追加するポリシーを *Add policy* ドロップダウン・ボックスで選択します。"

msgid ""
"Enter a value for the *Policy Value* corresponding with the policy chosen."
msgstr "選択したポリシーに対応する *Policy Value* に値を入力します。"

msgid ""
"Password policy image:{project_images}/password-policy.png[Password Policy]"
msgstr ""
"Password policy image:{project_images}/password-policy.png[Password Policy]"

msgid ""
"After saving the policy, {project_name} enforces the policy for new users "
"and sets an Update Password action for existing users to ensure they change "
"their password the next time they log in. For example:"
msgstr ""
"ポリシーを保存した後、{project_name}は新しいユーザーに対してポリシーを適用し、既存のユーザーに対しては、次回ログイン時にパスワードが変更されるようにパスワードの更新アクションを設定します。たとえば、次のようになります。"

msgid "Failed password policy"
msgstr "Failed password policy"

msgid ""
"image:{project_images}/failed-password-policy.png[Failed Password Policy]"
msgstr ""
"image:{project_images}/failed-password-policy.png[Failed Password Policy]"

msgid "Password policy types"
msgstr "Password policy types"

msgid "HashAlgorithm"
msgstr "HashAlgorithm"

msgid ""
"Passwords are not stored in cleartext. Before storage or validation, "
"{project_name} hashes passwords using standard hashing algorithms. PBKDF2 is"
" the only built-in and default algorithm available. See the "
"link:{developerguide_link}[{developerguide_name}] on how to add your own "
"hashing algorithm."
msgstr ""
"パスワードは平文で保存されません。保存や検証の前に、{project_name}は標準的なハッシュ・アルゴリズムでパスワードをハッシュします。PBKDF2"
" は、組み込みで利用可能な唯一のデフォルトのアルゴリズムです。独自のハッシュアルゴリズムを追加する方法については、 "
"link:{developerguide_link}[{developerguide_name}] を参照してください。"

msgid ""
"If you change the hashing algorithm, password hashes in storage will not "
"change until the user logs in."
msgstr "ハッシュ・アルゴリズムを変更した場合、ユーザーがログインするまで、ストレージ内のパスワード・ハッシュは変更されません。"

msgid "Hashing iterations"
msgstr "Hashing iterations"

msgid ""
"Specifies the number of times {project_name} hashes passwords before storage"
" or verification. The default value is 27,500."
msgstr "保存または検証前に{project_name}がパスワードをハッシュ化する回数を指定します。初期値は27,500回です。"

msgid ""
"{project_name} hashes passwords to ensure that hostile actors with access to"
" the password database cannot read passwords through reverse engineering."
msgstr ""
"{project_name}は、パスワード・データベースにアクセスできる敵対的な行為者がリバース・エンジニアリングによってパスワードを読み取れないようにするためにパスワードをハッシュ化します。"

msgid ""
"A high hashing iteration value can impact performance as it requires higher "
"CPU power."
msgstr "ハッシュ化の繰り返し値が大きいと、より高いCPUパワーを必要とするため、パフォーマンスに影響を与える可能性があります。"

msgid "Digits"
msgstr "Digits"

msgid "The number of numerical digits required in the password string."
msgstr "パスワード文字列に必要な数値の桁数。"

msgid "Lowercase characters"
msgstr "Lowercase characters"

msgid "The number of lower case letters required in the password string."
msgstr "パスワード文字列に必要な小文字の数。"

msgid "Uppercase characters"
msgstr "Uppercase characters"

msgid "The number of upper case letters required in the password string."
msgstr "パスワード文字列に必要な大文字の数。"

msgid "Special characters"
msgstr "Special characters"

msgid "The number of special characters required in the password string."
msgstr "パスワード文字列に必要な特殊文字の数。"

msgid "Not username"
msgstr "Not username"

msgid "The password cannot be the same as the username."
msgstr "パスワードはユーザー名と同じにすることはできません。"

msgid "Not email"
msgstr "Not email"

msgid "The password cannot be the same as the email address of the user."
msgstr "パスワードは、ユーザーの電子メールアドレスと同じにはできません。"

msgid "Regular expression"
msgstr "Regular expression"

msgid "Password must match one or more defined regular expression patterns."
msgstr "パスワードは、定義された1つ以上の正規表現パターンに一致する必要があります。"

msgid "Expire password"
msgstr "Expire password"

msgid ""
"The number of days the password is valid. When the number of days has "
"expired, the user must change their password."
msgstr "パスワードの有効日数です。日数が過ぎると、ユーザーはパスワードを変更する必要があります。"

msgid "Not recently used"
msgstr "Not recently used"

msgid ""
"Password cannot be already used by the user. {project_name} stores a history"
" of used passwords. The number of old passwords stored is configurable in "
"{project_name}."
msgstr ""
"パスワードは、ユーザーが既に使用しているものではありません。{project_name}は、使用されたパスワードの履歴を保存します。古いパスワードの保存数は{project_name}で設定可能です。"

msgid "Password blacklist"
msgstr "Password blacklist"

msgid "Password must not be in a blacklist file."
msgstr "パスワードは、ブラックリスト・ファイルに含まれていてはいけません。"

msgid ""
"Blacklist files are UTF-8 plain-text files with Unix line endings. Every "
"line represents a blacklisted password."
msgstr ""
"ブラックリスト・ファイルは、UTF-8のプレーンなテキストファイルで、Unixの行末を使用しています。各行はブラックリストに登録されたパスワードを表します。"

msgid ""
"{project_name} compares passwords in a case-insensitive manner. All "
"passwords in the blacklist must be lowercase."
msgstr ""
"{project_name}は、大文字と小文字を区別せずにパスワードを比較します。ブラックリストに登録するパスワードはすべて小文字でなければなりません。"

msgid ""
"The value of the blacklist file must be the name of the blacklist file."
msgstr "ブラックリスト・ファイルの値は、ブラックリスト・ファイルの名前でなければならない。"

msgid ""
"Blacklist files resolve against `${jboss.server.data.dir}/password-"
"blacklists/` by default. Customize this path using:"
msgstr ""
"ブラックリストファイルは、デフォルトで `${jboss.server.data.dir}/password-blacklists/` "
"に対して解決されます。このパスをカスタマイズするには次のプロパティーを使用します。"

msgid "The `keycloak.password.blacklists.path` property."
msgstr "`keycloak.password.blacklists.path` プロパティー。"

msgid ""
"The `blacklistsPath` property of the `passwordBlacklist` policy SPI "
"configuration."
msgstr "`passwordBlacklist` ポリシーSPIの設定の `blacklistsPath` プロパティー。"

msgid "One Time Password (OTP) policies"
msgstr "ワンタイムパスワード（OTP）ポリシー"

msgid ""
"{project_name} has several policies for setting up a FreeOTP or Google "
"Authenticator One-Time Password generator. Click the *Authentication* menu "
"and click the *OTP Policy* tab."
msgstr ""
"{project_name}には、FreeOTPやGoogle "
"Authenticatorのワンタイム・パスワード・ジェネレーターを設定するためのポリシーがいくつかあります。 *Authentication* "
"メニューをクリックし、 *OTP Policy* タブをクリックします。"

msgid "Otp policy"
msgstr "OTPポリシー"

msgid "image:{project_images}/otp-policy.png[OTP Policy]"
msgstr "image:{project_images}/otp-policy.png[OTP Policy]"

msgid ""
"{project_name} generates a QR code on the OTP set-up page, based on "
"information configured in the *OTP Policy* tab. FreeOTP and Google "
"Authenticator scan the QR code when configuring OTP."
msgstr ""
"{project_name}は、 *OTP Policy* "
"タブで設定した情報を元に、OTP設定画面でQRコードを生成します。FreeOTPとGoogle "
"Authenticatorは、OTP設定時にこのQRコードを読み取ります。"

msgid "Time-based or counter-based one time passwords"
msgstr "タイムベースまたはカウンターベースのワンタイムパスワード"

msgid ""
"The algorithms available in {project_name} for your OTP generators are time-"
"based and counter-based."
msgstr "OTPジェネレーターに使用できる{project_name}のアルゴリズムは、タイムベースとカウンターベースがあります。"

msgid ""
"With Time-Based One Time Passwords (TOTP), the token generator will hash the"
" current time and a shared secret.  The server validates the OTP by "
"comparing the hashes within a window of time to the submitted value.  TOTPs "
"are valid for a short window of time."
msgstr ""
"タイムベースのワンタイムパスワード（TOTP）では、トークン生成器が現在の時刻と共有のシークレットをハッシュ化します。サーバーは、時間枠内のハッシュと提出された値を比較することで、OTPを検証します。TOTPは、短い時間枠の中で有効です。"

msgid ""
"With Counter-Based One Time Passwords (HOTP), {project_name} uses a shared "
"counter rather than the current time. The {project_name} server increments "
"the counter with each successful OTP login. Valid OTPs change after a "
"successful login."
msgstr ""
"カウンターベースのワンタイムパスワード（HOTP）では、{project_name} "
"は現在時刻ではなく、共有カウンターを使用します。project_name}サーバーは、OTPログインが成功するたびにカウンターを増加させる。有効なOTPはログインに成功すると変化します。"

msgid ""
"TOTP is more secure than HOTP because the matchable OTP is valid for a short"
" window of time, while the OTP for HOTP is valid for an indeterminate amount"
" of time. HOTP is more user-friendly than TOTP because no time limit exists "
"to enter the OTP."
msgstr ""
"TOTPは、HOTPのOTPが不定期に有効なのに対し、マッチング可能なOTPが短時間で有効なため、HOTPよりも安全性が高い。HOTPは、OTPの入力に時間制限がないため、TOTPよりもユーザーフレンドリーである。"

msgid ""
"HOTP requires a database update every time the server increments the "
"counter. This update is a performance drain on the authentication server "
"during heavy load. To increase efficiency,  TOTP does not remember passwords"
" used, so there is no need to perform database updates. The drawback is that"
" it is possible to re-use TOTPs in the valid time interval."
msgstr ""
"HOTPは、サーバーがカウンターをインクリメントするたびに、データベースの更新を必要とします。この更新は、高負荷時に認証サーバーのパフォーマンスを低下させる。効率を上げるため、TOTPは使用したパスワードを記憶しないので、データベースの更新を行う必要はありません。欠点は、有効時間内にTOTPを再利用することが可能なことである。"

msgid "TOTP configuration options"
msgstr "TOTPの設定オプション"

msgid "OTP hash algorithm"
msgstr "OTP hash algorithm"

msgid ""
"The default algorithm is SHA1. The other, more secure options are SHA256 and"
" SHA512."
msgstr "デフォルトのアルゴリズムはSHA1です。他の、より安全なオプションは、SHA256とSHA512です。"

msgid "Number of digits"
msgstr "Number of digits"

msgid ""
"The length of the OTP.  Short OTP's are user-friendly, easier to type, and "
"easier to remember. Longer OTP's are more secure than shorter OTP's."
msgstr "OTPの長さ。  短いOTPはユーザーフレンドリーで、入力が簡単で、覚えやすい。長いOTPは、短いOTPよりも安全です。"

msgid "Look ahead window"
msgstr "Look ahead window"

msgid ""
"The number of intervals the server attempts to match the hash. This option "
"is present in {project_name} if the clock of the TOTP generator or "
"authentication server become out-of-sync. The default value of 1 is "
"adequate. For example, if the time interval for a token is 30 seconds, the "
"default value of 1 means it will accept valid tokens in the 30-second "
"window. Every increment of this value increases the valid window by 30 "
"seconds."
msgstr ""
"サーバーがハッシュの照合を試みる間隔数。このオプションは、TOTP生成器または認証サーバの時計が同期していない場合に{project_name} "
"に存在する。デフォルトの1が適切である。たとえば、トークンの時間間隔が30秒の場合、デフォルト値の1は、30秒のウィンドウで有効なトークンを受け入れることを意味する。この値を1つ増やすごとに、有効なウィンドウが30秒ずつ長くなります。"

msgid "OTP token period"
msgstr "OTP token period"

msgid ""
"The time interval in seconds the server matches a hash. Each time the "
"interval passes, the token generator generates a TOTP."
msgstr "サーバーがハッシュを照合する時間間隔(秒)。この間隔が経過するたびに、トークン生成器はTOTPを生成する。"

msgid "HOTP configuration options"
msgstr "HOTP configuration options"

msgid ""
"The length of the OTP.  Short OTPs are user-friendly, easier to type, and "
"easier to remember. Longer OTPs are more secure than shorter OTPs."
msgstr ""
"OTPの長さ。  短いOTPはユーザーフレンドリーで、入力が簡単で、覚えやすい。長いワンタイムパスワードは、短いワンタイムパスワードよりも安全です。"

msgid ""
"The number of intervals the server attempts to match the hash. This option "
"is present in {project_name} if the clock of the TOTP generator or "
"authentication server become out-of-sync. The default value of 1 is "
"adequate. This option is present in {project_name} to cover when the user's "
"counter gets ahead of the server."
msgstr ""
"サーバーがハッシュの照合を試みる間隔数。このオプションは、TOTP生成器または認証サーバの時計が同期していない場合に{project_name} "
"に存在する。デフォルトの1が適切である。このオプションは {project_name} "
"にあり、ユーザのカウンタがサーバより先に進んでしまった場合に対応する。"

msgid "Initial counter"
msgstr "Initial counter"

msgid "The value of the initial counter."
msgstr "初期カウンターの値。"

msgid "Authentication flows"
msgstr "認証フロー"

msgid ""
"An _authentication flow_ is a container of authentications, screens, and "
"actions, during log in, registration, and other {project_name} workflows. To"
" view all the flows, actions, and checks, each flow requires:"
msgstr ""
"認証フローとは、ログインや登録などの{project_name}のワークフローにおける、認証、画面、アクションのコンテナーのことです。すべてのフロー、アクション、およびチェックを表示するには、各フローに以下が必要です。"

msgid "Built-in flows"
msgstr "組み込みフロー"

msgid ""
"{project_name} has several built-in flows. You cannot modify these flows, "
"but you can alter the flow's requirements to suit your needs."
msgstr ""
"{project_name}には、いくつかの組み込みフローがあります。これらのフローを変更することはできませんが、フローの要件を自分のニーズに合わせて変更することは可能です。"

msgid ""
"In the drop-down list, select *browser* to display the Browser Flow screen."
msgstr "ドロップ・ダウンリストで、 *browser* を選択すると、Browser Flow画面が表示されます。"

msgid "Browser flow"
msgstr "ブラウザーフロー"

msgid "image:{project_images}/browser-flow.png[Browser Flow]"
msgstr "image:{project_images}/browser-flow.png[Browser Flow]"

msgid ""
"Hover over the question-mark tooltip of the drop-down list to view a "
"description of the flow. Two sections exist."
msgstr "ドロップダウンリストのクエスチョン・マークのツールチップにカーソルを合わせると、フローの説明が表示されます。2つのセクションが存在します。"

msgid "Auth type"
msgstr "Auth type"

msgid ""
"The name of the authentication or the action to execute. If an "
"authentication is indented, it is in a sub-flow. It may or may not be "
"executed, depending on the behavior of its parent."
msgstr ""
"認証または実行するアクションの名前。認証がインデントされている場合は、サブフローに含まれます。これは、親の動作によって実行される場合とされない場合があります。"

msgid "Cookie"
msgstr "Cookie"

msgid ""
"The first time a user logs in successfully, {project_name} sets a session "
"cookie.  If the cookie is already set, this authentication type is "
"successful. Since the cookie provider returned success and each execution at"
" this level of the flow is _alternative_, {project_name} does not perform "
"any other execution. This results in a successful login."
msgstr ""
"ユーザーが初めてログインに成功すると、{project_name}はセッションCookieを設定します。Cookieがすでに設定されている場合、この認証タイプは成功となります。Cookieプロバイダーは成功を返し、このレベルのフローの各エグゼキューションは"
" _alternative_ であるため、{project_name}は他のエグゼキューションを実行しません。この結果、ログインに成功します。"

msgid "Kerberos"
msgstr "Kerberos"

msgid ""
"This authenticator is disabled by default and is skipped during the Browser "
"Flow."
msgstr "このオーセンティケーターはデフォルトで無効になっており、ブラウザーフローではスキップされます。"

msgid "Identity Provider Redirector"
msgstr "Identity Provider Redirector"

msgid ""
"This action is configured through the *Actions* > *Config* link. It "
"redirects to another IdP for <<_identity_broker, identity brokering>>."
msgstr ""
"このアクションは *Actions* > *Config*のリンクから設定します。<<_identity_broker, "
"アイデンティティー・ブローカリング>>の別のIdPにリダイレクトします。"

msgid "Forms"
msgstr "Forms"

msgid ""
"Since this sub-flow is marked as _alternative_, it will not be executed if "
"the *Cookie* authentication type passed. This sub-flow contains an "
"additional authentication type that needs to be executed. {project_name} "
"loads the executions for this sub-flow and processes them."
msgstr ""
"このサブフローは _alternative_ とマークされているため、 *Cookie* "
"認証タイプが渡された場合は実行されません。このサブフローには、実行する必要がある追加の認証タイプが含まれています。{project_name}は、このサブフローのエグゼキューションをロードして処理します。"

msgid ""
"The first execution is the *Username Password Form*, an authentication type "
"that renders the username and password page. It is marked as _required_, so "
"the user must enter a valid username and password."
msgstr ""
"最初のエグゼキューションは *Username Password Form* で、ユーザー名とパスワードのページをレンダリングする認証タイプです。これは"
" _required_ とマークされているので、ユーザーは有効なユーザー名とパスワードを入力しなければなりません。"

msgid ""
"The second execution is the *Browser - Conditional OTP* sub-flow. This sub-"
"flow is _conditional_ and executes depending on the result of the *Condition"
" - User Configured* execution. If the result is true, {project_name} loads "
"the executions for this sub-flow and processes them."
msgstr ""
"2番目のエグゼキューションは、*Browser - Conditional OTP* サブフローです。このサブフローは "
"_conditional_であり、 *Condition - User Configured* "
"エグゼキューションによって実行されます。結果がtrueの場合、{project_name}はこのサブフローのエグゼキューションをロードして処理します。"

msgid ""
"The next execution is the *Condition - User Configured* authentication. This"
" authentication checks if {project_name} has configured other executions in "
"the flow for the user. The *Browser - Conditional OTP* sub-flow executes "
"only when the user has a configured OTP credential."
msgstr ""
"次のエグゼキューションは、 *Condition - User Configured* "
"認証である。この認証は、{project_name}がユーザーに対してフロー内の他のエグゼキューションを設定しているかどうかを確認します。 "
"*Browser - Conditional OTP* サブフローは、ユーザーが設定されたOTPクレデンシャルを持っている場合にのみ実行されます。"

msgid ""
"The final execution is the *OTP Form*. {project_name} marks this execution "
"as _required_ but it runs only when the user has an OTP credential set up "
"because of the setup in the _conditional_ sub-flow. If not, the user does "
"not see an OTP form."
msgstr ""
"最後のエグゼキューションは、 *OTP Form* です。{project_name}はこのエグゼキューションを必須とマークしていますが、 "
"_conditional_ "
"サブフローで設定されているため、ユーザーがOTPクレデンシャルをセットアップしている場合にのみ実行されます。そうでない場合、ユーザーにはOTPフォームが表示されません。"

msgid "Requirement"
msgstr "Requirement"

msgid ""
"A set of radio buttons that control the execution of an action executes."
msgstr "アクションのエグゼキューションを制御する一連のラジオボタンが実行されます。"

msgid ""
"All _Required_ elements in the flow must be successfully sequentially "
"executed. The flow terminates if a required element fails."
msgstr "フロー内のすべての _Required_ 要素が順次正常に実行される必要があります。必須要素が失敗した場合、フローは終了します。"

msgid "Alternative"
msgstr "Alternative"

msgid ""
"Only a single element must successfully execute for the flow to evaluate as "
"successful. Because the _Required_ flow elements are sufficient to mark a "
"flow as successful, any _Alternative_ flow element within a flow containing "
"_Required_ flow elements will not execute."
msgstr ""
"フローが成功したと評価されるには、1つの要素だけが正常に実行される必要があります。フローが成功したと評価されるには、 _Required_ "
"フロー要素があれば十分なので、 _Required_ フロー要素を含むフロー内の _Alternative_ フロー要素は、実行されません。"

msgid "Disabled"
msgstr "Disabled"

msgid "The element does not count to mark a flow as successful."
msgstr "この要素は、フローを成功としてマークするためにカウントされません。"

msgid "Conditional"
msgstr "Conditional"

msgid "This requirement type is only set on sub-flows."
msgstr "この要件タイプは、サブフローにのみ設定されます。"

msgid ""
"A _Conditional_ sub-flow contains executions. These executions must evaluate"
" to logical statements."
msgstr ""
"_Conditional_ サブフローはエグゼキューションを含みます。これらのエグゼキューションは、論理文として評価されなければなりません。"

msgid ""
"If all executions evaluate as _true_, the _Conditional_ sub-flow acts as "
"_Required_."
msgstr ""
"すべてのエグゼキューションが _true_ と評価された場合、 _Conditional_ サブフローは _Required_ として動作します。"

msgid ""
"If all executions evaluate as _false_, the _Conditional_ sub-flow acts as "
"_Disabled_."
msgstr ""
"すべてのエグゼキューションが _false_ と評価された場合、 _Conditional_ サブフローは _Disabled_ として動作します。"

msgid ""
"If you do not set an execution, the _Conditional_ sub-flow acts as "
"_Disabled_."
msgstr "エグゼキューションを設定しない場合、 _Conditional_ サブフローは _Disabled_ として動作します。"

msgid ""
"If a flow contains executions and the flow is not set to _Conditional_, "
"{project_name} does not evaluate the executions, and the executions are "
"considered functionally _Disabled_."
msgstr ""
"フローがエグゼキューションを含み、フローが _Conditional_ "
"に設定されていない場合、{project_name}はエグゼキューションを評価せず、エグゼキューションは機能的に _Disabled_ とみなされます。"

msgid "Creating flows"
msgstr "フローの作成"

msgid ""
"Important functionality and security considerations apply when you design a "
"flow."
msgstr "フローを設計する際には、重要な機能性とセキュリティーに関する考慮事項が適用されます。"

msgid "To create a flow, perform the following:"
msgstr "フローを作成するには、以下を実行します。"

msgid ""
"You can copy and then modify an existing flow. Select a flow, click *Copy*, "
"and enter a name for the new flow."
msgstr "既存のフローをコピーして、修正することができます。フローを選択し、 *Copy* をクリックし、新しいフローの名前を入力します。"

msgid ""
"When creating a new flow, you must create a top-level flow first with the "
"following options:"
msgstr "新しいフローを作成する場合、まず次のオプションでトップレベルのフローを作成する必要があります。"

msgid "Alias"
msgstr "Alias"

msgid "The name of the flow."
msgstr "フローの名前。"

msgid "The description you can set to the flow."
msgstr "フローに設定できる説明。"

msgid "Top-Level Flow Type"
msgstr "トップレベル・フロー・タイプ"

msgid ""
"The type of flow. The type *client* is used only for the authentication of "
"clients (applications). For all other cases, choose *generic*."
msgstr ""
"フローのタイプです。タイプ *client* は、クライアント（アプリケーション）の認証にのみ使用されます。それ以外の場合は、 *generic* "
"を選択します。"

msgid "Create a top-level flow"
msgstr "トップレベル・フローの作成"

msgid "image:{project_images}/Create-top-level-flow.png[Top Level Flow]"
msgstr "image:{project_images}/Create-top-level-flow.png[Top Level Flow]"

msgid ""
"When {project_name} has created the flow, {project_name} displays the "
"*Delete*, *Add execution*, and *Add flow* buttons."
msgstr ""
"{project_name}がフローを作成すると、{project_name}は *Delete* 、 *Add execution* 、 *Add "
"flow* ボタンを表示します。"

msgid "An empty new flow"
msgstr "空の新しいフロー"

msgid "image:{project_images}/New-flow.png[New Flow]"
msgstr "image:{project_images}/New-flow.png[New Flow]"

msgid "Three factors determine the behavior of flows and sub-flows."
msgstr "フローとサブフローの挙動は3つの要因で決まります。"

msgid "The structure of the flow and sub-flows."
msgstr "フローとサブフローの構造。"

msgid "The executions within the flows"
msgstr "フロー内のエグゼキューション"

msgid "The requirements set within the sub-flows and the executions."
msgstr "要求はサブフローとエグゼキューションの中で設定されます。"

msgid ""
"Executions have a wide variety of actions, from sending a reset email to "
"validating an OTP. Add executions with the *Add execution* button. Hover "
"over the question mark next to *Provider*, to see a description of the "
"execution."
msgstr ""
"リセットメールの送信からワンタイムパスワードの認証まで、さまざまなアクションを実行できます。実行を追加するには、 *Add execution* "
"ボタンをクリックします。 *Provider* の横にあるクエスチョン・マークにカーソルを合わせると、実行の説明が表示されます。"

msgid "Adding an authentication execution"
msgstr "認証エグゼキューションの追加"

msgid ""
"image:{project_images}/Create-authentication-execution.png[Adding an "
"Authentication Execution]"
msgstr ""
"image:{project_images}/Create-authentication-execution.png [認証実行を追加する]。"

msgid ""
"Two types of executions exist, _automatic executions_ and _interactive "
"executions_. _Automatic executions_ are similar to the *Cookie* execution "
"and will automatically perform their action in the flow. _Interactive "
"executions_ halt the flow to get input. Executions executing successfully "
"set their status to _success_.  For a flow to complete, it needs at least "
"one execution with a status of _success_."
msgstr ""
"_自動エグゼキューション_ と _対話型エグゼキューション_ の2種類が存在します。 _自動エグゼキューション_ は *Cookie* "
"エグゼキューションと同様で、フロー内で自動的にアクションを実行します。 _対話型エグゼキューション_ "
"は、入力を得るためにフローを停止させます。実行が成功すると、ステータスが _success_ に設定されます。フローが完了するには、ステータスが "
"_success_ である実行が少なくとも1つ必要です。"

msgid ""
"You can add sub-flows to top-level flows with the *Add flow* button. The "
"*Add flow* button displays the *Create Execution Flow* page. This page is "
"similar to the *Create Top Level Form* page. The difference is that the "
"*Flow Type* can be *generic* (default) or *form*. The *form* type constructs"
" a sub-flow that generates a form for the user, similar to the built-in "
"*Registration* flow. Sub-flows success depends on how their executions "
"evaluate, including their contained sub-flows. See the <<_execution-"
"requirements, execution requirements section>> for an in-depth explanation "
"of how sub-flows work."
msgstr ""
"トップレベルのフローにサブフローを追加するには、 *Add flow* ボタンを使用します。 *Add flow* ボタンを押すと、 *Create "
"Execution Flow* ページが表示されます。このページは、 *Create Top Level Form* ページと似ています。違いは、 "
"*Flow Type* に *generic* （デフォルト）または *form* を指定できることです。 *form* 型は、組み込みの "
"*Registration* "
"フローと同様に、ユーザー用のフォームを生成するサブフローを構築します。サブフローの成功は、含まれるサブフローを含め、そのエグゼキューション要件がどのように評価されるかに依存します。サブフローがどのように機能するかについての詳細な説明は、<<_execution-"
"requirements, エグゼキューション要件のセクション>>を参照してください。"

msgid ""
"After adding an execution, check the requirement has the correct value."
msgstr "エグゼキューションを追加した後、要件が正しい値であることを確認します。"

msgid ""
"All elements in a flow have a *Delete* option in the *Actions* menu. This "
"action removes the element from the flow. Executions have a *Config* menu "
"option to configure the execution. It is also possible to add executions and"
" sub-flows to sub-flows with the *Add execution* and *Add flow* menu "
"options."
msgstr ""
"フロー内のすべての要素には、 *Actions* メニューに *Delete* "
"オプションがあります。このアクションは、フローからエレメントを削除します。実行には、実行を設定するための *Config* "
"メニューオプションがあります。また、*Add execution* および *Add flow* "
"メニューオプションを使用して、実行とサブフローを追加することも可能です。"

msgid ""
"Since the order of execution is important, you can move executions and sub-"
"flows up and down within their flows using the up and down buttons beside "
"their names."
msgstr ""
"エグゼキューションの順序は重要です。エグゼキューションやサブフローは、その名前の横にある上下のボタンで、フロー内で上下に移動させることができます。"

msgid ""
"Make sure to properly test your configuration when you configure the "
"authentication flow to confirm that no security holes exist in your setup. "
"We recommend that you test various corner cases. For example, consider "
"testing the authentication behavior for a user when you remove various "
"credentials from the user's account before authentication."
msgstr ""
"認証フローを設定する際には、設定にセキュリティー・ホールが存在しないことを確認するために、適切にテストを行うようにしてください。様々なコーナーケースをテストすることをお勧めします。たとえば、認証前にユーザーのアカウントからさまざまなクレデンシャルを削除した場合の、そのユーザーの認証動作をテストすることを検討します。"

msgid ""
"As an example, when 2nd-factor authenticators, such as OTP Form or WebAuthn "
"Authenticator, are configured in the flow as REQUIRED and the user does not "
"have credential of particular type, the user will be able to setup the "
"particular credential during authentication itself. This situation means "
"that the user does not authenticate with this credential as he setup it "
"right during the authentication. So for browser authentication, make sure to"
" configure your authentication flow with some 1st-factor credentials such as"
" Password or WebAuthn Passwordless Authenticator."
msgstr ""
"たとえば、OTPフォームやWebAuthn認証などの2要素認証がフローでREQUIREDに設定されており、ユーザーが特定のタイプのクレデンシャルを持っていない場合、ユーザーは認証中に特定のクレデンシャルを設定することができるようになります。この場合、ユーザーは認証時にこのクレデンシャルを正しくセットアップしているため、このクレデンシャルでは認証されないことを意味します。したがって、ブラウザー認証では、パスワードやWebAuthn"
" Passwordless Authenticatorなどの1要素クレデンシャルを使用して認証フローを設定するようにしてください。"

msgid "Creating a password-less browser login flow"
msgstr "パスワードレスのブラウザー・ログイン・フローの作成"

msgid ""
"To illustrate the creation of flows, this section describes creating an "
"advanced browser login flow. The purpose of this flow is to allow a user a "
"choice between logging in using a password-less manner with <<_webauthn, "
"WebAuthn>>, or two-factor authentication with a password and OTP."
msgstr ""
"フローの作成を説明するために、ここでは高度なブラウザー・ログイン・フローの作成について説明します。このフローの目的は、<<_webauthn, "
"WebAuthn>>を使ったパスワードレスでのログインと、パスワードとOTPによる二要素認証のどちらかをユーザーが選択できるようにすることです。"

msgid "Enter `Browser Password-less` as an alias."
msgstr "エイリアスとして `Browser Password-less` を入力します。"

msgid "Click *Add execution*."
msgstr "*Add execution* をクリックします。"

msgid "Select *Cookie* from the drop-down list."
msgstr "ドロップダウン・リストから *Cookie* を選択します。"

msgid ""
"Click *Alternative* for the *Cookie* authentication type to set its "
"requirement to alternative."
msgstr "認証タイプ *Cookie* の *Alternative* をクリックし、その要件を代替に設定します。"

msgid "Select *Kerberos* from the drop-down list."
msgstr "ドロップダウン・リストから *Kerberos* を選択します。"

msgid "Select *Identity Provider Redirector* from the drop-down list."
msgstr "ドロップダウン・リストから *Identity Provider Redirector* を選択します。"

msgid ""
"Click *Alternative* for the *Identity Provider Redirector* authentication "
"type to set its requirement to alternative."
msgstr ""
"*Identity Provider Redirector* *認証タイプの *Alternative* をクリックして、その要件を代替に設定します。"

msgid "Click *Add flow*."
msgstr "*Add flow* をクリックします。"

msgid "Enter *Forms* as an alias."
msgstr "エイリアスとして *Forms* を入力します。"

msgid ""
"Click *Alternative* for the *Forms* authentication type to set its "
"requirement to alternative."
msgstr "*Forms* 認証タイプの *Alternative* をクリックして、その要件を代替に設定します。"

msgid "The common part with the browser flow"
msgstr "ブラウザーフローとの共通部分"

msgid "image:images/Passwordless-browser-login-common.png[]"
msgstr "image:images/Passwordless-browser-login-common.png[]"

msgid "Click *Actions for the *Forms* execution."
msgstr "*Forms* を実行するための *Actions* をクリックします。"

msgid "Select *Add execution*."
msgstr "*Add execution* を選択します。"

msgid "Select *Username Form* from the drop-down list."
msgstr "ドロップダウンリストから、 *Username Form* を選択します。"

msgid ""
"Click *Required* for the *Username Form* authentication type to set its "
"requirement to required."
msgstr "*Username Form* 認証タイプの *Required*  認証をクリックして、その要件を必須に設定します。"

msgid ""
"At this stage, the form requires a username but no password. We must enable "
"password authentication to avoid security risks."
msgstr ""
"この段階では、フォームにはユーザー名は必要ですが、パスワードは必要ありません。セキュリティー・リスクを回避するために、パスワード認証を有効にする必要があります。"

msgid "Click *Actions* for the *Forms* sub-flow."
msgstr "*Forms* サブフローの *Actions* をクリックします。"

msgid "Enter `Authentication` as an alias."
msgstr "エイリアスとして `Authentication` を入力します。"

msgid ""
"Click *Required* for the *Authentication* authentication type to set its "
"requirement to required."
msgstr "*Authentication* 認証タイプの *Required* をクリックして、その要件を必須に設定します。"

msgid "Click *Actions* for the *Authentication* sub-flow."
msgstr "*Authentication* サブフローの *Actions* をクリックします。"

msgid "Select *Webauthn Passwordless Authenticator* from the drop-down list."
msgstr "ドロップダウン・リストから *Webauthn Passwordless Authenticator* を選択します。"

msgid ""
"Click *Alternative* for the *Webauthn Passwordless Authenticator* "
"authentication type to set its requirement to alternative."
msgstr ""
"*Webauthn Passwordless Authenticator* の認証タイプの *Alternative* "
"をクリックして、その要件を代替に設定します。"

msgid "Enter `Password with OTP` as an alias."
msgstr "エイリアスとして `Password with OTP` を入力します。"

msgid ""
"Click *Alternative* for the *Password with OTP* authentication type to set "
"its requirement to alternative."
msgstr " *Password with OTP* の認証タイプは、 *Alternative* をクリックすると代替になります。"

msgid "Click *Actions* for the *Password with OTP* sub-flow."
msgstr "*Password with OTP* サブフローの *Actions* をクリックします。"

msgid "Select *Password Form* from the drop-down list."
msgstr "ドロップダウン・リストから *Password Form* を選択します。"

msgid ""
"Click *Required* for the *Password Form* authentication type to set its "
"requirement to required."
msgstr "*Password Form* の認証タイプの *Required* をクリックして、その要件を必須に設定します。"

msgid "Select *OTP Form* from the drop-down list."
msgstr "ドロップダウン・リストから *OTP Form* を選択します。"

msgid ""
"Click *Required* for the *OTP Form* authentication type to set its "
"requirement to required."
msgstr "*OTP Form* 認証タイプの *Required* をクリックして、その要件を必須に設定します。"

msgid "Finally, change the bindings."
msgstr "最後に、バインディングを変更します。"

msgid "Click the *Bindings* tab."
msgstr "*Bindings* をクリックします。"

msgid "Click the *Browser Flow* drop-down list."
msgstr "*Browser Flow* のドロップダウン・リストをクリックします。"

msgid "Select *Browser Password-less* from the drop-down list."
msgstr "ドロップダウン・リストから、 *Browser Password-less* を選択します。"

msgid "A password-less browser login"
msgstr "パスワードレス・ブラウザー・ログイン"

msgid "image:images/Passwordless-browser-login.png[]"
msgstr "image:images/Passwordless-browser-login.png[]"

msgid "After entering the username, the flow works as follows:"
msgstr "ユーザー名を入力すると、次のような流れで動作します。"

msgid ""
"If users have WebAuthn passwordless credentials recorded, they can use these"
" credentials to log in directly. This is the password-less login. The user "
"can also select *Password with OTP* because the `WebAuthn Passwordless` "
"execution and the `Password with OTP` flow are set to *Alternative*. If they"
" are set to *Required*, the user has to enter WebAuthn, password, and OTP."
msgstr ""
"ユーザーがWebAuthnのパスワードレス・クレデンシャルを記録している場合、このクレデンシャルを使って直接ログインすることができます。これがパスワードレス・ログインです。"
" `WebAuthn Passwordless` のエグゼキューションと `Password with OTP` フローが *Alternative* "
"に設定されているため、ユーザーは *Password with OTP* を選択することもできます。これらが *Required* "
"に設定されている場合、ユーザーはWebAuthn、パスワード、OTPを入力する必要があります。"

msgid ""
"If the user selects the *Try another way* link with `WebAuthn passwordless` "
"authentication, the user can choose between `Password` and `Security Key` "
"(WebAuthn passwordless). When selecting the password, the user will need to "
"continue and log in with the assigned OTP. If the user has no WebAuthn "
"credentials, the user must enter the password and then the OTP. If the user "
"has no OTP credential, they will be asked to record one."
msgstr ""
"WebAuthnパスワードレス認証で *Try another way* リンクを選択した場合、ユーザーは `Password` と `Security"
" Key` "
"（WebAuthnパスワードレス）のどちらかを選択することができます。パスワードを選択した場合、ユーザーは割り当てられたワンタイムパスワードでログインを続ける必要があります。WebAuthnのクレデンシャルを持っていない場合、ユーザーはパスワードを入力し、次にOTPを入力する必要があります。ユーザーが"
" OTP クレデンシャルを持っていない場合は、OTP を記録するように求められます。"

msgid ""
"Since the WebAuthn Passwordless execution is set to *Alternative* rather "
"than  *Required*, this flow will never ask the user to register a WebAuthn "
"credential. For a user to have a Webauthn credential, an administrator must "
"add a required action to the user. Do this by:"
msgstr ""
"WebAuthn Passwordlessのエグゼキューションが *Required* ではなく *Alternative* "
"に設定されているため、このフローはユーザーにWebAuthnクレデンシャルの登録を要求することはありません。ユーザーにWebauthnクレデンシャルを持たせるためには、管理者がそのユーザーに必須アクションを追加する必要があります。これを行うには、以下のようにします。"

msgid ""
"Enabling the *Webauthn Register Passwordless* required action in the realm "
"(see the <<_webauthn,WebAuthn>> documentation)."
msgstr ""
"レルムで *Webauthn Register Passwordless* "
"の必須アクションを有効にします（<<_webauthn,WebAuthn>>のドキュメントを参照してください）。"

msgid ""
"Setting the required action using the *Credential Reset* part of a user's "
"xref:ref-user-credentials_{context}[Credentials] management menu."
msgstr ""
"ユーザーの xref:ref-user-credentials_{context}[Credentials] 管理メニューの *Credential "
"Reset* 部分を使用した必須アクションの設定。"

msgid ""
"Creating an advanced flow such as this can have side effects. For example, "
"if you enable the ability to reset the password for users, this would be "
"accessible from the password form. In the default `Reset Credentials` flow, "
"users must enter their username. Since the user has already entered a "
"username earlier in the `Browser Password-less` flow, this action is "
"unnecessary for {project_name} and sub-optimal for user experience. To "
"correct this problem, you can:"
msgstr ""
"このような高度なフローを作成すると、副作用が発生することがあります。たとえば、ユーザーのパスワードをリセットする機能を有効にした場合、パスワードフォームからアクセスできるようになります。デフォルトの"
" `Reset Credentials` フローでは、ユーザーはユーザー名を入力しなければなりません。ユーザーは `Browser Password-"
"less` "
"フローですでにユーザー名を入力しているので、このアクションは{project_name}にとって不要であり、ユーザー・エクスペリエンスにとって最適とは言えません。この問題を修正するには、次のようにします。"

msgid ""
"Copy the `Reset Credentials` flow. Set its name to `Reset Credentials for "
"password-less`, for example."
msgstr ""
"`Reset Credentials` フローをコピーします。その名前を、たとえば `Reset Credentials for password-"
"less` に設定します。"

msgid "Select *Delete* in the *Actions* menu of the *Choose user* execution."
msgstr "*Choose user* のエグゼキューションの *Actions* メニューで *Delete* を選択します。"

msgid ""
"In the *Bindings* menu, change the reset credential flow from *Reset "
"Credentials* to *Reset Credentials for password-less*"
msgstr ""
"*Bindings* メニューで、クレデンシャルのリセットフローを *Reset Credentials* から *Reset Credentials "
"for password-less*に変更します。"

msgid "Script Authenticator"
msgstr "スクリプト・オーセンティケーター"

msgid ""
"Ability to upload scripts through the Admin Console and REST endpoints is "
"deprecated."
msgstr "スクリプトを管理コンソールやRESTエンドポイントからアップロードする機能は廃止予定です。"

msgid ""
"For more details see "
"link:{developerguide_jsproviders_link}[{developerguide_jsproviders_name}]."
msgstr ""
"詳しくは、 "
"link:{developerguide_jsproviders_link}[{developerguide_jsproviders_name}] "
"を参照してください。"

msgid ""
"{project_name} supports login with a Kerberos ticket through the Simple and "
"Protected GSSAPI Negotiation Mechanism (SPNEGO) protocol. SPNEGO "
"authenticates transparently through the web browser after the user "
"authenticates the session. For non-web cases, or when a ticket is not "
"available during login, {project_name} supports login with Kerberos username"
" and password."
msgstr ""
"{project_name}は、Simple and Protected GSSAPI Negotiation Mechanism (SPNEGO) "
"プロトコルによるKerberosチケットを使ったログインをサポートしています。SPNEGOは、ユーザーがセッションを認証した後、Webブラウザーを通じて透過的に認証します。Web以外の場合、またはログイン時にチケットが利用できない場合、{project_name}はKerberosのユーザー名とパスワードによるログインをサポートします。"

msgid "A typical use case for web authentication is the following:"
msgstr "Web認証の一般的なユースケースは次のとおりです。"

msgid "The user logs into the desktop."
msgstr "ユーザーはデスクトップにログインする。"

msgid ""
"The user accesses a web application secured by {project_name} using a "
"browser."
msgstr "ユーザーはブラウザーを使って{project_name}で保護されたWebアプリケーションにアクセスします。"

msgid "The application redirects to {project_name} login."
msgstr "アプリケーションは{project_name}のログイン画面にリダイレクトされます。"

msgid ""
"{project_name} renders the HTML login screen with status 401 and HTTP header"
" `WWW-Authenticate: Negotiate`"
msgstr ""
"{project_name}は、ステータス401、HTTPヘッダー `WWW-Authenticate.Negotiate: Negotiate` "
"のHTMLログイン画面をレンダリングします。"

msgid ""
"If the browser has a Kerberos ticket from desktop login, the browser "
"transfers the desktop sign-on information to {project_name} in header "
"`Authorization: Negotiate 'spnego-token'`. Otherwise, it displays the "
"standard login screen, and the user enters the login credentials."
msgstr ""
"ブラウザーがデスクトップ・ログイン時のKerberosチケットを持っている場合、ブラウザーはデスクトップのサインオン情報を "
"`Authorization: Negotiate 'spnego-token'' "
"ヘッダーで{project_name}へ転送します。そうでなければ、標準的なログイン画面が表示され、ユーザーはログインクレデンシャルを入力します。"

msgid ""
"{project_name} validates the token from the browser and authenticates the "
"user."
msgstr "{project_name}は、ブラウザーから送信されたトークンを検証し、ユーザーを認証します。"

msgid ""
"If using LDAPFederationProvider with Kerberos authentication support, "
"{project_name} provisions user data from LDAP. If using "
"KerberosFederationProvider, {project_name} lets the user update the profile "
"and pre-fill  login data."
msgstr ""
"Kerberos認証をサポートするLDAPFederationProviderを使用する場合、{project_name}はLDAPからユーザーデータをプロビジョニングします。KerberosFederationProviderを使用する場合、{project_name}は、ユーザーにプロフィールの更新とログインデータの事前入力をさせます。"

msgid ""
"{project_name} returns to the application. {project_name} and the "
"application communicate through OpenID Connect or SAML messages. "
"{project_name} acts as a broker to Kerberos/SPNEGO login. Therefore "
"{project_name} authenticating through Kerberos is hidden from the "
"application."
msgstr ""
"{project_name}はアプリケーションに戻ります。{project_name}とアプリケーションはOpenID "
"ConnectまたはSAMLメッセージで通信します。{project_name}は、Kerberos/SPNEGOログインのブローカーとして動作します。そのため、{project_name}がKerberosで認証していることは、アプリケーションからは見えません。"

msgid "Perform the following steps to set up Kerberos authentication:"
msgstr "以下の手順で、Kerberos認証を設定します。"

msgid "The setup and configuration of the Kerberos server (KDC)."
msgstr "Kerberosサーバー（KDC）のセットアップと設定です。"

msgid "The setup and configuration of the {project_name} server."
msgstr "{project_name}サーバーのセットアップと設定です。"

msgid "The setup and configuration of the client machines."
msgstr "クライアント・マシンのセットアップと設定です。"

msgid "Setup of Kerberos server"
msgstr "Kerberosサーバーのセットアップ"

msgid ""
"The steps to set up a Kerberos server depends on the operating system (OS) "
"and the Kerberos vendor. Consult Windows Active Directory, MIT Kerberos, and"
" your OS documentation for instructions on setting up and configuring a "
"Kerberos server."
msgstr ""
"Kerberosサーバーをセットアップする手順は、オペレーティング・システム（OS）とKerberosベンダーに依存します。Windows Active"
" Directory、MIT "
"Kerberos、およびお使いのOSのマニュアルを参照して、Kerberosサーバーのセットアップと設定を確認してください。"

msgid "During setup, perform these steps:"
msgstr "セットアップ時には、以下の手順で行ってください。"

msgid ""
"Add some user principals to your Kerberos database. You can also integrate "
"your Kerberos with LDAP, so user accounts provision from the LDAP server."
msgstr ""
"Kerberosデータベースにユーザー・プリンシパルを追加します。また、KerberosをLDAPと統合し、LDAPサーバーからユーザー・アカウントをプロビジョニングすることも可能です。"

msgid ""
"Add service principal for \"HTTP\" service. For example, if the "
"{project_name} server runs on `www.mydomain.org`, add the service principal "
"`HTTP/www.mydomain.org@<kerberos realm>`."
msgstr ""
"\"HTTP\" サービス用のサービス・プリンシパルを追加します。たとえば、{project_name}サーバーが `www.mydomain.org`"
" で動作している場合、 `HTTP/www.mydomain.org@<kerberos realm>` というサービスプリンシパルを追加します。"

msgid ""
"On MIT Kerberos, you run a \"kadmin\" session. On a machine with MIT "
"Kerberos, you can use the command:"
msgstr "MIT Kerberos上では、\"kadmin\"セッションを実行します。MIT Kerberosを搭載したマシンでは、コマンドを使用します。"

msgid "sudo kadmin.local"
msgstr "sudo kadmin.local"

msgid ""
"Then, add HTTP principal and export its key to a keytab file with commands "
"such as:"
msgstr "次に、HTTPプリンシパルを追加し、そのキーを以下のようなコマンドでkeytabファイルにエクスポートします。"

msgid ""
"addprinc -randkey HTTP/www.mydomain.org@MYDOMAIN.ORG\n"
"ktadd -k /tmp/http.keytab HTTP/www.mydomain.org@MYDOMAIN.ORG"
msgstr ""
"addprinc -randkey HTTP/www.mydomain.org@MYDOMAIN.ORG\n"
"ktadd -k /tmp/http.keytab HTTP/www.mydomain.org@MYDOMAIN.ORG"

msgid ""
"Ensure the keytab file `/tmp/http.keytab` is accessible on the host where "
"{project_name} is running."
msgstr ""
"{project_name}が動作しているホストで、keytabファイル `/tmp/http.keytab`  にアクセスできることを確認します。"

msgid "Setup and configuration of {project_name} server"
msgstr "{project_name}サーバーのセットアップと設定"

msgid "Install a Kerberos client on your machine."
msgstr "マシンにKerberosクライアントをインストールします。"

msgid ""
"Install a Kerberos client. If your machine runs Fedora, Ubuntu, or RHEL, "
"install the link:https://www.freeipa.org/page/Downloads[freeipa-client] "
"package, containing a Kerberos client and other utilities."
msgstr ""
"Kerberosクライアントをインストールします。Fedora、Ubuntu、または "
"RHELを使用している場合は、Kerberosクライアントとその他のユーティリティーを含む "
"link:https://www.freeipa.org/page/Downloads[freeipa-client] パッケージをインストールします。"

msgid ""
"Configure the Kerberos client (on Linux, the configuration settings are in "
"the "
"link:https://web.mit.edu/kerberos/krb5-1.12/doc/admin/conf_files/krb5_conf.html[/etc/krb5.conf]"
" file )."
msgstr ""
"Kerberosクライアントの設定（Linuxでは、　link:https://web.mit.edu/kerberos/krb5-1.12/doc/admin/conf_files/krb5_conf.html[/etc/krb5.conf]"
" ファイルに設定されています）。"

msgid ""
"Add your Kerberos realm to the configuration and configure the HTTP domains "
"your server runs on."
msgstr "Kerberosレルムを設定に追加し、サーバーが実行されるHTTPドメインを設定します。"

msgid ""
"For example, for the MYDOMAIN.ORG realm, you can configure the "
"`domain_realm` section like this:"
msgstr "たとえば、MYDOMAIN.ORGレルムでは、 `domain_realm` のセクションを次のように設定します。"

msgid ""
"[domain_realm]\n"
"  .mydomain.org = MYDOMAIN.ORG\n"
"  mydomain.org = MYDOMAIN.ORG"
msgstr ""
"[domain_realm]\n"
"  .mydomain.org = MYDOMAIN.ORG\n"
"  mydomain.org = MYDOMAIN.ORG"

msgid ""
"Export the keytab file with the HTTP principal and ensure the file is "
"accessible to the process running the {project_name} server. For production,"
" ensure that the file is readable by this process only."
msgstr ""
"HTTPプリンシパルでkeytabファイルをエクスポートし、そのファイルが{project_name}サーバーを実行しているプロセスからアクセス可能であることを確認します。実稼働環境では、このファイルがこのプロセスによってのみ読み取り可能であることを確認します。"

msgid ""
"For the MIT Kerberos example above, we exported keytab to the "
"`/tmp/http.keytab` file. If your _Key Distribution Centre (KDC)_ and "
"{project_name} run on the same host, the file is already available."
msgstr ""
"上記のMIT Kerberosの例では、keytabを `/tmp/http.keytab` ファイルにエクスポートしています。もし、_Key "
"Distribution Centre (KDC)_ と{project_name}が同じホストで動いていれば、このファイルはすでに利用可能です。"

msgid "Enabling SPNEGO processing"
msgstr "SPNEGO処理の有効化"

msgid ""
"By default, {project_name} disables SPNEGO protocol support. To enable it, "
"go to the <<_authentication-flows, browser flow>> and enable *Kerberos*."
msgstr ""
"デフォルトでは、{project_name}はSPNEGOプロトコルのサポートを無効にします。有効にするには、<<_authentication-"
"flows, ブラウザーフロー>>で *Kerberos* を有効にしてください。"

msgid ""
"Set the *Kerberos* requirement from _disabled_ to _alternative_ (Kerberos is"
" optional) or _required_ (browser must have Kerberos enabled). If you have "
"not configured the browser to work with SPNEGO or Kerberos, {project_name} "
"falls back to the regular login screen."
msgstr ""
"*Kerberos* requirementを _disabled_ から _alternative_ (Kerberos はオプション) または "
"_required_ (ブラウザーでKerberosを有効にする必要がある) "
"に設定します。SPNEGOまたはKerberosで動作するようにブラウザーを設定していない場合、{project_name}は通常のログイン画面に戻ります。"

msgid "Configure Kerberos user storage federation providerxs"
msgstr "Kerberosユーザー・ストレージ・フェデレーション・プロバイダーの設定"

msgid ""
"You must now use <<_user-storage-federation,User Storage Federation>> to "
"configure how {project_name} interprets Kerberos tickets. Two different "
"federation providers exist with Kerberos authentication support."
msgstr ""
"ここで<<_user-storage-"
"federation,ユーザー・ストレージ・フェデレーション>>を使用して、{project_name}がKerberosチケットを解釈する方法を設定する必要があります。Kerberos認証をサポートする2つの異なるフェデレーション・プロバイダーが存在します。"

msgid ""
"To authenticate with Kerberos backed by an LDAP server, configure the "
"<<_ldap, LDAP Federation Provider>>."
msgstr ""
"LDAPサーバーにバックアップされたKerberosで認証するには、<<_ldap, LDAPフェデレーション・プロバイダー>>を設定します。"

msgid "Go to the configuration page for your LDAP provider."
msgstr "LDAPプロバイダーの設定ページに移動します。"

msgid "Ldap kerberos integration"
msgstr "LDAPとKerberosの統合"

msgid "image:{project_images}/ldap-kerberos.png[LDAP Kerberos Integration]"
msgstr "image:{project_images}/ldap-kerberos.png[LDAP Kerberos Integration]"

msgid "Toggle *Allow Kerberos authentication* to *ON*"
msgstr " *Allow Kerberos authentication* を *ON* にします。"

msgid ""
"*Allow Kerberos authentication* makes {project_name} use the Kerberos "
"principal access user information so information can import into the "
"{project_name} environment."
msgstr ""
"*Kerberos認証* "
"を許可すると、{project_name}はKerberosプリンシパル・アクセス・ユーザー情報を使用し、{project_name} "
"環境に情報をインポートできるようになります。"

msgid ""
"If an LDAP server is not backing up your Kerberos solution, use the "
"*Kerberos* User Storage Federation Provider."
msgstr ""
"LDAPサーバーがKerberosソリューションをバックアップしていない場合、*Kerberos*ユーザー・ストレージ・フェデレーション・プロバイダーを使用します。"

msgid "Select *Kerberos* from the *Add provider* select box."
msgstr "*Add provider* セレクトボックスから *Kerberos* を選択します。"

msgid "Kerberos user storage provider"
msgstr "Kerberosユーザー・ストレージ・プロバイダー"

msgid ""
"image:{project_images}/kerberos-provider.png[Kerberos User Storage Provider]"
msgstr ""
"image:{project_images}/kerberos-provider.png[Kerberos User Storage Provider]"

msgid ""
"The *Kerberos* provider parses the Kerberos ticket for simple principal "
"information and imports the information into the local {project_name} "
"database. User profile information, such as first name, last name, and "
"email, are not provisioned."
msgstr ""
"*Kerberos* "
"プロバイダーは、Kerberosチケットを解析して単純なプリンシパル情報を取得し、その情報をローカル{project_name}データベースにインポートします。姓、名、電子メールなどのユーザー・プロフィール情報はプロビジョニングされません。"

msgid "Setup and configuration of client machines"
msgstr "クライアントマシンのセットアップと設定"

msgid ""
"Client machines must have a Kerberos client and set up the `krb5.conf` as "
"described <<_server_setup, above>>. The client machines must also enable "
"SPNEGO login support in their browser. See "
"link:https://access.redhat.com/documentation/en-"
"us/red_hat_enterprise_linux/7/html/system-"
"level_authentication_guide/configuring_applications_for_sso[configuring "
"Firefox for Kerberos] if you are using the Firefox browser."
msgstr ""
"クライアントマシンはKerberosクライアントを持ち、<<_server_setup, 上>>で説明したように `krb5.conf` "
"を設定する必要があります。また、クライアント・マシンは、ブラウザーでSPNEGOログインサポートを有効にしなければなりません。Firefoxを使用している場合は、link:https://access.redhat.com/documentation/en-"
"us/red_hat_enterprise_linux/7/html/system-"
"level_authentication_guide/configuring_applications_for_sso[Kerberos用にFirefoxを設定する]を参照してください。"

msgid ""
"The `.mydomain.org` URI must be in the `network.negotiate-auth.trusted-uris`"
" configuration option."
msgstr ""
"`.mydomain.org` のURI は `network.negotiate-auth.trusted-uris` "
"設定オプションに含まれていなければなりません。"

msgid ""
"In Windows domains, clients do not need to adjust their configuration. "
"Internet Explorer and Edge can already participate in SPNEGO authentication."
msgstr ""
"Windowsドメインでは、クライアント側で設定を調整する必要はありません。Internet "
"ExplorerとEdgeは、すでにSPNEGO認証に参加することができます。"

msgid "Example setups"
msgstr "設定例"

msgid "{Project_name} and FreeIPA docker image"
msgstr "{Project_name}とFreeIPAのdockerイメージ"

msgid ""
"When you install https://www.docker.com/[docker], run a docker image with "
"the FreeIPA server installed. FreeIPA provides an integrated security "
"solution with MIT Kerberos and 389 LDAP server. The image also contains a "
"{project_name} server configured with an LDAP Federation provider and "
"enabled SPNEGO/Kerberos authentication against the FreeIPA server. See "
"details https://github.com/mposolda/keycloak-freeipa-"
"docker/blob/master/README.md[here]."
msgstr ""
"https://www.docker.com/[docker] "
"をインストールすると、FreeIPAサーバーがインストールされたdockerイメージが実行されます。FreeIPA は、MIT Kerberosと389"
" LDAP "
"サーバーによる統合セキュリティー・ソリューションを提供します。また、このイメージには、LDAPフェデレーション・プロバイダーで設定され、FreeIPAサーバーに対してSPNEGO/Kerberos認証を有効にした{project_name}サーバーが含まれています。詳しくは、"
"  https://github.com/mposolda/keycloak-freeipa-"
"docker/blob/master/README.md[here] を参照してください。"

msgid "ApacheDS testing Kerberos server"
msgstr "ApacheDSテストKerberosサーバー"

msgid ""
"For quick testing and unit tests, use a simple "
"https://directory.apache.org/apacheds/[ApacheDS] Kerberos server. You must "
"build {project_name} from the source and then run the Kerberos server with "
"the maven-exec-plugin from our test suite. See details "
"https://github.com/keycloak/keycloak/blob/main/docs/tests.md#kerberos-"
"server[here]."
msgstr ""
"クイックテストとユニットテストのために、単純な  https://directory.apache.org/apacheds/[ApacheDS] "
"Kerberosサーバーを使用します。ソースから{project_name}をビルドし、私たちのテストスイートから取得したmaven-exec-"
"pluginを使ってKerberos サーバーを実行する必要があります。詳細は  "
"https://github.com/keycloak/keycloak/blob/main/docs/tests.md#kerberos-server"
" [ここ] を参照してください。"

msgid "Credential delegation"
msgstr "クレデンシャルの委譲"

msgid ""
"Kerberos supports the credential delegation. Applications may need access to"
" the Kerberos ticket so they can re-use it to interact with other services "
"secured by Kerberos. Because the {project_name} server processed the SPNEGO "
"protocol, you must propagate the GSS credential to your application within "
"the OpenID Connect token claim or a SAML assertion attribute. {project_name}"
" transmits this to your application from the {project_name} server. To "
"insert this claim into the token or assertion, each application must enable "
"the built-in protocol mapper `gss delegation credential`. This mapper is "
"available in the *Mappers* tab of the application's client page.  See "
"<<_protocol-mappers, Protocol Mappers>> chapter for more details."
msgstr ""
"Kerberosはクレデンシャルの委譲をサポートします。アプリケーションは、Kerberosチケットにアクセスする必要があり、Kerberosでセキュリティー保護された他のサービスと対話するためにそれを再使用することができます。{project_name}サーバーはSPNEGOプロトコルを処理したため、OpenID"
" ConnectトークンのクレームまたはSAMLアサーションの属性内で "
"GSSクレデンシャルをアプリケーションに伝搬させる必要があります。{project_name} "
"は、これを{project_name}サーバーからアプリケーションに送信します。このクレームをトークンまたはアサーションに挿入するには、各アプリケーションは組み込みのプロトコル・マッパーである"
" `gss delegation credential` を有効にする必要があります。このマッパーは、アプリケーションのクライアント・ページの "
"*Mappers* タブで利用可能です。  詳細は<<_protocol-mappers, プロトコル・マッパー>> の章を参照してください。"

msgid ""
"Applications must deserialize the claim it receives from {project_name} "
"before using it to make GSS calls against other services. When you "
"deserialize the credential from the access token to the GSSCredential "
"object, create the GSSContext with this credential passed to the "
"`GSSManager.createContext` method. For example:"
msgstr ""
"アプリケーションは{project_name}から受け取ったクレームを、他のサービスに対してGSSコールを行う前にデシリアライズする必要があります。アクセストークンから"
" `GSSCredential` オブジェクトにクレデンシャルをデシリアライズしたら、 `GSSManager.createContext` "
"メソッドに渡されたこのクレデンシャルを用いて `GSSContext` を作成する。たとえば、以下のようになります。"

msgid ""
"// Obtain accessToken in your application.\n"
"KeycloakPrincipal keycloakPrincipal = (KeycloakPrincipal) servletReq.getUserPrincipal();\n"
"AccessToken accessToken = keycloakPrincipal.getKeycloakSecurityContext().getToken();\n"
"\n"
"// Retrieve Kerberos credential from accessToken and deserialize it\n"
"String serializedGssCredential = (String) accessToken.getOtherClaims().\n"
"    get(org.keycloak.common.constants.KerberosConstants.GSS_DELEGATION_CREDENTIAL);\n"
"\n"
"GSSCredential deserializedGssCredential = org.keycloak.common.util.KerberosSerializationUtils.\n"
"    deserializeCredential(serializedGssCredential);\n"
"\n"
"// Create GSSContext to call other Kerberos-secured services\n"
"GSSContext context = gssManager.createContext(serviceName, krb5Oid,\n"
"    deserializedGssCredential, GSSContext.DEFAULT_LIFETIME);"
msgstr ""
"// Obtain accessToken in your application.\n"
"KeycloakPrincipal keycloakPrincipal = (KeycloakPrincipal) servletReq.getUserPrincipal();\n"
"AccessToken accessToken = keycloakPrincipal.getKeycloakSecurityContext().getToken();\n"
"\n"
"// Retrieve Kerberos credential from accessToken and deserialize it\n"
"String serializedGssCredential = (String) accessToken.getOtherClaims().\n"
"    get(org.keycloak.common.constants.KerberosConstants.GSS_DELEGATION_CREDENTIAL);\n"
"\n"
"GSSCredential deserializedGssCredential = org.keycloak.common.util.KerberosSerializationUtils.\n"
"    deserializeCredential(serializedGssCredential);\n"
"\n"
"// Create GSSContext to call other Kerberos-secured services\n"
"GSSContext context = gssManager.createContext(serviceName, krb5Oid,\n"
"    deserializedGssCredential, GSSContext.DEFAULT_LIFETIME);"

msgid ""
"Examples of this code exist in `examples/kerberos` in the {project_name} "
"example distribution or demo distribution download. You can also check the "
"example sources directly "
"https://github.com/keycloak/keycloak/tree/main/examples/kerberos[here]."
msgstr ""
"このコードの例は、{project_name}のサンプル配布ファイルまたはデモ配布ファイルのダウンロードの `examples/kerberos` "
"に存在します。また、サンプルのソースを "
"https://github.com/keycloak/keycloak/tree/main/examples/kerberos[ここ]で "
"直接確認することもできます。"

msgid ""
"Configure `forwardable` Kerberos tickets in `krb5.conf` file and add support"
" for delegated credentials to your browser."
msgstr ""
"`krb5.conf` ファイルに `forwardable` "
"Kerberosチケットを設定し、ブラウザーに委任されたクレデンシャルのサポートを追加します。"

msgid ""
"Credential delegation has security implications, so use it only if necessary"
" and only with HTTPS. See https://access.redhat.com/documentation/en-"
"us/red_hat_enterprise_linux/7/html/system-"
"level_authentication_guide/configuring_applications_for_sso[this article] "
"for more details and an example."
msgstr ""
"クレデンシャルの委譲はセキュリティー上の問題があるため、必要な場合のみ使用し、HTTPSでのみ使用してください。詳細と例については、 "
"https://access.redhat.com/documentation/en-"
"us/red_hat_enterprise_linux/7/html/system-"
"level_authentication_guide/configuring_applications_for_sso[この記事] を参照してください。"

msgid "Cross-realm trust"
msgstr "クロスレルム・トラスト"

msgid ""
"In the Kerberos protocol, the `realm` is a set of Kerberos principals. The "
"definition of these principals exists in the Kerberos database, which is "
"typically an LDAP server."
msgstr ""
"Kerberosプロトコルにおいて、 `realm` "
"はKerberosプリンシパルの集合です。これらのプリンシパルの定義はKerberosデータベースに存在し、それは通常LDAPサーバーです。"

msgid ""
"The Kerberos protocol allows cross-realm trust. For example, if 2 Kerberos "
"realms, A and B, exist, then cross-realm trust will allow the users from "
"realm A to access realm B's resources. Realm B trusts realm A."
msgstr ""
"Kerberosプロトコルは、レルム間の信頼を可能にします。たとえば、2つのKerberosレルム、AとBが存在する場合、レルム間信頼はレルムAからのユーザがレルムBのリソースにアクセスすることを可能にします。レルムBはレルムAを信頼します。"

msgid "Kerberos cross-realm trust"
msgstr "Kerberosクロスレルム・トラスト"

msgid "image:images/kerberos-trust-basic.png[]"
msgstr "image:images/kerberos-trust-basic.png[]"

msgid ""
"The {project_name} server supports cross-realm trust. To implement this, "
"perform the following:"
msgstr "{project_name}サーバーは、クロス・レルム・トラストをサポートしています。これを実装するには、以下を実行します。"

msgid ""
"Configure the Kerberos servers for the cross-realm trust. Implementing this "
"step depends on the Kerberos server implementations. This step is necessary "
"to add the Kerberos principal `krbtgt/B@A` to the Kerberos databases of "
"realm A and B. This principal must have the same keys on both Kerberos "
"realms. The principals must have the same password, key version numbers, and"
" ciphers in both realms. Consult the Kerberos server documentation for more "
"details."
msgstr ""
"クロス・レルム・トラストのためにKerberosサーバを設定します。このステップの実装は、Kerberosサーバーの実装に依存します。このステップは、Kerberosプリンシパル"
" `krbtgt/B@A` "
"をレルムAとレルムBのKerberosデータベースに追加するために必要です。プリンシパルは両方のレルムで同じパスワード、鍵のバージョン番号、暗号を持たなければなりません。詳細については、Kerberos"
" サーバーのドキュメントを参照してください。"

msgid ""
"The cross-realm trust is unidirectional by default. You must add the "
"principal `krbtgt/A@B` to both Kerberos databases for bidirectional trust "
"between realm A and realm B. However, trust is transitive by default. If "
"realm B trusts realm A and realm C trusts realm B, then realm C trusts realm"
" A without the principal, `krbtgt/C@A`, available. Additional configuration "
"(for example, `capaths`) may be necessary on the Kerberos client-side so "
"clients can find the trust path. Consult the Kerberos documentation for more"
" details."
msgstr ""
"クロス・レルム・トラストは、デフォルトでは一方向的です。レルムAとレルムBの間で双方向の信頼を行うには、両方のKerberosデータベースに "
"`krbtgt/A@B` "
"というプリンシパルを追加する必要があります。しかし、デフォルトでは信頼は推移的です。レルムBがレルムAを信頼し、レルムCがレルムBを信頼する場合、レルムCはプリンシパル"
" `krbtgt/C@A` "
"を使用せずにレルムAを信頼することになります。クライアントがトラストパスを見つけられるように、Kerberosのクライアントサイドで追加の設定 "
"(たとえば `capaths` ) が必要かもしれません。詳細についてはKerberosのドキュメントを参照してください。"

msgid "Configure {project_name} server"
msgstr "{project_name}サーバーの設定"

msgid ""
"When using an LDAP storage provider with Kerberos support, configure the "
"server principal for realm B, as in this example: `HTTP/mydomain.com@B`. The"
" LDAP server must find the users from realm A if users from realm A are to "
"successfully authenticate to {project_name}, because {project_name} must "
"perform the SPNEGO flow and then find the users."
msgstr ""
"KerberosをサポートするLDAPストレージ・プロバイダーを使用する場合、 `HTTP/mydomain.com@B` "
"のようにレルムBのサーバー・プリンシパルを設定します。LDAPサーバーは、レルムAのユーザーが{project_name}の認証に成功するためには、レルムAのユーザーを見つけなければなりません。なぜなら、{project_name}はSPNEGOフローを実行してから、ユーザーを見つけなければならないからです。"

msgid ""
"For example, Kerberos principal user `john@A` must be available in the LDAP "
"under an LDAP DN such as `uid=john,ou=People,dc=example,dc=com`. If you want"
" users from realm A and B to authenticate, ensure that LDAP can find users "
"from both realms A and B."
msgstr ""
"たとえば、Kerberosのプリンシパル・ユーザーである `john@A` は、LDAPにおいて "
"`uid=john,ou=People,dc=example,dc=com` といったLDAP "
"DNで利用可能でなければなりません。レルムAとレルムBのユーザーを認証したい場合は、LDAPがレルムAとレルムBの両方のユーザーを見つけることができることを確認してください。"

msgid ""
"When using a Kerberos user storage provider (typically, Kerberos without "
"LDAP integration), configure the server principal as `HTTP/mydomain.com@B`, "
"and users from Kerberos realms A and B must be able to authenticate."
msgstr ""
"Kerberosユーザー・ストレージ・プロバイダー（通常、LDAP統合なしのKerberos）を使用する場合、サーバー主体を "
"`HTTP/mydomain.com@B`と設定し、KerberosレルムAおよびレルムBのユーザーが認証できるようにする必要があります。"

msgid ""
"When using the Kerberos user storage provider, there cannot be conflicting "
"users among Kerberos realms. If conflicting users exist, {project_name} maps"
" them to the same user."
msgstr ""
"Kerberosユーザー保存プロバイダーを使用する場合、Kerberosレルム間でユーザーが競合することはできません。競合するユーザーが存在する場合、{project_name}はそれらを同じユーザーにマップします。"

msgid "If you have issues, enable additional logging to debug the problem:"
msgstr "問題が発生した場合は、追加のログを有効にしてデバッグしてください。"

msgid ""
"Enable `Debug` flag in the Admin Console for Kerberos or LDAP federation "
"providers"
msgstr "管理コンソールでKerberosまたはLDAPフェデレーションプロバイダの`Debug`フラグを有効にする。"

msgid ""
"Enable TRACE logging for category `org.keycloak` in the logging section of "
"`standalone/configuration/standalone.xml` to receive more information in "
"`standalone/log/server.log`"
msgstr ""
"`standalone/configuration/standalone.xml` の `logging` のセクションで  "
"`org.keycloak` というカテゴリーのTRACEロギングを有効にすると、  `standalone/log/server.log` "
"でさらに情報を受け取れるようになります。"

msgid ""
"Add system properties `-Dsun.security.krb5.debug=true` and "
"`-Dsun.security.spnego.debug=true`"
msgstr ""
"システム・プロパティー `-Dsun.security.krb5.debug=true` と "
"`-Dsun.security.spnego.debug=true` を追加します"

msgid "X.509 client certificate user authentication"
msgstr "X.509クライアント証明書によるユーザー認証"

msgid ""
"{project_name} supports logging in with an X.509 client certificate if you "
"have configured the server to use mutual SSL authentication."
msgstr ""
"{project_name}は、サーバーがMutual "
"SSL認証を使用するように設定されている場合、X.509クライアント証明書によるログインをサポートします。"

msgid "A typical workflow:"
msgstr "以下は、典型的なワークフローです。"

msgid "A client sends an authentication request over SSL/TLS channel."
msgstr "クライアントは、SSL/TLSチャネル上で認証要求を送信します。"

msgid ""
"During the SSL/TLS handshake, the server and the client exchange their "
"x.509/v3 certificates."
msgstr "SSL/TLSハンドシェイクでは、サーバーとクライアントはx.509/v3証明書を交換します。"

msgid ""
"The container ({appserver_name}) validates the certificate PKIX path and the"
" certificate expiration date."
msgstr "コンテナー（{appserver_name}）は、証明書のPKIXパスと証明書の有効期限を検証します。"

msgid ""
"The x.509 client certificate authenticator validates the client certificate "
"by using the following methods:"
msgstr "x.509クライアント証明書オーセンティケーターは、以下の方法でクライアント証明書を検証します。"

msgid ""
"Checks the certificate revocation status by using CRL or CRL Distribution "
"Points."
msgstr "CRLおよび（または）CRL配布ポイントを使用して証明書失効ステータスをチェックします。"

msgid ""
"Checks the Certificate revocation status by using OCSP (Online Certificate "
"Status Protocol)."
msgstr "OCSP（オンライン証明書ステータス・プロトコル）を使用して証明書失効ステータスをチェックします。"

msgid "Validates whether the key in the certificate matches the expected key."
msgstr "証明書内のキー使用が予想されるキー使用と一致するかどうかを検証します。"

msgid ""
"Validates whether the extended key in the certificate matches the expected "
"extended key."
msgstr "証明書内の拡張キーが予想される拡張キーと一致するかどうかを検証します。"

msgid ""
"If any of the these checks fail, the x.509 authentication fails. Otherwise, "
"the authenticator extracts the certificate identity and maps it to an "
"existing user."
msgstr ""
"これらのチェックのいずれかが失敗した場合、x.509認証は失敗します。それ以外の場合、オーセンティケーターは証明書のアイデンティティーを抽出し、既存のユーザーにマッピングします。"

msgid ""
"When the certificate maps to an existing user, the behavior diverges "
"depending on the authentication flow:"
msgstr "証明書が既存のユーザーにマッピングされる場合、認証フローによって動作が分岐する。"

msgid ""
"In the Browser Flow, the server prompts users to confirm their identity or "
"sign in with a username and password."
msgstr ""
"Browser Flowでは、サーバーはユーザーにアイデンティティーの確認やユーザー名とパスワードによるサインインを求めるプロンプトを表示します。"

msgid "In the Direct Grant Flow, the server signs in the user."
msgstr "Direct Grant Flowでは、サーバーがユーザーにサインインします。"

msgid ""
"Note that it is the responsibility of the web container to validate "
"certificate PKIX path. X.509 authenticator on the {project_name} side "
"provides just the additional support for check the certificate expiration, "
"certificate revocation status and key usage. If you are using {project_name}"
" deployed behind reverse proxy, make sure that your reverse proxy is "
"configured to validate PKIX path. If you do not use reverse proxy and users "
"directly access the {appserver_name}, you should be fine as {appserver_name}"
" makes sure that PKIX path is validated as long as it is configured as "
"described below."
msgstr ""
"証明書のPKIXパスを検証するのはWebコンテナーの責任であることに注意してください。{project_name}側のX.509オーセンティケーターは、証明書の有効期限、証明書の失効ステータス、およびキーの使用状況を確認するための追加サポートを提供します。リバース・プロキシーの背後にデプロイされた{project_name}を使用している場合は、リバース・プロキシーがPKIXパスを検証するように設定されていることを確認してください。リバース・プロキシーを使用せず、ユーザーが{appserver_name}に直接アクセスする場合は、{appserver_name}が、以下に説明するように設定されている限り、PKIXパスが検証されていることを確認するので問題ありません。"

msgid "Supported Certificate Identity Sources:"
msgstr "サポートされている証明書のアイデンティティー・ソース"

msgid "Match SubjectDN by using regular expressions"
msgstr "正規表現を使用したSubjectDN一致"

msgid "X500 Subject's email attribute"
msgstr "X500のSubjectのe-mail属性"

msgid ""
"X500 Subject's email from Subject Alternative Name Extension (RFC822Name "
"General Name)"
msgstr ""
"X500のSubject Alternative Name Extension（RFC822Name General "
"Name）からのSubjectのemail"

msgid ""
"X500 Subject's other name from Subject Alternative Name Extension. This "
"other name is the User Principal Name (UPN), typically."
msgstr ""
"Subject Alternative Name Extensionから取得したX500サブジェクトの別の名前。この別名は通常UPN（User "
"Principal Name）です。"

msgid "X500 Subject's Common Name attribute"
msgstr "X500 Subject's Common Name属性"

msgid "Match IssuerDN by using regular expressions"
msgstr "正規表現を使用したIssuerDN一致"

msgid "Certificate Serial Number"
msgstr "証明書のシリアル番号"

msgid "Certificate Serial Number and IssuerDN"
msgstr "証明書のシリアル番号とIssuerDN"

msgid "SHA-256 Certificate thumbprint"
msgstr "SHA-256証明書のサムプリント"

msgid "Full certificate in PEM format"
msgstr "PEM形式の完全な証明書"

msgid "Regular expressions"
msgstr "正規表現"

msgid ""
"{project_name} extracts the certificate identity from Subject DN or Issuer "
"DN by using a regular expression as a filter. For example, this regular "
"expression matches the email attribute:"
msgstr ""
"{project_name}は、正規表現をフィルターとして使用し、Subject DNまたはIssuer "
"DNから証明書のIDを抽出します。たとえば、この正規表現はemail属性にマッチします。"

msgid "emailAddress=(.*?)(?:,|$)"
msgstr "emailAddress=(.*?)(?:,|$)"

msgid ""
"The regular expression filtering applies if the `Identity Source` is set to "
"either `Match SubjectDN using regular expression` or `Match IssuerDN using "
"regular expression`."
msgstr ""
"正規表現フィルタリングは、 `Identity Source` が `Match SubjectDN using regular expression`"
" か、 `Match IssuerDN using regular expression` のどちらかにセットされている場合に適用されます。"

msgid "Mapping certificate identity to an existing user"
msgstr "既存のユーザーに証明書のアイデンティティーをマッピングする"

msgid ""
"The certificate identity mapping can map the extracted user identity to an "
"existing user's username, email, or a custom attribute whose value matches "
"the certificate identity. For example, setting `Identity source` to "
"_Subject's email_ or `User mapping method` to _Username or email_ makes the "
"X.509 client certificate authenticator use the email attribute in the "
"certificate's Subject DN as the search criteria when searching for an "
"existing user by username or by email."
msgstr ""
"証明書アイデンティティー・マッピングは、抽出されたユーザー・アイデンティティーを既存のユーザーのユーザー名、電子メール、または証明書アイデンティティーと一致する値を持つカスタム属性にマップできます。たとえば、"
" `Identity source` を _Subject's email_ に、または `User mapping method` を "
"_Username or email_ "
"に設定すると、X.509クライアント証明書オーセンティケーターはユーザー名または電子メールで既存のユーザーをルックアップする際の、検索基準として証明書のSubjectDNのemail属性を使用します。"

msgid ""
"If you disable *Login with email* at realm settings, the same rules apply to"
" certificate authentication. Users are unable to log in by using the email "
"attribute."
msgstr ""
"レルムの設定で *Login with email* "
"を無効にすると、証明書認証と同じルールが適用されます。ユーザーは、email属性を使用してログインすることができません。"

msgid ""
"Using `Certificate Serial Number and IssuerDN` as an identity source "
"requires two custom attributes for the serial number and the IssuerDN."
msgstr ""
"アイデンティティー・ソースとして `Certificate Serial Number and IssuerDN` "
"を使用するには、シリアル番号用とIssuerDN用の2つのカスタム属性が必要です。"

msgid ""
"`SHA-256 Certificate thumbprint` is the lowercase hexadecimal representation"
" of SHA-256 certificate thumbprint."
msgstr "`SHA-256 Certificate thumbprint` は、SHA-256証明書のサムプリントの小文字での16進数表現です。"

msgid ""
"Using `Full certificate in PEM format` as an identity source is limited to "
"the custom attributes mapped to external federation sources, such as LDAP. "
"{project_name} cannot store certificates in its database due to length "
"limitations, so in the case of LDAP, you must enable `Always Read Value From"
" LDAP`."
msgstr ""
"IDソースとして `Full certificate in PEM format` "
"を使用すると、LDAPなどの外部フェデレーション・ソースにマッピングされたカスタム属性に制限されます。{project_name}は長さの制限により証明書をデータベースに保存できないため、LDAPの場合は"
" `Always Read Value From LDAP` を有効にする必要があります。"

msgid "Extended certificate validation"
msgstr "拡張された証明書検証"

msgid "Revocation status checking using CRL."
msgstr "CRLを使用した失効ステータスの確認"

msgid "Revocation status checking using CRL/Distribution Point."
msgstr "CRL/Distributionポイントを使用した失効ステータスの確認"

msgid "Revocation status checking using OCSP/Responder URI."
msgstr "OCSP/Responder URIを使用した失効ステータスの確認"

msgid "Certificate KeyUsage validation."
msgstr "証明書のKeyUsage検証"

msgid "Certificate ExtendedKeyUsage validation."
msgstr "証明書のExtendedKeyUsage検証"

msgid "Enable X.509 client certificate user authentication"
msgstr "X.509クライアント証明書のユーザー認証を有効にする"

msgid ""
"The following sections describe how to configure {appserver_name}/Undertow "
"and the {project_name} Server to enable X.509 client certificate "
"authentication."
msgstr ""
"以下のセクションでは、X.509クライアント証明書認証を有効にするために{appserver_name}/Undertowと{project_name}サーバーを設定する方法について説明します。"

msgid "Enable mutual SSL in {appserver_name}"
msgstr "{appserver_name}で相互SSLを有効にする"

msgid ""
"See link:https://docs.wildfly.org/24/Admin_Guide.html#enable-ssl[Enable SSL]"
" for the instructions to enable SSL in {appserver_name}."
msgstr ""
"{appserver_name}でSSLを有効にする方法については、 "
"link:https://docs.wildfly.org/24/Admin_Guide.html#enable-ssl[Enable SSL] "
"を参照してください。"

msgid ""
"Open {project_dirref}/standalone/configuration/standalone.xml and add a new "
"realm:"
msgstr ""
"{project_dirref}/standalone/configuration/standalone.xmlを開き、新しいレルムを追加します。"

msgid ""
"<security-realms>\n"
"    <security-realm name=\"ssl-realm\">\n"
"        <server-identities>\n"
"            <ssl>\n"
"                <keystore path=\"servercert.jks\"\n"
"                          relative-to=\"jboss.server.config.dir\"\n"
"                          keystore-password=\"servercert password\"/>\n"
"            </ssl>\n"
"        </server-identities>\n"
"        <authentication>\n"
"            <truststore path=\"truststore.jks\"\n"
"                        relative-to=\"jboss.server.config.dir\"\n"
"                        keystore-password=\"truststore password\"/>\n"
"        </authentication>\n"
"    </security-realm>\n"
"</security-realms>"
msgstr ""
"<security-realms>\n"
"    <security-realm name=\"ssl-realm\">\n"
"        <server-identities>\n"
"            <ssl>\n"
"                <keystore path=\"servercert.jks\"\n"
"                          relative-to=\"jboss.server.config.dir\"\n"
"                          keystore-password=\"servercert password\"/>\n"
"            </ssl>\n"
"        </server-identities>\n"
"        <authentication>\n"
"            <truststore path=\"truststore.jks\"\n"
"                        relative-to=\"jboss.server.config.dir\"\n"
"                        keystore-password=\"truststore password\"/>\n"
"        </authentication>\n"
"    </security-realm>\n"
"</security-realms>"

msgid "`ssl/keystore`"
msgstr "`ssl/keystore`"

msgid ""
"The `ssl` element contains the `keystore` element that contains the details "
"to load the server public key pair from a JKS keystore."
msgstr "ssl` 要素には、JKS 鍵ストアからサーバーの公開鍵ペアを読み込むための詳細を記述した `keystore` 要素が含まれます。"

msgid "`ssl/keystore/path`"
msgstr "`ssl/keystore/path`"

msgid "The path to the JKS keystore."
msgstr "JKSキーストアへのパス。"

msgid "`ssl/keystore/relative-to`"
msgstr "`ssl/keystore/relative-to`"

msgid "The path that the keystore path is relative to."
msgstr "キーストアパスが相対的なパス。"

msgid "`ssl/keystore/keystore-password`"
msgstr "`ssl/keystore/keystore-password`"

msgid "The password to open the keystore."
msgstr "キーストアを開くためのパスワード。"

msgid "`ssl/keystore/alias` (optional)"
msgstr "`ssl/keystore/alias` （オプション）"

msgid ""
"The alias of the entry in the keystore. Set if the keystore contains "
"multiple entries."
msgstr "キーストア内のエントリーのエイリアス。キーストアに複数のエントリーが含まれている場合に設定します。"

msgid "`ssl/keystore/key-password` (optional)"
msgstr "`ssl/keystore/key-password` （オプション）"

msgid "The private key password, if different from the keystore password."
msgstr "秘密鍵のパスワード（キーストアのパスワードと異なる場合）。"

msgid "`authentication/truststore`"
msgstr "`authentication/truststore`"

msgid ""
"Defines how to load a trust store to verify the certificate presented by the"
" remote side of the inbound/outgoing connection. Typically, the truststore "
"contains a collection of trusted CA certificates."
msgstr ""
"インバウンド/アウトゴーイング接続のリモート側が提示する証明書を検証するためにトラストストアをロードする方法を定義します。通常、トラストストアには、信頼できる認証局の証明書のコレクションが含まれています。"

msgid "`authentication/truststore/path`"
msgstr "`authentication/truststore/path`"

msgid ""
"The path to the JKS keystore containing the certificates of the trusted "
"certificate authorities."
msgstr "信頼できる認証局の証明書を含むJKSキーストアへのパス。"

msgid "`authentication/truststore/relative-to`"
msgstr "`authentication/truststore/relative-to`"

msgid "The path that the truststore path is relative to."
msgstr "トラストストアのパスが相対的であることを示すパス。"

msgid "`authentication/truststore/keystore-password`"
msgstr "`authentication/truststore/keystore-password`"

msgid "The password to open the truststore."
msgstr "トラストストアを開くためのパスワード。"

msgid "Enable HTTPS listener"
msgstr "HTTPSリスナーを有効にする"

msgid ""
"See link:https://docs.wildfly.org/24/Admin_Guide.html#https-listener[HTTPS "
"Listener] for the instructions to enable HTTPS in WildFly."
msgstr ""
"WildFlyでHTTPSを有効にする方法については、 "
"link:https://docs.wildfly.org/24/Admin_Guide.html#https-listener[HTTPSリスナー] "
"を参照してください。"

msgid "Add the <https-listener> element."
msgstr "<https-listener>要素を追加します。"

msgid ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"\t....\n"
"    <server name=\"default-server\">\n"
"\t    <https-listener name=\"default\"\n"
"                        socket-binding=\"https\"\n"
"                        security-realm=\"ssl-realm\"\n"
"                        verify-client=\"REQUESTED\"/>\n"
"    </server>\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"\t....\n"
"    <server name=\"default-server\">\n"
"\t    <https-listener name=\"default\"\n"
"                        socket-binding=\"https\"\n"
"                        security-realm=\"ssl-realm\"\n"
"                        verify-client=\"REQUESTED\"/>\n"
"    </server>\n"
"</subsystem>"

msgid "`https-listener/security-realm`"
msgstr "`https-listener/security-realm`"

msgid "This value must match the name of the realm from the previous section."
msgstr "この値は、前のセクションのレルムの名前と一致する必要があります。"

msgid "`https-listener/verify-client`"
msgstr "`https-listener/verify-client`"

msgid ""
"If set to *REQUESTED*, the server optionally asks for a client certificate. "
"If set to *REQUIRED*, the server refuses inbound connections if no client "
"certificate has been provided."
msgstr ""
"*REQUESTED* に設定すると、サーバーはオプションでクライアント証明書の提出を求めます。 *REQUIRED* "
"に設定すると、サーバーは、クライアント証明書が提供されていない場合、受信接続を拒否します。"

msgid "Adding X.509 client certificate authentication to browser flows"
msgstr "ブラウザーフローへのX.509クライアント証明書認証の追加"

msgid "Click the \"Browser\" flow."
msgstr "\"Browser\" フローをクリックします。"

msgid "Click *Copy* to make a copy of the built-in \"Browser\" flow."
msgstr "*Copy* をクリックすると、内蔵の \"Browser\" フローのコピーが作成されます。"

msgid "Enter a name for the copy."
msgstr "コピーの名前を入力します。"

msgid "Click *Ok*."
msgstr "*Ok* をクリックします。"

msgid "Click the copy in the *Add policy* drop-down box."
msgstr "*Add policy* ドロップダウン・ボックスでコピーをクリックします。"

msgid "Click \"X509/Validate Username Form\"."
msgstr "\"X509/Validate Username Form\"をクリックします。"

msgid "X509 execution"
msgstr "X509エグゼキューション"

msgid "image:images/x509-execution.png[X509 Execution]"
msgstr "image:images/x509-execution.png[X509 Execution]"

msgid ""
"Click the up/down arrow buttons to move the \"X509/Validate Username Form\" "
"over the \"Browser Forms\" execution."
msgstr ""
"上下の矢印ボタンをクリックして、 \"X509/Validate Username Form\" を \"Browser Forms\" "
"エグゼキューションの上に移動させることができます。"

msgid "Set the requirement to \"ALTERNATIVE\"."
msgstr "条件を \"ALTERNATIVE\" に設定します。"

msgid "X509 browser flow"
msgstr "X509ブラウザーフロー"

msgid "image:images/x509-browser-flow.png[X509 Browser Flow]"
msgstr "image:images/x509-browser-flow.png[X509 Browser Flow]"

msgid "Click the copy of the browser flow from the drop-down list."
msgstr "ドロップダウン・リストから、ブラウザーフローのコピーをクリックします。"

msgid "X509 browser flow bindings"
msgstr "X509ブラウザーフロー・バインディング"

msgid ""
"image:images/x509-browser-flow-bindings.png[X509 Browser Flow Bindings]"
msgstr ""
"image:images/x509-browser-flow-bindings.png[X509 Browser Flow Bindings]"

msgid "Configuring X.509 client certificate authentication"
msgstr "X.509クライアント証明書認証の設定"

msgid "X509 configuration"
msgstr "X509の設定"

msgid "image:images/x509-configuration.png[X509 Configuration]"
msgstr "image:images/x509-configuration.png[X509 Configuration]"

msgid "*User Identity Source*"
msgstr "*User Identity Source*"

msgid ""
"Defines the method for extracting the user identity from a client "
"certificate."
msgstr "クライアント証明書からユーザーIDを抽出する方法を定義します。"

msgid "*Canonical DN representation enabled*"
msgstr "*Canonical DN representation enabled*"

msgid ""
"Defines whether to use canonical format to determine a distinguished name. "
"The official "
"link:https://docs.oracle.com/javase/8/docs/api/javax/security/auth/x500/X500Principal.html#getName-"
"java.lang.String-[Java API documentation] describes the format. This option "
"affects the two User Identity Sources _Match SubjectDN using regular "
"expression_ and _Match IssuerDN using regular expression_ only. Enable this "
"option when you set up a new {project_name} instance. Disable this option to"
" retain backward compatibility with existing {project_name} instances."
msgstr ""
"識別名を決定するためにcanonical形式を使用するかどうかを定義します。公式リンク:https://docs.oracle.com/javase/8/docs/api/javax/security/auth/x500/X500Principal.html#getName-"
"java.lang.String-[Java API "
"documentation]にフォーマットが記載されています。このオプションは、2つのユーザーIDソース_Match SubjectDN using "
"regular expression_および_Match IssuerDN using regular "
"expression_にのみ影響します。このオプションは、新しい {project_name} "
"インスタンスをセットアップするときに有効にします。このオプションを無効にすると、既存の {project_name} "
"インスタンスとの後方互換性が保たれます。"

msgid "*Enable Serial Number hexadecimal representation*"
msgstr "*Enable Serial Number hexadecimal representation*"

msgid ""
"Represent the "
"link:https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.2[serial "
"number] as hexadecimal. The serial number with the sign bit set to 1 must be"
" left padded with 00 octet. For example, a serial number with decimal value "
"_161_, or _a1_ in hexadecimal representation is encoded as _00a1_, according"
" to RFC5280. See "
"link:https://datatracker.ietf.org/doc/html/rfc5280#appendix-B[RFC5280, "
"appendix-B] for more details."
msgstr ""
"link:https://datatracker.ietf.org/doc/html/rfc5280#section-4.1.2.2[シリアル番号] "
"を16進数で表現します。符号ビットを1に設定したシリアル番号は、00オクテットで左詰めをする必要があります。たとえば、10進数で _161_ "
"、16進数で _a1_ のシリアルナンバーは、RFC5280によれば _00a1_ と符号化されます。詳細は "
"link:https://datatracker.ietf.org/doc/html/rfc5280#appendix-B[RFC5280, "
"appendix-B] を参照してください。"

msgid "*A regular expression*"
msgstr "*A regular expression*"

msgid ""
"A regular expression to use as a filter for extracting the certificate "
"identity. The expression must contain a single group."
msgstr "証明書のIDを抽出するためのフィルターとして使用する正規表現。この式には1つのグループを含める必要があります。"

msgid "*User Mapping Method*"
msgstr "*User Mapping Method*"

msgid ""
"Defines the method to match the certificate identity with an existing user. "
"_Username or email_ searches for existing users by username or email. "
"_Custom Attribute Mapper_ searches for existing users with a custom "
"attribute that matches the certificate identity. The name of the custom "
"attribute is configurable."
msgstr ""
"証明書のIDを既存のユーザーと照合する方法を定義します。 _Username or email_ "
"は、ユーザー名または電子メールによって既存のユーザーを検索します。 _Custom Attribute Mapper_ "
"は、証明書のIDに一致するカスタム属性を持つ既存のユーザーを検索します。カスタム属性の名前は設定可能です。"

msgid "*A name of user attribute*"
msgstr "*A name of user attribute*"

msgid ""
"A custom attribute whose value matches against the certificate identity. Use"
" multiple custom attributes when attribute mapping is related to multiple "
"values, For example,  'Certificate Serial Number and IssuerDN'."
msgstr ""
"証明書IDに対して値が一致するカスタム属性。たとえば、 'Certificate Serial Number and IssuerDN' "
"のように、属性マッピングが複数の値に関連する場合、複数のカスタム属性を使用します。"

msgid "*CRL Checking Enabled*"
msgstr "*CRL Checking Enabled*"

msgid ""
"Check the revocation status of the certificate by using the Certificate "
"Revocation List. The location of the list is defined in the *CRL file path* "
"attribute."
msgstr "証明書失効リストを使用して、証明書の失効状況を確認します。リストの場所は、 *CRL file path* 属性で定義されます。"

msgid "*Enable CRL Distribution Point to check certificate revocation status*"
msgstr ""
"*Enable CRL Distribution Point to check certificate revocation status*"

msgid ""
"Use CDP to check the certificate revocation status. Most PKI authorities "
"include CDP in their certificates."
msgstr "証明書の失効状況を確認するには、CDPを使用します。ほとんどのPKI機関は、CDPを証明書に含めています。"

msgid "*CRL file path*"
msgstr "*CRL file path*"

msgid ""
"The path to a file containing a CRL list. The value must be a path to a "
"valid file if the *CRL Checking Enabled* option is enabled."
msgstr ""
"CRLのリストを含むファイルへのパス。この値は、 *CRL Checking Enabled* "
"オプションが有効な場合、有効なファイルへのパスでなければなりません。"

msgid "*OCSP Checking Enabled*"
msgstr "*OCSP Checking Enabled*"

msgid ""
"Checks the certificate revocation status by using Online Certificate Status "
"Protocol."
msgstr "オンライン証明書ステータス・プロトコルを用いて、証明書の失効状況を確認します。"

msgid "*OCSP Fail-Open Behavior*"
msgstr "*OCSP Fail-Open Behavior*"

msgid ""
"By default the OCSP check must return a positive response in order to "
"continue with a successful authentication. Sometimes however this check can "
"be inconclusive: for example, the OCSP server could be unreachable, "
"overloaded, or the client certificate may not contain an OCSP responder URI."
" When this setting is turned ON, authentication will be denied only if an "
"explicit negative response is received by the OCSP responder and the "
"certificate is definitely revoked. If a valid OCSP response is not avalaible"
" the authentication attempt will be accepted."
msgstr ""
"デフォルトでは、認証に成功するためには、OCSPチェックが肯定的な応答を返す必要があります。たとえば、OCSPサーバーに到達できない、オーバーロードしている、クライアント証明書にOCSPレスポンダのURIが含まれていない、などの可能性があります。この設定をオンにすると、OCSPレスポンダーから明示的な否定応答を受信し、かつ証明書が確実に失効している場合にのみ、認証が拒否されます。有効なOCSP応答が得られない場合は、認証の試行が許可されます。"

msgid "*OCSP Responder URI*"
msgstr "*OCSP Responder URI*"

msgid "Override the value of the OCSP responder URI in the certificate."
msgstr "証明書に記載されているOCSPレスポンダー URI の値を上書きします。"

msgid "*Validate Key Usage*"
msgstr "*Validate Key Usage*"

msgid ""
"Verifies the certificate's KeyUsage extension bits are set. For example, "
"\"digitalSignature,KeyEncipherment\" verifies if bits 0 and 2 in the "
"KeyUsage extension are set. Leave this parameter empty to disable the Key "
"Usage validation. See "
"link:https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3[RFC5280, "
"Section-4.2.1.3] for more information. {project_name} raises an error when a"
" key usage mismatch occurs."
msgstr ""
"証明書のKeyUsage拡張ビットが設定されていることを確認します。たとえば、\"digitalSignature,KeyEncipherment\"は、KeyUsage拡張のビット0および2が設定されているかどうかを検証します。このパラメーターを空にすると、Key"
" Usageの検証を無効にすることができます。詳細は "
"link:https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.3[RFC5280, "
"Section-4.2.1.3] を参照。{project_name}は、鍵の使用法の不一致が発生した場合にエラーを発生させます。"

msgid "*Validate Extended Key Usage*"
msgstr "*Validate Extended Key Usage*"

msgid ""
"Verifies one or more purposes defined in the Extended Key Usage extension. "
"See "
"link:https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12[RFC5280,"
" Section-4.2.1.12] for more information. Leave this parameter empty to "
"disable the Extended Key Usage validation. {project_name} raises an error "
"when flagged as critical by the issuing CA and a key usage extension "
"mismatch occurs."
msgstr ""
"拡張キー使用法の拡張で定義された1つ以上の目的を検証します。詳細は "
"link:https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.12[RFC5280,"
" Section-4.2.1.12] "
"を参照してください。拡張キー使用法の検証を無効にするには、このパラメーターを空にします。{project_name}は、発行元のCAがCriticalとフラグを立て、キー使用法の拡張の不一致が発生した場合にエラーを発生させます。"

msgid "*Validate Certificate Policy*"
msgstr "*Validate Certificate Policy*"

msgid ""
"Verifies one or more policy OIDs as defined in the Certificate Policy "
"extension. See "
"link:https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.4[RFC5280, "
"Section-4.2.1.4]. Leave the parameter empty to disable the Certificate "
"Policy validation. Multiple policies should be separated using a comma."
msgstr ""
"証明書ポリシー拡張で定義された、1つ以上のポリシーOIDを検証します。 "
"link:https://datatracker.ietf.org/doc/html/rfc5280#section-4.2.1.4[RFC5280、セクション-4.2.1.4]"
" を参照してください。証明書ポリシーの検証を無効にするには、このパラメーターを空にします。複数のポリシーはカンマで区切る必要があります。"

msgid "*Certificate Policy Validation Mode*"
msgstr "*Certificate Policy Validation Mode*"

msgid ""
"When more than one policy is specified in the `Validate Certificate Policy` "
"setting, it decides whether the matching should check for all requested "
"policies to be present, or one match is enough for a successful "
"authentication. Default value is `All`, meaning that all requested policies "
"should be present in the client certificate."
msgstr ""
"`Validate Certificate Policy` "
"の設定で複数のポリシーが指定された場合、要求されたすべてのポリシーが存在することを確認するのか、それとも認証に成功するために1つのマッチングで十分なのかを決定します。デフォルト値は"
" `All` で、要求されたすべてのポリシーがクライアント証明書に存在する必要があることを意味します。"

msgid "*Bypass identity confirmation*"
msgstr "*Bypass identity confirmation*"

msgid ""
"If enabled, X.509 client certificate authentication does not prompt the user"
" to confirm the certificate identity. {project_name} signs in the user upon "
"successful authentication."
msgstr ""
"このオプションを有効にすると、X.509クライアント証明書認証で、証明書のアイデンティティーを確認するためのプロンプトが表示されなくなります。認証に成功すると、{project_name}がユーザーにサインインします。"

msgid "*Revalidate client certificate*"
msgstr "*Revalidate client certificate*"

msgid ""
"If set, the client certificate trust chain will be always verified at the "
"application level using the certificates present in the configured trust "
"store. This can be useful if the underlying web server does not enforce "
"client certificate chain validation, for example because it is behind a non-"
"validating load balancer or reverse proxy, or when the number of allowed CAs"
" is too large for the mutual SSL negotiation (most browsers cap the maximum "
"SSL negotiation packet size at 32767 bytes, which corresponds to about 200 "
"advertised CAs). By default this option is off."
msgstr ""
"設定すると、クライアント証明書のトラストチェーンは、設定されたトラストストアに存在する証明書を使用して、常にアプリケーション・レベルで検証されます。これは、たとえばWebサーバーが検証しないロードバランサーやリバース・プロキシーの背後にあるなどの理由でクライアント証明書チェーンの検証を実施しない場合や、許可されるCAの数がMutual"
" "
"SSLネゴシエーションに対して多すぎる場合（ほとんどのブラウザーは最大SSLネゴシエーション・パケット・サイズを32767バイトに制限しており、これは約200のアドバタイズCAに相当します）に有用となります。デフォルトでは、このオプションはオフになっています。"

msgid "Adding X.509 Client Certificate Authentication to a Direct Grant Flow"
msgstr "ダイレクト・グラント・フローへのX.509クライアント証明書認証の追加"

msgid "Click the \"Direct Grant\" flow."
msgstr "\"Direct Grant\"フローをクリックします。"

msgid "Click *Copy* to make a copy of the \"Direct Grant\" flow."
msgstr "*Copy* をクリックすると、\"Direct Grant\"フローのコピーが作成されます。"

msgid ""
"Click on the *Actions* link for \"Username Validation\" and click *Delete*."
msgstr "\"Username Validation\"の *Actions* リンクをクリックし、 *Delete* をクリックします。"

msgid "Click *Delete*."
msgstr "*Delete* をクリックします。"

msgid "Click on the *Actions* link for \"Password\" and click *Delete*."
msgstr "\"Password\"の *Actions* リンクをクリックし、 *Delete* をクリックします。"

msgid "Click \"X509/Validate Username\"."
msgstr "\"X509/Validate Username\"をクリックします。"

msgid "X509 direct grant execution"
msgstr "X509ダイレクト・グラント・エグゼキューション"

msgid ""
"image:images/x509-directgrant-execution.png[X509 Direct Grant Execution]"
msgstr ""
"image:images/x509-directgrant-execution.png[X509 Direct Grant Execution]"

msgid ""
"Set up the x509 authentication configuration by following the steps "
"described in the <<_browser_flow, x509 Browser Flow>> section."
msgstr "<<_browser_flow, x509 Browser Flow>>に記載されている手順で、x509認証の設定を行います。"

msgid "Click the *Direct Grant Flow* drop-down list."
msgstr "*Direct Grant Flow* のドロップダウン・リストをクリックします。"

msgid "Click the newly created \"x509 Direct Grant\" flow."
msgstr "新しく作成した\"x509 Direct Grant\"フローをクリックします。"

msgid "X509 direct grant flow bindings"
msgstr "X509ダイレクト・グラント・バインディング"

msgid ""
"image:images/x509-directgrant-flow-bindings.png[X509 Direct Grant Flow "
"Bindings]"
msgstr ""
"image:images/x509-directgrant-flow-bindings.png[X509 Direct Grant Flow "
"Bindings]"

msgid "Client certificate lookup"
msgstr "クライアント証明書検索"

msgid ""
"When the {project_name} server receives a direct HTTP request, the "
"{appserver_name} undertow subsystem establishes an SSL handshake and "
"extracts the client certificate. The {appserver_name} saves the client "
"certificate to the `javax.servlet.request.X509Certificate` attribute of the "
"HTTP request, as specified in the servlet specification. The {project_name} "
"X509 authenticator can look up the certificate from this attribute."
msgstr ""
"project_name} サーバーが直接 HTTP リクエストを受け取ると、{appserver_name} サーブレットサブシステムは SSL "
"ハンドシェイクを確立し、クライアント証明書を抽出します。appserver_name} は、サーブレット仕様で規定されているように、HTTPリクエストの"
" `javax.servlet.request.X509Certificate` 属性にクライアント証明書を保存します。project_name} "
"X509認証ツールは、この属性から証明書を検索することができます。"

msgid ""
"However, when the {project_name} server listens to HTTP requests behind a "
"load balancer or reverse proxy, the proxy server may extract the client "
"certificate and establish a mutual SSL connection. A reverse proxy generally"
" puts the authenticated client certificate in the HTTP header of the "
"underlying request. The proxy forwards the request to the back end "
"{project_name} server. In this case, {project_name} must look up the X.509 "
"certificate chain from the HTTP headers rather than the attribute of the "
"HTTP request."
msgstr ""
"しかし、{project_name}サーバーがロードバランサーやリバース・プロキシーの背後でHTTPリクエストをリッスンしている場合、プロキシー・サーバーはクライアント証明書を抽出し、相互のSSL接続を確立することがあります。リバース・プロキシーは一般に、認証されたクライアント証明書を基礎となるリクエストのHTTPヘッダーにセットします。プロキシーはリクエストをバックエンド{project_name}サーバーに転送します。この場合、{project_name}はHTTPリクエストの属性ではなくHTTPヘッダーからX.509証明書チェーンを調べなければなりません。"

msgid ""
"If {project_name} is behind a reverse proxy, you generally need to configure"
" the alternative provider of the `x509cert-lookup` SPI in "
"{project_dirref}/standalone/configuration/standalone.xml. With the `default`"
" provider looking up the HTTP header certificate, two additional built-in "
"providers exist: `haproxy` and `apache`."
msgstr ""
"{project_name}がリバース・プロキシーの背後にある場合、一般的には "
"{project_dirref}/standalone/configuration/standalone.xml で `x509cert-lookup`"
" SPI の代替プロバイダーを設定する必要があります。HTTPヘッダー証明書を検索する `default` "
"プロバイダーには、さらに2つの組み込みプロバイダー `haproxy` と `apache` が存在します。"

msgid "HAProxy certificate lookup provider"
msgstr "HAProxy証明書検索プロバイダー"

msgid ""
"You use this provider when your {project_name} server is behind an HAProxy "
"reverse proxy. Use the following configuration for your server:"
msgstr ""
"このプロバイダーは、{project_name}サーバーがHAProxyのリバース・プロキシーの背後にある場合に使用します。サーバーには、次の設定を使用します。"

msgid ""
"<spi name=\"x509cert-lookup\">\n"
"    <default-provider>haproxy</default-provider>\n"
"    <provider name=\"haproxy\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"sslClientCert\" value=\"SSL_CLIENT_CERT\"/>\n"
"            <property name=\"sslCertChainPrefix\" value=\"CERT_CHAIN\"/>\n"
"            <property name=\"certificateChainLength\" value=\"10\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"x509cert-lookup\">\n"
"    <default-provider>haproxy</default-provider>\n"
"    <provider name=\"haproxy\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"sslClientCert\" value=\"SSL_CLIENT_CERT\"/>\n"
"            <property name=\"sslCertChainPrefix\" value=\"CERT_CHAIN\"/>\n"
"            <property name=\"certificateChainLength\" value=\"10\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid ""
"In this example configuration, the client certificate is looked up from the "
"HTTP header, `SSL_CLIENT_CERT`, and the other certificates from its chain "
"are looked up from HTTP headers such as `CERT_CHAIN_0` through "
"`CERT_CHAIN_9`. The attribute `certificateChainLength` is the maximum length"
" of the chain so the last attribute is `CERT_CHAIN_9`."
msgstr ""
"この設定例では、クライアント証明書はHTTPヘッダーの `SSL_CLIENT_CERT` から検索され、そのチェーンの他の証明書はHTTPヘッダーの "
"`CERT_CHAIN_0` を介して `CERT_CHAIN_9` などから検索されるようになっています。 "
"`certificateChainLength` 属性はチェーンの最大長なので、最後の属性は `CERT_CHAIN_9` となります。"

msgid ""
"Consult the HAProxy documentation for the details of configuring the HTTP "
"Headers for the client certificate and client certificate chain."
msgstr ""
"クライアント証明書およびクライアント証明書チェーンのHTTPヘッダーの設定の詳細については、HAProxyのドキュメントを参照してください。"

msgid "Apache certificate lookup provider"
msgstr "Apache証明書検索プロバイダー"

msgid ""
"You can use this provider when your {project_name} server is behind an "
"Apache reverse proxy. Use the following configuration for your server:"
msgstr ""
"このプロバイダーは、{project_name}サーバーがApacheのリバース・プロキシーの後ろにある場合に使用できます。サーバーには、次の設定を使用してください。"

msgid ""
"<spi name=\"x509cert-lookup\">\n"
"    <default-provider>apache</default-provider>\n"
"    <provider name=\"apache\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"sslClientCert\" value=\"SSL_CLIENT_CERT\"/>\n"
"            <property name=\"sslCertChainPrefix\" value=\"CERT_CHAIN\"/>\n"
"            <property name=\"certificateChainLength\" value=\"10\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"x509cert-lookup\">\n"
"    <default-provider>apache</default-provider>\n"
"    <provider name=\"apache\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"sslClientCert\" value=\"SSL_CLIENT_CERT\"/>\n"
"            <property name=\"sslCertChainPrefix\" value=\"CERT_CHAIN\"/>\n"
"            <property name=\"certificateChainLength\" value=\"10\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid ""
"This configuration is the same as the `haproxy` provider. Consult the Apache"
" documentation on "
"link:https://httpd.apache.org/docs/current/mod/mod_ssl.html[mod_ssl] and "
"link:https://httpd.apache.org/docs/current/mod/mod_headers.html[mod_headers]"
" for details on how the HTTP Headers for the client certificate and client "
"certificate chain are configured."
msgstr ""
"この設定は `haproxy` プロバイダーと同じです。クライアント証明書とクライアント証明書チェーンのHTTPヘッダーの設定方法については、  "
"link:https://httpd.apache.org/docs/current/mod/mod_ssl.html[mod_ssl] と "
"link:https://httpd.apache.org/docs/current/mod/mod_headers.html[mod_headers]"
" にあるApacheのドキュメントを参照してください。"

msgid "NGINX certificate lookup provider"
msgstr "Nginx証明書検索プロバイダー"

msgid ""
"You can use this provider when your {project_name} server is behind an NGINX"
" reverse proxy. Use the following configuration for your server:"
msgstr ""
"このプロバイダーは、{project_name}サーバーがNGINXのリバース・プロキシーの後ろにある場合に使用できます。サーバーには、次の設定を使用してください。"

msgid ""
"<spi name=\"x509cert-lookup\">\n"
"    <default-provider>nginx</default-provider>\n"
"    <provider name=\"nginx\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"sslClientCert\" value=\"ssl-client-cert\"/>\n"
"            <property name=\"sslCertChainPrefix\" value=\"USELESS\"/>\n"
"            <property name=\"certificateChainLength\" value=\"2\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"x509cert-lookup\">\n"
"    <default-provider>nginx</default-provider>\n"
"    <provider name=\"nginx\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"sslClientCert\" value=\"ssl-client-cert\"/>\n"
"            <property name=\"sslCertChainPrefix\" value=\"USELESS\"/>\n"
"            <property name=\"certificateChainLength\" value=\"2\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid ""
"The NGINX "
"link:http://nginx.org/en/docs/http/ngx_http_ssl_module.html#variables[SSL/TLS"
" module] does not expose the client certificate chain. {project_name}'s "
"NGINX certificate lookup provider rebuilds it by using the "
"link:{installguide_truststore_link}[{installguide_truststore_name}]. "
"Populate the {project_name} truststore by using the keytool CLI with all "
"root and intermediate CA's for rebuilding client certificate chain."
msgstr ""
"NGINXの "
"link:http://nginx.org/en/docs/http/ngx_http_ssl_module.html#variables[SSL/TLSモジュール]"
" はクライアント証明書チェーンを公開しません。{project_name}のNGINX証明書検索プロバイダーは、 "
"link:{installguide_truststore_link}[{installguide_truststore_name}] "
"を使用してそれを再構築します。クライアント証明書チェーンを再構築するために、keytool "
"CLIを使用してすべてのルートおよび中間CAで{project_name}トラストストアを入力します。"

msgid ""
"Consult the NGINX documentation for the details of configuring the HTTP "
"Headers for the client certificate."
msgstr "クライアント証明書のHTTPヘッダーの設定の詳細については、NGINXのドキュメントを参照してください。"

msgid "Example of NGINX configuration file :"
msgstr "NGINXの設定ファイルの例を以下に示します。"

msgid ""
" ...\n"
" server {\n"
"    ...\n"
"    ssl_client_certificate                  trusted-ca-list-for-client-auth.pem;\n"
"    ssl_verify_client                       optional_no_ca;\n"
"    ssl_verify_depth                        2;\n"
"    ...\n"
"    location / {\n"
"      ...\n"
"      proxy_set_header ssl-client-cert        $ssl_client_escaped_cert;\n"
"      ...\n"
"    }\n"
"    ...\n"
"}"
msgstr ""
" ...\n"
" server {\n"
"    ...\n"
"    ssl_client_certificate                  trusted-ca-list-for-client-auth.pem;\n"
"    ssl_verify_client                       optional_no_ca;\n"
"    ssl_verify_depth                        2;\n"
"    ...\n"
"    location / {\n"
"      ...\n"
"      proxy_set_header ssl-client-cert        $ssl_client_escaped_cert;\n"
"      ...\n"
"    }\n"
"    ...\n"
"}"

msgid ""
"All certificates in trusted-ca-list-for-client-auth.pem must be added to "
"link:{installguide_truststore_link}[{installguide_truststore_name}]."
msgstr ""
"link:{installguide_truststore_link}[{installguide_truststore_name}] "
"に、trusted-ca-list-for-client-auth.pemのすべての証明書を追加する必要があります。"

msgid "Other reverse proxy implementations"
msgstr "その他のリバース・プロキシーの実装"

msgid ""
"{project_name} does not have built-in support for other reverse proxy "
"implementations. However, you can make other reverse proxies behave in a "
"similar way to `apache` or `haproxy`. If none of these work, create your "
"implementation of the "
"`org.keycloak.services.x509.X509ClientCertificateLookupFactory` and "
"`org.keycloak.services.x509.X509ClientCertificateLookup` providers. See the "
"link:{developerguide_link}[{developerguide_name}] for details on how to add "
"your provider."
msgstr ""
"{project_name}は、他のリバース・プロキシーの実装をビルトインでサポートしていません。しかし、他のリバース・プロキシーでも `apache`"
" や `haproxy` と同じような動作をさせることができます。もし、どれもうまくいかない場合は、 "
"`org.keycloak.services.x509.X509ClientCertificateLookupFactory` と "
"`org.keycloak.services.x509.X509ClientCertificateLookup` "
"プロバイダーを自分で実装して作成してください。プロバイダーの追加方法については、 "
"link:{developerguide_link}[{developerguide_name}] を参照してください。"

msgid "Dumping HTTP headers"
msgstr "HTTPヘッダーのダンプ"

msgid ""
"To view what the reverse proxy sends to Keycloak, enable the "
"`RequestDumpingHandler` Undertow filter and consult the `server.log` file."
msgstr ""
"リバース・プロキシーがKeycloakに送信するものを見るには、 `RequestDumpingHandler` "
"Undertowフィルターを有効にして、 `server.log` ファイルを参照してください。"

msgid "Enable TRACE logging under the logging subsystem"
msgstr "ロギング・サブシステムでTRACEロギングを有効にします。"

msgid ""
"...\n"
"    <profile>\n"
"        <subsystem xmlns=\"urn:jboss:domain:logging:8.0\">\n"
"...\n"
"            <logger category=\"org.keycloak.authentication.authenticators.x509\">\n"
"                <level name=\"TRACE\"/>\n"
"            </logger>\n"
"            <logger category=\"org.keycloak.services.x509\">\n"
"                <level name=\"TRACE\"/>\n"
"            </logger>"
msgstr ""
"...\n"
"    <profile>\n"
"        <subsystem xmlns=\"urn:jboss:domain:logging:8.0\">\n"
"...\n"
"            <logger category=\"org.keycloak.authentication.authenticators.x509\">\n"
"                <level name=\"TRACE\"/>\n"
"            </logger>\n"
"            <logger category=\"org.keycloak.services.x509\">\n"
"                <level name=\"TRACE\"/>\n"
"            </logger>"

msgid "Do not use RequestDumpingHandler or TRACE logging in production."
msgstr "RequestDumpingHandlerやTRACEロギングをプロダクション環境で使用しないでください。"

msgid "Direct Grant authentication with X.509"
msgstr "X.509によるダイレクト・グラント認証"

msgid ""
"You can use the following template to request a token by using the Resource "
"Owner Password Credentials Grant:"
msgstr "リソース・オーナー・パスワード・クレデンシャル・グラントを利用してトークンを要求する場合、以下のテンプレートを使用することができます。"

msgid ""
"$ curl https://[host][:port]/auth/realms/master/protocol/openid-connect/token \\\n"
"       --insecure \\\n"
"       --data \"grant_type=password&scope=openid profile&username=&password=&client_id=CLIENT_ID&client_secret=CLIENT_SECRET\" \\\n"
"       -E /path/to/client_cert.crt \\\n"
"       --key /path/to/client_cert.key"
msgstr ""
"$ curl https://[host][:port]/auth/realms/master/protocol/openid-connect/token \\\n"
"       --insecure \\\n"
"       --data \"grant_type=password&scope=openid profile&username=&password=&client_id=CLIENT_ID&client_secret=CLIENT_SECRET\" \\\n"
"       -E /path/to/client_cert.crt \\\n"
"       --key /path/to/client_cert.key"

msgid "`[host][:port]`"
msgstr "`[host][:port]`"

msgid "The host and the port number of the remote {project_name} server."
msgstr "リモート{project_name}サーバーのホストとポート番号です。"

msgid "`CLIENT_ID`"
msgstr "`CLIENT_ID`"

msgid "The client id."
msgstr "クライアントID。"

msgid "`CLIENT_SECRET`"
msgstr "`CLIENT_SECRET`"

msgid "For confidential clients, a client secret."
msgstr "コンフィデンシャル・クライアントに対するクライアント・シークレット。"

msgid "`client_cert.crt`"
msgstr "`client_cert.crt`"

msgid ""
"A public key certificate to verify the identity of the client in mutual SSL "
"authentication. The certificate must be in PEM format."
msgstr "Mutual SSL認証において、クライアントの身元を確認するための公開鍵証明書です。証明書はPEM形式である必要があります。"

msgid "`client_cert.key`"
msgstr "`client_cert.key`"

msgid "A private key in the public key pair. This key must be in PEM format."
msgstr "公開鍵ペアの秘密鍵。この鍵はPEM形式である必要があります。"

msgid "W3C Web Authentication (WebAuthn)"
msgstr "W3C Web Authentication（WebAuthn）"

msgid ""
"{project_name} provides limited support for "
"https://www.w3.org/TR/webauthn/[W3C Web Authentication (WebAuthn)]. "
"{project_name} works as a WebAuthn's "
"https://www.w3.org/TR/webauthn/#webauthn-relying-party[Relying Party (RP)]."
msgstr ""
"{project_name}は、 https://www.w3.org/TR/webauthn/[W3C Web "
"Authentication（WebAuthn）] の限定的なサポートを提供します。{project_name}はWebAuthnの "
"https://www.w3.org/TR/webauthn/#webauthn-relying-party[Relying Party（RP）] "
"として機能します。"

msgid ""
"Please note that WebAuthn support is in development. Use this feature "
"experimentally."
msgstr "WebAuthnのサポートは開発中であることに注意してください。この機能は実験的に使用してください。"

msgid ""
"WebAuthn's operations success depends on the user's WebAuthn supporting "
"authenticator, browser, and platform. Make sure your authenticator, browser,"
" and platform support the WebAuthn specification."
msgstr ""
"WebAuthnの運用がうまくいくかどうかは、ユーザーのWebAuthn対応オーセンティケーター、ブラウザー、プラットフォームに依存します。お使いのオーセンティケーター、ブブラウザー、プラットフォームが"
" WebAuthn 仕様をサポートしていることを確認してください。"

msgid "Setup"
msgstr "セットアップ"

msgid "The setup procedure of WebAuthn support for 2FA is the following :"
msgstr "2FAのWebAuthnサポートのセットアップ手順は次のとおりです。"

msgid "Enable WebAuthn authenticator registration"
msgstr "WebAuthnオーセンティケーターの登録の有効化"

msgid "Click *Register*."
msgstr "*Register* をクリックします。"

msgid "Click the *Required Action* drop-down list."
msgstr "*Required Action* のドロップダウン・リストをクリックします。"

msgid "Click *Webauthn Register*."
msgstr "*Webauthn Register* をクリックします。"

msgid ""
"Mark the *Default Action* checkbox if you want all new users to be required "
"to register their WebAuthn credentials."
msgstr ""
"すべての新規ユーザーにWebAuthnのクレデンシャルの登録を要求する場合は、 *Default Action* のチェックボックスをONにします。"

msgid "Adding WebAuthn authentication to a browser flow"
msgstr "ブラウザーフローへのWebAuthn認証の追加"

msgid "Click the *Browser* flow."
msgstr "*Browser* フローをクリックします。"

msgid "Click *Copy* to make a copy of the built-in *Browser* flow."
msgstr "*Copy* をクリックすると、内蔵の *Browser* フローのコピーが作成されます。"

msgid ""
"Click the _Actions_ link for *WebAuthn Browser Browser - Conditional OTP* "
"and click _Delete_."
msgstr ""
"*WebAuthn Browser Browser - Conditional OTP* の _Actions_ リンクをクリックし、 _Delete_"
" をクリックします。"

msgid "If you require WebAuthn for all users:"
msgstr "すべてのユーザーにWebAuthnが必要な場合は、以下のようにします。"

msgid "Click on the _Actions_ link for *WebAuthn Browser Forms*."
msgstr "*WebAuthn Browser Forms* の _Actions_ のリンクをクリックします。"

msgid "Click the *Provider* drop-down list."
msgstr "*Provider* のドロップダウン・リストをクリックします。"

msgid "Click *WebAuthn Authenticator*."
msgstr "*Webauthn Authenticator* をクリックします。"

msgid "Click _REQUIRED_ for *WebAuthn Authenticator*"
msgstr "*WebAuthn Authenticator* の _REQUIRED_ をクリックします。"

msgid "image:images/webauthn-browser-flow-required.png[]"
msgstr "image:images/webauthn-browser-flow-required.png[]"

msgid "Click *WebAuthn Browser*."
msgstr "*Webauthn Browser* をクリックします。"

msgid ""
"If a user does not have WebAuthn credentials, the user must register "
"WebAuthn credentials."
msgstr "ユーザーがWebAuthnのクレデンシャルを持っていない場合、ユーザーはWebAuthnのクレデンシャルを登録する必要があります。"

msgid ""
"Users can log in with WebAuthn if they have a WebAuthn credential registered"
" only. So instead of adding the *WebAuthn Authenticator* execution, you can:"
msgstr ""
"ユーザーは、WebAuthnのクレデンシャルが登録されている場合のみ、WebAuthnでログインすることができます。そのため、 *WebAuthn "
"Authenticator* のエグゼキューションを追加する代わりに、以下ができます。"

msgid "Enter \"Conditional 2FA\" for the _Alias_ field."
msgstr "_Alias_ の項目には \"Conditional 2FA\" と入力します。"

msgid "Click _CONDITIONAL_ for *Conditional 2FA*"
msgstr "*Conditional 2FA* の _CONDITIONAL_ をクリックします。"

msgid "Click on the _Actions_ link for *Conditional 2FA*."
msgstr "条件付き2FA*の_Actions_のリンクをクリックします。"

msgid "Click *Condition - User Configured*."
msgstr "*Condition - User Configured* をクリックします。"

msgid "Click _REQUIRED_ for *Conditional 2FA*"
msgstr "*Conditional 2FA* の _REQUIRED_ をクリックします。"

msgid "Click _ALTERNATIVE_ for *Conditional 2FA*"
msgstr "*Conditional 2FA* の _ALTERNATIVE_ をクリックします。"

msgid "image:images/webauthn-browser-flow-conditional.png[]"
msgstr "image:images/webauthn-browser-flow-conditional.png[]"

msgid ""
"The user can choose between using WebAuthn and OTP for the second factor:"
msgstr "2つ目の要素については、WebAuthnを使用するかOTPを使用するかをユーザーが選択できます。"

msgid "Click the _Actions_ link for *Conditional 2FA*."
msgstr "*Conditional 2FA* の _Actions_ のリンクをクリックします。"

msgid "Click *ITP Form*."
msgstr "*ITP Form* をクリックします。"

msgid "image:images/webauthn-browser-flow-conditional-with-OTP.png[]"
msgstr "image:images/webauthn-browser-flow-conditional-with-OTP.png[]"

msgid "Authenticate with WebAuthn authenticator"
msgstr "WebAuthnオーセンティケーターを使用した認証"

msgid ""
"After registering a WebAuthn authenticator, the user carries out the "
"following operations:"
msgstr "WebAuthnオーセンティケーターを登録した後、ユーザーは以下の操作を行います。"

msgid ""
"Open the login form. The user must authenticate with a username and "
"password."
msgstr "ログインフォームを開きます。ユーザーはユーザー名とパスワードで認証する必要があります。"

msgid ""
"The user's browser asks the user to authenticate by using their WebAuthn "
"authenticator."
msgstr "ユーザーのブラウザーは、ユーザーにWebAuthnオーセンティケーターを使用した認証を要求します。"

msgid "Managing WebAuthn as an administrator"
msgstr "管理者としてWebAuthnを管理する"

msgid "Managing credentials"
msgstr "クレデンシャルの管理"

msgid ""
"{project_name} manages WebAuthn credentials similarly to other credentials "
"from xref:ref-user-credentials_{context}[User credential management]:"
msgstr ""
"{project_name}は、 xref:ref-user-credentials_{context}[ユーザークレデンシャル管理] "
"の他のクレデンシャルと同様にWebAuthnのクレデンシャルを管理します。"

msgid ""
"{project_name} assigns users a required action to create a WebAuthn "
"credential from the *Reset Actions* list and select *Webauthn Register*."
msgstr ""
"{project_name}は、 *Reset Actions* の一覧からWebAuthnクレデンシャルを作成し、 *Webauthn "
"Register* を選択するという必須アクションをユーザーに割り当てます。"

msgid "Administrators can delete a WebAuthn credential by clicking *Delete*."
msgstr "管理者は、 *Delete* をクリックして、WebAuthnのクレデンシャルを削除することができます。"

msgid ""
"Administrators can view the credential's data, such as the AAGUID, by "
"selecting *Show data...*."
msgstr "管理者は、 *Show data...* を選択して、AAGUIDなどのクレデンシャルのデータを表示できます。"

msgid ""
"Administrators can set a label for the credential by setting a value in the "
"*User Label* field and saving the data."
msgstr "管理者は、*User Label* フィールドに値を設定し、データを保存することで、クレデンシャルにラベルを設定することができます。"

msgid "Managing policy"
msgstr "ポリシーの管理"

msgid ""
"Administrators can configure WebAuthn related operations as *WebAuthn "
"Policy* per realm."
msgstr "管理者は、WebAuthn関連の操作をレルムごとに *WebAuthn Policy* として設定できます。"

msgid "Click the *WebAuthn Policy* tab."
msgstr "*WebAuthn Policy* タブをクリックします。"

msgid "Configure the items within the policy (see description below)."
msgstr "ポリシー内の項目を設定します（以下の説明を参照）。"

msgid "The configurable items and their description are as follows:"
msgstr "設定可能な項目とその説明は次のとおりです。"

msgid "Relying Party Entity Name"
msgstr "Relying Party Entity Name"

msgid ""
"The readable server name as a WebAuthn Relying Party. This item is mandatory"
" and applies to the registration of the WebAuthn authenticator. The default "
"setting is \"keycloak\". For more details, see "
"https://www.w3.org/TR/webauthn/#dictionary-pkcredentialentity[WebAuthn "
"Specification]."
msgstr ""
"WebAuthn Relying "
"Partyとしての読み取り可能なサーバー名。この項目は必須であり、WebAuthnオーセンティケーターの登録に適用されます。デフォルトは "
"\"keycloak\" です。詳しくは https://www.w3.org/TR/webauthn/#dictionary-"
"pkcredentialentity[WebAuthnの仕様] を参照してください。"

msgid "Signature Algorithms"
msgstr "Signature Algorithms"

msgid ""
"The algorithms telling the WebAuthn authenticator which signature algorithms"
" to use for the https://www.w3.org/TR/webauthn/#iface-pkcredential[Public "
"Key Credential]. {project_name} uses the Public Key Credential to sign and "
"verify https://www.w3.org/TR/webauthn/#authentication-"
"assertion[Authentication Assertions]. If no algorithms exist, the default "
"https://datatracker.ietf.org/doc/html/rfc8152#section-8.1[ES256] is adapted."
" ES256 is an optional configuration item applying to the registration of "
"WebAuthn authenticators. For more details, see "
"https://www.w3.org/TR/webauthn/#dictdef-"
"publickeycredentialparameters[WebAuthn Specification]."
msgstr ""
"WebAuthnオーセンティケーターに https://www.w3.org/TR/webauthn/#iface-"
"pkcredential[Public Key Credential]に使用する署名アルゴ "
"リズムを伝えるアルゴリズム。{project_name}は公開鍵クレデンシャルを使用して "
"https://www.w3.org/TR/webauthn/#authentication-assertion[Authentication "
"Assertions] に署名および検証を行います。アルゴリズムが存在しない場合、デフォルトの "
"https://datatracker.ietf.org/doc/html/rfc8152#section-8.1[ES256] "
"が適応されます。ES256は、WebAuthnオーセンティケーターの登録に適用されるオプションの設定項目です。詳しくは "
"https://www.w3.org/TR/webauthn/#dictdef-"
"publickeycredentialparameters[WebAuthnの仕様]をご覧ください。"

msgid "Relying Party ID"
msgstr "Relying Party ID"

msgid ""
"The ID of a WebAuthn Relying Party that determines the scope of "
"https://www.w3.org/TR/webauthn/#public-key-credential[Public Key "
"Credentials]. The ID must be the origin's effective domain. This ID is an "
"optional configuration item applied to the registration of WebAuthn "
"authenticators. If this entry is blank, {project_name} adapts the host part "
"of {project_name}'s base URL. For more details, see "
"https://www.w3.org/TR/webauthn/[WebAuthn Specification]."
msgstr ""
"https://www.w3.org/TR/webauthn/#public-key-credential[Public Key "
"Credentials]の範囲を決定する、WebAuthn Relying "
"PartyのID。このIDは、オリジンの有効ドメインでなければなりません。このIDは、WebAuthnオーセンティケーターの登録に適用されるオプションの設定項目です。この項目が空白の場合、{project_name}は{project_name}のベースURLのホスト部分を適応します。詳しくは"
" https://www.w3.org/TR/webauthn/[WebAuthnの仕様]を参照してください。"

msgid "Attestation Conveyance Preference"
msgstr "Attestation Conveyance Preference"

msgid ""
"The WebAuthn API implementation on the browser "
"(https://www.w3.org/TR/webauthn/#webauthn-client[WebAuthn Client]) is the "
"preferential method to generate Attestation statements. This preference is "
"an optional configuration item applying to the registration of the WebAuthn "
"authenticator. If no option exists, its behavior is the same as selecting "
"\"none\". For more details, see https://www.w3.org/TR/webauthn/[WebAuthn "
"Specification]."
msgstr ""
"ブラウザー上のWebAuthn API実装（https://www.w3.org/TR/webauthn/#webauthn-"
"client[WebAuthn "
"Client]）は、Attestation文を生成するための優先的な方法です。この設定は、WebAuthnオーセンティケーターの登録に適用されるオプションの設定項目です。オプションがない場合は、"
" \"none\" を選択したのと同じ動作となります。詳しくは https://www.w3.org/TR/webauthn/[WebAuthnの仕様]"
" を参照してください。"

msgid "Authenticator Attachment"
msgstr "Authenticator Attachment"

msgid ""
"The acceptable attachment pattern of a WebAuthn authenticator for the "
"WebAuthn Client. This pattern is an optional configuration item applying to "
"the registration of the WebAuthn authenticator. For more details, see "
"https://www.w3.org/TR/webauthn/#enumdef-authenticatorattachment[WebAuthn "
"Specification]."
msgstr ""
"WebAuthnクライアントで使用可能なWebAuthnオーセンティケーターの添付ファイルパターン。このパターンは、WebAuthnオーセンティケーターの登録に適用されるオプションの設定項目です。詳しくは"
" https://www.w3.org/TR/webauthn/#enumdef-authenticatorattachment[WebAuthn "
"Specification] を参照してください。"

msgid "Require Resident Key"
msgstr "Require Resident Key"

msgid ""
"The option requiring that the WebAuthn authenticator generates the Public "
"Key Credential as https://www.w3.org/TR/webauthn/[Client-side-resident "
"Public Key Credential Source]. This option applies to the registration of "
"the WebAuthn authenticator. If left blank, its behavior is the same as "
"selecting \"No\". For more details, see https://www.w3.org/TR/webauthn/#dom-"
"authenticatorselectioncriteria-requireresidentkey[WebAuthn Specification]."
msgstr ""
"WebAuthnオーセンティケーターが公開鍵クレデンシャルを https://www.w3.org/TR/webauthn/[Client-side-"
"resident Public Key Credential Source]として生成することを要求するオプショ "
"ン。このオプションは、WebAuthnオーセンティケーターの登録に適用されます。空白のままだと、\"No\" "
"を選択した場合と同じ動作になります。詳しくは、 https://www.w3.org/TR/webauthn/#dom-"
"authenticatorselectioncriteria-requireresidentkey[WebAuthn 仕様] を参照してください。"

msgid "User Verification Requirement"
msgstr "User Verification Requirement"

msgid ""
"The option requiring that the WebAuthn authenticator confirms the "
"verification of a user. This is an optional configuration item applying to "
"the registration of a WebAuthn authenticator and the authentication of a "
"user by a WebAuthn authenticator. If no option exists, its behavior is the "
"same as selecting \"preferred\". For more details, see "
"https://www.w3.org/TR/webauthn/#dom-authenticatorselectioncriteria-"
"userverification[WebAuthn Specification for registering a WebAuthn "
"authenticator] and https://www.w3.org/TR/webauthn/#dom-"
"publickeycredentialrequestoptions-userverification[WebAuthn Specification "
"for authenticating the user by a WebAuthn authenticator]."
msgstr ""
"WebAuthnオーセンティケーターがユーザーの認証を確認することを要求するオプションです。これは、WebAuthnオーセンティケーターの登録および "
"WebAuthnオーセンティケーターによるユーザーの認証に適用されるオプション設定項目です。オプションがない場合は、\"preferred\" "
"を選択した場合と同じ動作となります。詳しくは、 https://www.w3.org/TR/webauthn/#dom-"
"authenticatorselectioncriteria-userverification[WebAuthnオーセンティケーターの登録に関する仕様]"
" および https://www.w3.org/TR/webauthn/#dom-publickeycredentialrequestoptions-"
"userverification[WebAuthnオーセンティケーターによるユーザー認証に関する仕様] を参照してください。"

msgid "Timeout"
msgstr "Timeout"

msgid ""
"The timeout value, in seconds, for registering a WebAuthn authenticator and "
"authenticating the user by using a WebAuthn authenticator. If set to zero, "
"its behavior depends on the WebAuthn authenticator's implementation. The "
"default value is 0. For more details, see "
"https://www.w3.org/TR/webauthn/#dom-publickeycredentialcreationoptions-"
"timeout[WebAuthn Specification for registering a WebAuthn authenticator] and"
" https://www.w3.org/TR/webauthn/#dom-publickeycredentialrequestoptions-"
"timeout[WebAuthn Specification for authenticating the user by a WebAuthn "
"authenticator]."
msgstr ""
"WebAuthnオーセンティケーターを用いてユーザーを登録し、認証する際のタイムアウト値を秒単位で指定します。0を指定すると、その動作は "
"WebAuthnオーセンティケーターの実装に依存します。デフォルトは 0 です。詳しくは "
"https://www.w3.org/TR/webauthn/#dom-publickeycredentialcreationoptions-"
"timeout[WebAuthnオーセンティケーターの登録に関する仕様] および "
"https://www.w3.org/TR/webauthn/#dom-publickeycredentialrequestoptions-"
"timeout[WebAuthnオーセンティケーターによるユーザー認証に関する仕様] を参照してください。"

msgid "Avoid Same Authenticator Registration"
msgstr "Avoid Same Authenticator Registration"

msgid ""
"If enabled, {project_name} cannot re-register an already registered WebAuthn"
" authenticator."
msgstr "有効な場合、{project_name}は既に登録されているWebAuthnオーセンティケーターを再登録することはできません。"

msgid "Acceptable AAGUIDs"
msgstr "Acceptable AAGUIDs"

msgid ""
"The white list of AAGUIDs which a WebAuthn authenticator must register "
"against."
msgstr "WebAuthnオーセンティケーターが登録しなければならないAAGUIDのホワイトリスト。"

msgid "Attestation statement verification"
msgstr "Attestation文の検証"

msgid ""
"When registering a WebAuthn authenticator, {project_name} verifies the "
"trustworthiness of the attestation statement generated by the WebAuthn "
"authenticator. {project_name} requires the trust anchor's certificates for "
"this. {project_name} uses the "
"link:{installguide_truststore_link}[{installguide_truststore_name}], so you "
"must import these certificates into it in advance."
msgstr ""
"WebAuthnオーセンティケーターを登録する際、{project_name}はWebAuthnオーセンティケーターが生成するAttestation文の信頼性を検証します。{project_name}は、このためにトラストアンカーの証明書を必要とします。{project_name}は"
" link:{installguide_truststore_link}[{installguide_truststore_name}]  "
"を利用しているので、事前にこれらの証明書をインポートしておく必要があります。"

msgid ""
"To omit this validation, disable this truststore or set the WebAuthn "
"policy's configuration item \"Attestation Conveyance Preference\" to "
"\"none\"."
msgstr ""
"この検証を省略するには、このトラストストアを無効にするか、WebAuthnポリシーの設定項目 \"Attestation Conveyance "
"Preference\" を \"none\" に設定してください。"

msgid "Managing WebAuthn credentials as a user"
msgstr "ユーザーとしてのWebAuthnクレデンシャルの管理"

msgid "Register WebAuthn authenticator"
msgstr "WebAuthnオーセンティケーターの登録"

msgid ""
"The appropriate method to register a WebAuthn authenticator depends on "
"whether the user has already registered an account on {project_name}."
msgstr ""
"WebAuthnオーセンティケーターを登録する適切な方法は、ユーザーが既に {project_name}にアカウントを登録しているかどうかに依存します。"

msgid "New user"
msgstr "新規ユーザー"

msgid ""
"If the *WebAuthn Register* required action is *Default Action* in a realm, "
"new users must set up the WebAuthn security key after their first login."
msgstr ""
"レルムで *WebAuthn Register*の必須アクションが *Default Action* "
"の場合、新規ユーザーは最初のログイン後にWebAuthnセキュリティー鍵をセットアップしなければなりません。"

msgid "Open the login form."
msgstr "ログインフォームを開きます。"

msgid "Fill in the items on the form."
msgstr "フォームの項目を記入します。"

msgid ""
"After successfully registering, the browser asks the user to enter the text "
"of their WebAuthn authenticator's label."
msgstr "登録に成功すると、ブラウザーは、WebAuthnオーセンティケーターのラベルのテキストを入力するようユーザーに要求します。"

msgid "Existing user"
msgstr "既存のユーザー"

msgid ""
"If `WebAuthn Authenticator` is set up as required as shown in the first "
"example, then when existing users try to log in, they are required to "
"register their WebAuthn authenticator automatically:"
msgstr ""
"最初の例のように `WebAuthn Authenticator` "
"を必須として設定すると、既存のユーザーがログインしようとしたときに、自動的にWebAuthnオーセンティケーターの登録が要求されるようになります。"

msgid "Enter the items on the form."
msgstr "フォームに項目を入力します。"

msgid "Click *Login*."
msgstr "*Login* をクリックします。"

msgid ""
"After successful registration, the user's browser asks the user to enter the"
" text of their WebAuthn authenticator's label."
msgstr "登録に成功すると、ユーザーのブラウザーは、WebAuthnオーセンティケーターのラベルのテキストを入力するように要求します。"

msgid "Passwordless WebAuthn together with Two-Factor"
msgstr "パスワードレスWebAuthnと二要素認証の併用"

msgid ""
"{project_name} uses WebAuthn for two-factor authentication, but you can use "
"WebAuthn as the first-factor authentication. In this case, users with "
"`passwordless` WebAuthn credentials can authenticate to {project_name} "
"without a password. {project_name} can use WebAuthn as both the passwordless"
" and two-factor authentication mechanism in the context of a realm and a "
"single authentication flow."
msgstr ""
"{project_name}は二要素認証にWebAuthnを使っていますが、一要素認証にWebAuthnを使うこともできます。この場合、 "
"`passwordless` のWebAuthn "
"のクレデンシャルを持つユーザーは、パスワードなしで{project_name}を認証することができます。{project_name}は、ひとつのレルムとひとつの認証フローで、WebAuthnをパスワードなし認証と二要素認証の両方の仕組みとして使うことができます。"

msgid ""
"An administrator typically requires that Security Keys registered by users "
"for the WebAuthn passwordless authentication meet different requirements. "
"For example, the security keys may require users to authenticate to the "
"security key using a PIN, or the security key attests with a stronger "
"certificate authority."
msgstr ""
"管理者は通常、WebAuthnパスワードレス認証のためにユーザーが登録したセキュリティー鍵が、異なる要件を満たすことを要求します。たとえば、セキュリティー鍵は、ユーザーがPINを使用してセキュリティー鍵に認証することを要求したり、セキュリティー鍵がより強力な認証局で認証することを要求したりすることがあります。"

msgid ""
"Because of this, {project_name} permits administrators to configure a "
"separate `WebAuthn Passwordless Policy`. There is a required `Webauthn "
"Register Passwordless` action of type  and separate authenticator of type "
"`WebAuthn Passwordless Authenticator`."
msgstr ""
"このため、{project_name}は管理者に個別の `WebAuthn Passwordless Policy` を設定することを許可しています。 "
"`WebAuthn Register Passwordless` のアクションが必要で、 `WebAuthn Passwordless "
"Authenticator` タイプのオーセンティケーターが別途必要です。"

msgid "Set up WebAuthn passwordless support as follows:"
msgstr "WebAuthnのパスワードレス対応については、以下のように設定してください。"

msgid ""
"Register a new required action for WebAuthn passwordless support. Use the "
"steps described in <<_webauthn-register, Enable WebAuthn Authenticator "
"Registration>>. Register the `Webauthn Register Passwordless` action."
msgstr ""
"WebAuthnのパスワードレス対応に必須アクションを新規に登録します。<<_webauthn-register, "
"WebAuthnオーセンティケーターの登録の有効化>>で説明した手順を使用してください。 `Webauthn Register "
"Passwordless` アクションを登録します。"

msgid ""
"Configure the policy. You can use the steps and configuration options "
"described in <<_webauthn-policy, Managing Policy>>. Perform the "
"configuration in the Admin Console in the tab *WebAuthn Passwordless "
"Policy*. Typically the requirements for the security key will be stronger "
"than for the two-factor policy. For example, you can set the *User "
"Verification Requirement* to *Required* when you configure the passwordless "
"policy."
msgstr ""
"ポリシーを設定します。<<_webauthn-policy, ポリシーの管理>>で説明した手順と設定オプションが使用できます。管理コンソールのタブ "
"*WebAuthn Passwordless Policy* "
"で設定を実行します。通常、セキュリティー鍵の要件は、2要素ポリシーの要件よりも強くなります。たとえば、パスワードレスポリシーを設定する際に、*User "
"Verification Requirement* を *Required* に設定します。"

msgid ""
"Configure the authentication flow. Use the *WebAuthn Browser* flow described"
" in <<_webauthn-authenticator-setup, Adding WebAuthn Authentication to a "
"Browser Flow>>. Configure the flow as follows:"
msgstr ""
"認証フローを設定します。<<_webauthn-authenticator-setup, "
"ブラウザフローへのWebAuthnオーセンティケーターの追加>>で説明した *WebAuthn Browser* "
"のフローを使用します。フローを以下のように設定します。"

msgid ""
"The *WebAuthn Browser Forms* subflow contains *Username Form* as the first "
"authenticator. Delete the default *Username Password Form* authenticator and"
" add the *Username Form* authenticator. This action requires the user to "
"provide a username as the first step."
msgstr ""
"** WebAuthn Browser Forms* サブフローには、最初の認証子として *Username Form* が含まれています。デフォルトの"
" *Username Password Form* 認証機能を削除して、*Username Form* "
"認証機能を追加してください。このアクションでは、最初のステップとしてユーザーにユーザー名を提供するよう要求します。"

msgid ""
"There will be a required subflow, which can be named *Passwordless Or Two-"
"factor*, for example. This subflow indicates the user can authenticate with "
"Passwordless WebAuthn credential or with Two-factor authentication."
msgstr ""
"たとえば、*Passwordless Or Two-factor* "
"という名前の必須サブフローが存在します。このサブフローは、ユーザーがパスワードレスのWebAuthnクレデンシャルまたは2要素認証で認証できることを示します。"

msgid ""
"The flow contains *WebAuthn Passwordless Authenticator* as the first "
"alternative."
msgstr "このフローには、最初の選択肢として *WebAuthn Passwordless Authenticator* が含まれています。"

msgid ""
"The second alternative will be a subflow named *Password And Two-factor "
"Webauthn*, for example. This subflow contains a *Password Form* and a "
"*WebAuthn Authenticator*."
msgstr ""
"2つ目の選択肢は、たとえば *Password And Two-factor Webauthn* という名前のサブフローになります。このサブフローには、"
" *Password Form* と *WebAuthn Authenticator* が含まれます。"

msgid "The final configuration of the flow looks similar to this:"
msgstr "最終的なフローの設定はこのような感じになります。"

msgid "image:images/webauthn-passwordless-flow.png[]"
msgstr "image:images/webauthn-passwordless-flow.png[]"

msgid ""
"You can now add *WebAuthn Register Passwordless* as the required action to a"
" user, already known to {project_name}, to test this. During the first "
"authentication, the user must use the password and second-factor WebAuthn "
"credential. The user does not need to provide the password and second-factor"
" WebAuthn credential if they use the WebAuthn Passwordless credential. === "
"Conditions in conditional flows"
msgstr ""
"すでに{project_name}に認識されているユーザーに、必須アクションとして *WebAuthn Register Passwordless* を追加し、これをテストすることができます。最初の認証では、ユーザーはパスワードと第2要素のWebAuthnクレデンシャルを使用する必要があります。WebAuthn Passwordlessクレデンシャルを使用する場合、ユーザーはパスワードと第2要素の WebAuthn クレデンシャルを提供する必要はありません。\n"
"\n"
"=== 条件付きフロー内のCondition"

msgid ""
"As was mentioned in <<_execution-requirements, Execution requirements>>, "
"_Condition_ executions can be only contained in _Conditional_ subflow. If "
"all _Condition_ executions evaluate as true, then the _Conditional_ sub-flow"
" acts as _Required_. You can process the next execution in the _Conditional_"
" sub-flow. If some executions included in the _Conditional_ sub-flow "
"evaluate as false, then the whole sub-flow is considered as _Disabled_."
msgstr ""
"<<_execution-requirements, エグゼキューション要件>>で述べたように、 _Condition_ エグゼキューションは "
"_Conditional_ サブフローにのみ含めることができます。すべての _Condition_ エグゼキューションがtrueと評価された場合、 "
"_Conditional_ サブフローは _Required_ として機能します。 _Conditional_ サブフローで次の実行を処理できます。 "
"_Conditional_ サブフローに含まれる一部のエグゼキューションがfalseと評価された場合、サブフロー全体が _Disabled_ "
"と見なされます。"

msgid "Available conditions"
msgstr "利用可能なCondition"

msgid "`Condition - User Role`"
msgstr "`Condition - User Role`"

msgid ""
"This execution has the ability to determine if the user has a role defined "
"by _User role_ field. If the user has the required role, the execution is "
"considered as true and other executions are evaluated. The administrator has"
" to define the following fields:"
msgstr ""
"このエグゼキューションは、ユーザが _User role_ "
"フィールドで定義されたロールを持っているかどうかを判断する機能を持っています。ユーザが必要なロールを持っている場合、このエグゼキューションはtrueとみなされ、他のエグゼキューションが評価されます。管理者は以下のフィールドを定義しなければなりません。"

msgid ""
"Describes a name of the execution, which will be shown in the authentication"
" flow."
msgstr "認証フローに表示されるエグゼキューションの名前を記述します。"

msgid "User role"
msgstr "User role"

msgid ""
"Role the user should have to execute this flow. To specify an application "
"role the syntax is `appname.approle` (for example `myapp.myrole`)."
msgstr ""
"ユーザがこのフローを実行するために持つべきロールです。アプリケーション・ロールを指定するには、構文は `appname.approle` （たとえば "
"`myapp.myrole` ）です。"

msgid "`Condition - User Configured`"
msgstr "`Condition - User Configured`"

msgid ""
"This checks if the other executions in the flow are configured for the user."
" The Execution requirements section includes an example of the OTP form."
msgstr ""
"これは、フロー内の他のエグゼキューションがユーザに対して設定されているかどうかをチェックします。エグゼキューション要件のセクションには、OTPフォームの例が含まれています。"

msgid "`Condition - User Attribute`"
msgstr "`Condition - User Attribute`"

msgid ""
"This checks if the user has set up the required attribute. There is a "
"possibility to negate output, which means the user should not have the "
"attribute. The xref:proc-configuring-user-attributes_{context}[User "
"Attributes] section shows how to add a custom attribute. You can provide "
"these fields:"
msgstr ""
"これは、ユーザが必要な属性を設定したかどうかをチェックします。ユーザーがその属性を持つべきではないことを意味する、出力を否定する可能性があります。 "
"xref:proc-configuring-user-attributes_{context}[ユーザー属性] "
"のセクションでは、カスタム属性を追加する方法を示しています。次のフィールドを提供することができます。"

msgid "Attribute name"
msgstr "Attribute name"

msgid "Name of the attribute to check."
msgstr "チェックする属性の名前です。"

msgid "Expected attribute value"
msgstr "Expected attribute value"

msgid "Expected value in the attribute."
msgstr "属性に期待される値です。"

msgid "Negate output"
msgstr "Negate output"

msgid ""
"You can negate the output. In other words, the attribute should not be "
"present."
msgstr "出力を否定することができます。つまり、属性が存在してはいけないということです。"

msgid "Explicitly deny/allow access in conditional flows"
msgstr "条件付きフローでのアクセスを明示的に拒否/許可する"

msgid ""
"You can allow or deny access to resources in a conditional flow. The two "
"authenticators `Deny Access` and `Allow Access` control access to the "
"resources by conditions."
msgstr ""
"条件付きフローでリソースへのアクセスを許可または拒否できます。2つのオーセンティケーター `Deny Access` と `Allow Access` "
"は、条件によってリソースへのアクセスを制御します。"

msgid "`Allow Access`"
msgstr "`Allow Access`"

msgid ""
"Authenticator will always successfully authenticate. This authenticator is "
"not configurable."
msgstr "オーセンティケーターは常に正常に認証されます。このオーセンティケーターは設定できません。"

msgid "`Deny Access`"
msgstr "`Deny Access`"

msgid ""
"Access will always be denied. You can define an error message, which will be"
" shown to the user. You can provide these fields:"
msgstr "アクセスは常に拒否されます。ユーザーに表示されるエラーメッセージを定義できます。次のフィールドを指定できます。"

msgid "Error message"
msgstr "Error message"

msgid ""
"Error message which will be shown to the user. The error message could be "
"provided as a particular message or as a property in order to use it with "
"localization. (i.e \"_You do not have the role 'admin'._\", _my-property-"
"deny_ in messages properties) Leave blank for the default message defined as"
" property `access-denied`."
msgstr ""
"ユーザーに表示されるエラーメッセージ。エラーメッセージは、ローカリゼーションで使用するために、特定のメッセージまたはプロパティーとして提供できます（つまり、メッセージ・プロパティーに"
" \"_You do not have the role 'admin'._\", _my-property-deny_ ）。プロパティー "
"`access-denied` として定義されているデフォルトのメッセージは空白のままにします。"

msgid ""
"Here is an example how to deny access to all users who do not have the role "
"`role1` and show an error message defined by a property `deny-role1`. This "
"example includes `Condition - User Role` and `Deny Access` executions."
msgstr ""
"これは、ロール `role1` を持たないすべてのユーザーへのアクセスを拒否し、プロパティー `deny-role1` "
"で定義されたエラーメッセージを表示する方法の例です。この例には、 `Condition - User Role` および `Deny Access` "
"のエグゼキューションが含まれます。"

msgid "image:images/deny-access-flow.png[]"
msgstr "image:images/deny-access-flow.png[]"

msgid "Condition - user role configuration"
msgstr "条件 - ユーザーロールの設定"

msgid "image:images/deny-access-role-condition.png[]"
msgstr "image:images/deny-access-role-condition.png[]"

msgid ""
"Configuration of the `Deny Access` is really easy. You can specify an "
"arbitrary Alias and required message like this:"
msgstr "`Deny Access` の設定はとても簡単です。次のように、任意のエイリアスと必要なメッセージを指定できます。"

msgid "image:images/deny-access-execution-cond.png[]"
msgstr "image:images/deny-access-execution-cond.png[]"

msgid ""
"The last thing is defining the property with an error message in the login "
"theme `messages_en.properties` (for English):"
msgstr "最後に、ログインテーマの `messages_en.properties`（英語の場合）でエラーメッセージを含むプロパティーを定義します。"

msgid "deny-role1 = You do not have required role!"
msgstr "deny-role1 = You do not have required role!"

msgid "Integrating identity providers"
msgstr "アイデンティティー・プロバイダーの統合"

msgid ""
"An Identity Broker is an intermediary service connecting service providers "
"with identity providers. The identity broker creates a relationship with an "
"external identity provider to use the provider's identities to access the "
"internal services the service provider exposes."
msgstr ""
"アイデンティティー・ブローカーは、サービス・プロバイダーとアイデンティティー・プロバイダーをつなぐ仲介サービスです。アイデンティティー・ブローカーは、外部のアイデンティティー・プロバイダーとの関係を構築し、プロバイダーのアイデンティティーを使用して、サービス・プロバイダーが公開している内部サービスにアクセスします。"

msgid ""
"From a user perspective, identity brokers provide a user-centric, "
"centralized way to manage identities for security domains and realms. You "
"can link an account with one or more identities from identity providers or "
"create an account based on the identity information from them."
msgstr ""
"ユーザーの視点から見ると、アイデンティティー・ブローカーは、ユーザーを中心とした、セキュリティー・ドメインやレルムのアイデンティティーを一元的に管理する方法を提供します。アカウントをアイデンティティー・プロバイダーから取得した1つまたは複数のアイデンティティーとリンクさせたり、アイデンティティー・プロバイダーから取得したアイデンティティー情報をもとにアカウントを作成することができます。"

msgid ""
"An identity provider derives from a specific protocol used to authenticate "
"and send authentication and authorization information to users. It can be:"
msgstr ""
"アイデンティティー・プロバイダーは、ユーザーを認証し、認証・認可情報を送信するために使用される特定のプロトコルに由来します。アイデンティティー・プロバイダーは、以下を行うことができます。"

msgid "A social provider such as Facebook, Google, or Twitter."
msgstr "Facebook、Google、Twitterなどのソーシャル・プロバイダー"

msgid "A business partner whose users need to access your services."
msgstr "サービスにアクセスする必要があるユーザーの所属するビジネスパートナー"

msgid "A cloud-based identity service you want to integrate."
msgstr "統合したいクラウドベースのアイデンティティー・サービス"

msgid ""
"Typically, {project_name} bases identity providers on the following "
"protocols:"
msgstr "通常、{project_name}は、以下のプロトコルに基づいてアイデンティティー・プロバイダーを構築します。"

msgid "`SAML v2.0`"
msgstr "`SAML v2.0`"

msgid "`OpenID Connect v1.0`"
msgstr "`OpenID Connect v1.0`"

msgid "`OAuth v2.0`"
msgstr "`OAuth v2.0`"

msgid "Brokering overview"
msgstr "ブローカリングの概要"

msgid ""
"When using {project_name} as an identity broker, {project_name} does not "
"force users to provide their credentials to authenticate in a specific "
"realm. {project_name} displays a list of identity providers from which they "
"can authenticate."
msgstr ""
"アイデンティティー・ブローカーとして{project_name}を使用する場合、{project_name}は、特定のレルムで認証するためのクレデンシャルの提供をユーザーに強制しません。{project_name}は、ユーザーが認証できるアイデンティティー・プロバイダーのリストを表示します。"

msgid ""
"If you configure a default identity provider, {project_name} redirects users"
" to the default provider."
msgstr ""
"デフォルトのアイデンティティー・プロバイダーを設定している場合、{project_name}はユーザーをデフォルトのプロバイダーにリダイレクトします。"

msgid ""
"Different protocols may require different authentication flows. All the "
"identity providers supported by {project_name} use the following flow."
msgstr ""
"プロトコルによっては、異なる認証フローが必要になる場合があります。{project_name}がサポートするすべてのアイデンティティー・プロバイダーは、以下のフローを使用します。"

msgid "Identity broker flow"
msgstr "アイデンティティー・ブローカー・フロー"

msgid "image:images/identity_broker_flow.png[Identity broker flow]"
msgstr "image:images/identity_broker_flow.png[Identity broker flow]"

msgid ""
"The unauthenticated user requests a protected resource in a client "
"application."
msgstr "認証されていないユーザーが、クライアント・アプリケーションで保護されたリソースを要求します。"

msgid ""
"The client application redirects the user to {project_name} to authenticate."
msgstr "クライアント・アプリケーションは、ユーザーを{project_name} にリダイレクトし、認証を行います。"

msgid ""
"{project_name} displays the login page with a list of identity providers "
"configured in a realm."
msgstr "{project_name}は、レルムに設定されているアイデンティティー・プロバイダーの一覧を含むログインページを表示します。"

msgid ""
"The user selects one of the identity providers by clicking its button or "
"link."
msgstr "ユーザーは、ボタンやリンクをクリックして、いずれかのアイデンティティー・プロバイダーを選択します。"

msgid ""
"{project_name} issues an authentication request to the target identity "
"provider requesting authentication and redirects the user to the identity "
"provider's login page. The administrator has already set the connection "
"properties and other configuration options for the Admin Console's identity "
"provider."
msgstr ""
"{project_name}は、対象のアイデンティティー・プロバイダーに認証を要求する認証リクエストを発行し、ユーザーをアイデンティティー・プロバイダーのログインページにリダイレクトします。管理者は、管理コンソールのアイデンティティー・プロバイダーの接続プロパティーやその他の設定オプションをすでに設定しています。"

msgid ""
"The user provides credentials or consents to authenticate with the identity "
"provider."
msgstr "ユーザーはアイデンティティー・プロバイダーを認証するためのクレデンシャルまたは同意を提供します。"

msgid ""
"Upon successful authentication by the identity provider, the user redirects "
"back to {project_name} with an authentication response. Usually, the "
"response contains a security token used by {project_name} to trust the "
"identity provider's authentication and retrieve user information."
msgstr ""
"アイデンティティー・プロバイダーによる認証が成功すると、ユーザーは認証レスポンスとともに{project_name}にリダイレクトして戻ります。通常、このレスポンスには{project_name}がアイデンティティー・プロバイダーの認証を信頼してユーザー情報を取得するために使用するセキュリティー・トークンが含まれています。"

msgid ""
"{project_name} checks if the response from the identity provider is valid. "
"If valid, {project_name} imports and creates a user if the user does not "
"already exist. {project_name} may ask the identity provider for further user"
" information if the token does not contain that information. This behavior "
"is _identity federation_. If the user already exists, {project_name} may ask"
" the user to link the identity returned from the identity provider with the "
"existing account. This behavior is _account linking_. With {project_name}, "
"you can configure _Account linking_ and specify it in the "
"<<_identity_broker_first_login,First Login Flow>>. At this step, "
"{project_name} authenticates the user and issues its token to access the "
"requested resource in the service provider."
msgstr ""
"{project_name}は、アイデンティティー・プロバイダーからのレスポンスが有効かどうかをチェックします。有効であれば、{project_name}は、ユーザーがまだ存在していない場合、ユーザーをインポートして作成します。{project_name}は、トークンにユーザー情報が含まれていない場合、アイデンティティー・プロバイダーにさらなるユーザー情報を求めることがあります。この動作が"
" _アイデンティティー・フェデレーション_ です。  "
"ユーザーがすでに存在している場合、{project_name}は、アイデンティティー・プロバイダーから返されたアイデンティティーを既存のアカウントとリンクさせるようユーザーに求めることがあります。この動作は"
" _アカウント・リンキング_ "
"です。{project_name}では、_アカウント・リンキング_を設定し、<<_identity_broker_first_login,First "
"Login "
"Flow>>で指定します。この段階で、{project_name}はユーザーを認証し、サービス・プロバイダーで要求されたリソースにアクセスするためのトークンを発行します。"

msgid ""
"When the user authenticates, {project_name} redirects the user to the "
"service provider by sending the token previously issued during the local "
"authentication."
msgstr ""
"ユーザーが認証されると、{project_name}は、ローカル認証時に以前に発行されたトークンを送信して、ユーザーをサービス・プロバイダーにリダイレクトします。"

msgid ""
"The service provider receives the token from {project_name} and permits "
"access to the protected resource."
msgstr "サービス・プロバイダーは {project_name}からトークンを受け取り、保護されたリソースへのアクセスを許可します。"

msgid ""
"Variations of this flow are possible. For example, the client application "
"can request a specific identity provider rather than displaying a list of "
"them, or you can set {project_name} to force users to provide additional "
"information before federating their identity."
msgstr ""
"このフローのバリエーションは可能です。たとえば、クライアント・アプリケーションは、特定のアイデンティティー・プロバイダーのリストを表示するのではなく、特定のアイデンティティー・プロバイダーを要求することができます。また、{project_name}を設定して、アイデンティティーを連携させる前にユーザーに追加情報の提供を強制することもできます。"

msgid ""
"At the end of the authentication process, {project_name} issues its token to"
" client applications. Client applications are separate from the external "
"identity providers, so they cannot see the client application's protocol or "
"how they validate the user's identity. The provider only needs to know about"
" {project_name}."
msgstr ""
"認証プロセスの最後に、{project_name}はそのトークンをクライアント・アプリケーションに発行します。クライアント・アプリケーションは外部の "
"アイデンティティー・プロバイダーとは別のものなので、クライアント・アプリケーショ "
"ンのプロトコルや、ユーザーのアイデンティティーをどのように検証するかを見ることはできません。プロバイダーは "
"{project_name}のことだけを知っていればよいのです。"

msgid "Default Identity Provider"
msgstr "デフォルトのアイデンティティー・プロバイダー"

msgid ""
"{project_name} can redirect to an identity provider rather than displaying "
"the login form. To enable this redirection:"
msgstr ""
"{project_name}は、ログイン画面を表示するのではなく、アイデンティティー・プロバイダーにリダイレクトすることができます。このリダイレクトを有効にするには以下を行います。"

msgid ""
"Set *Default Identity Provider* to the identity provider you want to "
"redirect users to."
msgstr "*Default Identity Provider* に、ユーザーをリダイレクトしたいアイデンティティー・プロバイダーを設定します。"

msgid ""
"If {project_name} does not find the configured default identity provider, "
"the login form is displayed."
msgstr "{project_name}が設定されたデフォルトのアイデンティティー・プロバイダーを見つけられない場合は、ログイン画面が表示されます。"

msgid ""
"This authenticator is responsible for processing the `kc_idp_hint` query "
"parameter. See the <<_client_suggested_idp, client suggested identity "
"provider>> section for more information."
msgstr ""
"このオーセンティケーターは、 `kc_idp_hint` "
"のクエリー・パラメーターの処理を担当します。詳細は<<_client_suggested_idp, "
"クライアント提案のアイデンティティー・プロバイダー>のセクションを参照してください。"

msgid "General configuration"
msgstr "一般的な構成"

msgid ""
"The foundations of the identity broker configuration are identity providers "
"(IDPs). {project_name} creates identity providers for each realm and enables"
" them for every application by default. Users from a realm can use any of "
"the registered identity providers when signing in to an application."
msgstr ""
"アイデンティティー・ブローカーの設定の基礎となるのは、アイデンティティー・プロバイダー（IDP）です。{project_name}は、各レルムに対して "
"アイデンティティー・プロバイダーを作成し、デフォルトですべてのアプリケーションに対して有効にします。レルムのユーザーは、アプリケーションにサインインする際に、登録されたアイデンティティー・プロバイダーのいずれかを使用できます。"

msgid "Click *Identity Providers* in the menu."
msgstr "メニューの *Identity Providers* をクリックします。"

msgid "Identity Providers"
msgstr "アイデンティティー・プロバイダー"

msgid "image:{project_images}/identity-providers.png[Identity Providers]"
msgstr "image:{project_images}/identity-providers.png[Identity Providers]"

msgid ""
"From the `Add provider` list, select the identity provider you want to add. "
"{project_name} displays the configuration page for the identity provider you"
" selected."
msgstr ""
"`Add provider` "
"のリストから、追加したいアイデンティティー・プロバイダーを選択します。{project_name}は、選択したアイデンティティー・プロバイダーの設定ページを表示します。"

msgid "Add facebook identity Provider"
msgstr "facebookアイデンティティー・プロバイダーの追加"

msgid ""
"image:{project_images}/add-identity-provider.png[Add Facebook Identity "
"Provider]"
msgstr ""
"image:{project_images}/add-identity-provider.png[Add Facebook Identity "
"Provider]"

msgid ""
"When you configure an identity provider, the identity provider appears on "
"the {project_name} login page as an option. You can place custom icons on "
"the login screen for each identity provider. See  "
"link:{developerguide_link}#custom-identity-providers-icons[custom icons] for"
" more information."
msgstr ""
"アイデンティティー・プロバイダーを設定すると、{project_name}のログイン画面にアイデンティティー・プロバイダーがオプションとして表示されます。ログイン画面には、アイデンティティー・プロバイダーごとにカスタムアイコンを配置できます。詳しくは"
" link:{developerguide_link}#custom-identity-providers-icons[カスタムアイコン] "
"を参照してください。"

msgid "IDP login page"
msgstr "IDPログイン・ページ"

msgid "image:{project_images}/identity-provider-login-page.png[]"
msgstr "image:{project_images}/identity-provider-login-page.png[]"

msgid "Social"
msgstr "ソーシャル"

msgid ""
"Social providers enable social authentication in your realm. With "
"{project_name}, users can log in to your application using a social network "
"account. Supported providers include Twitter, Facebook, Google, LinkedIn, "
"Instagram, Microsoft, PayPal, Openshift v3, GitHub, GitLab, Bitbucket, and "
"Stack Overflow."
msgstr ""
"ソーシャル・プロバイダーは、あなたのレルムでソーシャル認証を可能にします。{project_name}を使用すると、ユーザーはソーシャル・ネットワーク・アカウントを使用してアプリケーションにログインできます。サポートされているプロバイダーは、Twitter、Facebook、Google、LinkedIn、Instagram、Microsoft、PayPal、Openshift"
" v3、GitHub、GitLab、Bitbucket、Stack Overflowです。"

msgid "Protocol-based"
msgstr "プロトコル・ ベース"

msgid ""
"Protocol-based providers rely on specific protocols to authenticate and "
"authorize users. Using these providers, you can connect to any identity "
"provider compliant with a specific protocol. {project_name} provides support"
" for SAML v2.0 and OpenID Connect v1.0 protocols. You can configure and "
"broker any identity provider based on these open standards."
msgstr ""
"プロトコルベースのプロバイダーは、特定のプロトコルに依存してユーザーの認証と認可を行います。これらのプロバイダーを使用することで、特定のプロトコルに準拠した任意のアイデンティティー・プロバイダーに接続することができます。{project_name}は、SAML"
" v2.0およびOpenID Connect "
"v1.0プロトコルに対応しています。これらのオープンスタンダードに基づいて、任意のアイデンティティー・プロバイダーを設定し、仲介することができます。"

msgid ""
"Although each type of identity provider has its configuration options, all "
"share a common configuration. The following configuration options available:"
msgstr ""
"アイデンティティー・プロバイダーの種類ごとに設定オプションがありますが、すべてのタイプに共通する設定があります。以下の設定オプションが利用可能です。"

msgid "Common Configuration"
msgstr "共通の設定"

msgid ""
"The alias is a unique identifier for an identity provider and references an "
"internal identity provider. {project_name} uses the alias to build redirect "
"URIs for OpenID Connect protocols that require a redirect URI or callback "
"URL to communicate with an identity provider. All identity providers must "
"have an alias. Alias examples include `facebook`, `google`, and "
"`idp.acme.com`."
msgstr ""
"エイリアスは、アイデンティティー・プロバイダーの一意の識別子であり、内部のアイデンティティー・プロバイダーを参照します。{project_name}は、エイリアスを使用して、アイデンティティー・プロバイダーとの通信にリダイレクトURIまたはコールバックURLを必要とするOpenID"
" ConnectプロトコルのリダイレクトURIを構築します。すべてのアイデンティティー・プロバイダーにはエイリアスが必要です。エイリアスの例としては、 "
"`facebook`、 `google` 、 `idp.acme.com` などがあります。"

msgid "Enabled"
msgstr "Enabled"

msgid "Toggles the provider ON or OFF."
msgstr "プロバイダーのON/OFFを切り替えます。"

msgid "Hide on Login Page"
msgstr "Hide on Login Page"

msgid ""
"When *ON*, {project_name} does not display this provider as a login option "
"on the login page. Clients can request this provider by using the "
"'kc_idp_hint' parameter in the URL to request a login."
msgstr ""
"*ON* "
"の場合、{project_name}は、ログインページのログイン・オプションとしてこのプロバイダーを表示しません。クライアントは、ログインを要求するURLに"
" 'kc_idp_hint' パラメーターを使用して、このプロバイダーを要求できます。"

msgid "Account Linking Only"
msgstr "Account Linking Only"

msgid ""
"When *ON*, {project_name} links existing accounts with this provider. This "
"provider cannot log users in, and {project_name} does not display this "
"provider as an option on the login page."
msgstr ""
"*ON*の場合、{project_name}は既存のアカウントとこのプロバイダーをリンクします。このプロバイダーはユーザーをログインさせることができず、{project_name}はログインページのオプションとしてこのプロバイダーを表示しません。"

msgid "Store Tokens"
msgstr "Store Tokens"

msgid "When *ON*, {project_name} stores tokens from the identity provider."
msgstr "*ON* の場合、{project_name}はアイデンティティー・プロバイダーから取得したトークンを保存します。"

msgid "Stored Tokens Readable"
msgstr "Stored Tokens Readable"

msgid ""
"When *ON*, users can retrieve the stored identity provider token. This "
"action also applies to the _broker_ client-level role _read token_."
msgstr ""
"*ON* "
"の場合、ユーザーは保存されているアイデンティティー・プロバイダーのトークンを取得できます。このアクションは、_broker_クライアントレベル・ロールの"
" _read token_ にも適用されます。"

msgid "Trust Email"
msgstr "Trust Email"

msgid ""
"When *ON*, {project_name} trusts email addresses from the identity provider."
" If the realm requires email validation, users that log in from this "
"identity provider do not need to perform the email verification process."
msgstr ""
"*ON* "
"の場合、{project_name}はアイデンティティー・プロバイダーからの電子メールアドレスを信頼します。レルムが電子メールの検証を必要とする場合、このアイデンティティー・プロバイダーからログインするユーザーは、電子メールの検証プロセスを実行する必要はありません。"

msgid "GUI Order"
msgstr "GUI Order"

msgid "The sort order of the available identity providers on the login page."
msgstr "ログインページで利用可能なアイデンティティー・プロバイダーのソート順を指定します。"

msgid "First Login Flow"
msgstr "初回ログインフロー"

msgid ""
"The authentication flow {project_name} triggers when users use this identity"
" provider to log into {project_name} for the first time."
msgstr ""
"ユーザーがこのアイデンティティー・プロバイダーを使用して{project_name}に初めてログインしたときに{project_name}がトリガーする認証フロー。"

msgid "Post Login Flow"
msgstr "Post Login Flow"

msgid ""
"The authentication flow {project_name} triggers when a user finishes logging"
" in with the external identity provider."
msgstr "ユーザーが外部アイデンティティー・プロバイダーへのログインを終了したときに{project_name}がトリガーする認証フロー。"

msgid "Sync Mode"
msgstr "Sync Mode"

msgid ""
"Strategy to update user information from the identity provider through "
"mappers. When choosing *legacy*, {project_name} used the current behavior. "
"*Import* does not update user data and *force* updates user data when "
"possible. See <<_mappers, Identity Provider Mappers>> for more information."
msgstr ""
"アイデンティティー・プロバイダーからマッパーを介してユーザー情報を更新する戦略。 *legacy* "
"を選択する際、{project_name}は現在の動作を使用します。 *Import* はユーザーデータを更新せず、 *force* "
"は可能な限りユーザーデータを更新します。詳しくは<<_mappers, アイデンティティー・プロバイダー・マッパー>> を参照してください。"

msgid "Social Identity Providers"
msgstr "ソーシャル・アイデンティティー・プロバイダー"

msgid ""
"A social identity provider can delegate authentication to a trusted, "
"respected social media account. {project_name} includes support for social "
"networks such as Google, Facebook, Twitter, GitHub, LinkedIn, Microsoft, and"
" Stack Overflow."
msgstr ""
"ソーシャル・アイデンティティー・プロバイダーは、信頼され、評判の高いソーシャル・メディアのアカウントに認証を委ねることができます。{project_name}には、Google、Facebook、Twitter、GitHub、LinkedIn、Microsoft、Stack"
" Overflowなどのソーシャル・ネットワークのサポートが含まれています。"

msgid "Bitbucket"
msgstr "Bitbucket"

msgid "To log in with Bitbucket, perform the following procedure."
msgstr "Bitbucketでログインするには、以下の手順で行います。"

msgid "From the `Add provider` list, select `Bitbucket`."
msgstr " `Add provider`の一覧から `Bitbucket` を選択します。"

msgid "Add identity provider"
msgstr "アイデンティティー・プロバイダーの追加"

msgid ""
"image:{project_images}/bitbucket-add-identity-provider.png[Add Identity "
"Provider]"
msgstr ""
"image:{project_images}/bitbucket-add-identity-provider.png[Add Identity "
"Provider]"

msgid "Copy the value of *Redirect URI* to your clipboard."
msgstr "Redirect URI* の値をクリップボードにコピーしてください。"

msgid ""
"In a separate browser tab, perform the "
"https://support.atlassian.com/bitbucket-cloud/docs/use-oauth-on-bitbucket-"
"cloud/[OAuth on Bitbucket Cloud] process. When you click *Add Consumer*:"
msgstr ""
"ブラウザーの別のタブで、 https://support.atlassian.com/bitbucket-cloud/docs/use-oauth-"
"on-bitbucket-cloud/[OAuth on Bitbucket Cloud] の処理を行います。 *Add Consumer* "
"をクリックすると"

msgid "Paste the value of *Redirect URI* into the *Callback URL* field."
msgstr "*Callback URL* フィールドに *Redirect URI* の値を貼り付けてください。"

msgid ""
"Ensure you select *Email* and *Read* in the *Account* section to permit your"
" application to read email."
msgstr ""
"アプリケーションがメールを読むことを許可するために、*Account* セクションで *Email* と *Read* "
"を選択していることを確認してください。"

msgid ""
"Note the `Key` and `Secret` values Bitbucket displays when you create your "
"consumer."
msgstr "コンシューマーを作成する際に Bitbucket が表示する `Key` と `Secret` の値に注意してください。"

msgid ""
"In {project_name}, paste the value of the `Key` into the *Client ID* field."
msgstr "{project_name}では、 `Key` の値を *Client ID* フィールドに貼り付けます。"

msgid ""
"In {project_name}, paste the value of the `Secret` into the *Client Secret* "
"field."
msgstr "{project_name}では、 `Secret` の値を *Client Secret* フィールドに貼り付けます。"

msgid "Facebook"
msgstr "Facebook"

msgid ""
"From the `Add provider` list, select `Facebook`. {project_name} displays the"
" configuration page for the Facebook identity provider."
msgstr ""
"`Add provider` の一覧から `Facebook` "
"を選択します。{project_name}はFacebookのアイデンティティー・プロバイダーの設定ページを表示します。"

msgid ""
"image:{project_images}/facebook-add-identity-provider.png[Add Identity "
"Provider]"
msgstr ""
"image:{project_images}/facebook-add-identity-provider.png[Add Identity "
"Provider]"

msgid ""
"In a separate browser tab, follow the "
"https://developers.facebook.com/docs/development/[Facebook Developer "
"Guide's] instructions to create a project and client in Facebook."
msgstr ""
"別のブラウザータブで、 https://developers.facebook.com/docs/development/[Facebook "
"Developer Guide] の指示に従って、Facebookでプロジェクトとクライアントを作成します。"

msgid "Ensure your app is a website-type app."
msgstr "アプリがWebサイトタイプのアプリであることを確認します。"

msgid ""
"Enter the *Redirect URI's* value into the `Site URL` of the Facebook "
"`Website` settings block."
msgstr "Facebookの `Website` 設定ブロックの `Site URL` に、 *Redirect URI* の値を入力します。"

msgid "Ensure the app is public."
msgstr "アプリが公開されていることを確認します。"

msgid ""
"Enter the https://developers.facebook.com/docs/facebook-login/access-"
"tokens/[`Client ID` and `Client Secret`] values from your Facebook app into "
"the `Client ID` and `Client Secret` fields in {project_name}."
msgstr ""
"https://developers.facebook.com/docs/facebook-login/access-tokens/[ `Client "
"ID` and `Client Secret` ] の値をFacebookアプリから{project_name}の `Client ID` と "
"`Client Secret` のフィールドに入力します。"

msgid ""
"Enter the required scopes into the *Default Scopes* field. By default, "
"{project_name} uses the `email` scope. See "
"https://developers.facebook.com/docs/graph-api[Graph API] for more "
"information about Facebook scopes."
msgstr ""
"*Default Scopes* フィールドに必要なスコープを入力します。デフォルトで{project_name}は、 `email` "
"のスコープを使用しています。Facebookのスコープの詳細については、 "
"https://developers.facebook.com/docs/graph-api[Graph API] を参照してください。"

msgid ""
"{project_name} sends profile requests to "
"`graph.facebook.com/me?fields=id,name,email,first_name,last_name` by "
"default. The response contains the id, name, email, first_name, and "
"last_name fields only. To fetch additional fields from the Facebook profile,"
" add a corresponding scope and add the field name in the `Additional user's "
"profile fields` configuration option field."
msgstr ""
"{project_name} デフォルトでは、プロファイル・リクエストを "
"`graph.facebook.com/me?fields=id,name,email,first_name,last_name` "
"に送信します。レスポンスには、id、name、email、first_name、last_nameの各フィールドのみが含まれます。Facebookのプロフィールから追加のフィールドを取得するには、対応するスコープを追加して、"
" `Additional user's profile fields` という設定オプションのフィールドにフィールド名を追加します。"

msgid "GitHub"
msgstr "GitHub"

msgid "To log in with Github, perform the following procedure."
msgstr "Githubでログインするには、以下の手順で行います。"

msgid "From the `Add provider` list, select `Github`."
msgstr "`Add provider` のリストから `Github` を選択します。"

msgid ""
"image:{project_images}/github-add-identity-provider.png[Add Identity "
"Provider]"
msgstr ""
"image:{project_images}/github-add-identity-provider.png[Add Identity "
"Provider]"

msgid ""
"In a separate browser tab, "
"https://docs.github.com/en/developers/apps/building-oauth-apps/creating-an-"
"oauth-app[create an OAUTH app]."
msgstr ""
"別のブラウザータブで、 https://docs.github.com/en/developers/apps/building-oauth-"
"apps/creating-an-oauth-app[create an OAUTH app] を実行します。"

msgid ""
"Enter the value of *Redirect URI* into the `Authorization callback URL` "
"field when creating the app."
msgstr ""
"アプリの作成時に、 `Authorization callback URL` フィールドに *Redirect URI* の値を入力してください。"

msgid ""
"Note the Client ID and Client secret on the management page of your OAUTH "
"app."
msgstr "OAUTHアプリの管理画面で、Client IDとClient secretをメモします。"

msgid ""
"In {project_name}, paste the value of the `Client ID` into the *Client ID* "
"field."
msgstr "{project_name}では、`Client ID` の値を *Client ID* フィールドに貼り付けます。"

msgid ""
"In {project_name}, paste the value of the `Client Secret` into the *Client "
"Secret* field."
msgstr "{project_name}では、`Client Secret` の値を *Client Secret* フィールドに貼り付けます。"

msgid "GitLab"
msgstr "GitLab"

msgid "From the `Add provider` list, select `GitLab`."
msgstr "`Add provider` のリストから `GitLab` を選択します。"

msgid ""
"image:{project_images}/github-add-identity-provider.png[Add identity "
"provider]"
msgstr ""
"image:{project_images}/github-add-identity-provider.png[Add identity "
"provider]"

msgid ""
"In a separate browser tab, "
"https://docs.gitlab.com/ee/integration/oauth_provider.html[add a new GitLab "
"application]."
msgstr ""
"別のブラウザータブで、 https://docs.gitlab.com/ee/integration/oauth_provider.html[add a"
" new GitLab application] を実行します。"

msgid "Use the *Redirect URI* in your clipboard as the *Redirect URI*."
msgstr "クリップボードにある *Redirect URI* を *Redirect URI* として使用します。"

msgid ""
"Note the `Client ID` and `Client Secret` when you save the application."
msgstr "アプリケーションを保存する際には、 `Client ID` と `Client Secret` をメモしてください。"

msgid "Google"
msgstr "Google"

msgid "From the `Add provider` list, select `Google`."
msgstr "`Add provider` のリストから `Google` を選択します。"

msgid ""
"image:{project_images}/google-add-identity-provider.png[Add Identity "
"Provider]"
msgstr ""
"image:{project_images}/google-add-identity-provider.png[Add Identity "
"Provider]"

msgid ""
"In a separate browser tab open https://console.cloud.google.com/[the Google "
"Cloud Platform console]."
msgstr ""
"ブラウザーの別のタブで、 https://console.cloud.google.com/[Google Cloud Platformのコンソール] "
"を開きます。"

msgid ""
"In the Google dashboard for your Google app, click the *OAuth consent "
"screen* menu. Create a consent screen, ensuring that the user type of the "
"consent screen is external."
msgstr ""
"GoogleアプリのGoogleダッシュボードで、 *OAuth consent screen* "
"メニューをクリックします。同意画面を作成し、同意画面のユーザータイプが外部であることを確認します。"

msgid "In the Google dashboard:"
msgstr "Googleのダッシュボードで以下を行います。"

msgid "Click the *Credentials* menu."
msgstr "*Credentials* メニューをクリックします。"

msgid "Click *CREATE CREDENTIALS* - *OAuth Client ID*."
msgstr "*CREATE CREDENTIALS* - *OAuth Client ID* をクリックします。"

msgid "From the *Application type* list, select *Web application*."
msgstr "*Application type* の一覧から *Web application* を選択します。"

msgid "Note *Your Client ID* and *Your Client Secret*."
msgstr "*Your Client ID* と *Your Client Secret* に注意してください。"

msgid ""
"In {project_name}, paste the value of the *Your Client ID* into the *Client "
"ID* field."
msgstr "{project_name}では、*Your Client ID* の値を *Client ID* フィールドに貼り付けます。"

msgid ""
"In {project_name}, paste the value of the *Your Client Secret* into the "
"*Client Secret* field."
msgstr ""
"{project_name}では、*Your Client Secret* の値を *Client Secret* フィールドに貼り付けます。"

msgid ""
"Enter the required scopes into the *Default Scopes* field. By default, "
"{project_name} uses the following scopes: `openid` `profile` `email`. See "
"the https://developers.google.com/oauthplayground/[OAuth Playground] for a "
"list of Google scopes."
msgstr ""
"*Default Scopes* の欄に必要なスコープを入力してください。デフォルトでは、{project_name}は `openid` 、 "
"`profile`  、`email` のスコープを使用します。Googleのスコープの一覧は、 "
"https://developers.google.com/oauthplayground/[OAuth Playground] を参照してください。"

msgid ""
"To restrict access to your GSuite organization's members only, enter the G "
"Suite domain into the `Hosted Domain` field."
msgstr "GSuite組織のメンバーのみにアクセスを制限するには、 `Hosted Domain` フィールドにG Suiteドメインを入力します。"

msgid "LinkedIn"
msgstr "LinkedIn"

msgid "From the `Add provider` list, select `LinkedIn`."
msgstr "`Add provider` のリストから `LinkedIn` を選択します。"

msgid ""
"In a separate browser tab, https://www.linkedin.com/developer/apps[create an"
" app]."
msgstr ""
"別のブラウザータブで、 https://www.linkedin.com/developer/apps[create an app] を実行します。"

msgid "After you create the app, click the *Auth* tab."
msgstr "アプリを作成した後、 *Auth* タブをクリックします。"

msgid ""
"Enter the value of *Redirect URI* into the *Authorized redirect URLs for "
"your app* field."
msgstr ""
"*Authorized redirect URLs for your app* フィールドに、 *Redirect URI* の値を入力してください。"

msgid ""
"In {project_name}, paste the value of the *Client ID* into the *Client ID* "
"field."
msgstr "{project_name}では、*Client ID* の値を *Client ID* フィールドに貼り付けます。"

msgid ""
"In {project_name}, paste the value of the *Client Secret* into the *Client "
"Secret* field."
msgstr "{project_name}では、*Client Secret* の値を *Client Secret* フィールドに貼り付けます。"

msgid "Microsoft"
msgstr "Microsoft"

msgid "From the `Add provider` list, select `Microsoft`."
msgstr " `Add provider`の一覧から `Microsoft` を選択します。"

msgid ""
"In a separate browser tab, "
"https://account.live.com/developers/applications/create[create a Microsoft "
"app]."
msgstr ""
"別のブラウザータブで、 https://account.live.com/developers/applications/create[create a"
" Microsoft app] を実行します。"

msgid "Click *Add URL* to add the redirect URL to the Microsoft app."
msgstr "*Add URL* をクリックして、MicrosoftアプリにリダイレクトURLを追加します。"

msgid "Note the *Application ID* and *Application Secret*."
msgstr "*Application ID* と *Application Secret* に注意してください。"

msgid ""
"In {project_name}, paste the value of the *Application ID* into the *Client "
"ID* field."
msgstr "{project_name}では、*Application ID* の値を *Client ID* フィールドに貼り付けます。"

msgid ""
"In {project_name}, paste the value of the *Application Secret* into the "
"*Client Secret* field."
msgstr ""
"{project_name}では、*Application Secret* の値を *Client Secret* フィールドに貼り付けます。"

msgid "OpenShift 3"
msgstr "OpenShift 3"

msgid "From the `Add provider` list, select `Openshift`."
msgstr "`Add provider` のリストから `Openshift` を選択します。"

msgid ""
"image:images/openshift-add-identity-provider.png[Add Identity Provider]"
msgstr ""
"image:images/openshift-add-identity-provider.png[Add Identity Provider]"

msgid "Register your client using the `oc` command-line tool."
msgstr "コマンドライン・ツール `oc` を使って、クライアントを登録します。"

msgid ""
"$ oc create -f <(echo '\n"
"kind: OAuthClient\n"
"apiVersion: v1\n"
"metadata:\n"
" name: kc-client <1>\n"
"secret: \"...\" <2>\n"
"redirectURIs:\n"
" - \"http://www.example.com/\" <3>\n"
"grantMethod: prompt <4>\n"
"')"
msgstr ""
"$ oc create -f <(echo '\n"
"kind: OAuthClient\n"
"apiVersion: v1\n"
"metadata:\n"
" name: kc-client <1>\n"
"secret: \"...\" <2>\n"
"redirectURIs:\n"
" - \"http://www.example.com/\" <3>\n"
"grantMethod: prompt <4>\n"
"')"

msgid ""
"The `name` of your OAuth client. Passed as `client_id` request parameter "
"when making requests to `_<openshift_master>_/oauth/authorize` and "
"`_<openshift_master>_/oauth/token`."
msgstr ""
"OAuthクライアントの `name` です。 `_<openshift_master>_/oauth/authorize` と "
"`_<openshift_master>_/oauth/token` へのリクエストを行うときに `client_id` "
"リクエスト・パラメーターとして渡されます。"

msgid ""
"The `secret` {project_name} uses for the `client_secret` request parameter."
msgstr "`client_secret` のリクエスト・パラメーターには、{project_name}の `secret` を使用します。"

msgid ""
"The `redirect_uri` parameter specified in requests to "
"`_<openshift_master>_/oauth/authorize` and "
"`_<openshift_master>_/oauth/token` must be equal to (or prefixed by) one of "
"the URIs in `redirectURIs`. You can obtain this from the *Redirect URI* "
"field in the Identity Provider screen"
msgstr ""
"`_<openshift_master>_/oauth/authorize` および "
"`_<openshift_master>_/oauth/token` へのリクエストで指定された `redirect_uri` パラメーターは、 "
"`redirectURIs` のURIの1つと一致する（または前方一致する）必要があります。これは、アイデンティティー・プロバイダー画面の "
"*リダイレクトURI* フィールドから取得できます。"

msgid ""
"The `grantMethod` {project_name} uses to determine the action when this "
"client requests tokens but has not been granted access by the user."
msgstr ""
"`grantMethod` "
"は、このクライアントがトークンを要求したがユーザーからのアクセスが許可されていない場合のアクションを決定するために{project_name}が使用します"
" 。"

msgid "OpenShift 4"
msgstr "OpenShift 4"

msgid "Installation of https://stedolan.github.io/jq/[jq]."
msgstr "https://stedolan.github.io/jq/[jq] のインストール。"

msgid ""
"`X509_CA_BUNDLE` configured in the container and set to "
"`/var/run/secrets/kubernetes.io/serviceaccount/ca.crt`."
msgstr ""
"コンテナーに設定された `X509_CA_BUNDLE` には、 "
"`/var/run/secrets/kubernetes.io/serviceaccount/ca.crt` が設定されています。"

msgid ""
"Run the following command on the command line and note the OpenShift 4 API "
"URL output."
msgstr "コマンドラインで以下のコマンドを実行し、OpenShift 4 APIのURLの出力をメモします。"

msgid ""
"curl -s -k -H \"Authorization: Bearer $(oc whoami -t)\" "
"\\https://<openshift-user-facing-api-"
"url>/apis/config.openshift.io/v1/infrastructures/cluster | jq "
"\".status.apiServerURL\""
msgstr ""
"curl -s -k -H \"Authorization: Bearer $(oc whoami -t)\" "
"\\https://<openshift-user-facing-api-"
"url>/apis/config.openshift.io/v1/infrastructures/cluster | jq "
"\".status.apiServerURL\""

msgid "Click *Identity Providers* in the {project_name} menu."
msgstr "{project_name}のメニューの *Identity Providers* をクリックします。"

msgid ""
"image:images/openshift-4-add-identity-provider.png[Add Identity Provider]"
msgstr ""
"image:images/openshift-4-add-identity-provider.png[Add Identity Provider]"

msgid ""
"$ oc create -f <(echo '\n"
"kind: OAuthClient\n"
"apiVersion: oauth.openshift.io/v1\n"
"metadata:\n"
" name: keycloak-broker <1>\n"
"secret: \"...\" <2>\n"
"redirectURIs:\n"
" - \"<copy pasted Redirect URI from OpenShift 4 Identity Providers page>\" <3>\n"
"grantMethod: prompt <4>\n"
"')"
msgstr ""
"$ oc create -f <(echo '\n"
"kind: OAuthClient\n"
"apiVersion: oauth.openshift.io/v1\n"
"metadata:\n"
" name: keycloak-broker <1>\n"
"secret: \"...\" <2>\n"
"redirectURIs:\n"
" - \"<copy pasted Redirect URI from OpenShift 4 Identity Providers page>\" <3>\n"
"grantMethod: prompt <4>\n"
"')"

msgid ""
"The `name` of your OAuth client. Passed as `client_id` request parameter "
"when making requests to `_<openshift_master>_/oauth/authorize` and "
"`_<openshift_master>_/oauth/token`. The `name` parameter must be the same in"
" the `OAuthClient` object and the {project_name} configuration."
msgstr ""
"OAuth クライアントの `name` です。 `_<openshift_master>_/oauth/authorize` や "
"`_<openshift_master>_/oauth/token` へのリクエストの際に `client_id` "
"というリクエストパラメータとして渡されます。 `name` パラメーターは、 `OAuthClient` "
"オブジェクトと{project_name}の設定で同じでなければなりません。"

msgid ""
"The `secret` {project_name} uses as the `client_secret` request parameter."
msgstr "`secret` は {project_name} が `client_secret` のリクエスト・パラメーターとして使用します。"

msgid ""
"The `redirect_uri` parameter specified in requests to "
"`_<openshift_master>_/oauth/authorize` and "
"`_<openshift_master>_/oauth/token` must be equal to (or prefixed by) one of "
"the URIs in `redirectURIs`. The easiest way to configure it correctly is to "
"copy-paste it from {project_name} OpenShift 4 Identity Provider "
"configuration page (`Redirect URI` field)."
msgstr ""
"`_<openshift_master>_/oauth/authorize` と `_<openshift_master>_/oauth/token` "
"へのリクエストで指定される `redirect_uri` パラメーターは、`redirectURIs` に含まれる URI のいずれかと等しい "
"(または前方一致している) "
"必要があります。正しく設定する最も簡単な方法は、{project_name}からコピーペーストすることです。OpenShift 4 Identity "
"Providerの設定ページ（ `Redirect URI` フィールド）からコピーペーストします。"

msgid ""
"See https://docs.okd.io/latest/authentication/configuring-oauth-"
"clients.html#oauth-register-additional-client_configuring-oauth-"
"clients[official OpenShift documentation] for more information."
msgstr ""
"詳しくは、 https://docs.okd.io/latest/authentication/configuring-oauth-"
"clients.html#oauth-register-additional-client_configuring-oauth-"
"clients[OpenShiftの公式ドキュメント] を参照してください。"

msgid "PayPal"
msgstr "PayPal"

msgid "From the `Add provider` list, select `PayPal`."
msgstr "`Add provider` のリストから `PayPal` を選択します。"

msgid ""
"In a separate browser tab, open the "
"https://developer.paypal.com/developer/applications[PayPal Developer "
"applications area]."
msgstr ""
"別のブラウザータブで、 https://developer.paypal.com/developer/applications[PayPal "
"Developer applications area] を開きます。"

msgid "Click *Create App* to create a PayPal app."
msgstr "*Create App* をクリックして、PayPalアプリを作成します。"

msgid ""
"Note the Client ID and Client Secret. Click the *Show* link to view the "
"secret."
msgstr "クライアントIDとクライアント・シークレットを確認します。 *Show* のリンクをクリックするとシークレットが表示されます。"

msgid "Ensure *Connect with PayPal* is checked."
msgstr "*Connect with PayPal* がチェックされていることを確認してください。"

msgid ""
"Set the value of the *Return URL* field to the value of *Redirect URI* from "
"{project_name}."
msgstr "{project_name}から取得した *Redirect URI* の値を*Return URL* フィールドに設定します。"

msgid "Stack overflow"
msgstr "スタックオーバーフロー"

msgid "From the `Add provider` list, select `Stack Overflow`."
msgstr "`Add provider` のリストから `Stack Overflow` を選択します。"

msgid ""
"In a separate browser tab, log into "
"https://stackapps.com/apps/oauth/register[registering your application on "
"Stack Apps]."
msgstr ""
"別のブラウザータブで、 https://stackapps.com/apps/oauth/register[Stack "
"Appsにアプリケーションを登録] にログインします。"

msgid "Register application"
msgstr "アプリケーションの登録"

msgid "image:images/stack-overflow-app-register.png[Register Application]"
msgstr "image:images/stack-overflow-app-register.png[Register Application]"

msgid "Enter your application name into the *Application Name* field."
msgstr "*Application Name* フィールドにアプリケーション名を入力してください。"

msgid "Enter the OAuth domain into the *OAuth Domain* field."
msgstr "*OAuth Domain* フィールドにOAuthドメインを入力してください。"

msgid "Click *Register Your Application*."
msgstr "*Register Your Application* をクリックします。"

msgid "Settings"
msgstr "設定"

msgid "image:images/stack-overflow-app-settings.png[Settings]"
msgstr "image:images/stack-overflow-app-settings.png[Settings]"

msgid "Note the *Client ID* and *Client Secret*."
msgstr "*Client ID* と *Client Secret* に注意してください。"

msgid "Twitter"
msgstr "Twitter"

msgid "A Twitter developer account."
msgstr "Twitterの開発者アカウントです。"

msgid "From the `Add provider` list, select `Twitter`."
msgstr "Add provider \"のリストから \"Twitter \"を選択します。"

msgid ""
"image:{project_images}/twitter-add-identity-provider.png[Add Identity "
"Provider]"
msgstr ""
"image:{project_images}/twitter-add-identity-provider.png[Add Identity "
"Provider]"

msgid ""
"In a separate browser tab, create an app in "
"https://developer.twitter.com/apps/[Twitter Application Management]."
msgstr ""
"ブラウザーの別のタブで https://developer.twitter.com/apps/[Twitter Application "
"Management] を開き、アプリを作成します。"

msgid "Enter any value for name and description."
msgstr "nameとdescriptionには任意の値を入力してください。"

msgid "The value for *Website* can be any valid URL except `localhost`."
msgstr "*Website* の値には、 `localhost` を除く任意の有効なURLを指定します。"

msgid "Paste the value of the *Redirect URL* into the *Callback URL* field."
msgstr "*Redirect URL* の値を *Callback URL* フィールドに貼り付けてください。"

msgid ""
"When you create your Twitter app, note the value of *Consumer Key* and "
"*Consumer Secret* in the *Keys and Access Tokens* section."
msgstr ""
"Twitterアプリを作成する際は、 *Keys and Access Tokens* のセクションの *Consumer Secret* と "
"*Keys and Access Tokens* の値に注意してください。"

msgid ""
"In {project_name}, paste the value of the *Consumer Key* into the *Client "
"ID* field."
msgstr "{project_name}では、 *Client ID* フィールドに *Consumer Key* の値を貼り付けます。"

msgid ""
"In {project_name}, paste the value of the *Consumer Secret* into the *Client"
" Secret* field."
msgstr "{project_name}では、 *Client Secret* フィールドに *Consumer Secret* の値を貼り付けます。"

msgid "Instagram"
msgstr "Instagram"

msgid ""
"From the `Add provider` list, select `Instagram`. {project_name} displays "
"the configuration page for the Instagram identity provider."
msgstr ""
"`Add provider` の一覧から `Instagram` "
"を選択します。{project_name}はInstagramのアイデンティティー・プロバイダーの設定ページを表示します。"

msgid ""
"image:{project_images}/instagram-add-identity-provider.png[Add Identity "
"Provider]"
msgstr ""
"image:{project_images}/instagram-add-identity-provider.png[Add Identity "
"Provider]"

msgid ""
"In a separate browser tab, open the "
"https://developers.facebook.com/[Facebook Developer Console]."
msgstr ""
"別のブラウザータブで、 https://developers.facebook.com/[Facebook Developer Console] "
"を開きます。"

msgid "Click *My Apps*."
msgstr "*My Apps* をクリックします。"

msgid "Select *Add a New App*."
msgstr "*Add a New App* を選択します。"

msgid "Add a new app"
msgstr "Add a new app"

msgid "image:images/instagram-add-new-app.png[Add a New App]"
msgstr "image:images/instagram-add-new-app.png[Add a New App]"

msgid "Select `For Everything Else`."
msgstr "`For Everything Else` を選択します。"

msgid "Create a new app ID"
msgstr "新規アプリIDの作成"

msgid "image:images/instagram-create-app-id.png[]"
msgstr "image:images/instagram-create-app-id.png[]"

msgid "Fill in all required fields."
msgstr "必須項目をすべて入力してください。"

msgid "Click *Create App*. Facebook then brings you to the dashboard."
msgstr "*Create App* をクリックすると、Facebookはダッシュボードを表示します。"

msgid "In the navigation panel, select *Settings* - *Basic*."
msgstr "ナビゲーション・パネルで、 *Settings* - *Basic* を選択します。"

msgid "Add platform"
msgstr "プラットフォームの追加"

msgid "image:images/instagram-add-platform.png[Add Platform]"
msgstr "image:images/instagram-add-platform.png[Add Platform]"

msgid "Select *+ Add Platform*."
msgstr "*+ Add Platform*を選択します。"

msgid "Click *[Website]*."
msgstr "*[Website]* をクリックします。"

msgid "Enter a URL for your site."
msgstr "あなたのサイトのURLを入力してください。"

msgid "Add a product"
msgstr "製品の追加"

msgid "image:images/instagram-add-product.png[]"
msgstr "image:images/instagram-add-product.png[]"

msgid "Select `Dashboard` from the menu."
msgstr "メニューから `Dashboard` を選択します。"

msgid "Click *Set Up* in the Instagram box."
msgstr "Instagramのボックスにある *Set Up* をクリックします。"

msgid "Select *Instagram* - *Basic Display* from the menu."
msgstr "メニューから *Instagram* - *Basic Display* を選択します。"

msgid "Click *Create New App*."
msgstr "*Create New App* をクリックします。"

msgid "Create a new Instagram app ID"
msgstr "インスタグラムのアプリIDを新規に作成します。"

msgid ""
"image:images/instagram-create-instagram-app-id.png[Create a New Instagram "
"App ID]"
msgstr ""
"image:images/instagram-create-instagram-app-id.png[Create a New Instagram "
"App ID]"

msgid "Enter a value into *Display Name*."
msgstr "*Display Name* に値を入力してください。"

msgid "Setup the app"
msgstr "アプリの設定"

msgid "image:images/instagram-app-settings.png[Setup the App]"
msgstr "image:images/instagram-app-settings.png[Setup the App]"

msgid ""
"Paste the *Redirect URL* from {project_name} into the *Valid OAuth Redirect "
"URIs* field."
msgstr ""
"{project_name}の *Redirect URL* を *Valid OAuth Redirect URIs* "
"フィールドに貼り付けてください。"

msgid ""
"Paste the *Redirect URL* from {project_name} into the *Deauthorize Callback "
"URL* field."
msgstr ""
"{project_name}の *Redirect URL* を *Deauthorize Callback URL* フィールドに貼り付けてください。"

msgid ""
"Paste the *Redirect URL* from {project_name} into the *Data Deletion Request"
" URL* field."
msgstr ""
"{project_name}の *Redirect URL* を *Data Deletion Request URL* "
"フィールドに貼り付けてください。"

msgid "Click *Show* in the *Instagram App Secret* field."
msgstr "*Instagram App Secret* フィールドの *Show* をクリックします。"

msgid "Note the *Instagram App ID* and the *Instagram App Secret*."
msgstr "*Instagram App ID* と *Instagram App Secret* に注意してください。"

msgid "Click *App Review* - *Requests*."
msgstr "*App Review* - *Requests* をクリックします。"

msgid "Follow the instructions on the screen."
msgstr "画面の指示に従ってください。"

msgid ""
"In {project_name}, paste the value of the *Instagram App ID* into the "
"*Client ID* field."
msgstr "{project_name}では、*Instagram App ID* の値を *Client ID* フィールドに貼り付けます。"

msgid ""
"In {project_name}, paste the value of the *Instagram App Secret* into the "
"*Client Secret* field."
msgstr ""
"{project_name}では、 *Instagram App Secret* の値を *Client Secret* フィールドに貼り付けます。"

msgid "OpenID Connect v1.0 identity providers"
msgstr "OpenID Connect v1.0アイデンティティー・プロバイダー"

msgid ""
"{project_name} brokers identity providers based on the OpenID Connect "
"protocol. These identity providers (IDPs) must support the xref:proc-"
"creating-oidc-client_{context}[Authorization Code Flow] defined in the "
"specification to authenticate users and authorize access."
msgstr ""
"{project_name}は、OpenID "
"Connectプロトコルに基づくアイデンティティー・プロバイダーを仲介します。これらのアイデンティティー・プロバイダー（IDP）は、ユーザーを認証してアクセスを許可するために、仕様で定義されている"
" xref:proc-creating-oidc-client_{context}[認可コードフロー] をサポートする必要があります。"

msgid "From the `Add provider` list, select `OpenID Connect v1.0`."
msgstr "`Add provider` のリストから `OpenID Connect v1.0` を選択します。"

msgid ""
"image:{project_images}/oidc-add-identity-provider.png[Add Identity Provider]"
msgstr ""
"image:{project_images}/oidc-add-identity-provider.png[Add Identity Provider]"

msgid ""
"Enter your initial configuration options. See <<_general-idp-config, General"
" IDP Configuration>> for more information about configuration options."
msgstr ""
"初期設定のオプションを入力します。設定オプションの詳細は<<_general-idp-config, General IDP "
"Configuration>>を参照してください。"

msgid "OpenID connect config"
msgstr "OpenID connectの設定"

msgid "Authorization URL"
msgstr "Authorization URL"

msgid "The authorization URL endpoint the OIDC protocol requires."
msgstr "OIDCプロトコルが要求する認可URLエンドポイント。"

msgid "Token URL"
msgstr "Token URL"

msgid "The token URL endpoint the OIDC protocol requires."
msgstr "OIDCプロトコルが要求するトークンURLエンドポイント。"

msgid "Logout URL"
msgstr "Logout URL"

msgid "The logout URL endpoint in the OIDC protocol. This value is optional."
msgstr "OIDCプロトコルのログアウトURLエンドポイント。この値は任意です。"

msgid "Backchannel Logout"
msgstr "Backchannel Logout"

msgid ""
"A background, out-of-band, REST request to the IDP to log out the user. Some"
" IDPs perform logout through browser redirects only, as they may identify "
"sessions using a browser cookie."
msgstr ""
"ユーザーをログアウトするためのIDPへのバックグラウンド（アウトオブバンド）のRESTリクエストです。一部のIDPは、ブラウザーのCookieを使用してセッションを識別する可能性があるため、ブラウザーのリダイレクトのみによってログアウトを実行します。"

msgid "User Info URL"
msgstr "User Info URL"

msgid ""
"An endpoint the OIDC protocol defines. This endpoint points to user profile "
"information."
msgstr "OIDCプロトコルが定義するエンドポイントです。このエンドポイントは、ユーザー・プロフィール情報を指します。"

msgid "Client Authentication"
msgstr "クライアント認証"

msgid ""
"Defines the Client Authentication method {project_name} uses with the "
"Authorization Code Flow. In the case of JWT signed with a private key, "
"{project_name} uses the realm private key. In the other cases, define a "
"client secret. See the https://openid.net/specs/openid-connect-"
"core-1_0.html#ClientAuthentication[Client Authentication specifications] for"
" more information."
msgstr ""
"{project_name}が認可コードフローで使用するクライアント認証方式を定義します。秘密鍵で署名されたJWTの場合、 "
"{project_name}はレルムの秘密鍵を使用します。その他のケースでは、クライアント・シークレットを定義します。詳細は、 "
"https://openid.net/specs/openid-connect-"
"core-1_0.html#ClientAuthentication[クライアント認証の仕様] を参照してください。"

msgid "Client ID"
msgstr "Client ID"

msgid ""
"A realm acting as an OIDC client to the external IDP. The realm must have an"
" OIDC client ID if you use the Authorization Code Flow to interact with the "
"external IDP."
msgstr ""
"外部IDPに対するOIDCクライアントとして動作するレルム。認可コードフローを使用して外部IDPとやり取りする場合、このレルムにはOIDCクライアントIDが必要です。"

msgid "Client Secret"
msgstr "Client Secret"

msgid ""
"Client secret from an external <<_vault-administration,vault>>. This secret "
"is necessary if you are using the Authorization Code Flow."
msgstr ""
"外部の<<_vault-"
"administration,ボールト>>からのクライアント・シークレットです。このシークレットは、認可コードフローを使用する場合に必要です。"

msgid "Client Assertion Signature Algorithm"
msgstr "Client Assertion Signature Algorithm"

msgid ""
"Signature algorithm to create JWT assertion as client authentication.\n"
"In the case of JWT signed with private key or Client secret as jwt, it is required. If no algorithm is specified, the following algorithm is adapted. `RS256` is adapted in the case of JWT signed with private key.  `HS256` is adapted in the case of Client secret as jwt."
msgstr ""
"クライアント認証としてJWTアサーションを作成するための署名アルゴリズム。秘密鍵で署名したJWTまたはJWTとしてのクライアント・シークレットの場合は必須です。アルゴリズムが指定されていない場合は、次のアルゴリズムが適用されます。秘密鍵で署名されたJWTの場合は、"
" `RS256` が適用されます。 JWTとしてのクライアント・シークレットの場合は、`HS256` が適用されます。"

msgid "Issuer"
msgstr "Issuer"

msgid ""
"{project_name} validates issuer claims, in responses from the IDP, against "
"this value."
msgstr "{project_name}はIDPから返されるレスポンスに含まれる発行者のクレームを、この値に対して検証します。"

msgid "Default Scopes"
msgstr "Default Scopes"

msgid ""
"A list of OIDC scopes {project_name} sends with the authentication request. "
"The default value is `openid`. A space separates each scope."
msgstr ""
"{project_name}が認証リクエストと一緒に送信するOIDCスコープのリストです。デフォルトの値は `openid` "
"です。各スコープはスペースで区切られています。"

msgid "Prompt"
msgstr "Prompt"

msgid ""
"The prompt parameter in the OIDC specification. Through this parameter, you "
"can force re-authentication and other options. See the specification for "
"more details."
msgstr "OIDC仕様のpromptパラメーター。このパラメーターを通じて、再認証などを強制的に行うことができます。詳しくは仕様書をご覧ください。"

msgid "Accepts prompt=none forward from client"
msgstr "Accepts prompt=none forward from client"

msgid ""
"Specifies if the IDP accepts forwarded authentication requests containing the `prompt=none` query parameter. If a realm receives an auth request with `prompt=none`, the realm checks if the user is currently authenticated and returns a `login_required` error if the user has not logged in. When {project_name} determines a default IDP for the auth request (using the `kc_idp_hint` query parameter or having a default IDP for the realm), you can forward the auth request with `prompt=none` to the default IDP. The default IDP checks the authentication of the user there. Because not all IDPs support requests with `prompt=none`, {project_name} uses this switch to indicate that the default IDP supports the parameter before redirecting the authentication request.\n"
"\n"
"If the user is unauthenticated in the IDP, the client still receives a `login_required` error. If the user is authentic in the IDP, the client can still receive an `interaction_required` error if {project_name} must display authentication pages that require user interaction. This authentication includes required actions (for example, password change), consent screens, and screens set to display by the `first broker login` flow or `post broker login` flow."
msgstr ""
"IDPが、 `prompt=none` のクエリー・パラメーターを含む転送された認証リクエストを受け入れるかどうかを指定します。あるレルムが `prompt=none` を含む認証リクエストを受信すると、そのユーザーが現在認証されているかどうかをチェックし、ユーザーがログインしていない場合は `login_required` エラーを返します。{project_name}が認証リクエストに対するデフォルトのIDPを決定した場合（ `kc_idp_hint` のクエリー・パラメーターを使うか、レルムのデフォルトIDPを持っている）、 `prompt=none` の認証リクエストをデフォルトのIDPに転送することができます。デフォルトのIDPはそこでユーザーの認証をチェックします。すべてのIDPが `prompt=none` のリクエストをサポートしているわけではないので、{project_name}はこのスイッチを使って、認証リクエストをリダイレクトする前に、デフォルトのIDPがこのパラメーターをサポートしていることを示します。\n"
"\n"
"ユーザーがIDPで認証されていない場合、クライアントは依然として `login_required` エラーを受け取ります。ユーザーがIDPで認証されている場合でも、{project_name}がユーザーとの対話を必要とする認証ページを表示しなければならない場合、クライアントは `interaction_required` エラーを受け取る可能性があります。この認証には、必須アクション（たとえば、パスワードの変更）、同意画面、および `first broker login` フローまたは `post broker login` フローで表示するように設定された画面が含まれます。"

msgid "Validate Signatures"
msgstr "Validate Signatures"

msgid ""
"Specifies if {project_name} verifies signatures on the external ID Token "
"signed by this IDP. If *ON*, {project_name} must know the public key of the "
"external OIDC IDP. For performance purposes, {project_name} caches the "
"public key of the external OIDC identity provider. If your identity "
"provider's private key is compromised, update your keys and clear the keys "
"cache. See <<_clear-cache, Clearing the cache>> section for more details."
msgstr ""
"{project_name}が、このIDPが署名した外部IDトークンの署名を検証するかどうかを指定します。*ON* "
"の場合、{project_name}は外部のOIDC "
"IDPの公開鍵を知っている必要があります。パフォーマンスのために、{project_name}は外部のOIDCアイデンティティー・プロバイダーの公開鍵をキャッシュします。アイデンティティー・プロバイダーの秘密鍵が漏洩した場合は、鍵を更新し、鍵キャッシュをクリアします。詳細については、<<_clear-"
"cache, キャッシュのクリア>>のセクションを参照してください。"

msgid "Use JWKS URL"
msgstr "Use JWKS URL"

msgid ""
"This switch is applicable if `Validate Signatures` is *ON*. If *Use JWKS "
"URL* is *ON*, {project_name} downloads the IDP's public keys from the JWKS "
"URL. New keys download when the identity provider generates a new keypair. "
"If *OFF*, {project_name} uses the public key (or certificate) from its "
"database, so when the IDP keypair changes, import the new key to the "
"{project_name} database as well."
msgstr ""
"このスイッチは、`Validate Signatures` が *ON* の場合に適用されます。 *Use JWKS URL* が *ON* "
"の場合、{project_name}はJWKS "
"URLからIDPの公開鍵をダウンロードします。アイデンティティー・プロバイダーが新しい鍵ペアを生成すると、新しい鍵がダウンロードされます。OFF*の場合、{project_name}はデータベースの公開鍵（または証明書）を使用するため、IDPのキーペアが変更された場合、新しい鍵を{project_name}のデータベースにもインポートします。"

msgid "JWKS URL"
msgstr "JWKS URL"

msgid ""
"The URL pointing to the location of the IDP JWK keys. For more information, "
"see the https://self-issued.info/docs/draft-ietf-jose-json-web-key.html[JWK "
"specification]. If you use an external {project_name} as an IDP, you can use"
" a URL such as http://broker-keycloak:8180/auth/realms/test/protocol/openid-"
"connect/certs if your brokered {project_name} is running on http://broker-"
"keycloak:8180 and its realm is `test`."
msgstr ""
"IDPのJWKキーの場所を指すURL。詳細については、 https://self-issued.info/docs/draft-ietf-jose-"
"json-web-key.html[JWK仕様] を参照してください。外部の{project_name}をIDPとして使用する場合、ブローカーの "
"{project_name}が http://broker-keycloak:8180 上で動作しており、そのレルムが `test` であれば、  "
"http://broker-keycloak:8180/auth/realms/test/protocol/openid-connect/certs "
"のような URL を使用することができます。"

msgid "Validating Public Key"
msgstr "Validating Public Key"

msgid ""
"The public key in PEM format that {project_name} uses to verify external IDP"
" signatures. This key applies if `Use JWKS URL` is *OFF*."
msgstr ""
"{project_name}が外部IDPの署名を検証するために使用するPEM形式の公開鍵です。この鍵は、 `Use JWKS URL` が *OFF* "
"の場合に適用されます。"

msgid "Validating Public Key Id"
msgstr "Validating Public Key Id"

msgid ""
"This setting applies if *Use JWKS URL* is *OFF*. This setting specifies the "
"ID of the public key in PEM format. Because there is no standard way for "
"computing key ID from the key, external identity providers can use different"
" algorithms from what {project_name} uses. If this field's value is not "
"specified, {project_name} uses the validating public key for all requests, "
"regardless of the key ID sent by the external IDP. When *ON*, this field's "
"value is the key ID used by {project_name} for validating signatures from "
"providers and must match the key ID specified by the IDP."
msgstr ""
"この設定は、 *Use JWKS URL* が *OFF* "
"の場合に適用されます。この設定では、公開鍵のIDをPEM形式で指定します。鍵から鍵IDを計算する標準的な方法がないため、外部のアイデンティティー・プロバイダーは{project_name}が使用するものとは異なるアルゴリズムを使用できます。このフィールドの値が指定されていない場合、{project_name}は、外部のIDPから送信された鍵IDに関係なく、すべてのリクエストに検証用の公開鍵を使用します。"
" *ON* "
"の場合、このフィールドの値は{project_name}がプロバイダーからの署名を検証するために使用する鍵IDであり、IDPが指定する鍵IDと一致しなければなりません。"

msgid ""
"You can import all this configuration data by providing a URL or file that "
"points to OpenID Provider Metadata. If you connect to a {project_name} "
"external IDP, you can import the IDP settings from "
"`<root>/auth/realms/{realm-name}/.well-known/openid-configuration`. This "
"link is a JSON document describing metadata about the IDP."
msgstr ""
"OpenID Provider "
"Metadataを指し示すURLやファイルを提供することで、これらの設定データをすべてインポートすることができます。{project_name}の外部IDPに接続する場合は、"
" `<root>/auth/realms/{realm-name}/.well-known/openid-configuration` "
"からIDPの設定をインポートできます。このリンクは、IDPに関するメタデータを記述したJSONドキュメントです。"

msgid "SAML v2.0 Identity Providers"
msgstr "SAML v2.0アイデンティティー・プロバイダー"

msgid ""
"{project_name} can broker identity providers based on the SAML v2.0 "
"protocol."
msgstr "{project_name}は、SAML v2.0プロトコルに基づいて、アイデンティティー・プロバイダーを仲介できます。"

msgid "From the `Add provider` list, select `SAML v2.0`."
msgstr "`Add provider` のリストから `SAML v2.0` を選択します。"

msgid ""
"image:{project_images}/saml-add-identity-provider.png[Add Identity Provider]"
msgstr ""
"image:{project_images}/saml-add-identity-provider.png[Add Identity Provider]"

msgid ""
"Enter your initial configuration options. See <<_general-idp-config, General"
" IDP Configuration>> for more information about configuration options. .SAML"
" Config"
msgstr ""
"初期設定のオプションを入力します。設定オプションの詳細は<<_general-idp-config, General IDP Configuration>>を参照してください。\n"
"\n"
".SAML Config"

msgid "Service Provider Entity ID"
msgstr "Service Provider Entity ID"

msgid ""
"The SAML Entity ID that the remote Identity Provider uses to identify "
"requests from this Service Provider. By default, this setting is set to the "
"realms base URL `<root>/auth/realms/{realm-name}`."
msgstr ""
"リモートのアイデンティティー・プロバイダーが、このサービス・プロバイダーからのリクエストを識別するために使用するSAMLエンティティーID。デフォルトでは、この設定はレルムベースのURL"
" `<root>/auth/realms/{realm-name}` に設定されています。"

msgid "Single Sign-On Service URL"
msgstr "Single Sign-On Service URL"

msgid ""
"The SAML endpoint that starts the authentication process.  If your SAML IDP "
"publishes an IDP entity descriptor, the value of this field is specified "
"there."
msgstr ""
"認証プロセスを開始するSAMLエンドポイント。SAML IDPがIDPエンティティー記述子を発行している場合、このフィールドの値はそこで指定されます。"

msgid "Single Logout Service URL"
msgstr "Single Logout Service URL"

msgid ""
"The SAML logout endpoint. If your SAML IDP publishes an IDP entity "
"descriptor, the value of this field is specified there."
msgstr ""
"SAMLログアウトのエンドポイント。SAML IDPがIDPエンティティー記述子を発行している場合、このフィールドの値はそこで指定されます。"

msgid ""
"Toggle this switch to *ON* if your SAML IDP supports back channel logout."
msgstr "SAML IDP がバックチャネル・ログアウトをサポートする場合は、このスイッチを *ON* に切り替えます。"

msgid "NameID Policy Format"
msgstr "NameID Policy Format"

msgid ""
"The URI reference corresponding to a name identifier format. By default, "
"{project_name} sets it to `urn:oasis:names:tc:SAML:2.0:nameid-"
"format:persistent`."
msgstr ""
"名前識別子のフォーマットに対応するURI参照。デフォルトでは、{project_name} が "
"`urn:oasis:names:tc:SAML:2.0:nameid-format:persistent` に設定する。"

msgid "Principal Type"
msgstr "Principal Type"

msgid ""
"Specifies which part of the SAML assertion will be used to identify and "
"track external user identities. Can be either Subject NameID or SAML "
"attribute (either by name or by friendly name). Subject NameID value can not"
" be set together with 'urn:oasis:names:tc:SAML:2.0:nameid-format:transient' "
"NameID Policy Format value."
msgstr ""
"SAMLアサーションのどの部分を外部ユーザー・アイデンティティを一意に特定しトラックするのに使用するかを指定します。Subject "
"NameID、SAML attributeのいずれか（名前もしくはフレンドリー名）です。Subject NameID値は、 "
"'urn:oasis:names:tc:SAML:2.0:nameid-format:transient' NameID Policy Format "
"値とともに設定することはできません。"

msgid "Principal Attribute"
msgstr "Principal Attribute"

msgid ""
"If a Principal type is non-blank, this field specifies the name (\"Attribute"
" [Name]\") or the friendly name (\"Attribute [Friendly Name]\") of the "
"identifying attribute."
msgstr ""
"Principal type が空白でない場合、識別属性の名前（\"Attribute [Name]\"）またはフレンドリー名（\"Attribute "
"[Friendly Name]\"）を指定する。"

msgid "Allow create"
msgstr "Allow create"

msgid ""
"Allow the external identity provider to create a new identifier to represent"
" the principal."
msgstr "外部アイデンティティー・プロバイダーがプリンシパルを表す新しい識別子を作成できるようにします。"

msgid "HTTP-POST Binding Response"
msgstr "HTTP-POST Binding Response"

msgid ""
"Controls the SAML binding in response to any SAML requests sent by an "
"external IDP. When *OFF*, {project_name} uses Redirect Binding."
msgstr ""
"外部 IDP から送信される SAML 要求に応答する SAML バインディングを制御する。OFF* の場合、{project_name} "
"はリダイレクトバインディングを使用します。"

msgid "HTTP-POST Binding for AuthnRequest"
msgstr "HTTP-POST Binding for AuthnRequest"

msgid ""
"Controls the SAML binding when requesting authentication from an external "
"IDP. When *OFF*, {project_name} uses Redirect Binding."
msgstr ""
"外部 IDP に認証を要求する際の SAML バインディングを制御します。OFF*の場合、{project_name}はRedirect "
"Bindingを使用します。"

msgid "Want AuthnRequests Signed"
msgstr "Want AuthnRequests Signed"

msgid ""
"When *ON*, {project_name} uses the realm's keypair to sign requests sent to "
"the external SAML IDP."
msgstr "ON*の場合、{project_name}は、外部のSAML IDPに送信されるリクエストに署名するために、レルムのキーペアを使用します。"

msgid "Signature Algorithm"
msgstr "Signature Algorithm"

msgid ""
"If *Want AuthnRequests Signed* is *ON*, the signature algorithm to use."
msgstr "Want AuthnRequests Signed* が*ON* の場合、使用する署名アルゴリズムを指定します。"

msgid "SAML Signature Key Name"
msgstr "SAML Signature Key Name"

msgid ""
"Signed SAML documents sent using POST binding contain the identification of signing key in `KeyName` element, which, by default, contains the {project_name} key ID. External SAML IDPs can expect a different key name. This switch controls whether `KeyName` contains:\n"
"* `KEY_ID` - Key ID.\n"
"* `CERT_SUBJECT` - the subject from the certificate corresponding to the realm key. Microsoft Active Directory Federation Services expect `CERT_SUBJECT`.\n"
"* `NONE` - {project_name} omits the key name hint from the SAML message."
msgstr ""
"POST バインディングで送信される署名付き SAML ドキュメントは、`KeyName` 要素に署名鍵の識別情報を含む。この要素は、デフォルトでは {project_name} 鍵 ID を含む。外部の SAML IDP は、別のキー名を期待することができる。このスイッチは `KeyName` が含むかどうかを制御する。\n"
"* `KEY_ID` - キーID。\n"
"* `CERT_SUBJECT` - realm キーに対応する証明書のサブジェクト。Microsoft Active Directory フェデレーションサービスは `CERT_SUBJECT` を想定しています。\n"
"* `NONE` - {project_name} SAMLメッセージからキー名のヒントを省略する。"

msgid "Force Authentication"
msgstr "Force Authentication"

msgid ""
"The user must enter their credentials at the external IDP even when the user"
" is already logged in."
msgstr "ユーザーが既にログインしている場合でも、外部IDPで資格情報を入力する必要があります。"

msgid "Validate Signature"
msgstr "Validate Signature"

msgid ""
"When *ON*, the realm expects SAML requests and responses from the external "
"IDP to be digitally signed."
msgstr "ON*の場合、realmは外部IDPからのSAMLリクエストとレスポンスがデジタル署名されていることを期待します。"

msgid "Validating X509 Certificate"
msgstr "Validating X509 Certificate"

msgid ""
"The public certificate {project_name} uses to validate the signatures of "
"SAML requests and responses from the external IDP."
msgstr "公開証明書{project_name}は、外部IDPからのSAMLリクエストとレスポンスの署名を検証するために使用される。"

msgid "Sign Service Provider Metadata"
msgstr "Sign Service Provider Metadata"

msgid ""
"When *ON*, {project_name} uses the realm's key pair to sign the "
"<<_identity_broker_saml_sp_descriptor, SAML Service Provider Metadata "
"descriptor>>."
msgstr ""
"ON*の場合、{project_name}はレルムのキーペアを使用して&lt;&gt;に署名します<_identity_broker_saml_sp_descriptor,"
" SAML Service Provider Metadata "
"descriptor>。</_identity_broker_saml_sp_descriptor,>"

msgid "Pass subject"
msgstr "Pass subject"

msgid ""
"Controls if {project_name} forwards a `login_hint` query parameter to the "
"IDP. {project_name} adds this field's value to the login_hint parameter in "
"the AuthnRequest's Subject so destination providers can pre-fill their login"
" form."
msgstr ""
"project_name} が `login_hint` クエリパラメータを IDP に転送するかどうかを制御します。{project_name} "
"はこのフィールドの値を AuthnRequest の Subject の login_hint "
"パラメータに追加し、宛先プロバイダがログインフォームに事前入力できるようにします。"

msgid "Attribute Consuming Service Index"
msgstr "Attribute Consuming Service Index"

msgid ""
"Identifies the attribute set to request to the remote IDP. {project_name} "
"automatically adds the attributes mapped in the identity provider "
"configuration to the autogenerated SP metadata document."
msgstr ""
"リモートIdPに要求する属性セットを特定します。{project_name}は、アイデンティティー・プロバイダー構成にマッピングされた属性を、自動生成されたSPメタデータ・ドキュメントに自動的に追加します。"

msgid "Attribute Consuming Service Name"
msgstr "Attribute Consuming Service Name"

msgid ""
"A descriptive name for the set of attributes that are advertised in the "
"autogenerated SP metadata document."
msgstr "自動生成されるSPメタデータ・ドキュメントで提示される一連の属性の説明的な名前です。"

msgid ""
"You can import all configuration data by providing a URL or a file pointing "
"to the SAML IDP entity descriptor of the external IDP. If you are connecting"
" to a {project_name} external IDP, you can import the IDP settings from the "
"URL `<root>/auth/realms/{realm-name}/protocol/saml/descriptor`. This link is"
" an XML document describing metadata about the IDP. You can also import all "
"this configuration data by providing a URL or XML file pointing to the "
"external SAML IDP's entity descriptor to connect to."
msgstr ""
"外部 IDP の SAML IDP エンティティ記述子を指す URL "
"またはファイルを指定することで、すべての構成データをインポートすることができる。プロジェクト名}の外部IDPに接続している場合、URL "
"`/auth/realms/{realm-name}/protocol/saml/descriptor` "
"からIDP設定をインポートすることができる<root>。このリンクは、IDPに関するメタデータを記述したXML文書です。また、接続先の外部 SAML "
"IDP のエンティティディスクリプタを指す URL や XML ファイルを指定して、この設定データをすべてインポートすることも可能です。</root>"

msgid "Requesting specific AuthnContexts"
msgstr "Requesting specific AuthnContexts"

msgid ""
"Identity Providers facilitate clients specifying constraints on the "
"authentication method verifying the user identity. For example, asking for "
"MFA, Kerberos authentication, or security requirements. These constraints "
"use particular AuthnContext criteria. A client can ask for one or more "
"criteria and specify how the Identity Provider must match the requested "
"AuthnContext, exactly, or by satisfying other equivalents."
msgstr ""
"アイデンティティー・プロバイダーは、クライアントがユーザーのアイデンティティーを検証する認証方式に関する制約を指定することを容易にします。たとえば、MFA、Kerberos認証、またはセキュリティー要件を求めるなどです。これらの制約は、特定のAuthnContext基準を使用します。クライアントは1つまたは複数の基準を要求し、アイデンティティー・プロバイダーが要求されたAuthnContextに正確に、または他の同等物を満たすことでどのように一致しなければならないかを指定することができます。"

msgid ""
"You can list the criteria your Service Provider requires by adding ClassRefs"
" or DeclRefs in the Requested AuthnContext Constraints section. Usually, you"
" need to provide either ClassRefs or DeclRefs, so check with your Identity "
"Provider documentation which values are supported. If no ClassRefs or "
"DeclRefs are present, the Identity Provider does not enforce additional "
"constraints."
msgstr ""
"Requested AuthnContext "
"ConstraintsセクションにClassRefsまたはDeclRefsを追加することで、サービスプロバイダが要求する条件を列挙することができます。通常、ClassRefs"
" あるいは DeclRefs のいずれかを指定する必要があるので、どの値がサポートされているかは ID "
"プロバイダのドキュメントで確認してください。ClassRefs または DeclRefs が存在しない場合、ID プロバイダは追加の制約を適用しません。"

msgid "Requested AuthnContext Constraints"
msgstr "Requested AuthnContext Constraints"

msgid "Comparison"
msgstr "Comparison"

msgid ""
"The method the Identity Provider uses to evaluate the context requirements. "
"The available values are `Exact`, `Minimum`, `Maximum`, or `Better`. The "
"default value is `Exact`."
msgstr ""
"アイデンティティー・プロバイダーがコンテキストの要件を評価するために使用する方法です。使用可能な値は `Exact` 、 `Minimum` 、 "
"`Maximum` あるいは `Better` です。デフォルトは `Exact` です。"

msgid "AuthnContext ClassRefs"
msgstr "AuthnContext ClassRefs"

msgid "The AuthnContext ClassRefs describing the required criteria."
msgstr "必要な条件を記述した AuthnContext ClassRefs。"

msgid "AuthnContext DeclRefs"
msgstr "AuthnContext DeclRefs"

msgid "The AuthnContext DeclRefs describing the required criteria."
msgstr "必要な条件を記述した AuthnContext DeclRefs。"

msgid "SP Descriptor"
msgstr "SP記述子"

msgid ""
"When you access the provider's SAML SP metadata, look for the `Endpoints` "
"item in the identity provider configuration settings. It contains a `SAML "
"2.0 Service Provider Metadata` link which generates the SAML entity "
"descriptor for the Service Provider. You can download the descriptor or copy"
" its URL and then import it into the remote Identity Provider."
msgstr ""
"プロバイダの SAML SP メタデータにアクセスするときは、ID プロバイダ構成設定の中の `Endpoints` 項目を探す。これには `SAML "
"2.0 Service Provider Metadata` リンクがあり、サービスプロバイダの SAML "
"エンティティディスクリプタが生成される。記述子をダウンロードするか、その URL をコピーして、リモート ID プロバイダにインポートすることができる。"

msgid ""
"This metadata is also available publicly by going to the following URL:"
msgstr "また、このメタデータは以下のURLで公開されています。"

msgid ""
"http[s]://{host:port}/auth/realms/{realm-name}/broker/{broker-"
"alias}/endpoint/descriptor"
msgstr ""
"http[s]://{host:port}/auth/realms/{realm-name}/broker/{broker-"
"alias}/endpoint/descriptor"

msgid ""
"Ensure you save any configuration changes before accessing the descriptor."
msgstr "ディスクリプターにアクセスする前に、設定変更を保存していることを確認してください。"

msgid "Send subject in SAML requests"
msgstr "SAMLリクエストでサブジェクトを送信する"

msgid ""
"By default, a social button pointing to a SAML Identity Provider redirects "
"the user to the following login URL:"
msgstr "デフォルトでは、SAML ID プロバイダを指すソーシャルボタンは、ユーザを以下のログイン URL にリダイレクトする。"

msgid ""
"http[s]://{host:port}/auth/realms/${realm-name}/broker/{broker-alias}/login"
msgstr ""
"http[s]://{host:port}/auth/realms/${realm-name}/broker/{broker-alias}/login"

msgid ""
"Adding a query parameter named `login_hint` to this URL adds the parameter's"
" value to SAML request as a Subject attribute. If this query parameter is "
"empty, {project_name} does not add a subject to the request."
msgstr ""
"このURLに `login_hint` というクエリーパラメータを追加すると、パラメータの値が Subject 属性として SAML "
"リクエストに追加されます。このクエリパラメータが空の場合、{project_name} はリクエストに Subject を追加しません。"

msgid "Enable the \"Pass subject\" option to send the subject in SAML requests."
msgstr "SAMLリクエストでサブジェクトを送信するために、\"Pass subject \"オプションを有効化する。"

msgid "Client-suggested Identity Provider"
msgstr "クライアント推奨のアイデンティティー・プロバイダー"

msgid ""
"OIDC applications can bypass the {project_name} login page by hinting at the"
" identity provider they want to use. You can enable this by setting the "
"`kc_idp_hint` query parameter in the Authorization Code Flow authorization "
"endpoint."
msgstr ""
"OIDCアプリケーションは、使用したいアイデンティティー・プロバイダーをヒントにすることで、{project_name}のログインページを回避することができます。この機能を有効にするには、認可コードフローの認可エンドポイントで"
" `kc_idp_hint` というクエリー・パラメーターを設定します。"

msgid ""
"With {project_name} OIDC client adapters, you can specify this query "
"parameter when you access a secured resource in the application."
msgstr ""
"{project_name}のOIDCクライアント・アダプターでは、アプリケーションでセキュリティー保護されたリソースにアクセスする際に、このクエリー・パラメーターを指定することができます。"

msgid "For example:"
msgstr "例："

msgid ""
"GET /myapplication.com?kc_idp_hint=facebook HTTP/1.1\n"
"Host: localhost:8080"
msgstr ""
"GET /myapplication.com?kc_idp_hint=facebook HTTP/1.1\n"
"Host: localhost:8080"

msgid ""
"In this case, your realm must have an identity provider with a `facebook` "
"alias. If this provider does not exist,  the login form is displayed."
msgstr ""
"この場合、レルムには `facebook` "
"というエイリアスを持つアイデンティティー・プロバイダーが必要です。このプロバイダーが存在しない場合は、ログイン画面が表示されます。"

msgid ""
"If you are using the `keycloak.js` adapter, you can also achieve the same "
"behavior as follows:"
msgstr "また、 `keycloak.js` アダプターを使用している場合は、以下のようにして同じ動作を実現できます。"

msgid ""
"var keycloak = new Keycloak('keycloak.json');\n"
"\n"
"keycloak.createLoginUrl({\n"
"\tidpHint: 'facebook'\n"
"});"
msgstr ""
"var keycloak = new Keycloak('keycloak.json');\n"
"\n"
"keycloak.createLoginUrl({\n"
"\tidpHint: 'facebook'\n"
"});"

msgid ""
"With the `kc_idp_hint` query parameter, the client can override the default "
"identity provider if you configure one for the `Identity Provider "
"Redirector` authenticator. The client can  disable the automatic redirecting"
" by setting the `kc_idp_hint` query parameter to an empty value."
msgstr ""
"kc_idp_hint` クエリー・パラメーターを使用すると、`Identity Provider Redirector` "
"オーセンティケーターにデフォルトのアイデンティティー・プロバイダーを設定している場合に、クライアントはそのアイデンティティー・プロバイダーをオーバーライドできます。クライアントは、"
" `kc_idp_hint` クエリー・パラメーターを空の値に設定することで、自動リダイレクトを無効にすることができます。"

msgid "Mapping claims and assertions"
msgstr "クレームとアサーションのマッピング"

msgid ""
"You can import the SAML and OpenID Connect metadata, provided by the "
"external IDP you are authenticating with, into the realm. After importing, "
"you can extract user profile metadata and other information, so you can make"
" it available to your applications."
msgstr ""
"認証先の外部IDPから提供されるSAMLやOpenID "
"Connectのメタデータをレルムにインポートすることができます。インポート後、ユーザー・プロフィールのメタデータなどを抽出して、アプリケーションで利用できるようにすることができます。"

msgid ""
"Each user logging into your realm using an external identity provider has an"
" entry in the local {project_name} database, based on the metadata from the "
"SAML or OIDC assertions and claims."
msgstr ""
"外部のアイデンティティー・プロバイダーを使用してレルムにログインする各ユーザーは、SAMLまたはOIDCのアサーションおよびクレームのメタデータに基づいて、ローカルの{project_name}データベースにエントリーを持ちます。"

msgid "Select one of the identity providers in the list."
msgstr "リストの中からいずれかのアイデンティティー・プロバイダーを選択します。"

msgid "Click the *Mappers* tab."
msgstr "*Mappers* タブをクリックします。"

msgid "Identity provider mappers"
msgstr "アイデンティティー・プロバイダー・マッパー"

msgid ""
"image:{project_images}/identity-provider-mappers.png[identity provider "
"mappers]"
msgstr ""
"image:{project_images}/identity-provider-mappers.png[identity provider "
"mappers]"

msgid "Identity provider mapper"
msgstr "アイデンティティー・プロバイダー・マッパー"

msgid ""
"image:{project_images}/identity-provider-mapper.png[identity provider "
"mapper]"
msgstr ""
"image:{project_images}/identity-provider-mapper.png[identity provider "
"mapper]"

msgid ""
"Select a value for *Sync Mode Override*. The mapper updates user information"
" when users log in repeatedly according to this setting."
msgstr ""
"*Sync Mode Override* の値を選択します。マッパーは、ユーザーが繰り返しログインする際に、この設定に従ってユーザー情報を更新します。"

msgid ""
"Select *legacy* to use the behavior of the previous {project_name} version."
msgstr "前のバージョンの{project_name}の動作を使用するには、 *legacy* を選択してください。"

msgid ""
"Select *import* to import data from when the user was first created in "
"{project_name} during the first login to {project_name} with a particular "
"identity provider."
msgstr ""
"特定のアイデンティティー・プロバイダーを使用して{project_name}に初めてログインした際に、{project_name}にユーザーが初めて作成された時のデータをインポートする場合は、"
" *import* を選択します。"

msgid "Select *force* to update user data at each user login."
msgstr "ユーザーがログインするたびにユーザーデータを更新する場合は、 *force* を選択します。"

msgid ""
"Select *inherit* to use the sync mode configured in the identity provider. "
"All other options will override this sync mode."
msgstr ""
"アイデンティティー・プロバイダーで設定された同期モードを使用するには、 *inherit* "
"を選択します。他のすべてのオプションは、この同期モードを上書きします。"

msgid ""
"Select a mapper from the *Mapper Type* list. Hover over the *Mapper Type* "
"for a description of the mapper and configuration to enter for the mapper."
msgstr ""
"*Mapper Type* のリストからマッパーを選択します。 *Mapper Type* "
"にカーソルを合わせると、マッパーの説明とマッパーに入力する設定が表示されます。"

msgid ""
"For JSON-based claims, you can use dot notation for nesting and square "
"brackets to access array fields by index. For example, "
"`contact.address[0].country`."
msgstr ""
"JSONベースのクレームの場合、入れ子にはドット記法、配列のフィールドにインデックスでアクセスするには角括弧を使います。たとえば、 "
"`contact.address[0].country` のようになります。"

msgid ""
"To investigate the structure of user profile JSON data provided by social "
"providers, you can enable the `DEBUG` level logger "
"`org.keycloak.social.user_profile_dump` in the server's app-server "
"configuration file (domain.xml or standalone.xml)."
msgstr ""
"ソーシャル・プロバイダーが提供するユーザー・プロフィールのJSONデータの構造を調査するには、サーバーのapp-"
"server設定ファイル（domain.xmlまたはstandalone.xml）で、 `DEBUG` レベルのロガー "
"`org.keycloak.social.user_profile_dump` を有効にします。"

msgid "Available user session data"
msgstr "利用可能なユーザー・セッション・ データ"

msgid ""
"After a user login from an external IDP, {project_name} stores user session "
"note data that you can access. This data can be propagated to the client "
"requesting log in using the token or SAML assertion passed back to the "
"client using an appropriate client mapper."
msgstr ""
"外部のIDPからユーザーがログインした後、{project_name}は、アクセス可能なユーザー・セッション・ノート・データを保存します。このデータは、適切なクライアント・マッパーを使用して、トークンまたはSAMLアサーションを使用して、ログインを要求するクライアントに伝搬させることができます。"

msgid "identity_provider"
msgstr "identity_provider"

msgid "The IDP alias of the broker used to perform the login."
msgstr "ログインを実行するために使用されるブローカーのIDPエイリアス。"

msgid "identity_provider_identity"
msgstr "identity_provider_identity"

msgid ""
"The IDP username of the currently authenticated user. Often, but not always,"
" the same as the {project_name} username. For example, {project_name} can "
"link a user john` to a Facebook user `john123@gmail.com`. In that case, the "
"value of the user session note is `john123@gmail.com`."
msgstr ""
"現在認証されているユーザーのIDPのユーザー名です。多くの場合、{project_name}のユーザー名と同じですが、必ずしもそうとは限りません。たとえば、{project_name}は、ユーザー"
" `john` をFacebookユーザー `john123@gmail.com` "
"にリンクすることができます。この場合、ユーザーセッション・ノートの値は `john123@gmail.com` となります。"

msgid ""
"You can use a <<_protocol-mappers, Protocol Mapper>> of type `User Session "
"Note` to propagate this information to your clients."
msgstr ""
"この情報をクライアントに伝えるために、 `ユーザー・セッション・ノート` タイプの<<_protocol-mappers, "
"プロトコル・マッパー>>を使うことができます。"

msgid "First login flow"
msgstr "初回ログインフロー"

msgid ""
"When users log in through identity brokering, {project_name} imports and "
"links aspects of the user within the realm's local database. When "
"{project_name} successfully authenticates users through an external identity"
" provider, two situations can exist:"
msgstr ""
"ユーザーがアイデンティティー・ブローカリングによってログインするとき、 "
"{project_name}はレルムのローカル・データベース内のユーザーの情報をインポートしてリンクします。{project_name}が外部のアイデンティティー・プロバイダーを通じてユーザーの認証に成功した場合、2つの状況が存在する可能性があります。"

msgid ""
"{project_name} has already imported and linked a user account with the "
"authenticated identity provider account. In this case, {project_name} "
"authenticates as the existing user and redirects back to the application."
msgstr ""
"{project_name}は、すでにユーザー・アカウントをインポートし、認証されたアイデンティティー・プロバイダーのアカウントとリンクしています。この場合、{project_name}は既存のユーザーとして認証し、アプリケーションにリダイレクトして戻ります。"

msgid ""
"No account exists for this user in {project_name}. Usually, you register and"
" import a new account into the {project_name} database, but there may be an "
"existing {project_name} account with the same email address. Automatically "
"linking the existing local account to the external identity provider is a "
"potential security hole. You cannot always trust the information you get "
"from the external identity provider."
msgstr ""
"{project_name}にこのユーザーのアカウントが存在しません。通常、{project_name}のデータベースに新しいアカウントを登録してインポートしますが、同じ電子メールアドレスを持つ既存の{project_name}アカウントが存在する場合があります。既存のローカル・アカウントを外部のアイデンティティー・プロバイダーに自動的にリンクすることは、セキュリティー・ホールになる可能性があります。外部のアイデンティティー・プロバイダーから得られる情報を常に信用することはできません。"

msgid ""
"Different organizations have different requirements when dealing with some "
"of these situations. With {project_name}, you can use the `First Login Flow`"
" option in the IDP settings to choose a <<_authentication-flows, workflow>> "
"for a user logging in from an external IDP for the first time. By default, "
"the `First Login Flow` option points to the `first broker login` flow, but "
"you can use your flow or different flows for different identity providers."
msgstr ""
"このようないくつかの状況に対処する際、組織によって要件が異なります。{project_name}では、IDPの設定の `First Login "
"Flow` オプションを使用して、外部IDPから初めてログインするユーザーの<<_authentication-flows, "
"ワークフロー>>を選択することができます。デフォルトでは、 `First Login Flow` オプションは、 `first broker "
"login` "
"フローを指していますが、独自のフローを使用することもできますし、異なるアイデンティティー・プロバイダー用の異なるフローを使用することもできます。"

msgid ""
"The flow is in the Admin Console under the *Authentication* tab. When you "
"choose the `First Broker Login` flow, you see the authenticators used by "
"default. You can re-configure the existing flow. For example, you can "
"disable some authenticators, mark some of them as `required`, or configure "
"some authenticators."
msgstr ""
"フローは、管理コンソールの *Authentication* タブにあります。 `First Broker Login` "
"フローを選択すると、デフォルトで使用されるオーセンティケーターが表示されます。既存のフローを再設定することができます。たとえば、いくつかのオーセンティケーターを無効にしたり、いくつかのオーセンティケーターを"
" `Required` とマークしたり、いくつかのオーセンティケーターを設定したりすることができます。"

msgid ""
"You can also create a new authentication flow, write your own Authenticator "
"implementations, and use it in your flow. See "
"link:{developerguide_link}[{developerguide_name}] for more information."
msgstr ""
"また、新しい認証フローを作成し、独自のオーセンティケーターの実装を記述し、フローで使用することもできます。詳しくはlink:{developerguide_link}[{developerguide_name}]を参照してください。"

msgid "Default first login flow authenticators"
msgstr "デフォルトのFirst Login Flowオーセンティケーター"

msgid "Review Profile"
msgstr "Review Profile"

msgid ""
"This authenticator displays the profile information page, so the users can "
"review their profile that {project_name} retrieves from an identity "
"provider."
msgstr ""
"このオーセンティケーターは、プロファイル情報ページを表示するので、ユーザーは{project_name}がアイデンティティー・プロバイダーから取得した自分のプロファイルを確認することができます。"

msgid ""
"You can set the `Update Profile On First Login` option in the *Actions* "
"menu."
msgstr "*Actions* メニューの `Update Profile On First Login` オプションで設定できます。"

msgid ""
"When *ON*, users are presented with the profile page requesting additional "
"information to federate the user's identities."
msgstr "*ON* の場合は、ユーザーのアイデンティティーを連携させるための追加情報を要求するプロファイル・ページが表示されます。"

msgid ""
"When *missing*, users are presented with the profile page if the identity "
"provider does not provide mandatory information, such as email, first name, "
"or last name."
msgstr ""
"*missing* "
"の場合、アイデンティティー・プロバイダーが電子メール、姓、名などの必須情報を提供していない場合、ユーザーにはプロファイル・ページが表示されます。"

msgid ""
"When *OFF*, the profile page does not display unless the user clicks in a "
"later phase on the `Review profile info` link in the page displayed by the "
"`Confirm Link Existing Account` authenticator."
msgstr ""
"*OFF* の場合、ユーザーが後の段階で `Confirm Link Existing Account` オーセンティケーターで表示されるページの "
"`Review profile info` のリンクをクリックしない限り、プロファイル・ページは表示されません。"

msgid "Create User If Unique"
msgstr "Create User If Unique"

msgid ""
"This authenticator checks if there is already an existing {project_name} "
"account with the same email or username like the account from the identity "
"provider. If it's not, then the authenticator just creates a new local "
"{project_name} account and links it with the identity provider and the whole"
" flow is finished. Otherwise it goes to the next `Handle Existing Account` "
"subflow. If you always want to ensure that there is no duplicated account, "
"you can mark this authenticator as `REQUIRED`. In this case, the user will "
"see the error page if there is an existing {project_name} account and the "
"user will need to link the identity provider account through Account "
"management."
msgstr ""
"このオーセンティケーターは、アイデンティティー・プロバイダーのアカウントの電子メールまたはユーザー名が同じ{project_name}アカウントが、すでに存在するかどうかをチェックします。存在しない場合、オーセンティケーターは新しいローカルの{project_name}アカウントを作成し、それをアイデンティティー・プロバイダーにリンクすることで、フロー全体が終了します。それ以外の場合は、次の"
" `Handle Existing Account` "
"サブフローに進みます。重複したアカウントがないことを常に確認したい場合は、このオーセンティケーターを `REQUIRED` "
"にマークすることができます。この場合、既存の{project_name}アカウントが存在する場合は、エラーページが表示され、ユーザーはアカウント管理を通じてアイデンティティー・プロバイダーのアカウントをリンクする必要があります。"

msgid ""
"This authenticator verifies that there is already a {project_name} account "
"with the same email or username as the identity provider's account."
msgstr ""
"このオーセンティケーターは、アイデンティティー・プロバイダーのアカウントと同じ電子メールまたはユーザー名を持つ{project_name}アカウントがすでに存在することを検証します。"

msgid ""
"If an account does not exist, the authenticator creates a local "
"{project_name} account, links this account with the identity provider, and "
"terminates the flow."
msgstr ""
"アカウントが存在しない場合、オーセンティケーターはローカルの "
"{project_name}アカウントを作成し、このアカウントをアイデンティティー・プロバイダーとリンクし、フローを終了します。"

msgid ""
"If an account exists, the authenticator implements the next `Handle Existing"
" Account` sub-flow."
msgstr "アカウントが存在する場合、オーセンティケーターは次の `Handle Existing Account` サブフローを実行します。"

msgid ""
"To ensure there is no duplicated account, you can mark this authenticator as"
" `REQUIRED`. The user sees the error page if a {project_name} account "
"exists, and users must link their identity provider account through Account "
"management."
msgstr ""
"重複するアカウントがないように、このオーセンティケーターを `REQUIRED` "
"としてマークすることができます。{project_name}のアカウントが存在する場合、ユーザーにはエラーページが表示され、ユーザーはアカウント管理を通じてアイデンティティー・プロバイダーのアカウントをリンクする必要があります。"

msgid "Confirm Link Existing Account"
msgstr "Confirm Link Existing Account"

msgid ""
"On the information page, users see a {project_name} account with the same "
"email. Users can review their profile again and use a different email or "
"username. The flow restarts and goes back to the `Review Profile` "
"authenticator."
msgstr ""
"情報ページで、ユーザーには同じ電子メールを使用した{project_name}のアカウントが表示されます。ユーザーは自分のプロファイルを再度確認し、異なる電子メールまたはユーザー名を使用できます。フローが再スタートして、`Review"
" Profile` オーセンティケーターに戻ります。"

msgid ""
"Alternatively, users can confirm that they want to link their identity "
"provider account with their existing {project_name} account."
msgstr ""
"あるいは、ユーザーは、アイデンティティー・プロバイダーのアカウントを既存の{project_name}アカウントとリンクさせることを確認することができます。"

msgid ""
"Disable this authenticator if you do not want users to see this confirmation"
" page and go straight to linking identity provider account by email "
"verification or re-authentication."
msgstr ""
"ユーザーにこの確認ページを表示させず、電子メール認証または再認証によるアイデンティティー・プロバイダーのアカウントのリンクに直行させたい場合は、このオーセンティケーターを無効にします。"

msgid "Verify Existing Account By Email"
msgstr "Verify Existing Account By Email"

msgid ""
"This authenticator is `ALTERNATIVE` by default. {project_name} uses this "
"authenticator if the realm has an SMTP setup configured."
msgstr ""
"このオーセンティケーターはデフォルトでは `ALTERNATIVE` "
"です。{project_name}は、レルムにSMTPの設定がある場合、このオーセンティケーターを使用します。"

msgid ""
"The authenticator sends an email to users to confirm that they want to link "
"the identity provider with their {project_name} account."
msgstr ""
"オーセンティケーターは、ユーザーに電子メールを送信して、アイデンティティー・プロバイダーを自分の{project_name}アカウントとリンクさせることを確認します。"

msgid ""
"Disable this authenticator if you do not want to confirm linking by email, "
"but want users to reauthenticate with their password."
msgstr "リンク確認を電子メールで行わず、ユーザーにパスワードで再認証させたい場合は、このオーセンティケーターを無効にします。"

msgid "Verify Existing Account By Re-authentication"
msgstr "Verify Existing Account By Re-authentication"

msgid ""
"Use this authenticator if the email authenticator is not available. For "
"example, you have not configured SMTP for your realm. This authenticator "
"displays a login screen for users to authenticate to link their "
"{project_name} account with the Identity Provider."
msgstr ""
"電子メール・オーセンティケーターが利用できない場合に、このオーセンティケーターを使用します。たとえば、レルムにSMTPを設定していない場合などです。このオーセンティケーターは、{project_name}アカウントをアイデンティティー・プロバイダーにリンクするためにユーザーが認証するためのログイン画面を表示します。"

msgid ""
"Users can also re-authenticate with another identity provider already linked"
" to their {project_name} account."
msgstr ""
"ユーザーは、自分の{project_name}アカウントにすでにリンクされている別のアイデンティティー・プロバイダーで再認証することもできます。"

msgid ""
"You can force users to use OTP. Otherwise, it is optional and used if you "
"have set OTP for the user account."
msgstr ""
"ユーザーにOTPの使用を強制することができます。それ以外の場合はオプションで、ユーザー・アカウントにOTPを設定している場合に使用されます。"

msgid "Automatically link existing first login flow"
msgstr "既存の初回ログインフローを自動的にリンクする"

msgid ""
"The AutoLink authenticator is dangerous in a generic environment where users"
" can register themselves using arbitrary usernames or email addresses. Do "
"not use this authenticator unless you are carefully curating user "
"registration and assigning usernames and email addresses."
msgstr ""
"AutoLinkオーセンティケーターは、ユーザーが任意のユーザー名や電子メールアドレスを使って自分を登録できるような一般的な環境では危険です。ユーザーの登録を慎重に管理し、ユーザー名や電子メールアドレスを割り当てる場合を除き、このオーセンティケーターを使用しないでください。"

msgid ""
"To configure a first login flow that links users automatically without "
"prompting, create a new flow with the following two authenticators:"
msgstr "プロンプトを表示せずにユーザーを自動的にリンクする初回ログインフローを構成するには、次の2つの認証子を持つ新しいフローを作成します。"

msgid ""
"This authenticator ensures {project_name} handles unique users. Set the "
"authenticator requirement to *Alternative*."
msgstr ""
"このオーセンティケーターは{project_name}がユニークなユーザーを扱うことを保証します。オーセンティケーターの要件を "
"*Alternative* に設定します。"

msgid "Automatically Set Existing User"
msgstr "Automatically Set Existing User"

msgid ""
"This authenticator sets an existing user to the authentication context "
"without verification. Set the authenticator requirement to \"Alternative\"."
msgstr ""
"このオーセンティケーターは、既存のユーザーを検証なしで認証コンテキストに設定します。オーセンティケーターの要件を \"Alternative\" "
"に設定します。"

msgid ""
"This setup is the simplest setup available, but it is possible to use other "
"authenticators. For example: * You can add the Review Profile authenticator "
"to the beginning of the flow if you want end users to confirm their profile "
"information. * You can add authentication mechanisms to this flow, forcing a"
" user to verify their credentials. Adding authentication mechanisms requires"
" a complex flow. For example, you can set the \"Automatically Set Existing "
"User\" and \"Password Form\" as \"Required\" in an \"Alternative\" sub-flow."
msgstr ""
"この設定は最もシンプルなものですが、他のオーセンティケーターを使用することも可能です。例：\n"
"* エンドユーザーに自分のプロフィール情報を確認させたい場合は、フローの最初にReview Profileオーセンティケーターを追加することができます。\n"
"* このフローに認証メカニズムを追加して、ユーザーにクレデンシャルの確認を強制することもできます。認証メカニズムを追加するには、複雑なフローが必要です。たとえば、\"Alternative\"サブフローで\"Automatically Set Existing User\"と\"Password Form\"を\"Required\"に設定します。"

msgid "Disabling automatic user creation"
msgstr "ユーザーの自動作成を無効にする"

msgid ""
"The Default first login flow looks up the {project_name} account matching "
"the external identity and offers to link them. If no matching {project_name}"
" account exists, the flow  automatically creates one."
msgstr ""
"デフォルトの初回ログインフローは、外部のアイデンティティーに一致する{project_name}アカウントを検索し、それらのリンクを提案します。一致する{project_name}アカウントが存在しない場合、フローは自動的にアカウントを作成します。"

msgid ""
"This default behavior may be unsuitable for some setups. One example is when"
" you use a read-only LDAP user store, where all users are pre-created. In "
"this case, you must switch off automatic user creation."
msgstr ""
"このデフォルトの動作は、いくつかのセットアップには適していないかもしれません。たとえば、読み取り専用のLDAPユーザーストアを使用していて、すべてのユーザーがあらかじめ作成されている場合です。このような場合には、ユーザーの自動作成をオフにする必要があります。"

msgid "To disable user creation:"
msgstr "ユーザーの作成を無効にするには、以下を行います。"

msgid "Select *First Broker Login* from the list."
msgstr "リストから *First Broker Login* を選択します。"

msgid "Set *Create User If Unique* to *DISABLED*."
msgstr "*Create User If Unique* を *DISABLED* に設定してください。"

msgid "Set *Confirm Link Existing Account* to *DISABLED*."
msgstr "*Confirm Link Existing Account* を *DISABLED* に設定してください。"

msgid ""
"This configuration also implies that Keycloak itself won't be able to "
"determine which internal account would correspond to the external identity. "
"Therefore, the `Verify Existing Account By Re-authentication` authenticator "
"will ask the user to provide both username and password."
msgstr ""
"この設定は、Keycloak自体が、外部アイデンティティーに対応する内部アカウントを判別できないことも意味します。したがって、 `Verify "
"Existing Account By Re-authentication` "
"オーセンティケーターは、ユーザーにユーザー名とパスワードの両方を提供するように要求します。"

msgid "Detect existing user first login flow"
msgstr "既存ユーザーの初回ログインフローの検出"

msgid "In order to configure a first login flow in which:"
msgstr "次のような最初のログインフローを設定するには、"

msgid "only users already registered in this realm can log in,"
msgstr "このレルムにすでに登録されているユーザーのみがログインできる"

msgid "users are automatically linked without being prompted,"
msgstr "ユーザーはプロンプトなしで自動的にリンクされる"

msgid "create a new flow with the following two authenticators:"
msgstr "次の2つのオーセンティケーターを使用して新しいフローを作成します。"

msgid "Detect Existing Broker User"
msgstr "既存のブローカー・ユーザーを検出する"

msgid ""
"This authenticator ensures that unique users are handled. Set the "
"authenticator requirement to `Mandatory`."
msgstr ""
"このオーセンティケーターは、一意にユーザーが処理されることを保障します。オーセンティケーターの要件は `Mandatory` に設定します。"

msgid ""
"Automatically sets an existing user to the authentication context without "
"any verification. Set the authenticator requirement to `Mandatory`."
msgstr "検証なしで、既存のユーザーを認証コンテキストに自動的に設定します。オーセンティケーターの要求は `Mandatory` に設定します。"

msgid ""
"You have to set the `First Login Flow` of the identity provider "
"configuration to that flow. You could set the also set `Sync Mode` to "
"`force` if you want to update the user profile (Last Name, First Name...) "
"with the identity provider attributes."
msgstr ""
"アイデンティティー・プロバイダーの設定の `First Login Flow` "
"にそのフローを設定する必要があります。アイデンティティー・プロバイダーの属性を使用してユーザー・プロファイル（姓、名など）を更新する場合は、 `Sync"
" Mode` を `force` に設定することもできます。"

msgid ""
"This flow can be used if you want to delegate the identity to other identity"
" providers (such as github, facebook ...) but you want to manage which users"
" that can log in."
msgstr ""
"このフローは、IDを他のアイデンティティー・プロバイダー（github、facebookなど）に委任したいが、ログインできるユーザーを管理したい場合に使用できます。"

msgid ""
"With this configuration, {project_name} is unable to determine which "
"internal account corresponds to the external identity. The *Verify Existing "
"Account By Re-authentication* authenticator asks the provider for the "
"username and password."
msgstr ""
"この設定では、{project_name}は、どの内部アカウントが外部アイデンティティーに対応するかを判断できません。 *Verify Existing"
" Account By Re-authentication* オーセンティケーターは、プロバイダーにユーザー名とパスワードを要求します。"

msgid "Retrieving external IDP tokens"
msgstr "外部IDPトークンの取得"

msgid ""
"With {project_name}, you can store tokens and responses from the "
"authentication process with the external IDP using the `Store Token` "
"configuration option on the IDP's settings page."
msgstr ""
"{project_name}では、IDPの設定ページにある `Store Token` "
"という設定オプションを使って、外部IDPでの認証プロセスから得たトークンとレスポンスを保存することができます。"

msgid ""
"Application code can retrieve these tokens and responses to import extra "
"user information or to request the external IDP securely. For example, an "
"application can use the Google token to use other Google services and REST "
"APIs. To retrieve a token for a particular identity provider, send a request"
" as follows:"
msgstr ""
"アプリケーション・コードは、これらのトークンとレスポンスを取得して、追加のユーザー情報をインポートしたり、外部のIDPを安全に要求したりすることができます。たとえば、アプリケーションはGoogleトークンを使用して、他のGoogleサービスやREST"
" APIを使用することができます。特定のアイデンティティー・プロバイダーのトークンを取得するには、次のようなリクエストを送信します。"

msgid ""
"GET /auth/realms/{realm}/broker/{provider_alias}/token HTTP/1.1\n"
"Host: localhost:8080\n"
"Authorization: Bearer <KEYCLOAK ACCESS TOKEN>"
msgstr ""
"GET /auth/realms/{realm}/broker/{provider_alias}/token HTTP/1.1\n"
"Host: localhost:8080\n"
"Authorization: Bearer <KEYCLOAK ACCESS TOKEN>"

msgid ""
"An application must authenticate with {project_name} and receive an access "
"token. This access token must have the `broker` client-level role `read-"
"token` set, so the user must have a role mapping for this role, and the "
"client application must have that role within its scope. In this case, since"
" you are accessing a protected service in {project_name}, send the access "
"token issued by {project_name} during the user authentication. You can "
"assign this role to newly imported users in the broker configuration page by"
" setting the *Stored Tokens Readable* switch to *ON*."
msgstr ""
"アプリケーションは{project_name}で認証を行い、アクセストークンを受け取る必要があります。このアクセストークンには、 `broker` "
"クライアントレベル・ロールの `read-token` "
"が設定されていなければなりません。したがって、ユーザーはこのロールに対応するロールマッピングを持っている必要があり、クライアント・アプリケーションはそのスコープ内にそのロールを持っている必要があります。この場合、{project_name}の保護されたサービスにアクセスしているので、ユーザー認証の際に{project_name}が発行したアクセストークンを送信します。ブローカー設定ページで、"
" *Stored Tokens Readable* スイッチを *ON* "
"に設定することで、新規にインポートしたユーザーにこのロールを割り当てることができます。"

msgid ""
"These external tokens can be re-established by logging in again through the "
"provider or using the client-initiated account linking API."
msgstr ""
"これらの外部トークンは、プロバイダーを介して再度ログインするか、クライアントが主導するアカウント・リンキングAPIを使用することで、再設定することができます。"

msgid "Identity broker logout"
msgstr "アイデンティティー・ブローカー・ログアウト"

msgid ""
"When logging out, {project_name} sends a request to the external identity "
"provider that is used to log in initially and logs the user out of this "
"identity provider. You can skip this behavior and avoid logging out of the "
"external identity provider. See link:{adapterguide_logout_link}[adapter "
"logout documentation] for more information."
msgstr ""
"ログアウトする際、{project_name}は、最初のログインに使用された外部の "
"アイデンティティー・プロバイダーにリクエストを送信し、このアイデンティティー・プロバイダーからユーザーをログアウトさせます。この動作をスキップして、外部のアイデンティティー・プロバイダーからのログアウトを回避することができます。詳細は"
" link:{adapterguide_logout_link}[アダプター・ログアウトのドキュメント] を参照してください。"

msgid "SSO protocols"
msgstr "SSOプロトコル"

msgid ""
"This section discusses authentication protocols, the {project_name} "
"authentication server and how applications, secured by the {project_name} "
"authentication server, interact with these protocols."
msgstr ""
"このセクションでは、認証プロトコル、{project_name}認証サーバー、および{project_name}認証サーバーによって保護されたアプリケーションがこれらのプロトコルとどのように連動するかについて説明します。"

msgid "OpenID Connect"
msgstr "OpenID Connect"

msgid ""
"link:https://openid.net/connect/[OpenID Connect] (OIDC) is an authentication"
" protocol that is an extension of "
"link:https://datatracker.ietf.org/doc/html/rfc6749[OAuth 2.0]."
msgstr ""
"link:https://openid.net/connect/[OpenID "
"Connect](OIDC)は、link:https://datatracker.ietf.org/doc/html/rfc6749[OAuth "
"2.0]を拡張した認証プロトコルです。"

msgid ""
"OAuth 2.0 is a framework for building authorization protocols and is "
"incomplete. OIDC, however, is a full authentication and authorization "
"protocol that uses the link:https://jwt.io[Json Web Token] (JWT) standards."
"  The JWT standards define an identity token JSON format and methods to "
"digitally sign and encrypt data in a compact and web-friendly way."
msgstr ""
"OAuth 2.0は、認可プロトコルを構築するためのフレームワークであり、不完全なものです。しかし、OIDCは、 "
"link:https://jwt.io[Json Web Token] "
"（JWT）標準を使用した完全な認証・認可プロトコルです。JWT標準は、IDトークンのJSONフォーマットと、コンパクトでウェブに適した方法でデータをデジタル署名・暗号化する方法を定義しています。"

msgid ""
"In general, OIDC implements two use cases. The first case is an application "
"requesting that a  {project_name} server authenticates a user. Upon "
"successful login, the application receives an _identity token_ and an "
"_access token_. The _identity token_ contains user information including "
"user name, email, and profile information. The realm digitally signs the "
"_access token_ which contains access information (such as user role "
"mappings) that applications use to determine the resources users can access "
"in the application."
msgstr ""
"一般的に、OIDCは2つのユースケースを実装しています。1つ目のケースは、アプリケーションが{project_name}サーバーにユーザーの認証を要求する場合です。ログインに成功すると、アプリケーションは"
" _IDトークン_ と _アクセストークン_ "
"を受け取ります。アイデンティティー・トークンには、ユーザー名、電子メール、プロフィール情報などのユーザー情報が含まれています。レルムは、ユーザーがアプリケーションでアクセスできるリソースを決定するためにアプリケーションが使用するアクセス情報（ユーザー・ロール・マッピングなど）を含む"
" _アクセストークン_ にデジタル署名します。"

msgid "The second use case is a client accessing remote services."
msgstr "2つ目のユースケースは、クライアントがリモートサービスにアクセスする場合です。"

msgid ""
"The client requests an _access token_ from {project_name} to invoke on "
"remote services on behalf of the user."
msgstr "クライアントは、ユーザーに代わってリモートサービスを呼び出すために、{project_name}に _アクセストークン_ を要求します。"

msgid ""
"{project_name} authenticates the user and asks the user for consent to grant"
" access to the requesting client."
msgstr "{project_name}はユーザーを認証し、リクエストしたクライアントにアクセスを許可することへの同意を求めます。"

msgid ""
"The client receives the _access token_ which is digitally signed by the "
"realm."
msgstr "クライアントは、レルムによってデジタル署名された _アクセストークン_ を受け取ります。"

msgid ""
"The client makes REST requests on remote services using the _access token_."
msgstr "クライアントは、 _アクセストークン_ を使ってリモートサービスにRESTリクエストを行います。"

msgid "The remote REST service extracts the _access token_."
msgstr "リモートRESTサービスは、 _アクセストークン_ を抽出します。"

msgid "The remote REST service verifies the tokens signature."
msgstr "リモートRESTサービスはトークンの署名を検証します。"

msgid ""
"The remote REST service decides, based on access information within the "
"token, to process or reject the request."
msgstr "リモートRESTサービスは、トークン内のアクセス情報に基づいて、リクエストを処理するか拒否するかを決定します。"

msgid "OIDC auth flows"
msgstr "OIDC認証フロー"

msgid ""
"OIDC has several methods, or flows, that clients or applications can use to "
"authenticate users and receive _identity_ and _access_ tokens.  The method "
"depends on the type of application or client requesting access."
msgstr ""
"OIDCには、クライアントやアプリケーションがユーザーを認証し、 _IDトークン_ および _アクセストークン_ "
"を受け取るために使用できるいくつかの方法、またはフローがあります。その方法は、アクセスを要求するアプリケーションやクライアントの種類によって異なります。"

msgid "Authorization Code Flow"
msgstr "認可コード・フロー"

msgid ""
"The Authorization Code Flow is a browser-based protocol and suits "
"authenticating and authorizing browser-based applications. It uses browser "
"redirects to obtain _identity_ and _access_ tokens."
msgstr ""
"認可コードフローは、ブラウザーベースのプロトコルであり、ブラウザーベースのアプリケーションの認証と認可に適しています。ブラウザーのリダイレクトを利用して、"
" _IDトークン_ および _アクセストークン_ を取得します。"

msgid ""
"A user connects to an application using a browser. The application detects "
"the user is not logged into the application."
msgstr ""
"ユーザーがブラウザーを使ってアプリケーションにアクセスします。アプリケーションは、ユーザーがアプリケーションにログインしていないことを検出します。"

msgid ""
"The application redirects the browser to {project_name} for authentication."
msgstr "アプリケーションは、認証のためにブラウザーを{project_name}にリダイレクトします。"

msgid ""
"The application passes a callback URL as a query parameter in the browser "
"redirect. {project_name} uses the parameter upon successful authentication."
msgstr ""
"アプリケーションは、ブラウザーのリダイレクトのクエリー・パラメーターとしてコールバックURLを渡します。{project_name}は、認証に成功するとそのパラメーターを使用します。"

msgid ""
"{project_name} authenticates the user and creates a one-time, short lived, "
"temporary code."
msgstr "{project_name}は、ユーザーを認証し、1回限りの短命の一時的なコードを作成します。"

msgid ""
"{project_name} redirects to the application using the callback URL and adds "
"the temporary code as a query parameter in the callback URL."
msgstr ""
"{project_name}は、コールバックURLを用いてアプリケーションにリダイレクトし、コールバックURLのクエリー・パラメーターとして一時コードを追加します。"

msgid ""
"The application extracts the temporary code and makes a background REST "
"invocation to {project_name} to exchange the code for an _identity_ and "
"_access_ and _refresh_ token.  To prevent replay attacks, the temporary code"
" cannot be used more than once."
msgstr ""
"アプリケーションは一時的なコードを抽出し、バックグラウンドで {project_name} に REST 呼び出しを行い、コードを _identity_"
" および _access_ と _refresh_ トークンに交換します。  リプレイ攻撃を防ぐため、一時的なコードを複数回使用することはできません。"

msgid ""
"A system is vulnerable to a stolen token for the lifetime of that token. For"
" security and scalability reasons, access tokens are generally set to expire"
" quickly so subsequent token requests fail. If a token expires, an "
"application can obtain a new access token using the additional _refresh_ "
"token sent by the login protocol."
msgstr ""
"システムは、盗まれたトークンの有効期間中、そのトークンに対して脆弱です。セキュリティーとスケーラビリティーの観点から、アクセストークンは一般にすぐに期限切れになるように設定されており、それ以降のトークンリクエストには失敗します。トークンの有効期限が切れた場合、アプリケーションはログイン・プロトコルによって送信される追加の"
" _リフレッシュ_ トークンを使用して新しいアクセストークンを取得することができます。"

msgid ""
"_Confidential_ clients provide client secrets when they exchange the "
"temporary codes for tokens. _Public_ clients are not required to provide "
"client secrets. _Public_ clients are secure when HTTPS is strictly enforced "
"and redirect URIs registered for the client are strictly controlled.  "
"HTML5/JavaScript clients have to be _public_ clients because there is no way"
" to securely transmit the client secret to HTML5/JavaScript clients. For "
"more details, see the xref:assembly-managing-clients_{context}[Managing "
"Clients] chapter."
msgstr ""
"_コンフィデンシャル_ "
"・クライアントは、一時的なコードをトークンに交換する際にクライアント・シークレットを提供します。パブリック・クライアントは、クライアント・シークレットの提供は必要ありません。パブリック・クライアントは、HTTPSを厳密に実施し、クライアントに登録されるリダイレクトURIを厳密に管理することで安全性を確保します。HTML5/JavaScriptクライアントは、クライアント・シークレットを安全に送信する方法がないため、"
" _パブリック_ クライアントである必要があります。詳しくは xref:assembly-managing-"
"clients_{context}[クライアントの管理] の章を参照してください。"

msgid ""
"{project_name} also supports the "
"https://datatracker.ietf.org/doc/html/rfc7636[Proof Key for Code Exchange] "
"specification."
msgstr ""
"{project_name}は、 https://datatracker.ietf.org/doc/html/rfc7636[Proof Key for"
" Code Exchange] の仕様にも対応しています。"

msgid "Implicit Flow"
msgstr "インプリシット・フロー"

msgid ""
"The Implicit Flow is a browser-based protocol. It is similar to the "
"Authorization Code Flow but with fewer requests and no refresh tokens."
msgstr ""
"インプリシット・フローは、ブラウザーベースのプロトコルです。認可コードフローと似ているが、リクエスト数が少なく、リフレッシュ・トークンもありません。"

msgid ""
"The possibility exists of _access_ tokens leaking in the browser history "
"when tokens are transmitted via redirect URIs (see below)."
msgstr "トークンをリダイレクトURIで送信する場合、 _アクセス_ トークンがブラウザーの履歴に漏れる可能性があります（下記参照）。"

msgid ""
"Also, this flow does not provide clients with refresh tokens. Therefore, "
"access tokens have to be long-lived or users  have to re-authenticate when "
"they expire."
msgstr ""
"また、このフローでは、クライアントにリフレッシュトークンを提供しません。したがって、アクセストークンは長寿命でなければならず、また、アクセストークンの有効期限が切れると、ユーザーは再認証をしなければならない。"

msgid ""
"We do not advise using this flow. This flow is supported because it is in "
"the OIDC and OAuth 2.0 specification."
msgstr "このフローを使用することはお勧めしません。このフローがサポートされているのは、OIDCとOAuth 2.0の仕様に含まれているからです。"

msgid "The protocol works as follows:"
msgstr "プロトコルは次のように動作します。"

msgid ""
"The application passes a callback URL as a query parameter in the browser "
"redirect. {project_name} uses the query parameter upon successful "
"authentication."
msgstr ""
"アプリケーションは、ブラウザーのリダイレクトにコールバックURLをクエリー・パラメーターとして渡します。{project_name}は、認証に成功すとクエリー・パラメーターを使用します。"

msgid ""
"{project_name} authenticates the user and creates an _identity_ and _access_"
" token. {project_name} redirects to the application using the callback URL "
"and additionally adds the _identity_ and _access_ tokens as a query "
"parameter in the callback URL."
msgstr ""
"{project_name}は、ユーザーを認証し、 _ID_ トークンと _アクセス_ "
"トークンを作成します。{project_name}はコールバックURLを使用してアプリケーションにリダイレクトし、さらに _ID_ トークンと "
"_アクセス_ トークンをコールバックURLのクエリー・パラメーターとして追加します。"

msgid ""
"The application extracts the _identity_ and _access_ tokens from the "
"callback URL."
msgstr "アプリケーションは、コールバックURLから _ID_ トークンと _アクセス_ トークンを抽出します。"

msgid "Resource owner password credentials grant (Direct Access Grants)"
msgstr "リソース・オーナー・パスワード・クレデンシャル・グラント（Direct Access Grants）"

msgid ""
"_Direct Access Grants_ are used by REST clients to obtain tokens on behalf "
"of users.  It is a HTTP POST request that contains:"
msgstr ""
"_Direct Access Grants_ は、RESTクライアントがユーザーの代わりにトークンを取得するために使用されます。これは、HTTP "
"POSTリクエストで、以下を含みます。"

msgid ""
"The credentials of the user. The credentials are sent within form "
"parameters."
msgstr "ユーザーのクレデンシャル。クレデンシャルはフォームのパラメーターで送信されます。"

msgid "The id of the client."
msgstr "クライアントのID。"

msgid "The clients secret (if it is a confidential client)."
msgstr "クライアントのシークレット（コンフィデンシャル・クライアントの場合）。"

msgid ""
"The HTTP response contains the _identity_, _access_, and _refresh_ tokens."
msgstr "HTTP レスポンスには、 _ID_ トークン、 _アクセス_ トークン、 _リフレッシュ_ トークンが含まれます。"

msgid "Client credentials grant"
msgstr "クライアント・クレデンシャル・グラント"

msgid ""
"The _Client Credentials Grant_ creates a token based on the metadata and "
"permissions of a service account associated with the client instead of "
"obtaining a token that works on behalf of an external user. _Client "
"Credentials Grants_ are used by REST clients."
msgstr ""
"_クライアント・クレデンシャル・グラント_ "
"は、外部ユーザーの代わりに動作するトークンを取得するのではなく、クライアントに関連付けられたサービス・アカウントのメタデータとパーミッションに基づいてトークンを作成します。"
" _クライアント・クレデンシャル・グラント_ は REST クライアントによって使用されます。"

msgid ""
"See the <<_service_accounts,Service Accounts>> chapter for more information."
msgstr "詳しくは<<_service_accounts,サービス・アカウント>>の章を参照してください。"

msgid "Device authorization grant"
msgstr "デバイス認可グラント"

msgid ""
"This is used by clients running on internet-connected devices that have "
"limited input capabilities or lack a suitable browser. Here's a brief "
"summary of the protocol:"
msgstr ""
"これは、入力機能が制限されているか、適切なブラウザーがない、インターネットに接続されたデバイスで実行されているクライアントによって使用されます。プロトコルの簡単な概要は次のとおりです。"

msgid ""
"The application requests {project_name} a device code and a user code. "
"{project_name} creates a device code and a user code. {project_name} returns"
" a response including the device code and the user code to the application."
msgstr ""
"アプリケーションは{project_name}にデバイスコードとユーザーコードを要求します。{project_name}は、デバイスコードとユーザーコードを作成します。{project_name}は、デバイス"
" コードとユーザーコードを含むレスポンスをアプリケーションに返します。"

msgid ""
"The application provides the user with the user code and the verification "
"URI. The user accesses a verification URI to be authenticated by using "
"another browser."
msgstr ""
"アプリケーションは、ユーザーコードと検証URIをユーザーに提供します。ユーザーは、別のブラウザーを使用して、認証を受けるための検証URIにアクセスします。"

msgid ""
"The application repeatedly polls {project_name} to find out if the user "
"completed the user authorization. If user authentication is complete, the "
"application exchanges the device code for an _identity_, _access_ and "
"_refresh_ token."
msgstr ""
"アプリケーションは{project_name}を繰り返しポーリングして、ユーザーがユーザー認証を完了したかどうかを調べます。ユーザー認証が完了すると、アプリケーションはデバイス"
" コードを _ID_ トークン、 _access_ トークン、 および _refresh_ トークンと交換します。"

msgid "Client initiated backchannel authentication grant"
msgstr "クライアント起点バックチャネル認証グラント"

msgid ""
"This feature is used by clients who want to initiate the authentication flow"
" by communicating with the OpenID Provider directly without redirect through"
" the user's browser like OAuth 2.0's authorization code grant. Here's a "
"brief summary of the protocol:"
msgstr ""
"この機能は、OAuth "
"2.0の認可コードグラントのようにユーザーのブラウザーを通してリダイレクトすることなく、OpenIDプロバイダーと直接通信して認証フローを開始させたいクライアントが使用します。以下はプロトコルの概要です。"

msgid ""
"The client requests {project_name} an auth_req_id that identifies the "
"authentication request made by the client. {project_name} creates the "
"auth_req_id."
msgstr ""
"クライアントは、クライアントによって行われた認証リクエストを識別するauth_req_idを{project_name}に要求します。{project_name}はauth_req_idを作成します。"

msgid ""
"After receiving this auth_req_id, this client repeatedly needs to poll "
"{project_name} to obtain an Access Token, Refresh Token and ID Token from "
"{project_name} in return for the auth_req_id until the user is "
"authenticated."
msgstr ""
"このauth_req_idを受信した後、このクライアントは{project_name}を繰り返しポーリングして、ユーザーが認証されるまでauth_req_idと引き換えに{project_name}からアクセストークン、リフレッシュトークン、IDトークンを取得する必要があります。"

msgid ""
"An administrator can configure Client Initiated Backchannel Authentication "
"(CIBA) related operations as `CIBA Policy` per realm."
msgstr ""
"管理者は、Client Initiated Backchannel Authentication (CIBA) 関連の操作をレルムごとの `CIBA "
"Policy` として設定できます。"

msgid ""
"Also please refer to other places of {project_name} documentation like "
"link:{adapterguide_link}#_backchannel_authentication_endpoint[Backchannel "
"Authentication Endpoint section] of {adapterguide_name} and "
"link:{adapterguide_link}#_client_initiated_backchannel_authentication_grant[Client"
" Initiated Backchannel Authentication Grant section] of {adapterguide_name}."
msgstr ""
"また、{adapterguide_name}の "
"link:{adapterguide_link}#_backchannel_authentication_endpoint[Backchannel "
"Authentication Endpointのセクション] や{adapterguide_name}の "
"link:{adapterguide_link}#_client_initiated_backchannel_authentication_grant[ClientInitiated"
" Backchannel Authentication Grant] "
"のセクションなど、{project_name}ドキュメントの他の場所も参照してください。"

msgid "CIBA Policy"
msgstr "CIBAポリシー"

msgid ""
"An administrator carries out the following operations on the `Admin Console`"
" :"
msgstr "管理者は、 `管理コンソール` で次の操作を行います。"

msgid "Open the `Authentication -> CIBA Policy` tab."
msgstr "`Authentication -> CIBA Policy` タブを開きます."

msgid "Configure items and click `Save`."
msgstr "アイテムを設定し、 `Save` をクリックします。"

msgid "The configurable items and their description follow."
msgstr "設定可能な項目とその説明は次のとおりです。"

msgid "Backchannel Token Delivery Mode"
msgstr "Backchannel Token Delivery Mode"

msgid ""
"Specifying how the CD (Consumption Device) gets the authentication result and related tokens. There are three modes, \"poll\", \"ping\" and \"push\". {project_name} only supports \"poll\". The default setting is \"poll\". This configuration is required.\n"
" For more details, see https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#rfc.section.5[CIBA Specification]."
msgstr ""
"CD（Consumption "
"Device）には認証結果と関連トークンを取得する方法を指定します。\"poll\"、\"ping\"、\"push\"の3つのモードがあります。{project_name}は\"poll\"のみをサポートします。デフォルト設定は\"poll\"です。この設定は必須です。詳細については、"
" https://openid.net/specs/openid-client-initiated-backchannel-"
"authentication-core-1_0.html#rfc.section.5[CIBA Specification] を参照してください。"

msgid "Expires In"
msgstr "Expires In"

msgid ""
"The expiration time of the \"auth_req_id\" in seconds since the authentication request was received. The default setting is 120. This configuration is required.\n"
" For more details, see https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#successful_authentication_request_acknowdlegment[CIBA Specification]."
msgstr ""
"認証リクエストを受信してからの\"auth_req_id\"の有効期限（秒単位）。デフォルトの設定は120です。この設定は必須です。詳細については、 "
"https://openid.net/specs/openid-client-initiated-backchannel-authentication-"
"core-1_0.html#successful_authentication_request_acknowdlegment[CIBA "
"Specification] を参照してください。"

msgid "Interval"
msgstr "Interval"

msgid ""
"The interval in seconds the CD (Consumption Device) needs to wait for between polling requests to the token endpoint. The default setting is 5. This configuration is optional.\n"
" For more details, see https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#successful_authentication_request_acknowdlegment[CIBA Specification]."
msgstr ""
"CD（Consumption "
"Device）がトークン・エンドポイントへのポーリング・リクエスト間で待機する必要がある秒単位の間隔。デフォルト設定は5です。この設定はオプションです。詳細については、"
" https://openid.net/specs/openid-client-initiated-backchannel-"
"authentication-"
"core-1_0.html#successful_authentication_request_acknowdlegment[CIBA "
"Specification] を参照してください。"

msgid "Authentication Requested User Hint"
msgstr "Authentication Requested User Hint"

msgid ""
"The way of identifying the end-user for whom authentication is being requested. The default setting is \"login_hint\".  There are three modes, \"login_hint\", \"login_hint_token\" and \"id_token_hint\". {project_name} only supports \"login_hint\". This configuration is required.\n"
" For more details, see https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#rfc.section.7.1[CIBA Specification]."
msgstr ""
"認証が要求されているエンドユーザーを識別する方法。デフォルト設定は\"login_hint\"です。\"login_hint\"、\"login_hint_token\"、\"id_token_hint\"の3つのモードがあります。{project_name}は\"login_hint\"のみをサポートします。この設定は必須です。詳細については、"
" https://openid.net/specs/openid-client-initiated-backchannel-"
"authentication-core-1_0.html#rfc.section.5[CIBA Specification] を参照してください。"

msgid "Provider Setting"
msgstr "プロバイダー設定"

msgid "The CIBA grant uses the following two providers."
msgstr "CIBAグラントは、次の2つのプロバイダーを使用します。"

msgid ""
"Authentication Channel Provider : provides the communication between "
"{project_name} and the entity that actually authenticates the user via AD "
"(Authentication Device)."
msgstr ""
"認証チャネル・プロバイダー：{project_name}と、AD（Authentication "
"Device）を介してユーザーを実際に認証するエンティティーとの間の通信を提供します。"

msgid ""
"User Resolver Provider : get `UserModel` of {project_name} from the "
"information provided by the client to identify the user."
msgstr ""
"User Resolver Provider：クライアントから提供された情報から{project_name}の `UserModel` "
"を取得して、ユーザーを識別します。"

msgid ""
"{project_name} has both default providers. However, the administrator needs "
"to set up Authentication Channel Provider like this:"
msgstr ""
"{project_name}には両方のデフォルト・プロバイダーがあります。ただし、管理者は次のように認証チャネル・プロバイダーを設定する必要があります。"

msgid ""
"<spi name=\"ciba-auth-channel\">\n"
"    <default-provider>ciba-http-auth-channel</default-provider>\n"
"    <provider name=\"ciba-http-auth-channel\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"httpAuthenticationChannelUri\" value=\"https://backend.internal.example.com/auth\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"ciba-auth-channel\">\n"
"    <default-provider>ciba-http-auth-channel</default-provider>\n"
"    <provider name=\"ciba-http-auth-channel\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"httpAuthenticationChannelUri\" value=\"https://backend.internal.example.com/auth\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid "httpAuthenticationChannelUri"
msgstr "httpAuthenticationChannelUri"

msgid ""
"Specifying URI of the entity that actually authenticates the user via AD "
"(Authentication Device)."
msgstr "AD（Authentication Device）を介して実際にユーザーを認証するエンティティーのURIを指定します。"

msgid "Authentication Channel Provider"
msgstr "Authentication Channel Provider"

msgid ""
"CIBA standard document does not specify how to authenticate the user by AD. "
"Therefore, it might be implemented at the discretion of products. "
"{project_name} delegates this authentication to an external authentication "
"entity. To communicate with the authentication entity, {project_name} "
"provides Authentication Channel Provider."
msgstr ""
"CIBA標準ドキュメントでは、ADによるユーザーの認証方法は指定されていません。したがって、製品の判断で実装される可能性があります。{project_name}は、この認証を外部認証エンティティーに委任します。認証エンティティーと通信するために、{project_name}は認証チャネル・プロバイダーを提供します。"

msgid ""
"Its implementation of {project_name} assumes that the authentication entity "
"is under the control of the administrator of {project_name} so that "
"{project_name} trusts the authentication entity. It is not recommended to "
"use the authentication entity that the administrator of {project_name} "
"cannot control."
msgstr ""
"{project_name}の実装は、認証エンティティーが{project_name}の管理者の制御下にあることを前提としているため、{project_name}は認証エンティティーを信頼します。{project_name}の管理者が制御できない認証エンティティーを使用することはお勧めしません。"

msgid ""
"Authentication Channel Provider is provided as SPI provider so that users of"
" {project_name} can implement their own provider in order to meet their "
"environment. {project_name} provides its default provider called HTTP "
"Authentication Channel Provider that uses HTTP to communicate with the "
"authentication entity."
msgstr ""
"認証チャネル・プロバイダーはSPIプロバイダーとして提供されるため、{project_name}のユーザーは、環境に合わせて独自のプロバイダーを実装できます。{project_name}は、HTTPを使用して認証エンティティーと通信するHTTP認証チャネル・プロバイダーと呼ばれるデフォルトのプロバイダーを提供します。"

msgid ""
"If a user of {project_name} user want to use the HTTP Authentication Channel"
" Provider, they need to know its contract between {project_name} and the "
"authentication entity consisting of the following two parts."
msgstr ""
"{project_name}のユーザーがHTTP認証チャネル・プロバイダーを使用する場合、{project_name}と次の2つの部分で構成される認証エンティティーとの間のコントラクトを知る必要があります。"

msgid "Authentication Delegation Request/Response"
msgstr "Authentication Delegation Request/Response"

msgid ""
"{project_name} sends an authentication request to the authentication entity."
msgstr "{project_name}は、認証リクエストを認証エンティティーに送信します。"

msgid "Authentication Result Notification/ACK"
msgstr "Authentication Result Notification/ACK"

msgid ""
"The authentication entity notifies the result of the authentication to "
"{project_name}."
msgstr "認証エンティティーは、認証の結果を{project_name}に通知します。"

msgid ""
"Authentication Delegation Request/Response consists of the following "
"messaging."
msgstr "認証委任リクエスト/レスポンスは、次のメッセージで構成されます。"

msgid "Authentication Delegation Request"
msgstr "Authentication Delegation Request"

msgid ""
"The request is sent from {project_name} to the authentication entity to ask "
"it for user authentication by AD."
msgstr "リクエストは{project_name}から認証エンティティーに送信され、ADによるユーザー認証を要求します。"

msgid "POST [delegation_reception]"
msgstr "POST [delegation_reception]"

msgid "Headers"
msgstr "Headers"

msgid "Value"
msgstr "値"

msgid "Content-Type"
msgstr "Content-Type"

msgid "application/json"
msgstr "application/json"

msgid "The message body is json formatted."
msgstr "メッセージ本文はJSON形式です。"

msgid "Authorization"
msgstr "Authorization"

msgid "Bearer [token]"
msgstr "Bearer [token]"

msgid ""
"The [token] is used when the authentication entity notifies the result of "
"the authentication to {project_name}."
msgstr "[tokenン]は、認証エンティティーが認証の結果を{project_name}に通知するときに使用されます。"

msgid "Parameters"
msgstr "Parameters"

msgid "Path"
msgstr "Path"

msgid "delegation_reception"
msgstr "delegation_reception"

msgid ""
"The endpoint provided by the authentication entity to receive the delegation"
" request"
msgstr "委任リクストを受信するために認証エンティティーによって提供されるエンドポイント"

msgid "Body"
msgstr "Body"

msgid "login_hint"
msgstr "login_hint"

msgid ""
"It tells the authentication entity who is authenticated by AD. +\n"
"By default, it is the user's \"username\". +\n"
"This field is required and was defined by CIBA standard document."
msgstr ""
"ADによって認証された認証エンティティーに通知します。 +\n"
"デフォルトでは、これはユーザーの\"username\"です。 +\n"
"このフィールドは必須であり、CIBA標準ドキュメントによって定義されています。"

msgid "scope"
msgstr "scope"

msgid ""
"It tells which scopes the authentication entity gets consent from the authenticated user. +\n"
"This field is required and was defined by CIBA standard document."
msgstr ""
"認証エンティティーが認証されたユーザーから同意を得るスコープを示します。 +\n"
"このフィールドは必須であり、CIBA標準ドキュメントによって定義されています。"

msgid "is_consent_required"
msgstr "is_consent_required"

msgid ""
"It shows whether the authentication entity needs to get consent from the authenticated user about the scope. +\n"
" This field is required."
msgstr ""
"認証エンティティーがスコープについて認証されたユーザーから同意を得る必要があるかどうかを示します。 +\n"
"この項目は必須です。"

msgid "binding_message"
msgstr "binding_message"

msgid ""
"Its value is intended to be shown in both CD and AD's UI to make the user recognize that the authentication by AD is triggered by CD. +\n"
"This field is optional and was defined by CIBA standard document."
msgstr ""
"その値は、CDとADのUIの両方に表示され、ADによる認証がCDによってトリガーされたことをユーザーに認識させることを目的としています。 +\n"
"このフィールドはオプションであり、CIBA標準ドキュメントによって定義されています。"

msgid "acr_values"
msgstr "acr_values"

msgid ""
"It tells the requesting Authentication Context Class Reference from CD. +\n"
"This field is optional and was defined by CIBA standard document."
msgstr ""
"CDから要求している認証コンテキストクラス参照を通知します。 +\n"
"このフィールドはオプションであり、CIBA標準ドキュメントによって定義されています。"

msgid "Authentication Delegation Response"
msgstr "Authentication Delegation Response"

msgid ""
"The response is returned from the authentication entity to {project_name} to"
" notify that the authentication entity received the authentication request "
"from {project_name}."
msgstr ""
"認証エンティティーから{project_name}にレスポンスが返され、認証エンティティーが{project_name}から認証リクエストを受信したことが通知されます。"

msgid "Responses"
msgstr "Responses"

msgid "HTTP Status Code"
msgstr "HTTPステータスコード"

msgid "201"
msgstr "201"

msgid ""
"It notifies {project_name} of receiving the authentication delegation "
"request."
msgstr "認証委任リクエストを受信したことを{project_name}に通知します。"

msgid ""
"Authentication Result Notification/ACK consists of the following messaging."
msgstr "認証結果通知/ACKは以下のメッセージで構成されています。"

msgid "Authentication Result Notification"
msgstr "認証結果通知"

msgid ""
"The authentication entity sends the result of the authentication request to "
"{project_name}."
msgstr "認証エンティティーは、認証リクエストの結果を{project_name}に送信します。"

msgid ""
"POST /auth/realms/[realm]/protocol/openid-connect/ext/ciba/auth/callback"
msgstr ""
"POST /auth/realms/[realm]/protocol/openid-connect/ext/ciba/auth/callback"

msgid ""
"The [token] must be the one the authentication entity has received from "
"{project_name} in Authentication Delegation Request."
msgstr "[token]は、認証エンティティーが認証委任リクエストで{project_name}から受信したものである必要があります。"

msgid "realm"
msgstr "realm"

msgid "The realm name"
msgstr "レルム名"

msgid "status"
msgstr "status"

msgid ""
"It tells the result of user authentication by AD. +\n"
"It must be one of the following status. +\n"
"  SUCCEED : The authentication by AD has been successfully completed. +\n"
"  UNAUTHORIZED : The authentication by AD has not been completed. +\n"
"  CANCELLED : The authentication by AD has been cancelled by the user."
msgstr ""
"ADによるユーザー認証の結果を示します。 +\n"
"以下のステータスのいずれかでなければなりません。 +\n"
"  SUCCEED：ADによる認証が正常に完了しました。 +\n"
"UNAUTHORIZED：ADによる認証が完了していません。 +\n"
"CANCELLED：ADによる認証がユーザーによってキャンセルされました。"

msgid "Authentication Result ACK"
msgstr "Authentication Result ACK"

msgid ""
"The response is returned from {project_name} to the authentication entity to"
" notify {project_name} received the result of user authentication by AD from"
" the authentication entity."
msgstr ""
"レスポンスは{project_name}から認証エンティティーに返され、認証エンティティーからADによるユーザー認証の結果を{project_name}が受信したことを通知します。"

msgid "200"
msgstr "200"

msgid ""
"It notifies the authentication entity of receiving the notification of the "
"authentication result."
msgstr "認証結果の通知を受信したことを認証エンティティーに通知します。"

msgid "User Resolver Provider"
msgstr "User Resolver Provider"

msgid ""
"Even if the same user, its representation may differ in each CD, "
"{project_name} and the authentication entity."
msgstr "同じユーザーであっても、その表現はCD、{project_name}、および認証エンティティーごとに異なる場合があります。"

msgid ""
"For CD, {project_name} and the authentication entity to recognize the same "
"user, this User Resolver Provider converts their own user representations "
"among them."
msgstr ""
"CD、{project_name}、および認証エンティティーが同じユーザーを認識するために、このユーザー・リゾルバー・プロバイダーは、それらの間で独自のユーザー表現を変換します。"

msgid ""
"User Resolver Provider is provided as SPI provider so that users of "
"{project_name} can implement their own provider in order to meet their "
"environment. {project_name} provides its default provider called Default "
"User Resolver Provider that has the following characteristics."
msgstr ""
"ユーザー・リゾルバー・プロバイダーはSPIプロバイダーとして提供されるため、{project_name}のユーザーは、環境に合わせて独自のプロバイダーを実装できます。{project_name}は、次の特性を持つDefault"
" User ResolverProviderと呼ばれるデフォルト・プロバイダーを提供します。"

msgid "Only support `login_hint` parameter and is used as default."
msgstr "`login_hint` パラメーターのみをサポートし、デフォルトとして使用されます。"

msgid ""
"`username` of UserModel in {project_name} is used to represent the user on "
"CD, {project_name} and the authentication entity."
msgstr ""
"{project_name}のUserModelの `username` "
"は、CD、{project_name}、および認証エンティティーのユーザーを表すために使用されます。"

msgid "OIDC Logout"
msgstr "OIDCログアウト"

msgid ""
"OIDC has three different specifications relevant to logout mechanisms, all "
"of these are currently in draft status:"
msgstr "OIDCには、ログアウト機構に関連する3つの異なる仕様があり、これらはすべて現在ドラフトの状態です。"

msgid ""
"https://openid.net/specs/openid-connect-session-1_0.html[Session Management]"
msgstr ""
"https://openid.net/specs/openid-connect-session-1_0.html[Session Management]"

msgid ""
"https://openid.net/specs/openid-connect-frontchannel-1_0.html[Front-Channel "
"Logout]"
msgstr ""
"https://openid.net/specs/openid-connect-frontchannel-1_0.html[Front-Channel "
"Logout]"

msgid ""
"https://openid.net/specs/openid-connect-backchannel-1_0.html[Back-Channel "
"Logout]"
msgstr ""
"https://openid.net/specs/openid-connect-backchannel-1_0.html[Back-Channel "
"Logout]"

msgid ""
"Again since all of this is described in the OIDC specification we will only "
"give a brief overview here."
msgstr "繰り返しになりますが、これはすべてOIDCの仕様で説明されているため、ここでは簡単な概要のみを示します。"

msgid "Session Management"
msgstr "Session Management"

msgid ""
"This is a browser-based logout. The application obtains session status "
"information from {project_name} at a regular basis. When the session is "
"terminated at {project_name} the application will notice and trigger it's "
"own logout."
msgstr ""
"これはブラウザーベースのログアウトです。アプリケーションは、定期的に{project_name}からセッション・ステータス情報を取得します。セッションが{project_name}で終了すると、アプリケーションはそれに気づき、自身のログアウトをトリガーします。"

msgid "Frontchannel Logout"
msgstr "Frontchannel Logout"

msgid ""
"This is also a browser-based logout where the logout starts by redirecting "
"the user to a specific endpoint at {project_name}."
msgstr ""
"これもブラウザー・ベースのログアウトで、ログアウトが始まると、ユーザーは{project_name}の特定のエンドポイントにリダイレクトされます。"

msgid ""
"Once the user is redirected to the logout endpoint, {project_name} is going "
"to send logout requests to clients to let them to invalidate their local "
"user sessions, and potentially redirect the user to some URL once the logout"
" process is finished."
msgstr ""
"ユーザーがログアウト・エンドポイントにリダイレクトされると、{project_name}はクライアントにログアウト・リクエストを送信して、ローカル・ユーザー・セッションを無効にし、ログアウト・プロセスが終了したらユーザーを何らかのURLにリダイレクトするようにします。"

msgid ""
"Depending on the client configuration, logout requests can be sent to "
"clients through the front-channel or through the back-channel."
msgstr ""
"クライアントの設定により、ログアウト・リクエストは、フロントチャネルを介してクライアントに送信される場合と、バックチャネルを介して送信される場合があります。"

msgid ""
"To configure clients to receive logout requests through the front-channel, "
"look at the <<_front-channel-logout, Front-Channel Logout>> client setting. "
"When using this method, consider the following:"
msgstr ""
"フロントチャネルでログアウト・リクエストを受信するようにクライアントを設定するには、<<_front-channel-logout, Front-"
"Channel Logout>>のクライアントの設定を見てください。この方法を使用する場合、以下の点を考慮してください。"

msgid ""
"Logout requests sent by {project_name} to clients rely on the browser and on"
" embedded `iframes` that are rendered for the logout page."
msgstr ""
"{project_name}がクライアントに送信するログアウト・リクエストは、ブラウザーと、ログアウトページでレンダリングされる埋め込みの "
"`iframe` に依存しています。"

msgid ""
"By being based on `iframes`, front-channel logout might be impacted by "
"Content Security Policies (CSP) and logout requests might be blocked."
msgstr ""
"フロントチャネルのログアウトは、「iframe」に基づいているため、コンテンツ・セキュリティー・ポリシー（CSP）の影響を受け、ログアウト・リクエストがブロックされる可能性があります。"

msgid ""
"If the user closes the browser prior to rendering the logout page or before "
"logout requests are actually sent to clients, their sessions at the client "
"might not be invalidated."
msgstr ""
"ログアウトページを表示する前、またはログアウト・リクエストが実際にクライアントに送信される前にユーザーがブラウザーを閉じた場合、クライアントでのセッションが無効にならない可能性があります。"

msgid ""
"Consider using Back-Channel Logout as it provides a more reliable and secure"
" approach to log out users and terminate their sessions on the clients."
msgstr ""
"ユーザーをログアウトさせ、クライアント上のセッションを終了させるには、より信頼性が高く安全な方法であるバックチャネル・ログアウトの使用を検討してください。"

msgid ""
"If the client is not enabled with front-channel logout, then {project_name} "
"is going to try first to send logout requests through the back-channel using"
" the <<_back-channel-logout-url, Back-Channel Logout URL>>. If not defined, "
"the server is going to fall back to using the <<_admin-url, Admin URL>>."
msgstr ""
"クライアントがフロントチャネル・ログアウトを有効にしていない場合、{project_name}はまず<<_back-channel-logout-"
"url, Back-Channel Logout URL>>を使ってバックチャネルでログアウト・リクエストを送ろうとします。<_back-"
"channel-logout-url, Back-Channel Logout URL>定義されていない場合、サーバーは<<_admin-url, "
"Admin URL>>の使用に戻ります。"

msgid ""
"This is a non browser-based logout that uses direct backchannel "
"communication between {project_name} and clients. {project_name} sends a "
"HTTP POST request containing a logout token to all clients logged into "
"{project_name}. These requests are sent to a registered backchannel logout "
"URLs at {project_name} and are supposed to trigger a logout at client side."
msgstr ""
"これは、{project_name}とクライアント間の直接バックチャネル通信を使用する非ブラウザーベースのログアウトです。{project_name}は、ログアウト・トークンを含むHTTP"
" "
"POSTリクエストを{project_name}にログインしているすべてのクライアントに送信します。これらのリクエストは、{project_name}の登録済みバックチャネル・ログアウトURLに送信され、クライアント側でログアウトをトリガーすることになっています。"

msgid "{project_name} server OIDC URI endpoints"
msgstr "{project_name}サーバーのOIDC URIエンドポイント"

msgid ""
"The following is a list of OIDC endpoints that {project_name} publishes. "
"These endpoints can be used when a non-{project_name} client adapter uses "
"OIDC to communicate with the authentication server. They are all relative "
"URLs. The root of the URL consists of the HTTP(S) protocol, hostname, and "
"the path, which is usually prefixed with _/auth_:  For example"
msgstr ""
"{project_name}が公開しているOIDCエンドポイントの一覧を以下に示します。これらのエンドポイントは、{project_name}以外のクライアント・アダプターがOIDCを用いて認証サーバーと通信する際に利用することができます。これらはすべて相対URLです。URLのルートは、HTTP(S)プロトコル、ホスト名、パスからなり、通常"
" _/auth_ が先頭に付きます。たとえば、以下です。"

msgid "https://localhost:8080/auth"
msgstr "https://localhost:8080/auth"

msgid "/realms/{realm-name}/protocol/openid-connect/auth"
msgstr "/realms/{realm-name}/protocol/openid-connect/auth"

msgid ""
"Used for obtaining a temporary code in the Authorization Code Flow or "
"obtaining tokens using the Implicit Flow, Direct Grants, or Client Grants."
msgstr ""
"認可コードフローで一時的なコードを取得したり、インプリシット・フロー、ダイレクト・グラント、クライアント・グラントでトークンを取得する際に使用します。"

msgid "/realms/{realm-name}/protocol/openid-connect/token"
msgstr "/realms/{realm-name}/protocol/openid-connect/token"

msgid ""
"Used by the Authorization Code Flow to convert a temporary code into a "
"token."
msgstr "認可コードフローで、一時的なコードをトークンに変換するために使用されます。"

msgid "/realms/{realm-name}/protocol/openid-connect/logout"
msgstr "/realms/{realm-name}/protocol/openid-connect/logout"

msgid "Used for performing logouts."
msgstr "ログアウトを実行するために使用します。"

msgid "/realms/{realm-name}/protocol/openid-connect/userinfo"
msgstr "/realms/{realm-name}/protocol/openid-connect/userinfo"

msgid "Used for the User Info service described in the OIDC specification."
msgstr "OIDC仕様に記載されているUser Infoサービスに使用されます。"

msgid "/realms/{realm-name}/protocol/openid-connect/revoke"
msgstr "/realms/{realm-name}/protocol/openid-connect/revoke"

msgid ""
"Used for OAuth 2.0 Token Revocation described in "
"https://datatracker.ietf.org/doc/html/rfc7009[RFC7009]."
msgstr ""
"https://datatracker.ietf.org/doc/html/rfc7009[RFC7009] に記載されているOAuth 2.0 "
"Token Revocationに使用されます。"

msgid "/realms/{realm-name}/protocol/openid-connect/certs"
msgstr "/realms/{realm-name}/protocol/openid-connect/certs"

msgid ""
"Used for the JSON Web Key Set (JWKS) containing the public keys used to "
"verify any JSON Web Token (jwks_uri)"
msgstr ""
"JSON Web Token (jwks_uri) を検証するために使用する公開鍵を含むJSON Web Key Set (JWKS) に使用します。"

msgid "/realms/{realm-name}/protocol/openid-connect/auth/device"
msgstr "/realms/{realm-name}/protocol/openid-connect/auth/device"

msgid ""
"Used for Device Authorization Grant to obtain a device code and a user code."
msgstr "デバイス認可グラントで、デバイスコードとユーザーコードを取得するために使用します。"

msgid "In all of these, replace {realm-name} with the name of the realm."
msgstr "いずれも{realm-name}をレルムの名前に置き換えてください。"

msgid "SAML"
msgstr "SAML"

msgid ""
"link:http://saml.xml.org/saml-specifications[SAML 2.0] is a similar "
"specification to OIDC but more mature.  It is descended from SOAP and web "
"service messaging specifications so is generally more verbose than OIDC.  "
"SAML 2.0 is an authentication protocol that exchanges XML documents between "
"authentication servers and applications.  XML signatures and encryption are "
"used to verify requests and responses."
msgstr ""
"link:http://saml.xml.org/saml-specifications[SAML "
"2.0]は、OIDCと同様の仕様ですが、より成熟しています。SAML "
"2.0は、SOAPやWebサービスのメッセージング仕様の流れを汲んでいるため、一般にOIDCよりも冗長です。  SAML "
"2.0は、認証サーバーとアプリケーションの間でXML文書を交換する認証プロトコルです。リクエストとレスポンスの検証には、XML署名と暗号化が用いられます。"

msgid "In general, SAML implements two use cases."
msgstr "一般に、SAMLは2つのユースケースを実装しています。"

msgid ""
"The first use case is an application that requests the {project_name} server"
" authenticates a user.  Upon successful login, the application will receive "
"an XML document. This document contains an SAML assertion that specifies "
"user attributes. The realm digitally signs the the document which contains "
"access information (such as user role mappings) that applications use to "
"determine the resources users are allowed to access in the application."
msgstr ""
"1つ目のユースケースは、{project_name}サーバーにユーザーの認証を要求するアプリケーションです。ログインに成功すると、アプリケーションはXMLドキュメントを受け取ります。このドキュメントには、ユーザー属性を指定するSAMLアサーションが含まれます。このドキュメントには、アプリケーションがユーザーにアクセスを許可するリソー"
" を決定するために使用するアクセス情報（ユーザ・ロール・マッピングなど）が含まれており、レルムがデジタル署名を行います。"

msgid ""
"The second use case is a client accessing remote services.  The client "
"requests a SAML assertion from {project_name} to invoke on remote services "
"on behalf of the user."
msgstr ""
"2つ目のユースケースは、クライアントがリモート・サービスにアクセスする場合です。クライアントは、{project_name}からSAMLアサーションを要求して、ユーザーに代わってリモート・サービスを呼び出します。"

msgid "SAML bindings"
msgstr "SAMLバインディング"

msgid "{project_name} supports three binding types."
msgstr "{project_name}は、3つのバインディング・タイプに対応しています。"

msgid "Redirect binding"
msgstr "REDIRECTバインディング"

msgid ""
"_Redirect_ binding uses a series of browser redirect URIs to exchange "
"information."
msgstr "_REDIRECT_ バインディングは、一連のブラウザーのリダイレクトURIを使用して情報を交換します。"

msgid ""
"A user connects to an application using a browser. The application detects "
"the user is not authenticated."
msgstr "あるユーザーがブラウザーを使ってアプリケーションに接続します。アプリケーションは、ユーザーが認証されていないことを検出します。"

msgid ""
"The application generates an XML authentication request document and encodes"
" it as a query parameter in a URI. The URI is used to redirect to the "
"{project_name} server. Depending on your settings, the application can also "
"digitally sign the XML document and include the signature as a query "
"parameter in the redirect URI to {project_name}.  This signature is used to "
"validate the client that sends the request."
msgstr ""
"アプリケーションはXML認証要求文書を生成し、URIのクエリー・パラメーターとしてエンコードします。このURIは、{project_name}サーバーへのリダイレクトに使用されます。設定によっては、アプリケーションはXMLドキュメントにデジタル署名し、その署名を{project_name}へのリダイレクトURIのクエリー・パラメーターとして含めることもできます。この署名は、リクエストを送信したクライアントを検証するために使用されます。"

msgid "The browser redirects to {project_name}."
msgstr "ブラウザーは{project_name}にリダイレクトされます。"

msgid ""
"The server extracts the XML auth request document and verifies the digital "
"signature, if required."
msgstr "サーバーはXML認証要求文書を抽出し、必要であれば電子署名を検証します。"

msgid "The user enters their authentication credentials."
msgstr "ユーザーは認証クレデンシャルを入力します。"

msgid ""
"After authentication, the server generates an XML authentication response "
"document. The document contains a SAML assertion that holds metadata about "
"the user, including name, address, email, and any role mappings the user "
"has.  The document is usually digitally signed using XML signatures, and may"
" also be encrypted."
msgstr ""
"認証後、サーバーはXML認証応答文書を生成します。この文書には、名前、住所、電子メール、およびユーザーが持つすべてのロールマッピングなど、ユーザーに関するメタデータを保持するSAMLアサーションが含まれます。この文書は、通常、XML署名を使用してデジタル署名され、暗号化されることもあります。"

msgid ""
"The XML authentication response document is encoded as a query parameter in "
"a redirect URI. The URI brings the browser back to the application.  The "
"digital signature is also included as a query parameter."
msgstr ""
"XML認証応答文書は、リダイレクトURIのクエリー・パラメーターとしてエンコードされます。このURIにより、ブラウザーはアプリケーションに戻ります。デジタル署名もクエリー・パラメーターとして含まれます。"

msgid ""
"The application receives the redirect URI and extracts the XML document."
msgstr "アプリケーションはリダイレクトURIを受け取り、XMLドキュメントを抽出します。"

msgid ""
"The application verifies the realm's signature to ensure it is receiving a "
"valid authentication response.  The information inside the SAML assertion is"
" used to make access decisions or display user data."
msgstr ""
"アプリケーションはレルムの署名を検証し、有効な認証応答を受け取っていることを確認します。SAMLアサーション内の情報は、アクセスの判断やユーザーデータの表示に使用されます。"

msgid "POST binding"
msgstr "POSTバインディング"

msgid ""
"_POST_ binding is similar to _Redirect_ binding but _POST_ binding exchanges"
" XML documents using POST requests instead of using GET requests. _POST_ "
"Binding uses JavaScript to make the browser send a POST request to the "
"{project_name} server or application when exchanging documents. HTTP "
"responds with an HTML document which contains an HTML form containing "
"embedded JavaScript.  When the page loads, the JavaScript automatically "
"invokes the form."
msgstr ""
"_POST_ バインディングは _Redirect_ バインディングと似ていますが、 _POST_ "
"バインディングはGETリクエストの代わりにPOSTリクエストを使ってXMLドキュメントを交換します。 _POST_ "
"バインディングは、ドキュメントを交換する際にJavaScriptを使用して、ブラウザーが{project_name}サーバーやアプリケーションにPOSTリクエストを送信するようにします。HTTPは、JavaScriptが埋め込まれたHTMLフォームを含むHTMLドキュメントで応答します。ページがロードされると、JavaScriptは自動的にフォームを呼び出します。"

msgid "_POST_ binding is recommended due to two restrictions:"
msgstr "2つの制約があるため、 _POST_ バインディングを推奨します。"

msgid ""
"*Security* -- With _Redirect_ binding, the SAML response is part of the URL."
" It is less secure as it is possible to capture the response in logs."
msgstr ""
"*セキュリティー* -- _Redirect_ "
"バインディングにおいて、SAMLレスポンスはURLの一部となります。これは、ログにレスポンスを記録する可能性があるため、安全性が低いです。"

msgid ""
"*Size* -- Sending the document in the HTTP payload provides more scope for "
"large amounts of data than in a limited URL."
msgstr ""
"*サイズ* -- HTTPペイロードでドキュメントを送信することで、限られたURLで送信するよりも大量のデータに対してより広い範囲を提供します。"

msgid "ECP"
msgstr "ECP"

msgid ""
"Enhanced Client or Proxy (ECP) is a SAML v.2.0 profile which allows the "
"exchange of SAML attributes outside the context of a web browser. It is "
"often used by REST or SOAP-based clients."
msgstr ""
"拡張クライアントまたはプロキシー（ECP）は、SAML "
"v.2.0プロファイルであり、Webブラウザーのコンテキスト外でSAML属性の交換を可能にするものです。これは、RESTまたはSOAPベースのクライアントでよく使用されます。"

msgid "{project_name} Server SAML URI Endpoints"
msgstr "{project_name}サーバーSAML URIエンドポイント"

msgid "{project_name} has one endpoint for all SAML requests."
msgstr "{project_name}は、すべてのSAMLリクエストに対して1つのエンドポイントを持ちます。"

msgid "`http(s)://authserver.host/auth/realms/{realm-name}/protocol/saml`"
msgstr "`http(s)://authserver.host/auth/realms/{realm-name}/protocol/saml`"

msgid "All bindings use this endpoint."
msgstr "すべてのバインディングはこのエンドポイントを使用します。"

msgid "OpenID Connect compared to SAML"
msgstr "OpenID ConnectとSAMLの比較"

msgid ""
"The following lists a number of factors to consider when choosing a "
"protocol."
msgstr "以下に、プロトコルを選択する際に考慮すべきいくつかの要素を列挙します。"

msgid "For most purposes, {project_name} recommends using OIDC."
msgstr "ほとんどの場合、{project_name}はOIDCの使用を推奨しています。"

msgid "*OIDC*"
msgstr "*OIDC*"

msgid "OIDC is specifically designed to work with the web."
msgstr "OIDCはウェブとの連携に特化して設計されています。"

msgid ""
"OIDC is suited for HTML5/JavaScript applications because it is easier to "
"implement on the client side than SAML."
msgstr "OIDCは、SAMLに比べてクライアント側での実装が容易なため、HTML5/JavaScriptアプリケーションに向いています。"

msgid ""
"OIDC tokens are in the JSON format which makes them easier for Javascript to"
" consume."
msgstr "OIDCのトークンはJSON形式であるため、JavaScriptで簡単に利用することができます。"

msgid ""
"OIDC has features to make security implementation easier. For example, see "
"the link:https://openid.net/specs/openid-connect-"
"session-1_0.html#ChangeNotification[iframe trick] that the specification "
"uses to determine a users login status."
msgstr ""
"OIDCは、セキュリティーの実装を容易にするための機能を備えています。たとえば、ユーザーのログイン状態を判断するために仕様が使用している "
"link:https://openid.net/specs/openid-connect-"
"session-1_0.html#ChangeNotification[iframe trick] を参照してください。"

msgid "*SAML*"
msgstr "*SAML*"

msgid "SAML is designed as a layer to work on top of the web."
msgstr "SAMLは、Webの上で動作するレイヤーとして設計されています。"

msgid "SAML can be more verbose than OIDC."
msgstr "SAMLは、OIDCよりも冗長である可能性があります。"

msgid ""
"Users pick SAML over OIDC because there is a perception that it is mature."
msgstr "ユーザーがOIDCよりSAMLを選ぶのは、SAMLが成熟しているという認識があるからです。"

msgid ""
"Users pick SAML over OIDC existing applications that are secured with it."
msgstr "ユーザーは、SAMLで保護されたOIDCの既存アプリケーションよりも、SAMLを選ぶのです。"

msgid "Docker registry v2 authentication"
msgstr "Dockerレジストリv2認証"

msgid ""
"Docker authentication is disabled by default. To enable docker "
"authentication, see "
"link:{installguide_profile_link}[{installguide_profile_name}]."
msgstr ""
"Docker認証はデフォルトで無効になっています。docker "
"認証を有効にするには、link:{installguide_profile_link}[{installguide_profile_name}] "
"を参照してください。"

msgid ""
"link:https://docs.docker.com/registry/spec/auth/[Docker Registry V2 "
"Authentication] is a protocol, similar to OIDC, that authenticates users "
"against Docker registries.  {project_name}'s implementation of this protocol"
" lets Docker clients use a {project_name} authentication server authenticate"
" against a registry. This protocol uses standard token and signature "
"mechanisms but it does deviate from a true OIDC implementation. It deviates "
"by using a very specific JSON format for requests and responses as well as "
"mapping repository names and permissions to the OAuth scope mechanism."
msgstr ""
"link:https://docs.docker.com/registry/spec/auth/[Docker Registry V2 "
"Authentication]は、OIDCに似た、Dockerレジストリに対してユーザを認証するプロトコルです。  "
"{project_name}の実装では、Dockerクライアントが{project_name}認証サーバを使用してレジストリに対して認証を行うことができます。このプロトコルは標準的なトークンと署名のメカニズムを使用していますが、真のOIDCの実装からは逸脱しています。それは、リクエストとレスポンスに非常に特殊なJSONフォーマットを使用することと、リポジトリ名とパーミッションをOAuthスコープ機構にマッピングすることで逸脱しています。"

msgid "Docker authentication flow"
msgstr "Dockerの認証フロー"

msgid ""
"The authentication flow is described in the "
"link:https://docs.docker.com/registry/spec/auth/token/[Docker API "
"documentation]. The following is a summary from the perspective of the "
"{project_name} authentication server:"
msgstr ""
"認証の流れは、リンク:https://docs.docker.com/registry/spec/auth/token/[Docker "
"APIドキュメント]に記載されています。以下は{project_name}認証サーバーの立場からまとめたものです。"

msgid "Perform a `docker login`."
msgstr "docker login`を実行します。"

msgid ""
"The Docker client requests a resource from the Docker registry.  If the "
"resource is protected and no authentication token is in the request, the "
"Docker registry server responds with a 401 HTTP message with some "
"information on the permissions that are required and the location of the "
"authorization server."
msgstr ""
"DockerクライアントはDockerレジストリにリソースを要求します。  "
"リソースが保護されており、認証トークンがリクエストに含まれていない場合、Dockerレジストリサーバーは、必要なパーミッションと認証サーバーの場所に関するいくつかの情報を含む401"
" HTTPメッセージで応答します。"

msgid ""
"The Docker client constructs an authentication request based on the 401 HTTP"
" message from the Docker registry. The client uses the locally cached "
"credentials (from the `docker login` command) as part of the "
"link:https://datatracker.ietf.org/doc/html/rfc2617[HTTP Basic "
"Authentication] request to the {project_name} authentication server."
msgstr ""
"Dockerクライアントは、Dockerレジストリからの401 "
"HTTPメッセージに基づいて、認証リクエストを構築します。クライアントはローカルにキャッシュされた認証情報（`docker "
"login`コマンドによる）を、{project_name} 認証サーバへの "
"link:https://datatracker.ietf.org/doc/html/rfc2617[HTTP Basic "
"Authentication] リクエストの一部として使用します。"

msgid ""
"The {project_name} authentication server attempts to authenticate the user "
"and return a JSON body containing an OAuth-style Bearer token."
msgstr "project_name}認証サーバーは、ユーザーの認証を試み、OAuthスタイルのBearerトークンを含むJSONボディを返します。"

msgid ""
"The Docker client receives a bearer token from the JSON response and uses it"
" in the authorization header to request the protected resource."
msgstr ""
"DockerクライアントはJSONレスポンスからベアラートークンを受け取り、それをauthorizationヘッダーに使用して保護されたリソースを要求します。"

msgid ""
"The Docker registry receives the new request for the protected resource with"
" the token from the {project_name} server. The registry validates the token "
"and grants access to the requested resource (if appropriate)."
msgstr ""
"Dockerレジストリは、{project_name}サーバーからトークン付きの保護されたリソースに対する新しいリクエストを受信します。レジストリはトークンを検証し、要求されたリソースへのアクセスを許可します"
" (適切な場合)。"

msgid ""
"{project_name} does not create a browser SSO session after successful "
"authentication with the Docker protocol. The browser SSO session does not "
"use the Docker protocol as it cannot refresh tokens or obtain the status of "
"a token or session from the {project_name} server; therefore a browser SSO "
"session is not necessary. For more details, see the <<_transient-session, "
"transient session>> section."
msgstr ""
"{project_name}は、Dockerプロトコルで認証に成功した後、ブラウザのSSOセッションを作成しない。ブラウザSSOセッションは、トークンのリフレッシュや、トークンやセッションの状態を{project_name}"
" "
"サーバから取得できないため、Dockerプロトコルを使用しません。したがって、ブラウザSSOセッションは必要ありません。詳しくは、&lt;&gt;の<_transient-"
"session, transient session>項を</_transient-session,>ご覧ください。"

msgid "{project_name} Docker Registry v2 Authentication Server URI Endpoints"
msgstr "{project_name} Dockerレジストリーv2認証サーバーのURIエンドポイント"

msgid "{project_name} has one endpoint for all Docker auth v2 requests."
msgstr "{project_name}は、すべてのDocker auth v2リクエストに対して1つのエンドポイントを持ちます。"

msgid ""
"`http(s)://authserver.host/auth/realms/{realm-name}/protocol/docker-v2`"
msgstr ""
"`http(s)://authserver.host/auth/realms/{realm-name}/protocol/docker-v2`"

msgid "Controlling access to the Admin Console"
msgstr "管理コンソールへのアクセス制御"

msgid ""
"Each realm created on the {project_name} has a dedicated Admin Console from "
"which that realm can be managed. The `master` realm is a special realm that "
"allows admins to manage more than one realm on the system.  You can also "
"define fine-grained access to users in different realms to manage the "
"server.  This chapter goes over all the scenarios for this."
msgstr ""
"{project_name}で作成された各レルムには、そのレルムを管理できる専用の管理コンソールがあります。 `master` "
"レルムは、管理者がシステム上で複数のレルムを管理できる特別なレルムです。また、異なるレルム内のユーザーに対するきめ細かいアクセスを定義して、サーバーを管理することもできます。この章では、このシナリオのすべてについて説明します。"

msgid "Master realm access control"
msgstr "Masterレルムのアクセス・コントロール"

msgid ""
"The `master` realm in {project_name} is a special realm and treated "
"differently than other realms. Users in the {project_name} `master` realm "
"can be granted permission to manage zero or more realms that are deployed on"
" the {project_name} server. When a realm is created, {project_name} "
"automatically creates various roles that grant fine-grain permissions to "
"access that new realm. Access to The Admin Console and Admin REST endpoints "
"can be controlled by mapping these roles to users in the `master` realm. "
"It's possible to create multiple super users,  as well as users that can "
"only manage specific realms."
msgstr ""
"{project_name}の `master` レルムは特別なレルムであり、他のレルムとは異なる扱い方をされます。{project_name}の "
"`master` "
"レルムのユーザーには、{project_name}サーバーにデプロイされている0個以上のレルムを管理するパーミッションを与えることができます。レルムが作成されると、{project_name}は新しいレルムにアクセスするためのきめ細かいパーミッションを与えるさまざまなロールを自動的に作成します。これらのロールを"
" `master` "
"レルムのユーザーにマッピングすることで、管理コンソールおよび管理RESTエンドポイントへのアクセスを制御できます。特定のレルムだけを管理できるユーザーだけでなく、複数のスーパーユーザーを作成することも可能です。"

msgid "Global roles"
msgstr "グローバルロール"

msgid "There are two realm-level roles in the `master` realm. These are:"
msgstr "`master` レルムには次の2つのレルムレベルのロールがあります。 "

msgid "admin"
msgstr "admin"

msgid "create-realm"
msgstr "create-realm"

msgid ""
"Users with the `admin` role are super users and have full access to manage "
"any realm on the server.  Users with the `create-realm` role are allowed to "
"create new realms.  They will be granted full access to any new realm they "
"create."
msgstr ""
"`admin` ロールを持つユーザーはスーパーユーザーであり、サーバー上のあらゆるレルムを管理する完全なアクセス権を持っています。 `create-"
"realm` "
"ロールを持つユーザーは、新しいレルムを作成することができます。このユーザーは、自身が作成した全ての新しいレルムに対して、完全にアクセスできるようになります。"

msgid "Realm specific roles"
msgstr "レルム特有のロール"

msgid ""
"Admin users within the `master` realm can be granted management privileges "
"to one or more other realms in the system. Each realm in {project_name} is "
"represented by a client in the `master` realm. The name of the client is "
"`<realm name>-realm`.  These clients each have client-level roles defined "
"which define varying level of access to manage an individual realm."
msgstr ""
"`master` "
"レルム内の管理ユーザーは、システム内の1つ以上の他のレルムに対して管理権限を与えることができます。{project_name}の各レルムは、 "
"`master` レルムのクライアントによって表されます。クライアントの名前は `<realm name>-realm` "
"です。これらのクライアントには、個々のレルムを管理するためのさまざまなアクセスのレベルを定義したクライアントレベルのロールが定義されています。"

msgid "The roles available are:"
msgstr "利用可能なロールは次のとおりです。"

msgid "view-realm"
msgstr "view-realm"

msgid "view-users"
msgstr "view-users"

msgid "view-clients"
msgstr "view-clients"

msgid "view-events"
msgstr "view-events"

msgid "manage-realm"
msgstr "manage-realm"

msgid "manage-users"
msgstr "manage-users"

msgid "create-client"
msgstr "create-client"

msgid "manage-clients"
msgstr "manage-clients"

msgid "manage-events"
msgstr "manage-events"

msgid "view-identity-providers"
msgstr "view-identity-providers"

msgid "manage-identity-providers"
msgstr "manage-identity-providers"

msgid "impersonation"
msgstr "impersonation"

msgid ""
"Assign the roles you want to your users and they will only be able to use "
"that specific part of the administration console."
msgstr "ユーザーに必要なロールを割り当てると、管理コンソールの特定の部分のみを使用できます。"

msgid ""
"Admins with the `manage-users` role will only be able to assign admin roles "
"to users that they themselves have.  So, if an admin has the `manage-users` "
"role but doesn't have the `manage-realm` role, they will not be able to "
"assign this role."
msgstr ""
"`manage-users` ロールを持つ管理者は、自分自身が管理するユーザーにのみ管理ロールを割り当てることができます。したがって、 `manage-"
"users` ロールを持っていても、 `manage-realm` ロールを持っていない管理者は、このロールを割り当てることはできません。"

msgid "Dedicated realm admin consoles"
msgstr "レルム専用の管理コンソール"

msgid ""
"Each realm has a dedicated Admin Console that can be accessed by going to "
"the url `/auth/admin/{realm-name}/console`. Users within that realm can be "
"granted realm management permissions by assigning specific user role "
"mappings."
msgstr ""
"各レルムには専用の管理コンソールがあり、 `/auth/admin/{realm-name}/console` "
"のURLでアクセスできます。特定のユーザー・ロール・マッピングを割り当てることによって、そのレルム内のユーザーにレルム管理パーミッションを与えることができます。"

msgid ""
"Each realm has a built-in client called `realm-management`.  You can view "
"this client by going to the `Clients` left menu item of your realm.  This "
"client defines client-level roles that specify permissions that can be "
"granted to manage the realm."
msgstr ""
"各レルムには、 `realm-management` という名前のビルトイン・クライアントがあります。レルムの左メニュー項目の `Clients` "
"をクリックすることでこのクライアントを見ることができます。このクライアントは、レルムを管理するパーミッションを指定するクライアントレベルのロールを定義します。"

msgid "Fine grain admin permissions"
msgstr "きめ細かい管理パーミッション"

msgid ""
"Sometimes roles like `manage-realm` or `manage-users` are too coarse grain "
"and you want to create restricted admin accounts that have more fine grain "
"permissions.  {project_name} allows you to define and assign restricted "
"access policies for managing a realm.  Things like:"
msgstr ""
"時には `manage-realm` や `manage-users` "
"のようなロールより、きめ細かいパーミッションを持つ制限付き管理者アカウントを作成したいことがあります。{project_name}では、レルムを管理するための制限付きアクセスポリシーを定義して割り当てることができます。アクセスポリシーには次のようなものがあります。"

msgid "Managing one specific client"
msgstr "特定のクライアントの管理"

msgid "Managing users that belong to a specific group"
msgstr "特定のグループに属するユーザーの管理"

msgid "Managing membership of a group"
msgstr "グループのメンバーシップの管理"

msgid "Limited user management."
msgstr "制限付きのユーザー管理"

msgid "Fine grain impersonation control"
msgstr "きめ細かい代理ログイン制御"

msgid "Being able to assign a specific restricted set of roles to users."
msgstr "特定の制約付きロールセットをユーザーに割り当てる"

msgid ""
"Being able to assign a specific restricted set of roles to a composite role."
msgstr "特定の制約付きロールセットを複合ロールに割り当てる"

msgid ""
"Being able to assign a specific restricted set of roles to a client's scope."
msgstr "特定の制約付きロールセットをクライアントのスコープに割り当てる"

msgid ""
"New general policies for viewing and managing users, groups, roles, and "
"clients."
msgstr "ユーザー、グループ、ロール、およびクライアントの表示と管理のための新しい一般ポリシー"

msgid ""
"There are some important things to note about fine grain admin permissions:"
msgstr "きめ細かい管理パーミッションについて、いくつか注意すべき点があります。"

msgid ""
"Fine grain admin permissions were implemented on top of "
"link:{authorizationguide_link}[Authorization Services].  It is highly "
"recommended that you read up on those features before diving into fine grain"
" permissions."
msgstr ""
"きめ細かい管理パーミッションは、link:{authorizationguide_link}[認可サービス]上に実装されています。きめ細かいパーミッションを設定する前に、それらの機能を読んでおくことを強くお勧めします。"

msgid ""
"Fine grain permissions are only available within "
"<<_per_realm_admin_permissions, dedicated admin consoles>> and admins "
"defined within those realms.  You cannot define cross-realm fine grain "
"permissions."
msgstr ""
"きめ細かいパーミッションは、<<_per_realm_admin_permissions, "
"専用の管理コンソール>>およびレルム管理者のみ使用できます。レルム間のきめ細かいパーミッションは、定義することはできません。"

msgid ""
"Fine grain permissions are used to grant additional permissions.  You cannot"
" override the default behavior of the built in admin roles."
msgstr ""
"きめ細かいパーミッションは、追加のパーミッションを付与するために使用されます。組み込みの管理者ロールのデフォルトの動作を上書きすることはできません。"

msgid ""
"Let's look first at allowing an admin to manage one client and one client "
"only.  In our example, we have a realm called `test` and a client called "
"`sales-application`.  In the realm `test` we will give a user in that realm "
"permission to only manage that application."
msgstr ""
"最初に、管理者が1つのクライアントだけを管理できるようにしましょう。この例では、 `test` というレルムと `sales-application` "
"というクライアントがあります。レルム `test` では、レルムのユーザーに、そのアプリケーションだけを管理するパーミッションを与えます。"

msgid ""
"You cannot do cross realm fine grain permissions.  Admins in the `master` "
"realm are limited to the predefined admin roles defined in previous "
"chapters."
msgstr ""
"きめ細かいパーミッションはレルム間で使用することはできません。 `master` "
"レルムの管理者は、前の章で定義されている組み込みの管理者ロールに限定されています。"

msgid "Permission setup"
msgstr "パーミッションの設定"

msgid ""
"The first thing we must do is login to the Admin Console so we can set up "
"permissions for that client.  We navigate to the management section of the "
"client, we want to define fine-grain permissions for."
msgstr ""
"最初に、管理コンソールにログインして、クライアントのパーミッションを設定する必要があります。きめ細かいパーミッションを定義するクライアントの管理画面に移動します。"

msgid "Client management"
msgstr "クライアント管理"

msgid "image:{project_images}/fine-grain-client.png[]"
msgstr "image:{project_images}/fine-grain-client.png[]"

msgid ""
"You should see a tab menu item called `Permissions`.  Click on that tab."
msgstr "`Permissions` というタブメニュー項目が表示されるので、そのタブをクリックします。"

msgid "Client permissions tab"
msgstr "クライアント・パーミッション・タブ"

msgid "image:{project_images}/fine-grain-client-permissions-tab-off.png[]"
msgstr "image:{project_images}/fine-grain-client-permissions-tab-off.png[]"

msgid ""
"By default, each client is not enabled to do fine grain permissions.  So "
"turn the `Permissions Enabled` switch to on to initialize permissions."
msgstr ""
"デフォルトでは、各クライアントはきめ細かいパーミッションが有効になっていません。 `Permissions Enabled` "
"スイッチをONにしてパーミッションを初期化してください。"

msgid ""
"If you turn the `Permissions Enabled` switch to off, it will delete any and "
"all permissions you have defined for this client."
msgstr ""
"`Permissions Enabled` スイッチをOFFにすると、このクライアントに対して定義したすべてのパーミッションが削除されます。"

msgid "image:{project_images}/fine-grain-client-permissions-tab-on.png[]"
msgstr "image:{project_images}/fine-grain-client-permissions-tab-on.png[]"

msgid ""
"When you switch `Permissions Enabled` to on, it initializes various "
"permission objects behind the scenes using "
"link:{authorizationguide_link}[Authorization Services].  For this example, "
"we're interested in the `manage` permission for the client.  Clicking on "
"that will redirect you to the permission that handles the `manage` "
"permission for the client.  All authorization objects are contained in the "
"`realm-management` client's `Authorization` tab."
msgstr ""
"`Permissions Enabled` "
"をONにすると、link:{authorizationguide_link}[認可サービス]を使用してさまざまなパーミッション・オブジェクトを初期化します。ここでは、クライアントの"
" `manage` パーミッションを例にします。 `manage` "
"パーミッションのリンクをクリックすると、クライアントのパーミッション設定画面にリダイレクトされます。すべての認可オブジェクトは、 `realm-"
"management` クライアントの `Authorization` タブに含まれています。"

msgid "Client manage permission"
msgstr "クライアント管理パーミッション"

msgid "image:{project_images}/fine-grain-client-manage-permissions.png[]"
msgstr "image:{project_images}/fine-grain-client-manage-permissions.png[]"

msgid ""
"When first initialized the `manage` permission does not have any policies "
"associated with it. You will need to create one by going to the policy tab."
"  To get there fast, click on the `Authorization` link shown in the above "
"image. Then click on the policies tab."
msgstr ""
"最初に初期化されたとき、 `manage` "
"パーミッションは関連付けられたポリシーを持ちません。ポリシータブに移動して作成する必要があります。ポリシータブにアクセスするには、上記の画像に表示されている"
" `Authorization` リンクをクリックしてください。次に、Policiesタブをクリックします。"

msgid ""
"There's a pull down menu on this page called `Create policy`.  There's a "
"multitude of policies you can define.  You can define a policy that is "
"associated with a role or a group or even define rules in JavaScript.  For "
"this simple example, we're going to create a `User Policy`."
msgstr ""
"このページには、 `Create policy` "
"というプルダウン・メニューがあります。このメニューには、定義することができる多くのポリシーがあります。ロールまたはグループに関連付けられたポリシーを定義したり、JavaScriptでルールを定義することもできます。この例では、"
" `User Policy` を作成します。"

msgid "User policy"
msgstr "ユーザーポリシー"

msgid "image:{project_images}/fine-grain-client-user-policy.png[]"
msgstr "image:{project_images}/fine-grain-client-user-policy.png[]"

msgid ""
"This policy will match a hard-coded user in the user database.  In this "
"case, it is the `sales-admin` user.  We must then go back to the `sales-"
"application` client's `manage` permission page and assign the policy to the "
"permission object."
msgstr ""
"このポリシーは、ユーザー・データベース内のハードコードされたユーザーと一致させます。この例では、 `sales-admin` ユーザーです。次に、 "
"`sales-application` クライアントの `manage` "
"パーミッション・ページに戻り、ポリシーをパーミッション・オブジェクトに割り当てる必要があります。"

msgid "Assign user policy"
msgstr "ユーザーポリシーの割り当て"

msgid "image:{project_images}/fine-grain-client-assign-user-policy.png[]"
msgstr "image:{project_images}/fine-grain-client-assign-user-policy.png[]"

msgid ""
"The `sales-admin` user can now has permission to manage the `sales-"
"application` client."
msgstr ""
"`sales-admin` ユーザーは、 `sales-application` クライアントを管理するパーミッションを持つことができます。"

msgid ""
"There's one more thing we have to do.  Go to the `Role Mappings` tab and "
"assign the `query-clients` role to the `sales-admin`."
msgstr ""
"また、`Role Mappings` タブから、 `sales-admin` に `query-clients` ロールを割り当てる必要があります。"

msgid "Assign query-clients"
msgstr "query-clientsの割り当て"

msgid "image:{project_images}/fine-grain-assign-query-clients.png[]"
msgstr "image:{project_images}/fine-grain-assign-query-clients.png[]"

msgid ""
"Why do you have to do this?  This role tells the Admin Console what menu "
"items to render when the `sales-admin` visits the Admin Console.  The "
"`query-clients` role tells the Admin Console that it should render client "
"menus for the `sales-admin` user."
msgstr ""
"`query-clients` ロールを割り当てる理由として、このロールは、 `sales-admin` "
"が管理コンソールを訪れたときに表示するメニュー項目を管理コンソールに伝えるためです。 `query-clients` ロールは、管理コンソールに "
"`sales-admin` ユーザー用の表示すべきクライアント・メニューを伝えます。"

msgid ""
"IMPORTANT If you do not set the `query-clients` role, restricted admins like"
" `sales-admin` will not see any menu options when they log into the Admin "
"Console"
msgstr ""
"重要な点として、 `query-clients` ロールを設定しないと、 `sales-admin` "
"のような制限付きの管理者は、管理コンソールにログインするときにメニューオプションが表示されません。"

msgid "Testing it out"
msgstr "テストする"

msgid ""
"Next, we log out of the master realm and re-login to the "
"<<_per_realm_admin_permissions, dedicated admin console>> for the `test` "
"realm using the `sales-admin` as a username.  This is located under "
"`/auth/admin/test/console`."
msgstr ""
"次に、masterレルムからログアウトし、 `sales-admin` ユーザーで `test` "
"レルムの<<_per_realm_admin_permissions, 専用の管理コンソール>>に再ログインします。専用の管理コンソールは "
"`/auth/admin/test/console` にあります。"

msgid "Sales admin login"
msgstr "Sales Adminのログイン"

msgid "image:{project_images}/fine-grain-sales-admin-login.png[]"
msgstr "image:{project_images}/fine-grain-sales-admin-login.png[]"

msgid "This admin is now able to manage this one client."
msgstr "この管理者はこの1つのクライアントを管理できるようになりました。"

msgid "Restrict user role mapping"
msgstr "ユーザー・ロール・マッピングの制限"

msgid ""
"Another thing you might want to do is to restrict the set of roles an admin "
"is allowed to assign to a user.  Continuing our last example, let's expand "
"the permission set of the 'sales-admin' user so that he can also control "
"which users are allowed to access this application.  Through fine grain "
"permissions, we can enable it so that the `sales-admin` can only assign "
"roles that grant specific access to the `sales-application`.  We can also "
"restrict it so that the admin can only map roles and not perform any other "
"types of user administration."
msgstr ""
"もう一つは、管理者がユーザーへの割り当てを許可したロールを制限することです。最後の例に続けて、 `sales-admin` "
"ユーザーのパーミッション・セットを拡張して、このアプリケーションにアクセスできるユーザーを制御できるようにしましょう。きめ細かいパーミッションを使用して、"
" `sales-admin` が `sales-application` "
"に特定のアクセスを許可するロールのみを割り当てることができます。また、管理者だけがロールを割り当てることができ、その他のユーザー管理は実行できないように制限することもできます。"

msgid "The `sales-application` has defined three different client roles."
msgstr "`sales-application` には3つの異なるクライアント・ロールを定義しています。"

msgid "Sales application roles"
msgstr "Sales Applicationロール"

msgid "image:{project_images}/fine-grain-sales-application-roles.png[]"
msgstr "image:{project_images}/fine-grain-sales-application-roles.png[]"

msgid ""
"We want the `sales-admin` user to be able to map these roles to any user in "
"the system.  The first step to do this is to allow the role to be mapped by "
"the admin.  If we click on the `viewLeads` role, you'll see that there is a "
"`Permissions` tab for this role."
msgstr ""
"`sales-admin` "
"ユーザーが、これらのロールをシステム内のどのユーザーにも割り当てられるようにしたいです。これを行うための最初のステップは、管理者によってロールを割り当て可能とすることです。"
" `viewLeads` ロールをクリックすると、このロールの `Permissions` タブがあります。"

msgid "View leads role permission tab"
msgstr "View LeadsロールのPermissionタブ"

msgid "image:{project_images}/fine-grain-view-leads-role-tab.png[]"
msgstr "image:{project_images}/fine-grain-view-leads-role-tab.png[]"

msgid ""
"If we click on that tab and turn the `Permissions Enabled` on, you'll see "
"that there are a number of actions we can apply policies to."
msgstr "そのタブをクリックし、 `Permissions Enabled` をONにすると、ポリシーを適用できるアクションが表示されます。"

msgid "View leads permissions"
msgstr "View Leadsパーミッション"

msgid "image:{project_images}/fine-grain-view-leads-permissions.png[]"
msgstr "image:{project_images}/fine-grain-view-leads-permissions.png[]"

msgid ""
"The one we are interested in is `map-role`.  Click on this permission and "
"add the same User Policy that was created in the earlier example."
msgstr "ここで知りたいのは `map-role` です。このパーミッションをクリックし、前の例で作成したユーザーポリシーを追加します。"

msgid "Map-roles permission"
msgstr "Map-rolesのパーミッション"

msgid "image:{project_images}/fine-grain-map-roles-permission.png[]"
msgstr "image:{project_images}/fine-grain-map-roles-permission.png[]"

msgid ""
"What we've done is say that the `sales-admin` can map the `viewLeads` role."
"  What we have not done is specify which users the admin is allowed to map "
"this role too.  To do that we must go to the `Users` section of the admin "
"console for this realm.  Clicking on the `Users` left menu item brings us to"
" the users interface of the realm.  You should see a `Permissions` tab.  "
"Click on that and enable it."
msgstr ""
"これまでに行ったことは、 `sales-admin` が `viewLeads` "
"ロールを割り当て可能とすることです。これから行うことは、管理者がこのロールをどのように割り当てることができるかを指定することです。これを行うには、このレルムの管理コンソールの"
" `Users` セクションに移動する必要があります。左のメニュー項目の `Users` "
"をクリックすると、レルムのユーザー・インターフェイスが表示されます。 `Permissions` タブから、 `Permissions Enabled`"
" をクリックして有効にします。"

msgid "Users permissions"
msgstr "ユーザーのパーミッション"

msgid "image:{project_images}/fine-grain-users-permissions.png[]"
msgstr "image:{project_images}/fine-grain-users-permissions.png[]"

msgid ""
"The permission we are interested in is `map-roles`.  This is a restrictive "
"policy in that it only allows admins the ability to map roles to a user.  If"
" we click on the `map-roles` permission and again add the User Policy we "
"created for this, our `sales-admin` will be able to map roles to any user."
msgstr ""
"ここで知りたいパーミッションは `map-roles` "
"です。これは、管理者がロールをユーザーに割り当てる機能のみを許可するという点で、制限的なポリシーです。 `map-roles` "
"パーミッションをクリックし、これに対して作成したユーザーポリシーを再度追加すると、 `sales-admin` "
"はロールを任意のユーザーに割り当てることができます。"

msgid ""
"The last thing we have to do is add the `view-users` role to the `sales-"
"admin`.  This will allow the admin to view users in the realm he wants to "
"add the `sales-application` roles to."
msgstr ""
"最後に、 `view-users` ロールを `sales-admin` に追加します。これにより、管理者は `sales-application` "
"ロールを追加したいレルムのユーザーを表示することができます。"

msgid "Add view-users"
msgstr "view-usersの追加"

msgid "image:{project_images}/fine-grain-add-view-users.png[]"
msgstr "image:{project_images}/fine-grain-add-view-users.png[]"

msgid ""
"You will see that now the `sales-admin` can view users in the system.  If "
"you select one of the users you'll see that each user detail page is read "
"only, except for the `Role Mappings` tab. Going to this tab you'll find that"
" there are no `Available` roles for the admin to map to the user except when"
" we browse the `sales-application` roles."
msgstr ""
"`sales-admin` がシステム内のユーザーを表示することができるようになりました。いずれかのユーザーを選択すると、 `Role "
"Mappings` タブを除き、各ユーザーの詳細ページは読み取り専用になります。このタブでは、管理者が `sales-application` "
"ロールを表示する場合を除いて、ユーザーに割り当てるための `Available` ロールがないことがわかります。"

msgid "Add viewleads"
msgstr "viewLeadsの追加"

msgid "image:{project_images}/fine-grain-add-view-leads.png[]"
msgstr "image:{project_images}/fine-grain-add-view-leads.png[]"

msgid ""
"We've only specified that the `sales-admin` can map the `viewLeads` role."
msgstr "`sales-admin` が `viewLeads` ロールの割り当てができることを指定しました。"

msgid "Per client map-roles shortcut"
msgstr "クライアントごとのmap-rolesへのショートカット"

msgid ""
"It would be tedious if we had to do this for every client role that the "
"`sales-application` published. to make things easier, there's a way to "
"specify that an admin can map any role defined by a client.  If we log back "
"into the admin console to our master realm admin and go back   to the "
"`sales-application` permissions page, you'll see the `map-roles` permission."
msgstr ""
"`sales-application` "
"が公開したすべてのクライアント・ロールに対して、これを実行しなければならないのは面倒です。作業を簡単にするために、管理者がクライアントによって定義された任意のロールを割り当てられるように指定する方法があります。管理コンソールにログインしてmasterレルムの管理者でログインし、"
" `sales-application` パーミッションページに戻ると、 `map-roles` パーミッションが表示されます。"

msgid "Client map-roles permission"
msgstr "クライアントのmap-rolesパーミッション"

msgid ""
"If you grant access to this particular permission to an admin, that admin "
"will be able map any role defined by the client."
msgstr ""
"この特定のパーミッションへのアクセスを管理者に許可すると、その管理者はクライアントによって定義されたすべてのロールを割り当てることができます。"

msgid "Full list of permissions"
msgstr "パーミッションの一覧"

msgid ""
"You can do a lot more with fine grain permissions beyond managing a specific"
" client or the specific roles of a client. This chapter defines the whole "
"list of permission types that can be described for a realm."
msgstr ""
"特定のクライアントやクライアントの特定のロールを管理する以外にも、きめ細かいパーミッションを使用すると、さらに多くのことを行うことができます。この章では、レルムで記述できるパーミッション種別の一覧を示します。"

msgid "Role"
msgstr "ロール"

msgid ""
"When going to the `Permissions` tab for a specific role, you will see these "
"permission types listed."
msgstr "特定のロールの `Permissions` タブでは、これらのパーミッション種別が一覧で表示されます。"

msgid "map-role"
msgstr "map-role"

msgid ""
"Policies that decide if an admin can map this role to a user.  These "
"policies only specify that the role can be mapped to a user, not that the "
"admin is allowed to perform user role mapping tasks.  The admin will also "
"have to have manage or role mapping permissions.  See <<_users-permissions, "
"Users Permissions>> for more information."
msgstr ""
"管理者がロールをユーザーに割り当て可能であるかを決定するポリシーです。これらのポリシーでは、管理者がユーザーにロールを割り当てることができるのではなく、ロールをユーザーに割り当てることができます。また、管理者は管理またはロールマッピングのパーミッションを持っている必要があります。詳細については、<<_users-"
"permissions, ユーザーのパーミッション>>を参照してください。"

msgid "map-role-composite"
msgstr "map-role-composite"

msgid ""
"Policies that decide if an admin can map this role as a composite to another"
" role. An admin can define roles for a client if he has to manage "
"permissions for that client but he will not be able to add composites to "
"those roles unless he has the `map-role-composite` privileges for the role "
"he wants to add as a composite."
msgstr ""
"管理者がこのロールを複合ロールとして別のロールに割り当て可能であるかを決定するポリシーです。管理者はクライアントのロールを定義することができますが、そのクライアントのパーミッションを管理する必要がある場合、複合ロールとして追加したいロールに対して"
" `map-role-composite` 権限を持っていなければ、それらのロールに複合ロールを追加することはできません。"

msgid "map-role-client-scope"
msgstr "map-role-client-scope"

msgid ""
"Policies that decide if an admin can apply this role to the scope of a "
"client. Even if the admin can manage the client, he will not have permission"
" to create tokens for that client that contain this role unless this "
"privilege is granted."
msgstr ""
"管理者がこのロールをクライアントのスコープに適用可能であるかを決定するポリシーです。管理者がクライアントを管理できるとしても、この権限が与えられていない限り、このロールを含むクライアントのトークンを作成するパーミッションはありません。"

msgid "Client"
msgstr "クライアント"

msgid ""
"When going to the `Permissions` tab for a specific client, you will see "
"these permission types listed."
msgstr "特定のクライアントの `Permissions` タブで、これらのパーミッション種別が表示されます。"

msgid "view"
msgstr "view"

msgid "Policies that decide if an admin can view the client's configuration."
msgstr "管理者がクライアントの設定を表示可能であるかを決定するポリシーです。"

msgid "manage"
msgstr "manage"

msgid ""
"Policies that decide if an admin can view and manage the client's "
"configuration. There are some issues with this in that privileges could be "
"leaked unintentionally. For example, the admin could define a protocol "
"mapper that hardcoded a role even if the admin does not have privileges to "
"map the role to the client's scope. This is currently the limitation of "
"protocol mappers as they don't have a way to assign individual permissions "
"to them like roles do."
msgstr ""
"管理者がクライアントの設定を表示および管理することが可能であるかを決定するポリシーです。特権が意図せず漏れる可能性があるという点で、いくつかの問題があります。たとえば、管理者は、ロールをクライアントのスコープに割り当てる権限を持っていなくても、ロールをハードコーディングしたプロトコル・マッパーを定義することができます。プロトコル・マッパーには、ロールのように個々のパーミッションを割り当てる方法がありません。これは現在のプロトコル・マッパーの制約です。"

msgid "configure"
msgstr "configure"

msgid ""
"Reduced set of privileges to manage the client.  It is like the `manage` "
"scope except the admin is not allowed to define protocol mappers, change the"
" client template, or the client's scope."
msgstr ""
"クライアントを管理する特権セットを除外したポリシーです。プロトコル・マッパーの定義、クライアント・テンプレートの変更、クライアントのスコープの変更が許可されてないこと以外は"
" `manage` スコープと似ています。"

msgid "map-roles"
msgstr "map-roles"

msgid ""
"Policies that decide if an admin can map any role defined by the client to a"
" user. This is a shortcut, easy-of-use feature to avoid having to define "
"policies for each and every role defined by the client."
msgstr ""
"管理者がクライアントによって定義されたロールをユーザーに割り当て可能であるかを決定するポリシーです。ショートカットで使いやすい機能となっていて、クライアントが定義したすべてのロールごとにポリシーを設定する必要がありません。"

msgid "map-roles-composite"
msgstr "map-roles-composite"

msgid ""
"Policies that decide if an admin can map any role defined by the client as a"
" composite to another role. This is a shortcut, easy-of-use feature to avoid"
" having to define policies for each and every role defined by the client."
msgstr ""
"管理者がクライアントによって定義されたロールを複合ロールとして別のロールに割り当て可能であるかを決定するポリシーです。ショートカットで使いやすい機能となっていて、クライアントが定義したすべてのロールごとにポリシーを定義する必要がありません。"

msgid "map-roles-client-scope"
msgstr "map-roles-client-scope"

msgid ""
"Policies that decide if an admin can map any role defined by the client to "
"the scope of another client. This is a shortcut, easy-of-use feature to "
"avoid having to define policies for each and every role defined by the "
"client."
msgstr ""
"管理者がクライアントによって定義されたロールを別のクライアントのスコープに割り当て可能であるかを決定するポリシーです。ショートカットで使いやすい機能となっていて、クライアントが定義したすべてのロールごとにポリシーを定義する必要がありません。"

msgid ""
"When going to the `Permissions` tab for all users, you will see these "
"permission types listed."
msgstr "ユーザーの `Permissions` タブでは、これらのパーミッション種別が表示されます。"

msgid "Policies that decide if an admin can view all users in the realm."
msgstr "管理者がレルム内のすべてのユーザーを表示可能であるかを決定するポリシーです。"

msgid ""
"Policies that decide if an admin can manage all users in the realm.  This "
"permission grants the admin the privilege to perform user role mappings, but"
" it does not specify which roles the admin is allowed to map.  You'll need "
"to define the privilege for each role you want the admin to be able to map."
msgstr ""
"管理者がレルム内のすべてのユーザーを管理することが可能であるかを決定するポリシーです。このパーミッションは、管理者にユーザー・ロール・マッピングの権限を付与しますが、割り当てるロールは指定しません。管理者が割り当て可能とする各ロールの権限を定義する必要があります。"

msgid ""
"This is a subset of the privileges granted by the `manage` scope.  In this "
"case the admin is only allowed to map roles.  The admin is not allowed to "
"perform any other user management operation.  Also, like `manage`, the roles"
" that the admin is allowed to apply must be specified per role or per set of"
" roles if dealing with client roles."
msgstr ""
"これは、 `manage` "
"スコープによって与えられた権限のサブセットです。管理者はロールのみを割り当てることができますが、他のユーザーの管理操作を実行することはできません。また、"
" `manage` と同様に、管理者が適用できるロールは、クライアント・ロールを扱う場合、ロールごとまたはロールセットごとに指定する必要があります。"

msgid "manage-group-membership"
msgstr "manage-group-membership"

msgid ""
"Similar to `map-roles` except that it pertains to group membership: which "
"groups a user can be added or removed from.  These policies just grant the "
"admin permission to manage group membership, not which groups the admin is "
"allowed to manage membership for.  You'll have to specify policies for each "
"group's `manage-members` permission."
msgstr ""
"`map-roles` "
"に似ていますが、これはユーザーを追加または削除できるグループのグループ・メンバーシップに付属します。これらのポリシーは、管理者がメンバーシップの管理を許可されているグループではなく、グループ・メンバーシップを管理するための管理者パーミッションを許可します。グループの"
" `manage-members` パーミッションごとにポリシーを指定する必要があります。"

msgid "impersonate"
msgstr "impersonate"

msgid ""
"Policies that decide if the admin is allowed to impersonate other users.  "
"These policies are applied to the admin's attributes and role mappings."
msgstr "管理者が他のユーザーの代理ログインを許可するかを決定するポリシーです。これらのポリシーは、管理者の属性とロール・マッピングに適用されます。"

msgid "user-impersonated"
msgstr "user-impersonated"

msgid ""
"Policies that decide which users can be impersonated.  These policies will "
"be applied to the user being impersonated.  For example, you might want to "
"define a policy that will forbid anybody from impersonating a user that has "
"admin privileges."
msgstr ""
"どのユーザーが代理ログインの対象となるかを決定するポリシーです。これらのポリシーは、代理ログインされるユーザーに適用されます。たとえば、管理者特権を持つユーザーとして代理ログインすることを禁止するポリシーを定義することができます。"

msgid ""
"When going to the `Permissions` tab for a specific group, you will see these"
" permission types listed."
msgstr "特定のグループの `Permissions` タブでは、これらのパーミッション種別が表示されます。"

msgid ""
"Policies that decide if the admin can view information about the group."
msgstr "管理者がグループに関する情報を表示可能であるかを決定するポリシーです。"

msgid ""
"Policies that decide if the admin can manage the configuration of the group."
msgstr "管理者がグループの設定を管理することが可能であるかを決定するポリシーです。"

msgid "view-members"
msgstr "view-members"

msgid ""
"Policies that decide if the admin can view the user details of members of "
"the group."
msgstr "管理者がグループメンバーのユーザー詳細を表示可能であるかを決定するポリシーです。"

msgid "manage-members"
msgstr "manage-members"

msgid ""
"Policies that decide if the admin can manage the users that belong to this "
"group."
msgstr "管理者がこのグループに属するユーザーを管理することが可能であるかを決定するポリシーです。"

msgid "manage-membership"
msgstr "manage-membership"

msgid ""
"Policies that decide if an admin can change the membership of the group.  "
"Add or remove members from the group."
msgstr "管理者がグループのメンバーシップを変更することが可能であるかを決定するポリシーです。グループにメンバーを追加または削除することができます。"

msgid "Managing OpenID Connect and SAML Clients"
msgstr "OpenID ConnectおよびSAMLのクライアントの管理"

msgid ""
"Clients are entities that can request authentication of a user.  Clients "
"come in two forms. The first type of client is an application that wants to "
"participate in single-sign-on.  These clients just want {project_name} to "
"provide security for them.  The other type of client is one that is "
"requesting an access token so that it can invoke other services on behalf of"
" the authenticated user. This section discusses various aspects around "
"configuring clients and various ways to do it."
msgstr ""
"クライアントは、ユーザーの認証を要求できるエンティティーです。クライアントには2つの形式があります。最初のタイプのクライアントは、シングル・サインオンに参加させるアプリケーションです。これらのクライアントは{project_name}にセキュリティーの提供を要求するだけです。もう1つのタイプのクライアントは、認証されたユーザーに代わって他のサービスを呼び出すために、アクセストークンを要求します。このセクションでは、クライアントの設定に関するさまざまな側面とそれを実行するさまざまな方法について説明します。"

msgid "OIDC clients"
msgstr "OIDCクライアント"

msgid ""
"xref:con-oidc_{context}[OpenID Connect] is the recommended protocol to "
"secure applications.  It was designed from the ground up to be web friendly "
"and it works best with HTML5/JavaScript applications."
msgstr ""
"xref:con-oidc_{context}[OpenID Connect] "
"は、アプリケーションをセキュリティー保護するのに推奨されるプロトコルです。ウェブ・フレンドリーで、HTML5/JavaScriptアプリケーションで最もうまく動作するように、一から設計されました。"

msgid "Creating an OpenID Connect Client"
msgstr "OpenID Connectクライアントの作成"

msgid ""
"To protect an application that uses the OpenID connect protocol, you create "
"a client."
msgstr "OpenID Connectプロトコルを使用するアプリケーションを保護するために、クライアントを作成します。"

msgid "Click *Create* to go to the *Add Client* page."
msgstr "*Create* をクリックすると、 *Add Client* のページに移動します。"

msgid "Add client"
msgstr "Add client"

msgid "image:{project_images}/add-client-oidc.png[Add Client]"
msgstr "image:{project_images}/add-client-oidc.png[Add Client]"

msgid "Enter any name for *Client ID.*"
msgstr "*Client ID* に任意の名前を入力します。"

msgid "Select *openid-connect* in the *Client Protocol* drop down box."
msgstr "*Client Protocol* のドロップダウンボックスで、 *openid-connect* を選択します。"

msgid "Enter the base URL of your application in the *Root URL* field."
msgstr "*Root URL* フィールドにアプリケーションのベースURLを入力します。"

msgid "This action creates the client and bring you to the *Settings* tab."
msgstr "この操作により、クライアントが作成され、 *Settings* タブが表示されます。"

msgid "Client settings"
msgstr "クライアント設定"

msgid "image:{project_images}/client-settings-oidc.png[Client Settings]"
msgstr "image:{project_images}/client-settings-oidc.png[Client Settings]"

msgid ""
"For more information about the OIDC protocol, see xref:con-"
"oidc_{context}[OpenID Connect]."
msgstr "OIDCプロトコルの詳細については、 xref:con-oidc_{context}[OpenID Connect] を参照してください。"

msgid "Basic settings"
msgstr "基本設定"

msgid ""
"When you create an OIDC client, you see the following fields on the "
"*Settings* tab."
msgstr "OIDCクライアントを作成すると、 *Settings* タブに以下のフィールドが表示されます。"

msgid "*Client ID*"
msgstr "*Client ID*"

msgid ""
"The alpha-numeric ID string that is used in OIDC requests and in the "
"{project_name} database to identify the client."
msgstr "OIDCリクエストおよび{project_name}データベースでクライアントを識別するために使用される英数字のID文字列です。"

msgid "*Name*"
msgstr "*Name*"

msgid ""
"The name for the client in {project_name} UI screen. To localize the name, "
"set up a replacement string value. For example, a string value such as "
"$\\{myapp}.  See the link:{developerguide_link}[{developerguide_name}] for "
"more information."
msgstr ""
"{project_name}におけるクライアントの名前。UI画面での名称。名前をローカライズするには、置換文字列値を設定します。たとえば、${myapp}のような文字列値です。詳しくは、"
" link:{developerguide_link}[{developerguide_name}] を参照してください。"

msgid "*Description*"
msgstr "*説明*"

msgid "The description of the client.  This setting can also be localized."
msgstr "クライアントの説明文です。この設定はローカライズすることも可能です。"

msgid "*Enabled*"
msgstr "*Enabled*"

msgid "When turned off, the client cannot request authentication."
msgstr "オフにすると、クライアントは認証を要求できなくなります。"

msgid "*Consent Required*"
msgstr "*Consent Required*"

msgid ""
"When turned on, users see a consent page that they can use to grant access "
"to that application.  It will also display metadata so the user knows the "
"exact information that the client can access."
msgstr ""
"オンにすると、ユーザーはそのアプリケーションへのアクセスを許可するために使用できる同意ページを見ることができます。また、クライアントがアクセスできる正確な情報をユーザーが知ることができるように、メタデータが表示されます。"

msgid "*Access Type*"
msgstr "*Access Type*"

msgid "The type of OIDC client."
msgstr "OIDCクライアントの種類を表します。"

msgid "_Confidential_"
msgstr "_Confidential_"

msgid ""
"For server-side clients that perform browser logins and require client "
"secrets when making an Access Token Request. This setting should be used for"
" server-side applications."
msgstr ""
"ブラウザー・ログインを行い、アクセストークン・リクエストの際にクライアント・シークレットを要求するサーバーサイド・クライアント用。この設定は、サーバーサイドのアプリケーションで使用する必要があります。"

msgid "_Public_"
msgstr "_Public_"

msgid ""
"For client-side clients that perform browser logins. As it is not possible "
"to ensure that secrets can be kept safe with client-side clients, it is "
"important to restrict access by configuring correct redirect URIs."
msgstr ""
"ブラウザー・ログインを行うクライアントサイドのクライアント用。クライアントサイドのクライアントでは、シークレットの保持を確実に行うことができないため、正しいリダイレクトURIを設定することでアクセスを制限することが重要です。"

msgid "_Bearer-only_"
msgstr "_Bearer-only_"

msgid ""
"The application allows only bearer token requests. When turned on, this "
"application cannot participate in browser logins."
msgstr ""
"このアプリケーションは、ベアラートークンの要求のみを許可します。オンにすると、このアプリケーションはブラウザーのログインに参加できなくなります。"

msgid "*Standard Flow Enabled*"
msgstr "*Standard Flow Enabled*"

msgid ""
"When enabled, clients can use the OIDC xref:_oidc-auth-flows-"
"authorization[Authorization Code Flow]."
msgstr ""
"有効にすると、クライアントはOIDC xref:_oidc-auth-flows-"
"authorization[認可コードフロー]を使用できるようになります。"

msgid "*Implicit Flow Enabled*"
msgstr "*Implicit Flow Enabled*"

msgid ""
"When enabled, clients can use the OIDC xref:_oidc-auth-flows-"
"implicit[Implicit Flow]."
msgstr ""
"有効にすると、クライアントはOIDC xref:_oidc-auth-flows-implicit[インプリシット・フロー]を使用できるようになります。"

msgid "*Direct Access Grants Enabled*"
msgstr "*Direct Access Grants Enabled*"

msgid ""
"When enabled, clients can use the OIDC xref:_oidc-auth-flows-direct[Direct "
"Access Grants]."
msgstr ""
"有効にすると、クライアントはOIDC xref:_oidc-auth-flows-direct[Direct Access Grants] "
"を使用することができます。"

msgid "*OAuth 2.0 Device Authorization Grant Enabled*"
msgstr "*OAuth 2.0 Device Authorization Grant Enabled*"

msgid ""
"If this is on, clients are allowed to use the OIDC xref:con-oidc-auth-"
"flows_server_administration_guide[Device Authorization Grant]."
msgstr ""
"オンの場合、クライアントはOIDC xref:con-oidc-auth-"
"flows_server_administration_guide[Device認可グラント] の利用が許可されます。"

msgid ""
"*OpenID Connect Client Initiated Backchannel Authentication Grant Enabled*"
msgstr ""
"*OpenID Connect Client Initiated Backchannel Authentication Grant Enabled*"

msgid ""
"If this is on, clients are allowed to use the OIDC xref:con-oidc-auth-"
"flows_{context}[Client Initiated Backchannel Authentication Grant]."
msgstr ""
"これがオンの場合、クライアントは OIDC xref:con-oidc-auth-flows_{context}[Client Initiated "
"Backchannel Authentication Grant]の使用を許可されます。"

msgid "*Root URL*"
msgstr "*Root URL*"

msgid ""
"If {project_name} uses any configured relative URLs, this value is prepended"
" to them."
msgstr "{project_name}が設定された相対URLを使用する場合、この値が先頭に追加されます。"

msgid "*Valid Redirect URIs*"
msgstr "*Valid Redirect URIs*"

msgid ""
"Required field.  Enter a URL pattern and click *+* to add and *-* to remove "
"existing URLs and click *Save*. You can use wildcards at the end of the URL "
"pattern. For example $$http://host.com/*$$"
msgstr ""
"必須項目です。URLパターンを入力し、 *+* で追加、 *-* で既存のURLを削除して *Save* "
"をクリックします。URLパターンの末尾にワイルドカードを使用することができます。例） $$http://host.com/*$$"

msgid ""
"Exclusive redirect URL patterns are typically more secure.  See "
"xref:unspecific-redirect-uris_{context}[Unspecific Redirect URIs] for more "
"information."
msgstr ""
"排他的リダイレクトURLパターンは、通常、より安全です。詳しくは xref:unspecific-redirect-"
"uris_{context}[Unspecific Redirect URIs] を参照してください。"

msgid "*Base URL*"
msgstr "*Base URL*"

msgid "This URL is used when {project_name} needs to link to the client."
msgstr "このURLは、 {project_name} がクライアントにリンクする必要がある場合に使用されます。"

msgid "*Admin URL*"
msgstr "*Admin URL*"

msgid ""
"Callback endpoint for a client.  The server uses this URL to make callbacks "
"like pushing revocation policies, performing backchannel logout, and other "
"administrative operations.  For {project_name} servlet adapters, this URL "
"can be the root URL of the servlet application. For more information, see "
"link:{adapterguide_link}[{adapterguide_name}]."
msgstr ""
"クライアントのコールバック・エンドポイント。  "
"サーバーはこのURLを使用して、取り消しポリシーのプッシュ、バックチャネル・ログアウトの実行、およびその他の管理操作などのコールバックを実行します。{project_name"
" }サーブレット・アダプターの場合、このURLはサーブレット・アプリケーションのルートURLにすることができます。詳しくは、 "
"link:{adapterguide_link}[{adapterguide_name}] を参照してください。"

msgid "*Logo URL*"
msgstr "*Logo URL*"

msgid "URL that references a logo for the Client application."
msgstr "クライアント・アプリケーション用のロゴを参照するURL。"

msgid "*Policy URL*"
msgstr "*Policy URL*"

msgid ""
"URL that the Relying Party Client provides to the End-User to read about how"
" the profile data will be used."
msgstr "プロファイル・データがどのように使用されるかについて読むために、Relying Partyがエンドユーザーに提供するURL。"

msgid "*Terms of Service URL*"
msgstr "*Terms of Service URL*"

msgid ""
"URL that the Relying Party Client provides to the End-User to read about the"
" Relying Party's terms of service."
msgstr "Relying Partyが、エンドユーザーにRelying Partyの利用規約を提供するURL。"

msgid "*Web Origins*"
msgstr "*Web Origins*"

msgid ""
"Enter a URL pattern and click *+* to add and *-* to remove existing URLs. "
"Click *Save*."
msgstr "URLのパターンを入力し、 *+* で追加、 *-* で既存のURLを削除します。 *Save* をクリックします。"

msgid ""
"This option handles link:https://fetch.spec.whatwg.org/[Cross-Origin "
"Resource Sharing (CORS)]. If browser JavaScript attempts an AJAX HTTP "
"request to a server whose domain is different from the one that the "
"JavaScript code came from, the request must use CORS. The server must handle"
" CORS requests, otherwise the browser will not display or allow the request "
"to be processed. This protocol protects against XSS, CSRF, and other "
"JavaScript-based attacks."
msgstr ""
"このオプションは、 link:https://fetch.spec.whatwg.org/[Cross-Origin Resource Sharing "
"(CORS)] を処理します。ブラウザーのJavaScriptが、JavaScriptコードが由来するドメインとは異なるサーバーにAJAX "
"HTTPリクエストを試みる場合、そのリクエストはCORSを使用する必要があります。サーバーはCORSリクエストを処理する必要があり、そうでない場合、ブラウザーはそのリクエストを表示しないか、処理することを許可しません。このプロトコルは、XSS、CSRF、およびその他のJavaScriptベースの攻撃から保護します。"

msgid ""
"Domain URLs listed here are embedded within the access token sent to the "
"client application. The client application uses this information to decide "
"whether to allow a CORS request to be invoked on it.  Only {project_name} "
"client adapters support this feature. See "
"link:{adapterguide_link}[{adapterguide_name}] for more information."
msgstr ""
"ここに記載されているドメインURLは、クライアント・アプリケーションに送信されるアクセストークン内に埋め込まれています。クライアント・アプリケーションは、この情報を使用して、CORSリクエストの呼び出しを許可するかどうかを決定します。{project_name}クライアント・アダプターのみがこの機能をサポートしています。詳細については、"
" link:{adapterguide_link}[{adapterguide_name}] を参照してください。"

msgid "*Front Channel Logout*"
msgstr "*Front Channel Logout*"

msgid ""
"If *Front Channel Logout* is enabled, the application should be able to log "
"out users through the front channel as per "
"link:https://openid.net/specs/openid-connect-frontchannel-1_0.html[OpenID "
"Connect Front-Channel Logout] specification. If enabled, you should also "
"provide the `Front-Channel Logout URL`."
msgstr ""
"*Front Channel Logout* が有効な場合、アプリケーションは "
"link:https://openid.net/specs/openid-connect-frontchannel-1_0.html[OpenID "
"Connect Front-Channel Logout] "
"の仕様に従って、フロントチャネルを通してユーザーをログアウトできるようにする必要があります。有効にした場合、 `Front-Channel Logout"
" URL` も提供する必要があります。"

msgid "*Front-Channel Logout URL*"
msgstr "*Front-Channel Logout URL*"

msgid ""
"URL that will be used by {project_name} to send logout requests to clients "
"through the front-channel."
msgstr "{project_name}がフロントチャネルを通じてクライアントにログアウト・リクエストを送信するために使用するURL。"

msgid "*Backchannel Logout URL*"
msgstr "*Backchannel Logout URL*"

msgid ""
"URL that will cause the client to log itself out when a logout request is "
"sent to this realm (via end_session_endpoint). If omitted, no logout "
"requests are sent to the client."
msgstr ""
"ログアウト・リクエストがこのレルムに(end_session_endpoint経由で) "
"送られたときに、クライアントが自分自身をログアウトさせるためのURL。省略された場合、ログアウト・リクエストはクライアントに送信されません。"

msgid "Advanced settings"
msgstr "詳細設定"

msgid "When you click _Advanced Settings_, additional fields are displayed."
msgstr "詳細設定_をクリックすると、追加項目が表示されます。"

msgid "*OAuth 2.0 Mutual TLS Certificate Bound Access Tokens Enabled*"
msgstr "*OAuth 2.0 Mutual TLS Certificate Bound Access Tokens Enabled*"

msgid ""
"To enable mutual TLS in {project_name}, see <<_enable-mtls-wildfly, Enable "
"mutual SSL in WildFly>>."
msgstr ""
"{project_name}でMutual TLSを有効にするには、<<_enable-mtls-wildfly, WildFlyでMutual "
"SSLを有効にする>>を参照してください。"

msgid ""
"Mutual TLS binds an access token and a refresh token together with a client "
"certificate, which is exchanged during a TLS handshake. This binding "
"prevents an attacker from using stolen tokens."
msgstr ""
"Mutual "
"TLSは、アクセストークンとリフレッシュトークンを、TLSハンドシェイク中に交換されるクライアント証明書とともにバインドする。この結合により、攻撃者が盗んだトークンを使用することを防ぐことができます。"

msgid ""
"This type of token is a holder-of-key token. Unlike bearer tokens, the "
"recipient of a holder-of-key token can verify if the sender of the token is "
"legitimate."
msgstr ""
"このタイプのトークンは、Holder-of-Keyトークンです。ベアラ・トークンと異なり、Holder-of-Key "
"トークンの受信者は、トークンの送信者が正当であるかどうかを検証することができます。"

msgid "If this setting is on, the workflow is:"
msgstr "この設定がオンの場合、ワークフローは次のようになります。"

msgid ""
"A token request is sent to the token endpoint in an authorization code flow "
"or hybrid flow."
msgstr "トークン・リクエストは、認可コード・フローまたはハイブリッド・フローでトークン・エンドポイントに送信されます。"

msgid "{project_name} requests a client certificate."
msgstr "{project_name} は、クライアント証明書を要求する。"

msgid "{project_name} receives the client certificate."
msgstr "{project_name} は、クライアント証明書を受信する。"

msgid "{project_name} successfully verifies the client certificate."
msgstr "{project_name} は、クライアント証明書の検証に成功しました。"

msgid "If verification fails, {project_name} rejects the token."
msgstr "検証に失敗した場合、{project_name} はトークンを拒否する。"

msgid ""
"In the following cases, {project_name} will verify the client sending the "
"access token or the refresh token:"
msgstr "以下の場合、{project_name}はアクセストークンまたはリフレッシュトークンを送信するクライアントを確認します。"

msgid ""
"A token refresh request is sent to the token endpoint with a holder-of-key "
"refresh token."
msgstr "トークン更新リクエストは、Holder-of-Keyのリフレッシュトークンと共にトークンエンドポイントに送信されます。"

msgid ""
"A UserInfo request is sent to UserInfo endpoint with a holder-of-key access "
"token."
msgstr "UserInfoリクエストは、Holder-of-Keyアクセストークンを伴ってUserInfoエンドポイントに送信される。"

msgid ""
"A logout request is sent to Logout endpoint with a holder-of-key refresh "
"token."
msgstr "ログアウト要求は、Holder-of-keyリフレッシュトークンと共にLogoutエンドポイントに送信されます。"

msgid ""
"See https://datatracker.ietf.org/doc/html/draft-ietf-oauth-"
"mtls-08#section-3[Mutual TLS Client Certificate Bound Access Tokens] in the "
"OAuth 2.0 Mutual TLS Client Authentication and Certificate Bound Access "
"Tokens for more details."
msgstr ""
"詳しくは、OAuth 2.0 相互TLSクライアント認証と証明書バウンドアクセストークンの "
"https://datatracker.ietf.org/doc/html/draft-ietf-oauth-"
"mtls-08#section-3[Mutual TLS Client Certificate Bound Access Tokens]をご覧ください。"

msgid ""
"Currently, {project_name} client adapters do not support holder-of-key token"
" verification. {project_name} adapters treat access and refresh tokens as "
"bearer tokens."
msgstr ""
"現在、{project_name}クライアントアダプタは、Holder-of-Keyトークン検証をサポートしていない。{project_name} "
"アダプタは、アクセス・トークンとリフレッシュ・トークンをベアラ・トークンとし て扱います。"

msgid "*Proof Key for Code Exchange Code Challenge Method*"
msgstr "*Proof Key for Code Exchange Code Challenge Method*"

msgid ""
"If an attacker steals an authorization code of a legitimate client, Proof "
"Key for Code Exchange (PKCE) prevents the attacker from receiving the tokens"
" that apply to the code."
msgstr ""
"攻撃者が正規のクライアントの認証コードを盗んだ場合、Proof Key for Code "
"Exchange（PKCE）により、そのコードに該当するトークンを攻撃者が受け取ることを防ぐことができます。"

msgid "An administrator can select one of these options:"
msgstr "管理者は、これらのオプションのいずれかを選択することができます。"

msgid "*(blank)*"
msgstr "*(blank)*"

msgid ""
"{project_name} does not apply PKCE unless the client sends appropriate PKCE "
"parameters to {project_name}s authorization endpoint."
msgstr ""
"{project_name}は、クライアントが{project_name}の認可エンドポイントに適切なPKCEパラメータを送信しない限り、PKCEを適用しない。"

msgid "*S256*"
msgstr "*S256*"

msgid ""
"{project_name} applies to the client PKCE whose code challenge method is "
"S256."
msgstr "{project_name}は、コードチャレンジ方式がS256であるクライアントPKCEに適用される。"

msgid "*plain*"
msgstr "*plain*"

msgid ""
"{project_name} applies to the client PKCE whose code challenge method is "
"plain."
msgstr "{project_name}は、コードチャレンジ方式がplainであるクライアントPKCEに適用される。"

msgid ""
"See https://datatracker.ietf.org/doc/html/rfc7636[RFC 7636 Proof Key for "
"Code Exchange by OAuth Public Clients] for more details."
msgstr ""
"詳しくは https://datatracker.ietf.org/doc/html/rfc7636[RFC 7636 Proof Key for "
"Code Exchange by OAuth Public Clients]をご覧ください。"

msgid "*Signed and Encrypted ID Token Support*"
msgstr "*Signed and Encrypted ID Token Support*"

msgid ""
"{project_name} can encrypt ID tokens according to the "
"https://datatracker.ietf.org/doc/html/rfc7516[Json Web Encryption (JWE)] "
"specification. The administrator determines if ID tokens are encrypted for "
"each client."
msgstr ""
"{project_name} は、https://datatracker.ietf.org/doc/html/rfc7516[Json Web "
"Encryption (JWE)] の仕様に従って ID "
"トークンを暗号化することができます。管理者は、クライアントごとにIDトークンを暗号化するかどうかを決定します。"

msgid ""
"The key used for encrypting the ID token is the Content Encryption Key "
"(CEK). {project_name} and a client must negotiate which CEK is used and how "
"it is delivered. The method used to determine the CEK is the Key Management "
"Mode. The Key Management Mode that {project_name} supports is Key "
"Encryption."
msgstr ""
"IDトークンの暗号化に使用される鍵は、コンテンツ暗号化鍵（CEK）である。どのCEKを使うか、どのように配信するかは、{project_name} "
"とクライアントが交渉する必要がある。CEK を決定するために使用される方法は、Key Management Mode "
"である。project_name}がサポートするKey Management ModeはKey Encryptionである。"

msgid "In Key Encryption:"
msgstr "鍵の暗号化で。"

msgid "The client generates an asymmetric cryptographic key pair."
msgstr "クライアントは、非対称暗号鍵ペアを生成する。"

msgid "The public key is used to encrypt the CEK."
msgstr "公開鍵は、CEK を暗号化するために使用される。"

msgid "{project_name} generates a CEK per ID token"
msgstr "{project_name} IDトークンごとにCEKを生成する。"

msgid "{project_name} encrypts the ID token using this generated CEK"
msgstr "{project_name} この生成されたCEKを用いてIDトークンを暗号化する。"

msgid "{project_name} encrypts the CEK using the client's public key."
msgstr "{project_name}は、クライアントの公開鍵を用いてCEKを暗号化する。"

msgid "The client decrypts this encrypted CEK using their private key"
msgstr "クライアントは、この暗号化されたCEKを自分の秘密鍵で復号化する。"

msgid "The client decrypts the ID token using the decrypted CEK."
msgstr "クライアントは復号化されたCEKを使用してIDトークンを復号化する。"

msgid "No party, other than the client, can decrypt the ID token."
msgstr "クライアント以外の第三者は、IDトークンを復号化することはできない。"

msgid ""
"The client must pass its public key for encrypting CEK to {project_name}. "
"{project_name} supports downloading public keys from a URL provided by the "
"client. The client must provide public keys according to the "
"https://datatracker.ietf.org/doc/html/rfc7517[Json Web Keys (JWK)] "
"specification."
msgstr ""
"クライアントはCEKを暗号化するための公開鍵を{project_name}に渡さなければならない。{project_name} "
"は、クライアントが提供するURLからの公開鍵のダウンロードに対応している。クライアントは "
"https://datatracker.ietf.org/doc/html/rfc7517[Json Web Keys "
"(JWK)]の仕様に従った公開鍵を提供しなければならない。"

msgid "The procedure is:"
msgstr "その手順とは"

msgid "Open the client's *Keys* tab."
msgstr "クライアントの*Keys*タブを開きます。"

msgid "Toggle *JWKS URL* to ON."
msgstr "JWKS URL*をONに切り替えます。"

msgid "Input the client's public key URL in the *JWKS URL* textbox."
msgstr "JWKS URL* テキストボックスに、クライアントの公開鍵の URL を入力します。"

msgid ""
"Key Encryption's algorithms are defined in the "
"https://datatracker.ietf.org/doc/html/rfc7518#section-4.1[Json Web Algorithm"
" (JWA)] specification. {project_name} supports:"
msgstr ""
"Key "
"Encryptionのアルゴリズムは、https://datatracker.ietf.org/doc/html/rfc7518#section-4.1[Json"
" Web Algorithm (JWA)]仕様で定義されています。{project_name} に対応しています。"

msgid "RSAES-PKCS1-v1_5(RSA1_5)"
msgstr "RSAES-PKCS1-v1_5(RSA1_5)"

msgid "RSAES OAEP using default parameters (RSA-OAEP)"
msgstr "デフォルト・パラメータを使用したRSAES OAEP（RSA-OAEP）。"

msgid "RSAES OAEP 256 using SHA-256 and MFG1 (RSA-OAEP-256)"
msgstr "SHA-256とMFG1を用いたRSAES OAEP 256 (RSA-OAEP-256)"

msgid "The procedure to select the algorithm is:"
msgstr "アルゴリズムを選択する手順としては"

msgid "Open the client's *Settings* tab."
msgstr "クライアントの*Settings*タブを開きます。"

msgid "Open *Fine Grain OpenID Connect Configuration*."
msgstr "Fine Grain OpenID Connect Configuration*を開きます。"

msgid ""
"Select the algorithm from *ID Token Encryption Content Encryption Algorithm*"
" pulldown menu."
msgstr "IDトークン暗号化コンテンツ暗号化アルゴリズム*のプルダウンメニューから、アルゴリズムを選択します。"

msgid "Confidential client credentials"
msgstr "コンフィデンシャル・クライアントのクレデンシャル"

msgid ""
"If the <<_access-type, access type>> of the client is set to *confidential*,"
" the credentials of the client must be configured under the *Credentials* "
"tab."
msgstr ""
"クライアントの<<_access-type, access type>>が *confidential* "
"に設定されている場合、クライアントのクレデンシャルを *Credentials* タブで設定する必要があります。"

msgid "Credentials tab"
msgstr "Credentialsタブ"

msgid "image:{project_images}/client-credentials.png[Credentials Tab]"
msgstr "image:{project_images}/client-credentials.png[Credentials Tab]"

msgid ""
"The *Client Authenticator* drop-down list specifies the type of credential "
"to use for your client."
msgstr "*Client Authenticator* ドロップダウン・リストでは、クライアントに使用するクレデンシャルの種類を指定します。"

msgid "*Client ID and Secret*"
msgstr "*クライアントIDとシークレット*"

msgid ""
"This choice is the default setting. The secret is automatically generated "
"for you and the clicking *Regenerate Secret*  recreates the secret if "
"necessary."
msgstr ""
"この選択肢はデフォルトの設定です。シークレットは自動的に生成され、必要に応じて *Regenerate Secret* "
"をクリックすると、シークレットが再作成されます。"

msgid "Signed JWT"
msgstr "署名付きJWT"

msgid "image:{project_images}/client-credentials-jwt.png[]"
msgstr "image:{project_images}/client-credentials-jwt.png[]"

msgid "*Signed JWT* is \"Signed Json Web Token\"."
msgstr "*Signed JWT* は \"Signed Json Web Token\""

msgid ""
"When choosing this credential type you will have to also generate a private "
"key and certificate for the client in the tab `Keys`. The private key will "
"be used to sign the JWT, while the certificate is used by the server to "
"verify the signature."
msgstr ""
"このクレデンシャル・タイプを選択した場合、 `Keys` "
"タブでクライアントの秘密鍵と証明書も生成する必要があります。秘密鍵はJWTに署名するために使われ、一方、証明書はサーバーが署名を検証するために使われます。"

msgid "Keys tab"
msgstr "Keysタブ"

msgid "image:images/client-oidc-keys.png[]"
msgstr "image:images/client-oidc-keys.png[]"

msgid ""
"Click on the `Generate new keys and certificate` button to start this "
"process."
msgstr "この手順を開始するには、 `Generate new keys and certificate` ボタンをクリックしてください。"

msgid "Generate keys"
msgstr "鍵を生成する"

msgid "image:{project_images}/generate-client-keys.png[]"
msgstr "image:{project_images}/generate-client-keys.png[]"

msgid "Select the archive format you want to use."
msgstr "使用するアーカイブ形式を選択します。"

msgid "Enter a *key password*."
msgstr "*Key Password* を入力します。"

msgid "Enter a *store password*."
msgstr "*store password* を入力します。"

msgid "Click *Generate and Download*."
msgstr "*Generate and Download* をクリックします."

msgid ""
"When you generate the keys, {project_name} will store the certificate and "
"you download the private key and certificate for your client."
msgstr "鍵を生成すると、{project_name}が証明書を保存するので、クライアント用に秘密鍵と証明書をダウンロードします。"

msgid ""
"You can also generate keys using an external tool and then import the "
"client's certificate by clicking *Import Certificate*."
msgstr ""
"また、外部ツールを使って鍵を生成し、 *Import Certificate* をクリックしてクライアントの証明書をインポートすることも可能です。"

msgid "Import certificate"
msgstr "証明書のインポート"

msgid "image:{project_images}/import-client-cert.png[Import Certificate]"
msgstr "image:{project_images}/import-client-cert.png[Import Certificate]"

msgid "Select the archive format of the certificate."
msgstr "証明書のアーカイブ形式を選択します。"

msgid "Enter the store password."
msgstr "ストアパスワードを入力します。"

msgid "Select the certificate file by clicking *Import File*."
msgstr "*Import File* をクリックして、証明書ファイルを選択します。"

msgid "Click *Import*."
msgstr "*Import* をクリックします。"

msgid ""
"Importing a certificate is unnecessary if you click *Use JWKS URL*. In this "
"case, you can provide the URL where the public key is published in "
"https://self-issued.info/docs/draft-ietf-jose-json-web-key.html[JWK] format."
" With this option, if the key is ever changed, {project_name} reimports the "
"key."
msgstr ""
"*Use JWKS URL* をクリックすると、証明書のインポートは不要になります。この場合、公開鍵が公開されているURLを https://self-"
"issued.info/docs/draft-ietf-jose-json-web-key.html[JWK] "
"形式で指定します。このオプションを使用すると、鍵が変更されることがあっても、{project_name}は鍵を再インポートできます。"

msgid ""
"If you are using a client secured by {project_name} adapter, you can "
"configure the JWKS URL in this format, assuming that "
"https://myhost.com/myapp is the root URL of your client application:"
msgstr ""
"{project_name}アダプターでセキュリティー保護されたクライアントを使用している場合、https://myhost.com/myapp "
"をクライアント・アプリケーションのルートURLと仮定して、この形式でJWKS URLを設定することが可能です。"

msgid "https://myhost.com/myapp/k_jwks"
msgstr "https://myhost.com/myapp/k_jwks"

msgid ""
"See link:{developerguide_link}[{developerguide_name}] for more details."
msgstr "詳しくは link:{developerguide_link}[{developerguide_name}] を参照してください。"

msgid ""
"{project_name} caches public keys of OIDC clients. If the private key of "
"your client is compromised, update your keys and clear the key cache. See "
"<<_clear-cache, Clearing the cache>> section for more details."
msgstr ""
"{project_name}は、OIDCクライアントの公開鍵をキャッシュしています。クライアントの秘密鍵が漏洩した場合、鍵を更新して鍵キャッシュをクリアしてください。詳しくは<<_clear-"
"cache, キャッシュのクリア>>のセクションを参照してください。"

msgid "*Signed JWT with Client Secret*"
msgstr "*クライアントシークレットで署名されたJWT*"

msgid ""
"If you select this option, you can use a JWT signed by client secret instead"
" of the private key."
msgstr "このオプションを選択すると、秘密鍵の代わりにクライアント・シークレットで署名されたJWTを使用できます。"

msgid "The client secret will be used to sign the JWT by the client."
msgstr "クライアント・シークレットは、クライアントがJWTに署名するために使用されます。"

msgid "*X509 Certificate*"
msgstr "*X509 Certificate*"

msgid ""
"{project_name} will validate if the client uses proper X509 certificate "
"during the TLS Handshake."
msgstr "{project_name}は、TLSハンドシェイク時にクライアントが適切なX509証明書を使用しているかどうかを検証します。"

msgid ""
"This option requires mutual TLS in {project_name}. See <<_enable-mtls-"
"wildfly, Enable mutual SSL in WildFly>>."
msgstr ""
"このオプションは{project_name}でMutual TLSを必要とします。<<_enable-mtls-wildfly, "
"WildFlyでMutual SSLを有効にする>>を参照してください。"

msgid "X509 certificate"
msgstr "X509証明書"

msgid "image:{project_images}/x509-client-auth.png[]"
msgstr "image:{project_images}/x509-client-auth.png[]"

msgid ""
"The validator also checks the Subject DN field of the certificate with a "
"configured regexp validation expression. For some use cases, it is "
"sufficient to accept all certificates. In that case, you can use "
"`(.*?)(?:$)` expression."
msgstr ""
"バリデーターは、証明書のSubject "
"DNフィールドを、設定された正規表現でチェックします。いくつかのユースケースでは、すべての証明書を受け入れることで十分です。そのような場合は、`(.*?)(?:$)`"
" 式を使用することができます。"

msgid ""
"Two ways exist for {project_name} to obtain the Client ID from the request:"
msgstr "{project_name}がリクエストからクライアントIDを取得する方法は2つ存在します。"

msgid ""
"The `client_id` parameter in the query (described in Section 2.2 of the "
"https://datatracker.ietf.org/doc/html/rfc6749[OAuth 2.0 Specification])."
msgstr ""
"クエリーの `client_id` パラメーターです（ "
"https://datatracker.ietf.org/doc/html/rfc6749[OAuth 2.0仕様] のセクション 2.2 "
"で説明されています）。"

msgid "Supply `client_id` as a form parameter."
msgstr "フォームのパラメーターとして `client_id` を指定します。"

msgid "Using a service account"
msgstr "サービス・アカウントの使用"

msgid ""
"Each OIDC client has a built-in _service account_. Use this _service "
"account_ to obtain an access token."
msgstr ""
"OIDCの各クライアントには、 _サービス・アカウント_ が組み込まれています。この _サービス・アカウント_ を使ってアクセストークンを取得します。"

msgid "Select your client."
msgstr "クライアントを選択してださい。"

msgid "Click the *Settings* tab."
msgstr "*Settings* タブをクリックします。"

msgid ""
"Set the <<_access-type, Access Type>> of your client to *confidential*."
msgstr "クライアントの<<_access-type, Access Type>>を *confidential* に設定してください。"

msgid "Toggle *Service Accounts Enabled* to *ON*."
msgstr "*Service Accounts Enabled* を *ON* に切り替えてください。"

msgid "Configure your <<_client-credentials, client credentials>>."
msgstr "<<_client-credentials, クライアント・クレデンシャル>>の設定を行います。"

msgid "Click the *Scope* tab."
msgstr "*Scope* タブをクリックします。"

msgid "Verify that you have roles or toggle *Full Scope Allowed* to *ON*."
msgstr "ロールがあることを確認するか、 *Full Scope Allowed* を *ON* に切り替えてください。"

msgid "Click the *Service Account Roles* tab"
msgstr "*Service Account Roles* タブをクリックします。"

msgid "Configure the roles available to this service account for your client."
msgstr "このサービス・アカウントで利用可能なロールをクライアントに設定します。"

msgid "Roles from access tokens are the intersection of:"
msgstr "アクセストークンからのロールは、以下の論理積となります。"

msgid ""
"Role scope mappings of a client combined with the role scope mappings "
"inherited from linked client scopes."
msgstr ""
"クライアントのロール・スコープ・マッピングと、リンクされたクライアントのスコープから継承されたロール・スコープ・マッピングを組み合わせたもの。"

msgid "Service account roles."
msgstr "サービス・アカウント・ロール"

msgid ""
"The REST URL to invoke is `/auth/realms/{realm-name}/protocol/openid-"
"connect/token`. This URL must be invoked as a POST request and requires that"
" you post the client credentials with the request."
msgstr ""
"起動するREST URLは、 `/auth/realms/{realm-name}/protocol/openid-connect/token` "
"です。このURLはPOSTリクエストとして呼び出す必要があり、クライアントのクレデンシャルをリクエストに添付する必要があります。"

msgid ""
"By default, client credentials are represented by the clientId and "
"clientSecret of the client in the *Authorization: Basic* header but you can "
"also authenticate the client with a signed JWT assertion or any other custom"
" mechanism for client authentication."
msgstr ""
"デフォルトでは、クライアントのクレデンシャルは、 *Authorization.Basic* "
"ヘッダー内のクライアントのclientIdおよびclientSecretによって表されます。しかし、署名されたJWTアサーションやその他のカスタム・メカニズムを使ってクライアントを認証することもできます。"

msgid ""
"You also need to set the *grant_type* parameter to \"client_credentials\" as"
" per the OAuth2 specification."
msgstr ""
"また、OAuth 2の仕様に従って、 *grant_type* パラメーターを \"client_credentials\" に設定する必要があります。"

msgid ""
"For example, the POST invocation to retrieve a service account can look like"
" this:"
msgstr "たとえば、サービス・アカウントを取得するためのPOST呼び出しは次のようになります。"

msgid ""
"\n"
"    POST /auth/realms/demo/protocol/openid-connect/token\n"
"    Authorization: Basic cHJvZHVjdC1zYS1jbGllbnQ6cGFzc3dvcmQ=\n"
"    Content-Type: application/x-www-form-urlencoded\n"
"\n"
"    grant_type=client_credentials"
msgstr ""
"\n"
"    POST /auth/realms/demo/protocol/openid-connect/token\n"
"    Authorization: Basic cHJvZHVjdC1zYS1jbGllbnQ6cGFzc3dvcmQ=\n"
"    Content-Type: application/x-www-form-urlencoded\n"
"\n"
"    grant_type=client_credentials"

msgid ""
"The response would be similar to this "
"https://datatracker.ietf.org/doc/html/rfc6749#section-4.4.3[Access Token "
"Response] from the OAuth 2.0 specification."
msgstr ""
"このレスポンスは、OAuth 2.0の仕様の "
"https://datatracker.ietf.org/doc/html/rfc6749#section-4.4.3[Access Token "
"Response] に似ています。"

msgid ""
"\n"
"HTTP/1.1 200 OK\n"
"Content-Type: application/json;charset=UTF-8\n"
"Cache-Control: no-store\n"
"Pragma: no-cache\n"
"\n"
"{\n"
"    \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n"
"    \"token_type\":\"bearer\",\n"
"    \"expires_in\":60\n"
"}"
msgstr ""
"\n"
"HTTP/1.1 200 OK\n"
"Content-Type: application/json;charset=UTF-8\n"
"Cache-Control: no-store\n"
"Pragma: no-cache\n"
"\n"
"{\n"
"    \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n"
"    \"token_type\":\"bearer\",\n"
"    \"expires_in\":60\n"
"}"

msgid ""
"Only the access token is returned by default. No refresh token is returned "
"and no user session is created on the {project_name} side upon successful "
"authentication by default. Due to the lack of refresh token, re-"
"authentication is required when the access token expires. However, this "
"situation does not mean any additional overhead for the {project_name} "
"server because sessions are not created by default."
msgstr ""
"デフォルトでは、アクセストークンのみが返されます。デフォルトでは、認証に成功してもリフレッシュ・トークンは返されず、{project_name}側にユーザー・セッションは作成されません。リフレッシュトークンがないため、アクセストークンの有効期限が切れると再認証が必要になります。しかし、デフォルトではセッションが作成されないため、この状況は{project_name}サーバーにとって追加のオーバーヘッドを意味しません。"

msgid ""
"In this situation, logout is unnecessary. However, issued access tokens can "
"be revoked by sending requests to the OAuth2 Revocation Endpoint as "
"described in the xref:con-oidc_{context}[OpenID Connect Endpoints] section."
msgstr ""
"このような場合、ログアウトは不要です。ただし、発行されたアクセストークンは、 xref:con-oidc_{context}[OpenID "
"Connect Endpoints] のセクションで説明されているように、OAuth 2 Revocation "
"Endpointにリクエストを送ることで失効させることができます。"

msgid ""
"For more details, see <<_client_credentials_grant,Client Credentials "
"Grant>>."
msgstr "詳しくは<<_client_credentials_grant,Client Credentials Grant>>を参照してください。"

msgid "Audience support"
msgstr "Audienceのサポート"

msgid ""
"Typically, the environment where {project_name} is deployed consists of a "
"set of _confidential_ or _public_ client applications that use "
"{project_name} for authentication."
msgstr ""
"通常、{project_name}が配置される環境は、{project_name}を認証に使用する _confidential_ "
"クライアント・アプリケーションまたは _public_ クライアント・アプリケーションのセットで構成されています。"

msgid ""
"_Services_ (_Resource Servers_ in the "
"https://datatracker.ietf.org/doc/html/draft-ietf-oauth-"
"mtls-08#section-4.2[OAuth 2 specification]) are also available that serve "
"requests from client applications and provide resources to these "
"applications. These services require an _Access token_ (Bearer token) to be "
"sent to them to authenticate a request. This token is obtained by the "
"frontend application upon login to {project_name}."
msgstr ""
"クライアント・アプリケーションからのリクエストに対応し、これらのアプリケーションにリソースを提供する _サービス_  （ "
"https://datatracker.ietf.org/doc/html/draft-ietf-oauth-"
"mtls-08#section-4.2[OAuth 2 仕様]では _リソースサーバー_ ) "
"も用意されています。これらのサービスでは、リクエストを認証するために _アクセストークン_ "
"（ベアラートークン）を送信する必要があります。このトークンは、フロントエンド・アプリケーションが{project_name}にログインした際に取得します。"

msgid ""
"In the environment where trust among services is low, you may encounter this"
" scenario:"
msgstr "サービス間の信頼性が低い環境では、このようなシナリオに遭遇することがあります。"

msgid ""
"A frontend client application requires authentication against "
"{project_name}."
msgstr "フロントエンド・クライアント・アプリケーションが{project_name}に対して認証を要求します。"

msgid "{project_name} authenticates a user."
msgstr "{project_name}は、ユーザーを認証します。"

msgid "{project_name} issues a token to the application."
msgstr "{project_name}は、アプリケーションにトークンを発行します。"

msgid "The application uses the token to invoke an untrusted service."
msgstr "アプリケーションはトークンを使って、信頼できないサービスを呼び出します。"

msgid ""
"The untrusted service returns the response to the application. However, it "
"keeps the applications token."
msgstr "信頼されないサービスはアプリケーションにレスポンスを返します。ただし、アプリケーションのトークンは保持します。"

msgid ""
"The untrusted service then invokes a trusted service using the applications "
"token. This results in broken security as the untrusted service misuses the "
"token to access other services on behalf of the client application."
msgstr ""
"信頼されていないサービスは、アプリケーションのトークンを使用して信頼されたサービスを呼び出します。この結果、信頼されていないサービスがトークンを悪用して、クライアント・アプリケーションに代わって他のサービスにアクセスするため、セキュリティーが破られることになります。"

msgid ""
"This scenario is unlikely in environments with a high level of trust between"
" services but not in environments where trust is low. In some environments, "
"this workflow may be correct as the untrusted service may have to retrieve "
"data from a trusted service to return data to the original client "
"application."
msgstr ""
"このシナリオは、サービス間の信頼度が高い環境ではありえないが、信頼度が低い環境ではありえます。環境によっては、信頼されていないサービスが、元のクライアント・アプリケーションにデータを返すために、信頼されているサービスからデータを取得する必要があるため、このワークフローは正しいかもしれません。"

msgid ""
"An unlimited audience is useful when a high level of trust exists between "
"services. Otherwise, the audience should be limited. You can limit the "
"audience and, at the same time, allow untrusted services to retrieve data "
"from trusted services. In this case, ensure that the untrusted service and "
"the trusted service are added as audiences to the token."
msgstr ""
"サービス間に高い信頼性が存在する場合、無制限のAudienceが有効です。それ以外の場合は、Audienceを制限する必要があります。Audienceを制限すると同時に、信頼されていないサービスが信頼されているサービスからデータを取得することを許可することができます。この場合、信頼されていないサービスと信頼されたサービスがトークンのAudienceとして追加されていることを確認します。"

msgid ""
"To prevent any misuse of the access token, limit the audience on the token "
"and configure your services to verify the audience on the token. The flow "
"will change as follows:"
msgstr ""
"アクセストークンの悪用を防ぐため、トークンのAudienceを制限し、トークンのAudienceを確認するようにサービスを設定してください。フローは以下のように変更されます。"

msgid "A frontend application authenticates against {project_name}."
msgstr "フロントエンド・アプリケーションは{project_name}に対して認証を行います。"

msgid ""
"{project_name} issues a token to the application. The application knows that"
" it will need to invoke an untrusted service so it places *scope=<untrusted "
"service>* in the authentication request sent to {project_name} (see "
"<<_client_scopes, Client Scopes section>> for more details about the _scope_"
" parameter)."
msgstr ""
"{project_name}はアプリケーションにトークンを発行します。アプリケーションは信頼できないサービスを呼び出す必要があることを知っているので、{project_name}に送信する認証リクエストに"
" *scope=<untrusted service>* を指定します。 _scope_ "
"パラメーターの詳細については、<<_client_scopes, Client Scopes section>>を参照してください。"

msgid ""
"The token issued to the application contains a reference to the untrusted "
"service in its audience (*\"audience\": [ \"<untrusted service>\" ]*) which "
"declares that the client uses this access token to invoke the untrusted "
"service."
msgstr ""
"アプリケーションに発行されたトークンは、そのAudience（ *\"audience\": [ \"<untrusted service>\" ]* "
"）に信頼されないサービスへの参照を含み、クライアントはこのアクセストークンを使って信頼されないサービスを呼び出すと宣言しています。"

msgid ""
"The untrusted service invokes a trusted service with the token. Invocation "
"is not successful because the trusted service checks the audience on the "
"token and find that its audience is only for the untrusted service. This "
"behavior is expected and security is not broken."
msgstr ""
"信頼されていないサービスは、トークンを使って信頼されたサービスを呼び出します。信頼されたサービスがトークンのAudienceをチェックし、そのAudienceが信頼されていないサービスのみであることを発見したため、呼び出しは成功しません。この動作は予期されるものであり、セキュリティーが破られることはありません。"

msgid ""
"If the client wants to invoke the trusted service later, it must obtain "
"another token by reissuing the SSO login with *scope=<trusted service>*. The"
" returned token will then contain the trusted service as an audience:"
msgstr ""
"クライアントが後で信頼できるサービスを呼び出したい場合、SSOログインを *scope=<trusted service>* "
"で再発行して別のトークンを取得する必要があります。返されたトークンには、信頼されたサービスがAudienceとして含まれています。"

msgid "\"audience\": [ \"<trusted service>\" ]"
msgstr "\"audience\": [ \"<trusted service>\" ]"

msgid "Use this value to invoke the *<trusted service>*."
msgstr "この値で *<trusted service>* を呼び出す。"

msgid "When setting up audience checking:"
msgstr "Audienceチェックを設定する場合は、以下のようにします。"

msgid ""
"Ensure that services are configured to check audience on the access token "
"sent to them by adding the flag *_verify-token-audience_* in the adapter "
"configuration. See "
"link:{adapterguide_link_latest}#_java_adapter_config[Adapter configuration] "
"for details."
msgstr ""
"アダプターの設定に *_verify-token-audience_* "
"フラグを追加して、サービスが送信されたアクセストークンのAudienceチェックを行うよう設定されていることを確認します。詳しくは "
"link:{adapterguide_link_latest}#_java_adapter_config[アダプターの設定] を参照してください。"

msgid ""
"Ensure that access tokens issued by {project_name} contain all necessary "
"audiences. Audiences can be added using the client roles as described in the"
" <<_audience_resolve, next section>> or hardcoded. See "
"<<_audience_hardcoded, Hardcoded audience>>."
msgstr ""
"{project_name}が発行するアクセストークンには、必要なAudienceをすべて含んでいることを確認してください。Audienceは、<<_audience_resolve,"
" 次のセクション>>で説明したクライアントロールを使用して追加するか、ハードコードすることができます。<<_audience_hardcoded, "
"ハードコードされたAudience>>を参照してください。"

msgid "Automatically add audience"
msgstr "Audienceを自動的に追加"

msgid ""
"An _Audience Resolve_ protocol mapper is defined in the default client scope"
" _roles_. The mapper checks for clients that have at least one client role "
"available for the current token. The client ID of each client is then added "
"as an audience, which is useful if your service (usually bearer-only) "
"clients rely on client roles."
msgstr ""
"_Audience Resolve_ プロトコル・マッパーは、デフォルトのクライアントスコープ _roles_ "
"に定義されています。このマッパーは、現在のトークンに対して少なくとも一つのクライアントロールが利用可能であるクライアントをチェックします。これは、サービス（通常はbearer-"
"only）クライアントがクライアントロールに依存している場合に有用です。"

msgid ""
"For example, for a bearer-only client and a confidential client, you can use"
" the access token issued for the confidential client to invoke the bearer-"
"only client REST service. The bearer-only client will be automatically added"
" as an audience to the access token issued for the confidential client if "
"the following are true:"
msgstr ""
"たとえば、bearer-"
"onlyクライアントとコンフィデンシャル・クライアントの場合、コンフィデンシャル・クライアント用に発行されたアクセストークンを使用して、bearer-"
"onlyクライアントのRESTサービスを呼び出すことが可能です。bearer-"
"onlyクライアントは、以下の条件を満たす場合、コンフィデンシャル・クライアント用に発行されたアクセストークンに自動的にAudienceとして追加されます。"

msgid "The bearer-only client has any client roles defined on itself."
msgstr "bearer-onlyクライアントは、自分自身に定義された任意のクライアントロールを持ちます。"

msgid "Target user has at least one of those client roles assigned."
msgstr "対象のユーザーは、これらのクライアントロールのうち少なくとも1つが割り当てられています。"

msgid "Confidential client has the role scope mappings for the assigned role."
msgstr "コンフィデンシャル・クライアントは、割り当てられたロールのロール・スコープ・マッピングを持ちます。"

msgid ""
"If you want to ensure that the audience is not added automatically, do not "
"configure role scope mappings directly on the confidential client. Instead, "
"you can create a dedicated client scope that contains the role scope "
"mappings for the client roles of your dedicated client scope."
msgstr ""
"Audienceが自動的に追加されないようにするには、コンフィデンシャル・クライアントで直接ロール・スコープ・マッピングを設定しないでください。代わりに、専用クライアント・スコープを作成し、その専用クライアント・スコープのクライアントロールのロール・スコープ・マッピングを含むことができます。"

msgid ""
"Assuming that the client scope is added as an optional client scope to the "
"confidential client, the client roles and the audience will be added to the "
"token if explicitly requested by the *scope=<trusted service>*  parameter."
msgstr ""
"コンフィデンシャル・クライアントにオプションのクライアント・スコープが追加されたと仮定すると、*scope=*<trusted "
"service>パラメーターで明示的に要求された場合、クライアントロールとAudienceがトークンに追加されます。"

msgid ""
"The frontend client itself is not automatically added to the access token "
"audience, therefore allowing easy differentiation between the access token "
"and the ID token, since the access token will not contain the client for "
"which the token is issued as an audience."
msgstr ""
"フロントエンド・クライアント自身はアクセストークンのAudienceに自動的に追加されないため、アクセストークンとIDトークンを容易に区別することができます（アクセストークンには、トークンがAudienceとして発行されるクライアントが含まれないためです）。"

msgid ""
"If you need the client itself as an audience, see the <<_audience_hardcoded,"
" hardcoded audience>> option. However, using the same client as both "
"frontend and REST service is not recommended."
msgstr ""
"クライアント自体をAudienceとして必要とする場合は、<<_audience_hardcoded, "
"ハードコードされたAudience>>オプションを参照してください。しかし、同じクライアントをフロントエンドとRESTサービスの両方に使用することは推奨されません。"

msgid "Hardcoded audience"
msgstr "ハードコードされたAudience"

msgid ""
"When your service relies on realm roles or does not rely on the roles in the"
" token at all, it can be useful to use a hardcoded audience. A hardcoded "
"audience is a protocol mapper, that will add the client ID of the specified "
"service client as an audience to the token. You can use any custom value, "
"for example a URL, if you want to use a different audience than the client "
"ID."
msgstr ""
"サービスがレルムロールに依存している場合や、トークン内のロールに全く依存していない場合は、ハードコードされたAudienceを使用すると便利です。ハードコードされたAudienceとは、指定したサービス・クライアントのクライアントIDをAudienceとしてトークンに追加するプロトコル・マッパーのことです。クライアントIDとは異なるAudienceを使用したい場合は、任意のカスタム値（たとえば、URL）を使用することができます。"

msgid ""
"You can add the protocol mapper directly to the frontend client. If the "
"protocol mapper is added directly, the audience will be always added as "
"well."
msgstr ""
"プロトコル・マッパーは、フロントエンド・クライアントに直接追加することができます。プロトコル・マッパーを直接追加した場合、Audienceも必ず追加されます。"

msgid ""
"For more control over the protocol mapper, you can create the protocol "
"mapper on the dedicated client scope, which will be called for example "
"*good-service*."
msgstr ""
"プロトコル・マッパーをより詳細に制御するには、専用のクライアント・スコープにプロトコル・マッパーを作成し、たとえば *good-service* "
"と呼ばれるようにします。"

msgid "Audience protocol mapper"
msgstr "Audienceプロトコル・マッパー"

msgid "image:{project_images}/audience_mapper.png[]"
msgstr "image:{project_images}/audience_mapper.png[]"

msgid ""
"From the <<_client_installation, Installation tab>> of the *good-service* "
"client, you can generate the adapter configuration and you can confirm that "
"_verify-token-audience_ option will be set to *true*. This forces the "
"adapter to verify the audience if you use this configuration."
msgstr ""
"*good-service* クライアントの<<_client_installation, "
"Installationタブ>>から、アダプターの設定を生成することができ、 _verify-token-audience_ オプションが *true*"
" に設定されることを確認することができます。これにより、この設定を使用した場合、アダプターは強制的にAudienceを確認することになります。"

msgid ""
"You need to ensure that the confidential client is able to request *good-"
"service* as an audience in its tokens."
msgstr ""
"コンフィデンシャル・クライアントが、そのトークンにAudienceとして *good-service* を要求できるようにする必要があります。"

msgid "On the confidential client:"
msgstr "コンフィデンシャル・クライアントでは以下のようにします。"

msgid "Click the _Client Scopes_ tab."
msgstr "_Client Scopes_ タブをクリックします。"

msgid "Assign *good-service* as an optional (or default) client scope."
msgstr "オプション（またはデフォルト）のクライアント・スコープとして *good-service* を割り当てます。"

msgid ""
"See <<_client_scopes_linking, Client Scopes Linking section>> for more "
"details."
msgstr "詳しくは<<_client_scopes_linking, Client Scopes Linkingのセクション>>を参照してください。"

msgid ""
"You can optionally <<_client_scopes_evaluate, Evaluate Client Scopes>> and "
"generate an example access token. *good-service* will be added to the "
"audience of the generated access token if *good-service* is included in the "
"_scope_ parameter, when you assigned it as an optional client scope."
msgstr ""
"オプションで<<_client_scopes_evaluate, "
"クライアント・スコープの評価>>とアクセストークンの例を生成することができます。オプションのクライアントスコープとして割り当てた場合、 _scope_ "
"パラメーターに *good-service* が含まれていれば、生成されたアクセストークンのAudienceに *good-service* "
"が追加されます。"

msgid ""
"In your confidential client application, ensure that the _scope_ parameter "
"is used. The value *good-service* must be included when you want to issue "
"the token for accessing *good-service*."
msgstr ""
"コンフィデンシャル・クライアント・アプリケーションでは、 _scope_ パラメーターが使用されていることを確認してください。 *good-"
"service* にアクセスするためのトークンを発行する場合は、値 *good-service* を含める必要があります。"

msgid "See:"
msgstr "以下を参照してください。"

msgid ""
"link:{adapterguide_link}#_params_forwarding[parameters forwarding section] "
"if your application uses the servlet adapter."
msgstr ""
"link:{adapterguide_link}#_params_forwarding[parameters forwarding section] "
"（サーブレットアダプタを使用する場合）"

msgid ""
"link:{adapterguide_link}#_javascript_adapter[javascript adapter section] if "
"your application uses the javascript adapter."
msgstr ""
"link:{adapterguide_link}#_javascript_adapter[javascript adapter section] "
"（アプリケーションがJavaScriptアダプターを使用する場合）"

msgid ""
"Both the _Audience_ and _Audience Resolve_ protocol mappers add the "
"audiences to the access token only, by default. The ID Token typically "
"contains only a single audience, the client ID for which the token was "
"issued, a requirement of the OpenID Connect specification. However, the "
"access token does not necessarily have the client ID, which was the token "
"issued for, unless the audience mappers added it."
msgstr ""
"_Audience_ と _Audience Resolve_ "
"の両プロトコル・マッパーは、デフォルトではアクセストークンにのみAudienceを追加します。IDトークンは通常、OpenID "
"Connectの仕様の要件である、トークンが発行されたクライアントIDという単一のAudienceのみを含みます。しかし、アクセストークンには、Audienceマッパーが追加しない限り、トークンが発行されたクライアントIDが含まれているとは限りません。"

msgid "Creating a SAML client"
msgstr "SAMLクライアントの作成"

msgid ""
"{project_name} supports <<_saml,SAML 2.0>> for registered applications. POST"
" and Redirect bindings are supported. You can choose to require client "
"signature validation. You can have the server sign and/or encrypt responses "
"as well."
msgstr ""
"{project_name}は、登録されたアプリケーションに対して<<_saml,SAML "
"2.0>>をサポートし、POSTとRedirectのバインディングに対応しています。クライアント署名の検証を要求するかどうかを選択したり、サーバーに署名や暗号化をさせることもできます。"

msgid "image:{project_images}/add-client-saml.png[]"
msgstr "image:{project_images}/add-client-saml.png[]"

msgid ""
"Enter the *Client ID* of the client. This is often a URL and is the expected"
" *issuer* value in SAML requests sent by the application."
msgstr ""
"クライアントの *Client ID* を入力します。これは多くの場合URLであり、アプリケーションから送信されるSAMLリクエストで期待される "
"*issuer* の値です。"

msgid "Select *saml* in the *Client Protocol* drop down box."
msgstr "*Client Protocol* ドロップダウン・ボックスで *saml* を選択します。"

msgid ""
"Enter the *Client SAML Endpoint* URL. This URL is where you want the "
"{project_name} server to send SAML requests and responses. Generally, "
"applications have one URL for processing SAML requests. Multiple URLs can be"
" set in the *Settings* tab of the client."
msgstr ""
"*Client SAML Endpoint* "
"URLを入力します。このURLは、{project_name}サーバーにSAMLリクエストとレスポンスを送信させる場所です。一般的に、アプリケーションには、SAMLリクエストを処理するための1つのURLがあります。複数のURLを、クライアントの"
" *Settings* タブで設定することができます。"

msgid ""
"Click *Save*.  This action creates the client and brings you to the "
"*Settings* tab."
msgstr "*保存* をクリックします。この操作でクライアントが作成され、 *Settings*タブが表示されます。"

msgid "image:{project_images}/client-settings-saml.png[]"
msgstr "image:{project_images}/client-settings-saml.png[]"

msgid "The following list describes each setting:"
msgstr "各設定について、次の一覧で説明します。"

msgid ""
"The alpha-numeric ID string that is used in OIDC requests and in the "
"{project_name} database to identify the client. This value must match the "
"issuer value sent with AuthNRequests. {project_name} pulls the issuer from "
"the Authn SAML request and match it to a client by this value."
msgstr ""
"OIDCリクエストおよび {project_name} データベースでクライアントを識別するために使用される英数字の ID "
"文字列です。この値はAuthNRequestsで送信されるissuerの値と一致しなければならない。{project_name} は Authn "
"SAML リクエストから発行者を取り出し、この値でクライアントとマッチングさせる。"

msgid ""
"The name for the client in a {project_name} UI screen. To localize the name,"
" set up a replacement string value. For example, a string value such as "
"$\\{myapp}.  See the link:{developerguide_link}[{developerguide_name}] for "
"more information."
msgstr ""
"{project_name}のUI画面におけるクライアントの名前です。名前をローカライズするには、置換文字列値を設定します。たとえば、$\\{myapp}のような文字列値です。詳しくは、"
" link:{developerguide_link}[{developerguide_name}] を参照してください。"

msgid "When set to OFF, the client cannot request authentication."
msgstr "OFFに設定すると、クライアントは認証を要求できなくなります。"

msgid ""
"When set to ON, users see a consent page that grants access to that "
"application.  The page also displays the metadata of the information that "
"the client can access. If you have ever done a social login to Facebook, you"
" often see a similar page. Red Hat Single Sign-On provides the same "
"functionality."
msgstr ""
"ONに設定すると、ユーザーはそのアプリケーションへのアクセスを許可する同意ページを見ることができます。また、このページには、クライアントがアクセスできる情報のメタデータが表示されます。Facebookへのソーシャル・ログインをしたことがある人は、よく似たページを見ることができます。Red"
" Hat Single Sign-On は同じ機能を提供します。"

msgid "*Include AuthnStatement*"
msgstr "*Include AuthnStatement*"

msgid ""
"SAML login responses may specify the  authentication method used, such as "
"password, as well as timestamps of the login and the session expiration. "
"*Include AuthnStatement* is enabled by default, so that the *AuthnStatement*"
" element will be included in login responses. Setting this to OFF prevents "
"clients from determining the maximum session length, which can create client"
" sessions that do not expire."
msgstr ""
"SAMLログイン・レスポンスには、使用された認証方式（パスワードなど）、ログインのタイムスタンプおよびセッションの有効期限を指定することができます。 "
"*Include AuthnStatement* はデフォルトで有効になっており、ログイン・レスポンスに *AuthnStatement* "
"要素が含まれるようになります。これをOFFに設定すると、クライアントが最大セッション長を決定できなくなり、期限切れにならないクライアント・セッションが作成される可能性があります。"

msgid "*Sign Documents*"
msgstr "*Sign Documents*"

msgid ""
"When set to ON, {project_name} signs the document using the realms private "
"key."
msgstr "ONに設定すると、{project_name}はレルムの秘密鍵を使ってドキュメントに署名します。"

msgid "*Optimize REDIRECT signing key lookup*"
msgstr "*Optimize REDIRECT signing key lookup*"

msgid ""
"When set to ON, the SAML protocol messages include the {project_name} native"
" extension. This extension contains a hint with the signing key ID. The SP "
"uses the extension for signature validation instead of attempting to "
"validate the signature using keys."
msgstr ""
"ONに設定すると、SAMLプロトコル・メッセージに{project_name}ネイティブ拡張が含まれます。この拡張には、署名鍵IDを示すヒントが含まれます。SPは、鍵を用いた署名の検証を試みる代わりに、この拡張機能を署名の検証に用います。"

msgid ""
"This option applies to REDIRECT bindings where the signature is transferred "
"in query parameters and this information is not found in the signature "
"information. This is contrary to POST binding messages where key ID is "
"always included in document signature."
msgstr ""
"このオプションは、署名がクエリー・パラメーターで転送されるREDIRECTバインディングに適用され、この情報は署名情報には含まれません。これは、鍵IDが常にドキュメント署名に含まれるPOSTバインディング・メッセージとは異なります。"

msgid ""
"This option is used when {project_name} server and adapter provide the IDP "
"and SP. This option is only relevant when *Sign Documents* is set to ON."
msgstr ""
"このオプションは、{project_name}サーバーとアダプターがIDPとSPを提供する場合に使用されます。このオプションは、*Sign "
"Documents* がONに設定されている場合にのみ影響します。"

msgid "*Sign Assertions*"
msgstr "*Sign Assertions*"

msgid "The assertion is signed and embedded in the SAML XML Auth response."
msgstr "アサーションは署名され、SAML XML認証レスポンスに埋め込まれます。"

msgid "*Signature Algorithm*"
msgstr "*Signature Algorithm*"

msgid "The algorithm used in signing SAML documents."
msgstr "SAML文書に署名する際に使用されるアルゴリズム。"

msgid "*SAML Signature Key Name*"
msgstr "*SAML Signature Key Name*"

msgid ""
"Signed SAML documents sent using POST binding contain the identification of "
"the signing key in the *KeyName* element. This action can be controlled by "
"the *SAML Signature Key Name* option. This option controls the contents of "
"the *Keyname*."
msgstr ""
"POST バインディングを使用して送信される署名付き SAML ドキュメントには、*KeyName* "
"要素に署名鍵の識別情報が含まれています。この動作は、*SAML Signature Key Name* "
"オプションで制御することができます。このオプションは、*Keyname* の内容を制御します。"

msgid ""
"*KEY_ID* The *KeyName* contains the key ID. This option is the default "
"option."
msgstr "*KEY_ID* *KeyName* にはキーIDが含まれます。このオプションはデフォルトのオプションです。"

msgid ""
"*CERT_SUBJECT* The *KeyName* contains the subject from the certificate "
"corresponding to the realm key. This option is expected by Microsoft Active "
"Directory Federation Services."
msgstr ""
"*CERT_SUBJECT* *KeyName* は、レルムキーに対応する証明書からのサブジェクトを含みます。このオプションは、Microsoft "
"Active Directoryフェデレーション・サービスによって期待されています。"

msgid "*NONE* The *KeyName* hint is completely omitted from the SAML message."
msgstr "*NONE* SAMLメッセージから *KeyName* ヒントが完全に省略されます。"

msgid "*Canonicalization Method*"
msgstr "*Canonicalization Method*"

msgid "The canonicalization method for XML signatures."
msgstr "XML署名の正準化手法。"

msgid "*Encrypt Assertions*"
msgstr "*Encrypt Assertions*"

msgid ""
"Encrypts the assertions in SAML documents with the realms private key. The "
"AES algorithm uses a key size of 128 bits."
msgstr "SAML文書のアサーションをレルム秘密鍵で暗号化します。AES アルゴリズムは、128ビットのキーサイズを使用します。"

msgid "*Client Signature Required*"
msgstr "*Client Signature Required*"

msgid ""
"If *Client Signature Required* is enabled, documents coming from a client "
"are expected to be signed. {project_name} will validate this signature using"
" the client public key or cert set up in the `Keys` tab."
msgstr ""
"*Client Signature Required* "
"が有効な場合、クライアントからのドキュメントは署名されていることが期待されます。{project_name}は、 `鍵` "
"タブで設定されたクライアントの公開鍵または証明書を使用して、この署名を検証します。"

msgid "*Force POST Binding*"
msgstr "*Force POST Binding*"

msgid ""
"By default, {project_name} responds using the initial SAML binding of the "
"original request. By enabling *Force POST Binding*, {project_name} responds "
"using the SAML POST binding even if the original request used the redirect "
"binding."
msgstr ""
"デフォルトでは、{project_name}は元のリクエストの最初のSAMLバインディングを使用して応答します。 *Force POST "
"Binding* を有効にすると、{project_name}は、元のリクエストがREDIRECTバインディングを使用していたとしても、SAML "
"POSTバインディングを使用して応答します。"

msgid ""
"If *Front Channel Logout* is enabled, the application requires a browser "
"redirect to perform a logout. For example, the application may require a "
"cookie to be reset which could only be done via a redirect. If *Front "
"Channel Logout* is disabled, {project_name} invokes a background SAML "
"request to log out of the application."
msgstr ""
"*Front Channel Logout* "
"が有効な場合、アプリケーションはログアウトを実行するためにブラウザーのリダイレクトを必要とします。たとえば、アプリケーションはリダイレクトによってのみ実行可能なCookieのリセットを要求するかもしれません。"
" *Front Channel Logout* "
"が無効な場合、{project_name}はアプリケーションからログアウトするために、バックグラウンドでSAMLリクエストを呼び出します。"

msgid "*Force Name ID Format*"
msgstr "*Force Name ID Format*"

msgid ""
"If a request has a name ID policy, ignore it and use the value configured in"
" the Admin Console under *Name ID Format*."
msgstr ""
"リクエストにName IDのポリシーがある場合、それを無視して管理コンソールの *Name ID Format* で設定された値を使用します。"

msgid "*Name ID Format*"
msgstr "*Name ID Format*"

msgid ""
"The Name ID Format for the subject. This format is used if no name ID policy"
" is specified in a request, or if the Force Name ID Format attribute is set "
"to ON."
msgstr ""
"サブジェクトのName ID Format。この形式は、リクエストでName IDポリシーが指定されていない場合、またはName "
"ID形式の強制属性がONに設定されている場合に使用されます。"

msgid ""
"When {project_name} uses a configured relative URL, this value is prepended "
"to the URL."
msgstr "{project_name}が設定された相対URLを使用する場合、この値がURLの前に付加されます。"

msgid ""
"Enter a URL pattern and click the + sign to add.  Click the - sign to "
"remove. Click *Save* to save these changes. Wildcards values are allowed "
"only at the end of a URL. For example, http://host.com/*$$. This field is "
"used when the exact SAML endpoints are not registered and {project_name} "
"pulls the Assertion Consumer URL from a request."
msgstr ""
"URLパターンを入力し、+記号をクリックすると追加されます。削除する場合は、-記号をクリックします。 *Save* "
"をクリックして、これらの変更を保存します。ワイルドカードの値は、URLの末尾にのみ使用できます。たとえば、http://host.com/*$$のようになります。このフィールドは、正確なSAMLエンドポイントが登録されておらず、{project_name}のリクエストからAssertion"
" Consumer URLを導き出す場合に使用されます。"

msgid "If {project_name} needs to link to a client, this URL is used."
msgstr "{project_name}がクライアントにリンクする必要がある場合、このURLが使用されます。"

msgid "*Master SAML Processing URL*"
msgstr "*Master SAML Processing URL*"

msgid ""
"This URL is used for all SAML requests and the response is directed to the "
"SP. It is used as the Assertion Consumer Service URL and the Single Logout "
"Service URL."
msgstr ""
"このURLは、すべてのSAMLリクエストに使用され、レスポンスはSPに向けられます。これは、アサーション・コンシューマー・サービスのURLおよびシングル・ログアウト・サービスのURLとして使用されます。"

msgid ""
"If login requests contain the Assertion Consumer Service URL then those "
"login requests will take precedence. This URL must be validated by a "
"registered Valid Redirect URI pattern."
msgstr ""
"ログインリクエストにアサーション・コンシューマー・サービスのURLが含まれている場合、そのログインリクエストが優先されます。このURLは、登録された有効なリダイレクトURIパターンによって検証される必要があります。"

msgid "*Assertion Consumer Service POST Binding URL*"
msgstr "*Assertion Consumer Service POST Binding URL*"

msgid "POST Binding URL for the Assertion Consumer Service."
msgstr "アサーション・コンシューマー・サービスのPOSTバインディングURL。"

msgid "*Assertion Consumer Service Redirect Binding URL*"
msgstr "*Assertion Consumer Service Redirect Binding URL*"

msgid "Redirect Binding URL for the Assertion Consumer Service."
msgstr "アサーション・コンシューマー・サービスのREDIRECTバインディングURL。"

msgid "*Logout Service POST Binding URL*"
msgstr "*Logout Service POST Binding URL*"

msgid "POST Binding URL for the Logout Service."
msgstr "ログアウト・サービスのPOSTバインディングURL。"

msgid "*Logout Service Redirect Binding URL*"
msgstr "*Logout Service Redirect Binding URL*"

msgid "Redirect Binding URL for the Logout Service."
msgstr "ログアウト・サービスのREDIRECTバインディングURL。"

msgid "*Logout Service Artifact Binding URL*"
msgstr "*Logout Service Artifact Binding URL*"

msgid ""
"_Artifact_ Binding URL for the Logout Service. When set together with the "
"`Force Artifact Binding` option, _Artifact_ binding is forced for both login"
" and logout flows. _Artifact_ binding is not used for logout unless this "
"property is set."
msgstr ""
"ログアウト・サービスの _Artifact_ Binding URLです。 `Force Artifact Binding` "
"オプションと一緒に設定すると、ログインとログアウトの両方のフローで _Artifact_ "
"バインディングが強制されます。このプロパティーが設定されない限り、ログアウトに _Artifact_ バインディングは使用されません。"

msgid "*Artifact Binding URL*"
msgstr "*Artifact Binding URL*"

msgid "URL to send the HTTP artifact messages to."
msgstr "HTTPアーティファクト・メッセージの送信先のURL。"

msgid "*Artifact Resolution Service*"
msgstr "*Artifact Resolution Service*"

msgid ""
"URL of the client SOAP endpoint where to send the `ArtifactResolve` messages"
" to."
msgstr "`ArtifactResolve` メッセージの送信先となるクライアントSOAPエンドポイントのURL。"

msgid "IDP Initiated login"
msgstr "IDP Initiated Login"

msgid ""
"IDP Initiated Login is a feature that allows you to set up an endpoint on "
"the {project_name} server that will log you into a specific "
"application/client. In the *Settings* tab for your client, you need to "
"specify the *IDP Initiated SSO URL Name*. This is a simple string with no "
"whitespace in it. After this you can reference your client at the following "
"URL: `root/auth/realms/{realm}/protocol/saml/clients/{url-name}`"
msgstr ""
"IDP Initiated "
"Loginは、特定のアプリケーション/クライアントにログインするエンドポイントを{project_name}サーバーに設定できる機能です。クライアントの"
" *Settings* タブで、*IDP Initiated SSO URL Name* "
"を指定する必要があります。これは、空白を含まない単純な文字列です。この後、次のURLでクライアントを参照することができます。 "
"`root/auth/realms/{realm}/protocol/saml/clients/{url-name}` "

msgid ""
"The IDP initiated login implementation prefers _POST_ over _REDIRECT_ "
"binding (check <<_saml, saml bindings>> for more information). Therefore the"
" final binding and SP URL are selected in the following way:"
msgstr ""
"IdP initiated loginの実装は、_REDIRECT_ バインディングよりも _POST_ "
"バインディングを優先します（詳細については<<_saml, "
"SAMLバインディング>>をチェックしてください）。したがって、最終的なバインディングとSPのURLは次のように選択されます。"

msgid ""
"If the specific *Assertion Consumer Service POST Binding URL* is defined "
"(inside *Fine Grain SAML Endpoint Configuration* section of the client "
"settings) _POST_ binding is used through that URL."
msgstr ""
"特定の *Assertion Consumer Service POST Binding URL* が定義されている場合 (クライアント設定の "
"*Fine Grain SAML Endpoint Configuration* セクション内に)、そのURLを介して _POST_  "
"バインディングが使用されます。"

msgid ""
"If the general *Master SAML Processing URL* is specified then _POST_ binding"
" is used again throught this general URL."
msgstr ""
"一般的な *Master SAML Processing URL* が指定されている場合、_POST_ "
"バインディングは、この一般的なURLを介して再度使用されます。"

msgid ""
"As the last resort, if the *Assertion Consumer Service Redirect Binding URL*"
" is configured (inside *Fine Grain SAML Endpoint Configuration*) _REDIRECT_ "
"binding is used with this URL."
msgstr ""
"最後の手段として、*Assertion Consumer Service Redirect Binding URL* が設定されている場合（*Fine "
"Grain SAML Endpoint Configuration* 内）、このURLで _REDIRECT_ バインディングが使用されます。"

msgid ""
"If your client requires a special relay state, you can also configure this "
"on the *Settings* tab in the *IDP Initiated SSO Relay State* field. "
"Alternatively, browsers can specify the relay state in a *RelayState* query "
"parameter, i.e. `root/auth/realms/{realm}/protocol/saml/clients/{url-"
"name}?RelayState=thestate`."
msgstr ""
"クライアントが特別なリレーステートを必要とする場合、 *Settings* タブの *IDP Initiated SSO Relay State* "
"フィールドでこれを設定することもできます。また、ブラウザーは *RelayState* "
"クエリー・パラメーターでリレーステートを指定することもできます（例： "
"`root/auth/realms/{realm}/protocol/saml/clients/{url-"
"name}?RelayState=thestate` "

msgid ""
"When using <<_identity_broker,identity brokering>>, it is possible to set up"
" an IDP Initiated Login for a client from an external IDP. The actual client"
" is set up for IDP Initiated Login at broker IDP as described above. The "
"external IDP has to set up the client for application IDP Initiated Login "
"that will point to a special URL pointing to the broker and representing IDP"
" Initiated Login endpoint for a selected client at the brokering IDP. This "
"means that in client settings at the external IDP:"
msgstr ""
"<<_identity_broker,アイデンティティー・ブローカリング>>を使用する場合、クライアントに対して外部IDPからのIDP "
"Initiated ログインを設定することができます。実際のクライアントは、上記のようにブローカーIDPでIDP Initiated "
"ログインするように設定されます。外部IDPはクライアントを、特別なURLを指し示す、アプリケーションIDP Initiated "
"ログインのためにセットアップする必要があります。URLはブローカーを指し、ブローカリングIDPで選択されたクライアントのために、IDP "
"Initiated ログイン・エンドポイントを代理します。つまり、外部IDPのクライアント設定では次のようになります。"

msgid ""
"*IDP Initiated SSO URL Name* is set to a name that will be published as IDP "
"Initiated Login initial point,"
msgstr ""
"*IDP Initiated SSO URL Name* には、IDP Initiated Loginの初期ポイントとして公開される名前が設定されます。"

msgid ""
"*Assertion Consumer Service POST Binding URL* in the *Fine Grain SAML "
"Endpoint Configuration* section has to be set to the following URL: `broker-"
"root/auth/realms/{broker-realm}/broker/{idp-name}/endpoint/clients/{client-"
"id}`, where:"
msgstr ""
"*Fine Grain SAML Endpoint Configuration* のセクションの *Assertion Consumer Service POST Binding URL* は、以下のURLに設定する必要があります。\n"
"`broker-root/auth/realms/{broker-realm}/broker/{idp-name}/endpoint/clients/{client-id}`"

msgid "_broker-root_ is base broker URL"
msgstr "_broker-root_ はベースブローカーURLです。"

msgid ""
"_broker-realm_ is name of the realm at broker where external IDP is declared"
msgstr "_broker-realm_ は、外部IDPが宣言されているブローカー側のレルム名です。"

msgid "_idp-name_ is name of the external IDP at broker"
msgstr "_idp-name_ は、ブローカーでの外部IDPの名前です。"

msgid ""
"_client-id_ is the value of *IDP Initiated SSO URL Name* attribute of the "
"SAML client defined at broker. It is this client, which will be made "
"available for IDP Initiated Login from the external IDP."
msgstr ""
"_client-id_ は、ブローカーで定義されたSAMLクライアントの *IDP Initiated SSO URL Name** "
"属性の値です。このクライアントは、外部IDPからのIDP Initiated ログインに対して利用可能になります。"

msgid ""
"Please note that you can import basic client settings from the brokering IDP"
" into client settings of the external IDP - just use "
"<<_identity_broker_saml_sp_descriptor,SP Descriptor>> available from the "
"settings of the identity provider in the brokering IDP, and add "
"`clients/_client-id_` to the endpoint URL."
msgstr ""
"基本的なクライアント設定をブローカリングIDPから外部IDPのクライアント設定にインポートすることができます。ブローカリングIDPのアイデンティティー・プロバイダーの設定から利用可能な<<_identity_broker_saml_sp_descriptor,SP"
" 記述子>>を使用し、 `clients/_client-id_` をエンドポイントURLに追加します。"

msgid "Using an entity descriptor to create a client"
msgstr "エンティティー記述子を使用したクライアントの作成"

msgid ""
"Instead of registering a SAML 2.0 client manually, you can import the client"
" using a standard SAML Entity Descriptor XML file."
msgstr ""
"SAML "
"2.0クライアントを手動で登録する代わりに、標準のSAMLエンティティー記述子XMLファイルを使用してクライアントをインポートすることができます。"

msgid "The Add Client page includes an *Import* option."
msgstr "Add Clientページには、 *Import* オプションがあります。"

msgid "Click *Select File*."
msgstr "*Select File* をクリックします。"

msgid "Load the file that contains the XML entity descriptor information."
msgstr "XMLエンティティー記述子の情報を含むファイルを読み込みます。"

msgid "Review the information to ensure everything is set up correctly."
msgstr "すべての設定が正しく行われているか、情報を確認してください。"

msgid ""
"Some SAML client adapters, such as _mod-auth-mellon_, need the XML Entity "
"Descriptor for the IDP.  You can find this descriptor by going to this URL:"
msgstr ""
"_mod-auth-melon_ "
"などの一部のSAMLクライアント・アダプターは、IDPのXMLエンティティー記述子を必要とします。この記述子は、このURLにアクセスして見つけることができます。"

msgid "root/auth/realms/{realm}/protocol/saml/descriptor"
msgstr "root/auth/realms/{realm}/protocol/saml/descriptor"

msgid "where _realm_ is the realm of your client."
msgstr "ここで、 _realm_ はクライアントのレルムです。"

msgid "Client links"
msgstr "クライアントのリンク"

msgid ""
"To link from one client to another, {project_name} provides a redirect "
"endpoint: `/realms/realm_name/clients/\\{client-id}/redirect`."
msgstr ""
"あるクライアントから別のクライアントにリンクするために、{project_name}は "
"`/realms/realm_name/clients/\\{client-id}/redirect` のリダイレクト・エンドポイントを提供しています。"

msgid ""
"If a client accesses this endpoint using a `HTTP GET` request, "
"{project_name} returns the configured base URL for the provided Client and "
"Realm in the form of an `HTTP 307` (Temporary Redirect) in the response's "
"`Location` header. As a result of this, a client needs only to know the "
"Realm name and the Client ID to link to them. This indirection avoids hard-"
"coding client base URLs."
msgstr ""
"クライアントがこのエンドポイントに `HTTP GET` "
"リクエストでアクセスすると、{project_name}は、指定されたクライアントとレルムに対して設定されたベースURLを、レスポンスの "
"`Location` ヘッダーに `HTTP 307` （Temporary "
"Redirect）の形式で返します。これにより、クライアントはレルム名とクライアントIDを知っているだけで、それらにリンクすることができます。このインダイレクトにより、クライアントのベースURLをハードコーディングする必要がなくなります。"

msgid "As an example, given the realm `master` and the client-id `account`:"
msgstr "レルム `master` とクライアントID `account` が指定されている例を、以下に示します。"

msgid "http://host:port/auth/realms/master/clients/account/redirect"
msgstr "http://host:port/auth/realms/master/clients/account/redirect"

msgid ""
"This URL temporarily redirects to: "
"http://host:port/auth/realms/master/account"
msgstr "このURLは一時的にhttp://host:port/auth/realms/master/account にリダイレクトされます。"

msgid "OIDC token and SAML assertion mappings"
msgstr "OIDCトークンとSAMLアサーションのマッピング"

msgid ""
"Applications receiving ID tokens, access tokens, or SAML assertions may "
"require different roles and user metadata."
msgstr ""
"IDトークン、アクセストークン、またはSAMLアサーションを受け取るアプリケーションは、異なるロールとユーザー・メタデータを必要とする場合があります。"

msgid "You can use {project_name} to:"
msgstr "{project_name}を使用して次のこともできます。"

msgid "Hardcode roles, claims and custom attributes."
msgstr "ロール、クレーム、カスタム属性をハードコードする。"

msgid "Pull user metadata into a token or assertion."
msgstr "ユーザーのメタデータをトークンやアサーションに含める。"

msgid "Rename roles."
msgstr "ロールの名前を変更する。"

msgid "You perform these actions in the *Mappers* tab in the Admin Console."
msgstr "これらのアクションは、管理コンソールの *Mappers* タブで実行します。"

msgid "Mappers tab"
msgstr "Mappersタブ"

msgid "image:{project_images}/mappers-oidc.png[]"
msgstr "image:{project_images}/mappers-oidc.png[]"

msgid ""
"New clients do not have built-in mappers but they can inherit some mappers "
"from client scopes. See the <<_client_scopes, client scopes section>> for "
"more details."
msgstr ""
"新規クライアントはビルトイン・マッパーを持ちませんが、クライアント・スコープからいくつかのマッパーを継承することができます。詳しくは<<_client_scopes,"
" クライアント・スコープのセクション>>を参照してください。"

msgid ""
"Protocol mappers map items (such as an email address, for example) to a "
"specific claim in the identity and access token. The function of a mapper "
"should be self explanatory from its name. You  add pre-configured mappers by"
" clicking *Add Builtin*."
msgstr ""
"プロトコル・マッパーは、アイテム（たとえば電子メールアドレスなど）をIDトークンおよびアクセストークンの特定のクレームにマッピングします。マッパーの機能は、その名前分かるはずです。事前に設定されたマッパーを追加するには、"
" *Add Builtin* をクリックします。"

msgid ""
"Each mapper has a set of common settings. Additional settings are available,"
" depending on the mapper type. Click *Edit* next to a mapper to access the "
"configuration screen to adjust these settings."
msgstr ""
"各マッパーには、共通の設定項目があります。マッパータイプによって、その他の設定も可能です。マッパーの横にある *Edit* "
"をクリックすると、設定画面にアクセスし、これらの設定を調整することができます。"

msgid "Mapper config"
msgstr "マッパーの設定"

msgid "image:{project_images}/mapper-config.png[]"
msgstr "image:{project_images}/mapper-config.png[]"

msgid "Details on each option can be viewed by hovering over its tooltip."
msgstr "各オプションの詳細は、ツールチップにカーソルを合わせると表示されます。"

msgid ""
"You can use most OIDC mappers to control where the claim gets placed. You "
"opt to include or exclude the claim from the _id_ and _access_ tokens by "
"adjusting the *Add to ID token* and *Add to access token* switches."
msgstr ""
"ほとんどのOIDCマッパーで、クレームがどこに置かれるかを制御することができます。 *Add to ID token* と *Add to access"
" token* のスイッチを調整することで、 _ID_トークンと _アクセス_ トークンからクレームを含むかどうかを選択します。"

msgid "You can add mapper types as follows:"
msgstr "マッパータイプは以下のように追加できます。"

msgid "Go to the *Mappers* tab."
msgstr "*Mappers* タブに移動します。"

msgid "Add mapper"
msgstr "マッパーを追加します。"

msgid "image:{project_images}/add-mapper.png[]"
msgstr "image:{project_images}/add-mapper.png[]"

msgid "Select a *Mapper Type* from the list box."
msgstr "リストボックスから *Mapper Type* を選択します。"

msgid "Priority order"
msgstr "優先順位"

msgid ""
"Mapper implementations have _priority order_. _Priority order_ is not the "
"configuration property of the mapper. It is the property of the concrete "
"implementation of the mapper."
msgstr ""
"マッパーの実装には _優先順位_ があります。 _優先順位_ はマッパーの設定プロパティーではなく、マッパーの具体的な実装のプロパティーです。"

msgid ""
"Mappers are sorted by the order in the list of mappers. The changes in the "
"token or assertion are applied in that order with the lowest applying first."
" Therefore, the implementations that are dependent on other implementations "
"are processed in the necessary order."
msgstr ""
"マッパーはマッパーの一覧の順番でソートされます。トークンまたはアサーションの変更は、最も低いものが最初に適用されるように、その順序で適用されます。したがって、他の実装に依存している実装は、必要な順序で処理されます。"

msgid "For example, to compute the roles which will be included with a token:"
msgstr "たとえば、あるトークンに含まれるロールを計算する場合は、次のようになります。"

msgid "Resolve audiences based on those roles."
msgstr "そのロールに基づき、Audienceを解決する。"

msgid ""
"Process a JavaScript script that uses the roles and audiences already "
"available in the token."
msgstr "トークンで既に利用可能なロールとAudienceを使用するJavaScriptのスクリプトを処理します。"

msgid "OIDC user session note mappers"
msgstr "OIDCユーザー・セッション・ノート・マッパー"

msgid ""
"User session details are defined using mappers and are automatically "
"included when you use or enable a feature on a client. Click *Add builtin* "
"to include session details."
msgstr ""
"ユーザー・セッションの詳細は、マッパーを使用して定義され、クライアントで機能を使用または有効にすると、自動的に含まれます。セッションの詳細を含めるには、"
" *Add builtin* をクリックします。"

msgid "Impersonated user sessions provide the following details:"
msgstr "代理ユーザー・セッションは、次の詳細を提供します。"

msgid "*IMPERSONATOR_ID*: The ID of an impersonating user."
msgstr "*IMPERSONATOR_ID* ：代理ユーザーのID。"

msgid "*IMPERSONATOR_USERNAME*: The username of an impersonating user."
msgstr "*IMPERSONATOR_USERNAME* ：なりすましユーザーのユーザー名。"

msgid "Service account sessions provide the following details:"
msgstr "サービス・アカウント・セッションは、次の詳細を提供します。"

msgid "*clientId*: The client ID of the service account."
msgstr "*clientId* ：サービス・アカウントのクライアントID。"

msgid ""
"*clientAddress*: The remote host IP of the service account's authenticated "
"device."
msgstr "*clientAddress* ：サービス・アカウントの認証済みデバイスのリモートホストIP。"

msgid ""
"*clientHost*: The remote host name of the service account's authenticated "
"device."
msgstr "*clientHost* ：サービス・アカウントの認証済みデバイスのリモートホスト名。"

msgid "Script mapper"
msgstr "スクリプトマッパー"

msgid ""
"Use the *Script Mapper* to map claims to tokens by running user-defined "
"JavaScript code. For more details about deploying scripts to the server, see"
" link:{developerguide_jsproviders_link}[{developerguide_jsproviders_name}]."
msgstr ""
"ユーザー定義のJavaScriptコードを実行して、クレームをトークンにマッピングするには、  *Script Mapper* "
"を使用します。サーバーへのスクリプトのデプロイの詳細については、 "
"link:{developerguide_jsproviders_link}[{developerguide_jsproviders_name}] "
"を参照してください。"

msgid ""
"When scripts deploy, you should be able to select the deployed scripts from "
"the list of available mappers."
msgstr "スクリプトがデプロイされると、利用可能なマッパーの一覧からデプロイされたスクリプトを選択できるようになるはずです。"

msgid "Generating client adapter config"
msgstr "クライアント・アダプターの設定の生成"

msgid ""
"{project_name} can generate configuration files that you can use to install "
"a client adapter in your application's deployment environment. A number of "
"adapter types are supported for OIDC and SAML."
msgstr ""
"{project_name}は、アプリケーションのデプロイメント環境にクライアント・アダプターをインストールするために使用する設定ファイルを生成できます。OIDCおよびSAMLでは、さまざまなアダプタータイプがサポートされています。"

msgid ""
"Go to the *Installation* tab of the client you want to generate "
"configuration for."
msgstr "設定を生成したいクライアントの *Installation* タブに移動します。"

msgid "image:{project_images}/client-installation.png[]"
msgstr "image:{project_images}/client-installation.png[]"

msgid "Select the *Format Option* you want configuration generated for."
msgstr "設定を生成したい *Format Option* を選択します。"

msgid ""
"All {project_name} client adapters for OIDC and SAML are supported. The mod-"
"auth-mellon Apache HTTPD adapter for SAML is supported as well as standard "
"SAML entity descriptor files."
msgstr ""
"OIDCおよびSAML用のすべての{project_name}クライアント・アダプターがサポートされています。SAML用のApache "
"HTTPDアダプターmod-auth-mellonは、標準のSAMLエンティティー記述子ファイルと同様にサポートされています。"

msgid "Client scopes"
msgstr "クライアント・スコープ"

msgid ""
"Use {project_name} to define a shared client configuration in an entity "
"called a _client scope_. A _client scope_ configures <<_protocol-mappers, "
"protocol mappers>> and <<_role_scope_mappings, role scope mappings>> for "
"multiple clients."
msgstr ""
"{project_name}を使って、 _client scope_ "
"と呼ばれるエンティティーに共有のクライアント設定を定義します。クライアントスコープ_は、複数のクライアントに対して<<_protocol-"
"mappers, プロトコル・マッパー>> と <<_role_scope_mappings, ロール・スコープ・マッピング>>を設定します。"

msgid ""
"Client scopes also support the OAuth 2 *scope* parameter. Client "
"applications use this parameter to request claims or roles in the access "
"token, depending on the requirement of the application."
msgstr ""
"クライアント・スコープは、OAuth 2の *scope* "
"パラメーターもサポートしています。クライアント・アプリケーションは、このパラメーターを使用して、アプリケーションの要件に応じてアクセストークン内のクレームやロールを要求します。"

msgid "To create a client scope, follow these steps:"
msgstr "クライアント・スコープを作成するには、次の手順を実行します。"

msgid "Click *Client Scopes* in the menu."
msgstr "メニューの *Client Scopes* をクリックします。"

msgid "Client scopes list"
msgstr "クライアント・スコープの一覧"

msgid "image:{project_images}/client-scopes-list.png[]"
msgstr "image:{project_images}/client-scopes-list.png[]"

msgid "Name your client scope."
msgstr "クライアント・スコープを指定します。"

msgid ""
"A _client scope_ has similar tabs to regular clients. You can define "
"<<_protocol-mappers, protocol mappers>> and <<_role_scope_mappings, role "
"scope mappings>>. These mappings can be inherited by other clients and are "
"configured to inherit from this client scope."
msgstr ""
"クライアントスコープ_は、通常のクライアントと同様のタブを持ちます。 <<_protocol-mappers, プロトコル・マッパー>> と "
"<_role_scope_mappings, ロール・スコープ・マッピング>> "
"を定義することができます。これらのマッピングは他のクライアントに継承させることができ、このクライアント・スコープから継承するように設定されます。"

msgid "Protocol"
msgstr "プロトコル"

msgid ""
"When you create a client scope, choose the *Protocol*. Clients linked in the"
" same scope must have the same protocol."
msgstr ""
"クライアント・スコープを作成する際に、 *Protocol* "
"を選択します。同じスコープでリンクされたクライアントは、同じプロトコルを持つ必要があります。"

msgid ""
"Each realm has a set of pre-defined built-in client scopes in the menu."
msgstr "各レルムは、メニューにあらかじめ定義されたビルトインのクライアント・スコープのセットを持っています。"

msgid ""
"SAML protocol: The *role_list*. This scope contains one protocol mapper for"
"  the roles list in the SAML assertion."
msgstr ""
"SAMLプロトコル： *role_list* 。このスコープには、SAMLアサーションに含まれるロールリストのプロトコル・マッパーが 1 つ含まれます。"

msgid "OpenID Connect protocol: Several client scopes are available:"
msgstr "OpenID Connectプロトコル：いくつかのクライアント・スコープが利用可能です。"

msgid "*roles*"
msgstr "*roles*"

msgid ""
"This scope is not defined in the OpenID Connect specification and is not "
"added automatically to the *scope* claim in the access token. This scope has"
" mappers, which are used to add the roles of the user to the access token "
"and add audiences for clients that have at least one client role. These "
"mappers are described in more detail in the <<_audience_resolve, Audience "
"section>>."
msgstr ""
"このスコープは OpenID Connectの仕様では定義されておらず、 アクセストークンの *scope* "
"クレームに自動的に追加されることはありません。このスコープにはマッパーがあり、アクセストークンにユーザーのロールを追加したり、少なくともひとつのクライアントロールを持つクライアントのAudienceを追加したりするために使用されます。これらのマッパーについては、<<_audience_resolve,"
" Audienceのセクション>>で詳しく説明しています。"

msgid "*web-origins*"
msgstr "*web-origins*"

msgid ""
"This scope is also not defined in the OpenID Connect specification and not "
"added to the *scope* claiming the access token. This scope is used to add "
"allowed web origins to the access token *allowed-origins* claim."
msgstr ""
"このスコープもOpenID Connectの仕様では定義されておらず、アクセストークンの *scope* "
"に追加されることはありません。このスコープは、アクセストークンの *allowed-origins* "
"要求に許可されたウェブオリジンを追加するために使用されます。"

msgid "*microprofile-jwt*"
msgstr "*microprofile-jwt*"

msgid ""
"This scope handles claims defined in the "
"https://wiki.eclipse.org/MicroProfile/JWT_Auth[MicroProfile/JWT Auth "
"Specification]. This scope defines a user property mapper for the *upn* "
"claim and a realm role mapper for the *groups* claim. These mappers can be "
"changed so different properties can be used to create the MicroProfile/JWT "
"specific claims."
msgstr ""
"このスコープは、 https://wiki.eclipse.org/MicroProfile/JWT_Auth[MicroProfile/JWT "
"Auth Specification] で定義されているクレームを処理するために作成されました。このクライアント・スコープは、 `upn` "
"クレーム用のユーザー・プロパティー・マッパーと `groups` "
"クレーム用のレルム・ロール・マッパーを定義します。MicroProfile/JWT固有のクレームを作成するためさまざまなプロパティーを使用できるように、これらのマッパーは必要に応じて変更できます。"

msgid "*offline_access*"
msgstr "*offline_access*"

msgid ""
"This scope is used in cases when clients need to obtain offline tokens. More"
" details on offline tokens is available in the  <<_offline-access, Offline "
"Access section>> and in the https://openid.net/specs/openid-connect-"
"core-1_0.html#OfflineAccess[OpenID Connect specification]."
msgstr ""
"このスコープは、クライアントがオフライン・トークンを取得する必要がある場合に使用されます。オフライントークンの詳細は<<_offline-access,"
" Offline Accessのセクション>>および https://openid.net/specs/openid-connect-"
"core-1_0.html#OfflineAccess[OpenID Connectの仕様] に記載されています。"

msgid "*profile*"
msgstr "*profile*"

msgid "*email*"
msgstr "*email*"

msgid "*address*"
msgstr "*address*"

msgid "*phone*"
msgstr "*phone*"

msgid ""
"The client scopes *profile*, *email*, *address* and *phone* are defined in "
"the https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims[OpenID"
" Connect specification]. These scopes do not have any role scope mappings "
"defined but they do have protocol mappers defined. These mappers correspond "
"to the claims defined in the OpenID Connect specification."
msgstr ""
"クライアント・スコープである *profile* 、*email* 、*address* および *phone* は "
"https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims[OpenID "
"Connectの仕様] で定義されています。これらのスコープにはロール・スコープ・マッピングは定義されていませんが、 "
"プロトコル・マッパーは定義されています。これらのマッパーは、OpenID Connectの仕様で定義されているクレームに対応しています。"

msgid ""
"For example, when you open the *phone* client scope and open the *Mappers* "
"tab, you will see the protocol mappers which correspond to the claims "
"defined in the specification for the scope *phone*."
msgstr ""
"たとえば、*phone* クライアント・スコープを開き、 *Mappers* タブを開くと、スコープ *phone* "
"の仕様で定義されているクレームに対応するプロトコル・マッパーが表示されます。"

msgid "Client scope mappers"
msgstr "クライアント・スコープ・マッパー"

msgid "image:{project_images}/client-scopes-phone.png[]"
msgstr "image:{project_images}/client-scopes-phone.png[]"

msgid ""
"When the *phone* client scope is linked to a client, the client "
"automatically inherits all the protocol mappers defined in the *phone* "
"client scope. Access tokens issued for this client contain the phone number "
"information about the user, assuming that the user has a defined phone "
"number."
msgstr ""
"*phone*クライアント・スコープがクライアントにリンクされると、そのクライアントは自動的に *phone* "
"クライアント・スコープで定義されているすべてのプロトコル・マッパーを継承します。このクライアントに対して発行されるアクセストークンには、ユーザーの電話番号情報が含まれます（ユーザーが定義された電話番号を持っていることが前提）。"

msgid ""
"Built-in client scopes contain the protocol mappers as defined in the "
"specification. You are free to edit client scopes and create, update, or "
"remove any protocol mappers or role scope mappings."
msgstr ""
"内蔵のクライアント・スコープには、仕様で定義されているプロトコル・マッパーが含まれています。クライアントスコープを編集し、プロトコル・マッパーやロール・スコープ・マッピングを自由に作成、更新、削除することができます。"

msgid "Consent related settings"
msgstr "同意関連の設定"

msgid ""
"Client scopes contain options related to the consent screen. Those options "
"are useful if the linked client if *Consent Required* is enabled on the "
"client."
msgstr ""
"クライアント・スコープには、同意画面に関連するオプションが含まれています。これらのオプションは、リンク先のクライアントで *Consent "
"Required* が有効になっている場合に有効です。"

msgid "Display On Consent Screen"
msgstr "同意画面での表示"

msgid ""
"If *Display On Consent Screen* is enabled, and the scope is added to a "
"client that requires consent, the text specified in *Consent Screen Text* "
"will be displayed on the consent screen. This text is shown when the user is"
" authenticated and before the user is redirected from {project_name} to the "
"client. If *Display On Consent Screen* is disabled, this client scope will "
"not be displayed on the consent screen."
msgstr ""
"*Display On Consent Screen* が有効で、スコープが同意を必要とするクライアントに追加されると、 *Consent Screen"
" Text* "
"で指定されたテキストが同意画面上に表示されます。このテキストは、ユーザーが認証されたとき、およびユーザーが{project_name}からクライアントにリダイレクトされる前に表示されます。"
" *Display On Consent Screen* が無効の場合、このクライアント・スコープは同意画面に表示されません。"

msgid "Consent Screen Text"
msgstr "同意画面テキスト"

msgid ""
"The text displayed on the consent screen when this client scope is added to "
"a client when consent required defaults to the name of client scope. The "
"value for this text can be customised by specifying a substitution variable "
"with *${var-name}* strings. The customised value is  configured within the "
"property files in your theme. See the  "
"link:{developerguide_link}[{developerguide_name}] for more information on "
"customisation."
msgstr ""
"このクライアント・スコープがクライアントに追加されたときに同意画面に表示されるテキストは、同意が必要な場合、デフォルトでクライアントスコープの名前になります。このテキストの値は、"
" *${var-name}* "
"文字列で置換変数を指定することによってカスタマイズすることができます。カスタマイズされた値は、テーマのプロパティー・ファイル内で設定されます。カスタマイズの詳細については、"
" link:{developerguide_link}[{developerguide_name}] を参照してください。"

msgid "Link client scope with the client"
msgstr "クライアントとクライアント・スコープをリンクする"

msgid ""
"Linking between a client scope and a client is configured in the *Client "
"Scopes* tab of the client. Two ways of linking between client scope and "
"client are available."
msgstr ""
"クライアントとクライアント・スコープのリンクは、クライアントの *Client Scopes* "
"タブで設定されます。クライアント・スコープとクライアントの間のリンクは、2つの方法があります。"

msgid "Default Client Scopes"
msgstr "デフォルトのクライアント・スコープ"

msgid ""
"This setting is applicable to the OpenID Connect and SAML clients. Default "
"client scopes are applied when issuing OpenID Connect tokens or SAML "
"assertions for a client. The client will inherit Protocol Mappers and Role "
"Scope Mappings that are defined on the client scope. For the OpenID Connect "
"Protocol, the Mappers and Role Scope Mappings are always applied, regardless"
" of the value used for the scope parameter in the OpenID Connect "
"authorization request."
msgstr ""
"この設定は、OpenID ConnectおよびSAMLクライアントに適用されます。クライアントのOpenID "
"ConnectトークンまたはSAMLアサーションを発行する際には、デフォルトのクライアント・スコープが適用されます。クライアントは、クライアント・スコープに定義されているプロトコル・マッパーおよびロール・スコープ・マッピングを継承します。OpenID"
" Connect プロトコルでは、OpenID "
"Connect認証リクエストのscopeパラメーターに使用される値に関係なく、マッパーおよびロール・スコープ・マッピングが常に適用されます。"

msgid "Optional Client Scopes"
msgstr "オプションのクライアント・スコープ"

msgid ""
"This setting is applicable only for OpenID Connect clients. Optional client "
"scopes are applied when issuing tokens for this client but only when "
"requested by the *scope* parameter in the OpenID Connect authorization "
"request."
msgstr ""
"この設定は、OpenID "
"Connectクライアントにのみ適用されます。オプションのクライアント・スコープは、このクライアントに対してトークンを発行するときに適用されますが、OpenID"
" Connect認可リクエストの *scope* パラメーターによって要求された場合に限られます。"

msgid "Example"
msgstr "例"

msgid ""
"For this example, assume the client has *profile* and *email* linked as "
"default client scopes, and *phone* and *address* linked as optional client "
"scopes. The client uses the value of the scope parameter when sending a "
"request to the OpenID Connect authorization endpoint."
msgstr ""
"この例では、クライアントにはデフォルトのクライアント・スコープとして *profile* と *email* "
"がリンクされており、オプションのクライアント・スコープとして *profile* と *email* "
"がリンクされていると仮定します。クライアントは、OpenID "
"Connect認可エンドポイントにリクエストを送信するときに、scopeパラメーターの値を使用します。"

msgid "scope=openid phone"
msgstr "scope=openid phone"

msgid ""
"The scope parameter contains the string, with the scope values divided by "
"spaces. The value *openid* is the meta-value used for all OpenID Connect "
"requests. The token will contain mappers and role scope mappings from the "
"default client scopes *profile* and *email* as well as *phone*, an optional "
"client scope requested by the scope parameter."
msgstr ""
"scopeパラメーターには、scope値をスペースで区切った文字列を指定します。 *openid* は、すべてのOpenID "
"Connectリクエストで使用されるメタ値です。トークンには、デフォルトのクライアント・スコープである *profile* および *email* "
"と、scopeパラメーターで要求されたオプションのクライアント・スコープである *phone* "
"のマッパーおよびロールス・コープ・マッピングが含まれることになります。"

msgid "Evaluating Client Scopes"
msgstr "クライアント・スコープの評価"

msgid ""
"The *Mappers* tab contains the protocol mappers and the *Scope* tab contains"
" the role scope mappings declared for this client. They do not contain the "
"mappers and scope mappings inherited from client scopes. It is possible to "
"see the effective protocol mappers (that is the protocol mappers defined on "
"the client itself as well as inherited from the linked client scopes) and "
"the effective role scope mappings used when generating a token for a client."
msgstr ""
"マッパー*タブにはプロトコルマッパーが、*スコープ*タブにはこのクライアント用に宣言されたロールスコープマッピングが含まれます。クライアントのスコープから継承されたマッパーとスコープマッピングは含まれません。クライアントのトークンを生成するときに使用される有効なプロトコルマッパー（クライアント自身で定義されたプロトコルマッパーおよびリンクされたクライアントスコープから継承されたプロトコルマッパー）および有効なロールスコープマッピングを確認することは可能です。"

msgid "Click the *Client Scopes* tab for the client."
msgstr "クライアントの *Client Scopes* タブをクリックします。"

msgid "Open the sub-tab *Evaluate*."
msgstr "*Evaluate* サブタブを開きます。"

msgid "Select the optional client scopes that you want to apply."
msgstr "適用したいオプションのクライアントスコープを選択します。"

msgid ""
"This will also show you the value of the *scope* parameter. This parameter "
"needs to be sent from the application to the {project_name} OpenID Connect "
"authorization endpoint."
msgstr ""
"これは、 *scope* パラメーターの値も表示されます。このパラメーターは、アプリケーションから{project_name} OpenID "
"Connect認可エンドポイントに送信される必要があります。"

msgid "Evaluating client scopes"
msgstr "クライアント・スコープの評価"

msgid "image:{project_images}/client-scopes-evaluate.png[]"
msgstr "image:{project_images}/client-scopes-evaluate.png[]"

msgid ""
"To send a custom value for a *scope* parameter from your application, see "
"the link:{adapterguide_link_latest}#_params_forwarding[parameters forwarding"
" section], for servlet adapters or the "
"link:{adapterguide_link_latest}#_javascript_adapter[javascript adapter "
"section], for javascript adapters."
msgstr ""
"アプリケーションから *scope* パラメーターにカスタム値を送るには、 サーブレット・アダプターについては "
"link:{adapterguide_link_latest}#_params_forwarding[パラメーター転送のセクション]を、JavaScript"
" アダプターについては "
"link:{adapterguide_link_latest}#_javascript_adapter[JavaScriptアダプターのセクション] "
"を参照してください。"

msgid ""
"All examples are generated for the particular user and issued for the "
"particular client, with the specified value of the *scope* parameter. The "
"examples include all of the claims and role mappings used."
msgstr ""
"すべてのサンプルは、特定のユーザーに対して生成され、特定のクライアントに対して、 *scope* "
"パラメーターの指定値で発行されます。例には、使用されたすべてのクレームとロールマッピングが含まれます。"

msgid "Client scopes permissions"
msgstr "クライアント・スコープ・パーミッション"

msgid ""
"When issuing tokens to a user, the client scope applies only if the user is "
"permitted to use it."
msgstr "ユーザーにトークンを発行する場合、クライアント・スコープが適用されるのは、そのユーザーが使用を許可されている場合のみです。"

msgid ""
"When a client scope does not have any role scope mappings defined, each user"
" is permitted to use this client scope. However, when a client scope has "
"role scope mappings defined, the user must be a member of at least one of "
"the roles. There must be an intersection between the user roles and the "
"roles of the client scope. Composite roles are factored into evaluating this"
" intersection."
msgstr ""
"クライアント・スコープにロール・スコープ・マッピングが定義されていない場合、各ユーザーはこのクライアント・スコープを使用することができます。しかし、クライアント・スコープにロール・スコープ・マッピングが定義されている場合、ユーザーは少なくとも一つのロールのメンバーである必要があります。ユーザーのロールとクライアント・スコープのロールの間に共通点がなければなりません。複合ロールはこの共通点を評価する際に考慮されます。"

msgid ""
"If a user is not permitted to use the client scope, no protocol mappers or "
"role scope mappings will be used when generating tokens. The client scope "
"will not appear in the _scope_ value in the token."
msgstr ""
"ユーザーがクライアント・スコープを使用することを許可されていない場合、トークン生成時にプロトコル・マッパーやロール・スコープ・マッピングが使用されることはありません。トークンの"
" _scope_ の値には、クライアント・スコープが表示されなくなります。"

msgid "Realm default client scopes"
msgstr "レルムのデフォルトのクライアント・スコープ"

msgid ""
"Use *Realm Default Client Scopes* to define sets of client scopes that are "
"automatically linked to newly created clients."
msgstr ""
"*Realm Default Client Scopes* "
"を使用すると、新しく作成されたクライアントに自動的にリンクされるクライアント・スコープのセットを定義することができます。"

msgid "Click *Default Client Scopes*."
msgstr "*Default Client Scopes* をクリックします。"

msgid ""
"From here, select the client scopes that you want to add as *Default Client "
"Scopes* to newly created clients and *Optional Client Scopes*."
msgstr ""
"ここから、新しく作成するクライアントに *Default Client Scopes* として追加したいクライアントスコープと *Optional "
"Client Scopes* を選択します。"

msgid "Default client scopes"
msgstr "デフォルト・クライアント・スコープ"

msgid "image:{project_images}/client-scopes-default.png[]"
msgstr "image:{project_images}/client-scopes-default.png[]"

msgid ""
"When a client is created, you can unlink the default client scopes, if "
"needed. This is similar to removing <<_default_roles, Default Roles>>."
msgstr ""
"クライアントを作成する際、必要に応じてデフォルトのクライアントスコープをアンリンクすることができます。これは、<<_default_roles, "
"デフォルトロール>>を削除するのと似ています。"

msgid "Scopes explained"
msgstr "スコープの説明"

msgid "Client scope"
msgstr "クライアント・スコープ"

msgid ""
"Client scopes are entities in {project_name} that are configured at the "
"realm level and can be linked to clients. Client scopes are referenced by "
"their name when a request is sent to the {project_name} authorization "
"endpoint with a corresponding value of the *scope* parameter. See the "
"<<_client_scopes_linking, client scopes linking>> section for more details."
msgstr ""
"クライアント・スコープとは、レルムレベルで設定される{project_name}のエンティティーであり、クライアントにリンクすることができます。クライアント・スコープは、{project_name}の認可エンドポイントに、"
" "
"*scope*パラメーターに対応する値を指定してリクエストを送信すると、その名前によって参照されます。詳細については<<_client_scopes_linking,"
" クライアント・スコープ・リンキング>>のセクションを参照してください。"

msgid "Role scope mapping"
msgstr "ロール・スコープ・マッピング"

msgid ""
"This is available under the *Scope* tab of a client or client scope. Use "
"*Role scope mapping* to limit the roles that can be used in the access "
"tokens. See the <<_role_scope_mappings, Role Scope Mappings section>> for "
"more details."
msgstr ""
"これは、クライアントまたはクライアント・スコープの *Scope* タブで使用できます。アクセストークンで使用できるロールを制限するには、 "
"*ロール・スコープ・マッピング* を使用します。詳細については、<<_role_scope_mappings, "
"ロール・スコープ・マッピングのセクション>>を参照してください。"

msgid "Authorization scopes"
msgstr "認可スコープ"

msgid ""
"The *Authorization Scope* covers the actions that can be performed in the "
"application. See the link:{authorizationguide_link}[Authorization Services "
"Guide] for more details."
msgstr ""
"*Authorization Scope* は、アプリケーションで実行可能なアクションをカバーします。詳細については、 "
"link:{authorizationguide_link}[Authorization Services Guide] を参照してください。"

msgid "Client Policies"
msgstr "クライアント・ポリシー"

msgid ""
"To make it easy to secure client applications, it is beneficial to realize "
"the following points in a unified way."
msgstr "クライアント・アプリケーションのセキュリティー保護を容易にするために、以下の点を統一的に実現することが有益です。"

msgid "Setting policies on what configuration a client can have"
msgstr "クライアントが持つことができる構成に関するポリシーの設定"

msgid "Validation of client configurations"
msgstr "クライアント設定の検証"

msgid ""
"Conformance to a required security standards and profiles such as Financial-"
"grade API (FAPI)"
msgstr "Financial-grade API（FAPI）などの必要なセキュリティー標準およびプロファイルへの準拠"

msgid ""
"To realize these points in a unified way, _Client Policies_ concept is "
"introduced."
msgstr "これらの点を統一的に実現するために、 _クライアント・ポリシー_ の概念が導入されています。"

msgid "Use-cases"
msgstr "ユースケース"

msgid "Client Policies realize the following points mentioned as follows."
msgstr "クライアント・ポリシーは、以下を実現します。"

msgid ""
"Configuration settings on the client can be enforced by client policies "
"during client creation/update, but also during OpenID Connect requests to "
"{project_name} server, which are related to particular client. "
"{project_name} supports similar thing also through the Client Registration "
"Policies described in the "
"link:{adapterguide_link}#_client_registration_policies[{adapterguide_name}]."
" However, Client Registration Policies can only cover OIDC Dynamic Client "
"Registration. Client Policies cover not only what Client Registration "
"Policies can do, but other client registration and configuration ways. The "
"current plans are for Client Registration to be replaced by Client Policies."
msgstr ""
"クライアントの構成設定は、クライアントの作成/更新中だけでなく、特定のクライアントに関連する{project_name}サーバーへのOpenID "
"Connectリクエスト中にもクライアント・ポリシーによって適用できます。{project_name}は、 "
"link:{adapterguide_link}#_client_registration_policies[{adapterguide_name}] "
"で説明されているクライアント登録ポリシーを通じても同様のことをサポートしています。ただし、クライアント登録ポリシーは、OIDC動的クライアント登録のみを対象としています。クライアント・ポリシーは、クライアント登録ポリシーで実行できることだけでなく、他のクライアント登録および設定方法も対象としています。現在の計画では、クライアント登録はクライアント・ポリシーに置き換えられます。"

msgid ""
"{project_name} supports validation whether the client follows settings like "
"Proof Key for Code Exchange, Request Object Signing Algorithm, Holder-of-Key"
" Token, and so on on some endpoints like Authorization Endpoint, Token "
"Endpoint, and so on. These can be specified by each setting item (on Admin "
"Console, switch, pulldown menu and so on). To make the client application "
"secure, the administrator needs to set many settings in the appropriate way,"
" which makes it difficult for the administrator to secure the client "
"application. Client Policies can do these validation of client "
"configurations mentioned just above and they can also be used to auto-"
"configure some client configuration switches to meet the advanced security "
"requirements. In the future, individual client configuration settings may be"
" replaced by Client Policies directly performing required validations."
msgstr ""
"{project_name}は、認可エンドポイント、トークン・エンドポイントなどのいくつかのエンドポイントで、Proof Key for Code "
"Exchange、リクエストオブジェクトの署名アルゴリズム、Holder-of-Key "
"Tokenなどの設定にクライアントが従っているかどうかの検証をサポートします。これらは、各設定項目（管理コンソール上、スイッチ、プルダウンメニューなど）で指定できます。クライアント・アプリケーションをセキュアにするためには、管理者が多くの設定を適切に行う必要があり、それは困難です。クライアント・ポリシーは、ちょうど上で述べたクライアント設定のこれらの検証を行うことができ、また、高度なセキュリティー要件を満たすために、いくつかのクライアント設定スイッチを自動設定するために使用することができます。将来的には、個々のクライアント設定に代わって、クライアント・ポリシーが必要な検証を直接行うようになるかもしれません。"

msgid "Conformance to a required security standards and profiles such as FAPI"
msgstr "FAPIなどの必要なセキュリティー標準やプロファイルへの準拠"

msgid ""
"The _Global client profiles_ are client profiles pre-configured in "
"{project_name} by default. They are pre-configured to be compliant with "
"standard security profiles like link:{adapterguide_link}#_fapi-"
"support[FAPI], which makes it easy for the administrator to secure their "
"client application to be compliant with the particular security profile. At "
"this moment, {project_name} has global profiles for the support of FAPI 1 "
"specification. The administrator will just need to configure the client "
"policies to specify which clients should be compliant with the FAPI. The "
"administrator can configure client profiles and client policies, so that "
"{project_name} clients can be easily made compliant with various other "
"security profiles like SPA, Native App, Open Banking and so on."
msgstr ""
"_Global client profiles_ "
"は、{project_name}にデフォルトで設定されているクライアント・プロファイルです。link:{adapterguide_link}#_fapi-"
"support[FAPI] "
"のような標準的なセキュリティー・プロファイルに準拠するようにあらかじめ設定されているので、管理者は簡単にクライアント・アプリケーションを特定のセキュリティー・プロファイルに準拠するように保護することができます。現時点では、{project_name}は"
" FAPI 1 "
"仕様をサポートするためのグローバル・プロファイルを持っています。管理者は、どのクライアントがFAPIに準拠すべきかを指定するために、クライアント・ポリシーを設定する必要があるだけです。管理者はクライアント・プロファイルとクライアント・ポリシーを設定することで、{project_name}のクライアントをSPA、ネイティブアプリ、オープン・バンキングなど、他のさまざまなセキュリティー・プロファイルに簡単に準拠させることができます。"

msgid ""
"The client policy concept is independent of any specific protocol. However, "
"{project_name} currently supports it only just for the "
"link:{adapterguide_link}#_oidc[OpenID Connect (OIDC) protocol]."
msgstr ""
"クライアント・ポリシーのコンセプトは、特定のプロトコルに依存しません。しかし、{project_name}は現在、link:{adapterguide_link}#_oidc[OpenID"
" Connect（OIDC）プロトコル]に対してのみ、これをサポートしています。"

msgid "Architecture"
msgstr "アーキテクチャー"

msgid ""
"Client Policies consists of the four building blocks: Condition, Executor, "
"Profile and Policy."
msgstr ""
"クライアント・ポリシーは、4つのビルディング・ブロックから構成されています。Condition、Executor、Profile、Policyです。"

msgid "Condition"
msgstr "Condition"

msgid ""
"A condition determines to which client a policy is adopted and when it is "
"adopted. Some conditions are checked at the time of client create/update "
"when some other conditions are checked during client requests (OIDC "
"Authorization request, Token endpoint request and so on). The condition "
"checks whether one specified criteria is satisfied. For example, some "
"condition checks whether the access type of the client is confidential."
msgstr ""
"Conditionとは、あるポリシーがどのクライアントにいつ採用されるかを決めるものです。あるConditionは、クライアントの作成・更新時にチェックされ、他の条件は、クライアントのリクエスト（OIDC認可リクエスト、トークン・エンドポイント・リクエストなど）時にチェックされます。Conditionは、指定された1つの条件を満たすかどうかをチェックします。たとえば、クライアントのアクセスタイプがconfidentialであるかどうかをチェックするConditionがあります。"

msgid ""
"The condition can not be used solely by itself. It can be used in a "
"<<_client_policy_policy,policy>> that is described afterwards."
msgstr ""
"このConditionは単独で使用することはできません。後述の<<_client_policy_policy,policy>>の中で使用することができます。"

msgid ""
"A condition can be configurable the same as other configurable providers. "
"What can be configured depends on each condition's nature."
msgstr ""
"Conditionは、他の設定可能なプロバイダーと同様に設定することができます。設定可能な内容は、各Conditionの性質によって異なります。"

msgid "The following conditions are provided:"
msgstr "以下のConditionがあります。"

msgid "The way of creating/updating a client"
msgstr "クライアントの作成・更新方法"

msgid ""
"Dynamic Client Registration (Anonymous or Authenticated with Initial access "
"token or Registration access token)"
msgstr "動的クライアント登録（Anonymousまたは初期アクセストークンや登録アクセストークンによる認証）"

msgid "Admin REST API (Admin Console and so on)"
msgstr "管理REST API（管理コンソールなど）"

msgid ""
"So for example when creating a client, a condition can be configured to "
"evaluate to true when this client is created by OIDC Dynamic Client "
"Registration without initial access token (Anonymous Dynamic Client "
"Registration). So this condition can be used for example to ensure that all "
"clients registered through OIDC Dynamic Client Registration are FAPI "
"compliant."
msgstr ""
"そのため、たとえばクライアントを作成する際に、そのクライアントが初期アクセストークンなしのOIDC動的クライアント登録（Anonymousの動的クライアント登録）によって作成された場合、Conditionを真と評価するように設定することが可能です。このConditionを利用することで、たとえば、OIDC動的クライアント登録で登録されたクライアントがすべてFAPIに準拠していることを確認することができます。"

msgid ""
"Author of a client (Checked by presence to the particular role or group)"
msgstr "クライアントの作成者（特定のロールまたはグループへのプレゼンスでチェックされます）"

msgid ""
"On OpenID Connect dynamic client registration, an author of a client is the "
"end user who was authenticated to get an access token for generating a new "
"client, not Service Account of the existing client that actually accesses "
"the registration endpoint with the access token. On registration by Admin "
"REST API, an author of a client is the end user like the administrator of "
"the {project_name}."
msgstr ""
"OpenID "
"Connectの動的クライアント登録において、クライアントの作成者とは、新しいクライアントを生成するためのアクセストークンを取得するために認証されたエンドユーザであり、アクセストークンを使用して登録エンドポイントに実際にアクセスした既存クライアントのサービス・アカウントではありません。管理REST"
" APIによる登録の場合、クライアントのオーサーは{project_name}の管理者のようなエンドユーザーです。"

msgid "Client Access Type (confidential, public, bearer-only)"
msgstr "クライアント・アクセス・タイプ（confidential、public、bearer-only）"

msgid ""
"For example when a client sends an authorization request, a policy is "
"adopted if this client is confidential."
msgstr "たとえば、クライアントが認可リクエストを送信したとき、このクライアントがconfidentialであれば、ポリシーが採用されます。"

msgid "Client Scope"
msgstr "クライアント・スコープ"

msgid ""
"Evaluates to true if the client has a particular client scope (either as "
"default or as an optional scope used in current request). This can be used "
"for example to ensure that OIDC authorization requests with scope `fapi-"
"example-scope` need to be FAPI compliant."
msgstr ""
"クライアントが特定のクライアント・スコープ（デフォルトあるいは現在のリクエストで使用されるオプションのスコープ）を持っている場合にtrueと評価されます。これはたとえば、"
" `fapi-example-scope` "
"というスコープを持つOIDC認可リクエストが、FAPIに準拠している必要があることを保証するために使うことができます。"

msgid "Client Role"
msgstr "クライアントロール"

msgid "Applies for clients with the client role of the specified name"
msgstr "指定された名前のクライアントロールを持つクライアントに適用されます"

msgid "Client Domain Name, Host or IP Address"
msgstr "クライアントのドメイン名、ホストまたはIPアドレス"

msgid ""
"Applied for specific domain names of client. Or for the cases when the "
"administrator registers/updates client from particular Host or IP Address."
msgstr ""
"クライアントの特定のドメイン名に対して適用されます。または、管理者が特定のホストまたはIPアドレスからクライアントを登録・更新する場合に適用されます。"

msgid "Any Client"
msgstr "任意のクライアント"

msgid ""
"This condition always evaluates to true. It can be used for example to "
"ensure that all clients in the particular realm are FAPI compliant."
msgstr ""
"このConditionは常にtrueと評価されます。これは、たとえば特定のレルム内のすべてのクライアントがFAPIに準拠していることを確認するために使用します。"

msgid "Executor"
msgstr "Executor"

msgid ""
"An executor specifies what action is executed on a client to which a policy "
"is adopted. The executor executes one or several specified actions. For "
"example, some executor checks whether the value of the parameter "
"`redirect_uri` in the authorization request matches exactly with one of the "
"pre-registered redirect URIs on Authorization Endpoint and rejects this "
"request if not."
msgstr ""
"Executorは、ポリシーが採用されたクライアントで実行されるアクションを指定します。Executorは、指定された1つまたは複数のアクションを実します。たとえば、あるExecutorは認可リクエストのパラメータ"
" `redirect_uri` "
"の値が認可エンドポイントに予め登録されているリダイレクトURIのいずれかと正確に一致するかどうかを調べ、一致しない場合はこのリクエストを拒否します。"

msgid ""
"The executor can not be used solely by itself. It can be used in a "
"<<_client_policy_profile,profile>> that is described afterwards."
msgstr ""
"Executorは単体では使用できません。後述する<<_client_policy_profile,profile>>の中で使用することができます。"

msgid ""
"An executor can be configurable the same as other configurable providers. "
"What can be configured depends on the nature of each executor."
msgstr "Executorは、他の設定可能なプロバイダーと同様に設定することができます。何が設定できるかは、各Executorの性質に依存します。"

msgid ""
"An executor acts on various events. An executor implementation can ignore "
"certain types of events (For example, executor for checking OIDC `request` "
"object acts just on the OIDC authorization request). Events are:"
msgstr ""
"Executorは、さまざまなイベントに対して動作します。Executorの実装は、ある種のイベントを無視することができます（たとえば、OIDC "
"`request` オブジェクトをチェックするExecutorは、OIDC認可リクエストに対してのみ動作します）。以下のイベントがあります。"

msgid ""
"Creating a client (including creation through dynamic client registration)"
msgstr "クライアントの作成（動的クライアント登録による作成も含みます）"

msgid "Updating a client"
msgstr "クライアントの更新"

msgid "Sending an authorization request"
msgstr "認可リクエストの送信"

msgid "Sending a token request"
msgstr "トークン・リクエストの送信"

msgid "Sending a token refresh request"
msgstr "トークン・リフレッシュ・リクエストの送信"

msgid "Sending a token revocation request"
msgstr "トークン無効化リクエストの送信"

msgid "Sending a token introspection request"
msgstr "トークン・イントロスペクション・リクエストの送信"

msgid "Sending a userinfo request"
msgstr "UserInfoリクエストの送信"

msgid "Sending a logout request with a refresh token"
msgstr "リフレッシュ・トークン付きのログアウト・リクエストの送信"

msgid ""
"On each event, an executor can work in multiple phases. For example, on "
"creating/updating a client, the executor can modify the client configuration"
" by auto-configure specific client settings. After that, the executor "
"validates this configuration in validation phase."
msgstr ""
"各イベントにおいて、Executorは複数のフェーズで動作します。たとえば、クライアントを作成・更新する場合、Executorは特定のクライアント設定を自動構成することによって、クライアント設定を変更することができます。その後、Executorは検証フェーズでこの設定を検証します。"

msgid ""
"One of several purposes for this executor is to realize the security "
"requirements of client conformance profiles like FAPI. To do so, the "
"following executors are needed:"
msgstr ""
"このExecutorのいくつかの目的の一つは、FAPIのようなクライアントのコンフォーマンス・プロファイルのセキュリティー要件を実現することです。そのためには、以下のExecutorが必要です。"

msgid ""
"Enforce secure <<_client-credentials,Client Authentication method>> is used "
"for the client"
msgstr "セキュアな<<_client-credentials,クライアント認証メソッド>>をクライアントに使用することを強制"

msgid ""
"Enforce <<_mtls-client-certificate-bound-tokens,Holder-of-key tokens>> are "
"used"
msgstr "<<_mtls-client-certificate-bound-tokens,Holder-of-keyとIークン>>の使用を強制"

msgid ""
"Enforce <<_proof-key-for-code-exchange,Proof Key for Code Exchange (PKCE)>> "
"is used"
msgstr ""
"<<_proof-key-for-code-exchange,Proof Key for Code Exchange（PKCE）>>の使用を強制"

msgid ""
"Enforce secure signature algorithm for <<_client-credentials,Signed JWT "
"client authentication (private-key-jwt)>> is used"
msgstr ""
"<<_client-credentials,Signed JWTクライアント認証（private-key-"
"jwt）>>にセキュアな署名アルゴリズムを使用することを強制"

msgid ""
"Enforce HTTPS redirect URI and make sure that configured redirect URI does "
"not contain wildcards"
msgstr "HTTPSリダイレクトURIを強制し、設定したリダイレクトURIにワイルドカードが含まれないように強制"

msgid "Enforce OIDC `request` object satisfying high security level"
msgstr "高いセキュリティー・レベルを満たすOIDC `request` オブジェクトを強制"

msgid ""
"Enforce Response Type of OIDC Hybrid Flow including ID Token used as "
"_detached signature_ as described in the FAPI 1 specification, which means "
"that ID Token returned from Authorization response won't contain user "
"profile data"
msgstr ""
"FAPI 1 仕様にあるように、認可レスポンスで返されるIDトークンにユーザー・プロフィールのデータが含まれず、 _detached "
"signature_ として使用するOIDCハイブリッド・フローのレスポンスタイプを強制"

msgid ""
"Enforce more secure `state` and `nonce` parameters treatment for preventing "
"CSRF"
msgstr "CSRFを防止するため、より安全な `state` と `nonce` パラメーターの処理を強制"

msgid "Enforce more secure signature algorithm when client registration"
msgstr "クライアント登録時に、よりセキュアな署名アルゴリズムを強制"

msgid "Enforce `binding_message` parameter is used for CIBA requests"
msgstr "CIBAリクエストに `binding_message` パラメーターを使用するように強制"

msgid "Profile"
msgstr "Profile"

msgid ""
"A profile consists of several executors, which can realize a security "
"profile like FAPI. Profile can be configured by the Admin REST API (Admin "
"Console) together with its executors. Three _global profiles_ exist and they"
" are configured in {project_name} by default with pre-configured executors "
"compliant with the FAPI Baseline, FAPI Advanced and FAPI CIBA "
"specifications. More details exist in the FAPI section of the "
"link:{adapterguide_link}#_fapi-support[{adapterguide_name}]."
msgstr ""
"Profileは複数のExecutorで構成され、FAPIのようなセキュリティー・プロファイルを実現することができます。Profileは、管理REST "
"API（管理コンソール）を用いて、Executorとともに設定することができます。3つの _global profiles_ "
"が存在し、これらはデフォルトで{project_name}に設定され、FAPI Baseline、FAPI Advanced、FAPI "
"CIBAの仕様に準拠したExecutorが事前に設定されています。詳細は link:{adapterguide_link}#_fapi-"
"support[{adapterguide_name}] のFAPIセクションに記載されています。"

msgid "Policy"
msgstr "Policy"

msgid ""
"A policy consists of several conditions and profiles. The policy can be "
"adopted to clients satisfying all conditions of this policy. The policy "
"refers several profiles and all executors of these profiles execute their "
"task against the client that this policy is adopted to."
msgstr ""
"Policyは、いくつかのConditionとProfileから構成されます。Policyは、このPolicyのすべてのConditionを満たすクライアントに採用されます。PolicyはいくつかのProfileを参照し，そのProfileのExecutgorはすべて，このPolicyが採用されたクライアントに対してタスクを実行します。"

msgid ""
"Policies, profiles, conditions, executors can be configured by Admin REST "
"API, which means also the Admin Console. To do so, there is a tab _Realm_ ->"
" _Realm Settings_ -> _Client Policies_ , which means the administrator can "
"have client policies per realm."
msgstr ""
"Policy、Profile、Condition、Executorは、管理REST "
"API、つまり管理コンソールでも設定することができます。これを行うには、 _Realm_ -> _Realm Settings_ -> _Client "
"Policies_ というタブがあり、管理者はレルムごとにクライアント・ポリシーを持つことができます。"

msgid ""
"The _Global Client Profiles_ are automatically available in each realm. "
"However there are no client policies configured by default. This means that "
"the administrator is always required to create any client policy if they "
"want for example the clients of his realm to be FAPI compliant. Global "
"profiles cannot be updated, but the administrator can easily use them as a "
"template and create their own profile if they want to do some slight changes"
" in the global profile configurations. There is JSON Editor available in the"
" Admin Console, which simplifies the creation of new profile based on some "
"global profile."
msgstr ""
"_Global Client Profiles_ "
"は各レルムで自動的に利用できます。しかし、デフォルトでは、クライアント・ポリシーは設定されていません。これは、たとえば自分のレルムのクライアントをFAPIに準拠させたい場合、管理者が常にクライアント・ポリシーを作成する必要があることを意味します。グローバル・プロファイルは更新できませんが、グローバル・プロファイルの設定を少し変更したい場合、管理者は簡単にテンプレートとして使用し、独自のプロファイルを作成することができます。管理者コンソールにはJSONエディターがあり、グローバル・プロファイルに基づいた新しいプロファイルを簡単に作成することができます。"

msgid "Backward Compatibility"
msgstr "後方互換性"

msgid ""
"Client Policies can replace Client Registration Policies described in the "
"link:{adapterguide_link}#_client_registration_policies[{adapterguide_name}]."
" However, Client Registration Policies also still co-exist. This means that "
"for example during a Dynamic Client Registration request to create/update a "
"client, both client policies and client registration policies are applied."
msgstr ""
"クライアント・ポリシーは、link:{adapterguide_link}#_client_registration_policies[{adapterguide_name}]で説明したクライアント登録ポリシーに置き換えることができます。しかし、クライアント登録ポリシーもまだ共存しています。つまり、たとえばクライアントを作成・更新するための動的クライアント登録要求の際に、クライアント・ポリシーとクライアント登録ポリシーの両方が適用されます。"

msgid ""
"The current plans are for the Client Registration Policies feature to be "
"removed and the existing client registration policies will be migrated into "
"new client policies automatically."
msgstr ""
"現在の計画では、クライアント登録ポリシー機能は削除され、既存のクライアント登録ポリシーは自動的に新しいクライアント・ポリシーに移行される予定です。"

msgid "Using a vault to obtain secrets"
msgstr "ボールトを使用してシークレットを取得する"

msgid ""
"To obtain a secret from a vault rather than entering it directly, enter the "
"following specially crafted string into the appropriate field:"
msgstr ""
"シークレットを直接入力するのではなく、ボールトからシークレットを取得するには、以下のような特別な細工をした文字列を該当するフィールドに入力します。"

msgid "**${vault.**_key_**}**"
msgstr "**${vault.**_key_**}**"

msgid "where the `_key_` is the name of the secret recognized by the vault."
msgstr "ここで、`_key_` はボールトが認識するシークレットの名前です。"

msgid ""
"To prevent secrets from leaking across realms, {project_name} combines the "
"realm name with the `_key_` obtained from the vault expression. This method "
"means that the `_key_` does not directly map to an entry in the vault but "
"creates the final entry name according to the algorithm used to combine the "
"`_key_` with the realm name."
msgstr ""
"レルム間でシークレットが漏れるのを防ぐために、 {project_name}はレルム名とボールトの式から得られる `_key_` "
"を組み合わせます。この方法では、 `_key_` はデータボールトのエントリーに直接マッピングされませんが、 `_key_` "
"とレルム名を組み合わせたアルゴリズムに従って、最終的なエントリー名を作成することになります。"

msgid "You can obtain the secret from the vault in the following fields:"
msgstr "以下のフィールドで、ボールトのシークレットを取得することができます。"

msgid "SMTP password"
msgstr "SMTPパスワード"

msgid "In the realm <<_email,SMTP settings>>"
msgstr "レルムの<<_email,SMTP設定>>"

msgid "LDAP bind credential"
msgstr "LDAPバインド・クレデンシャル"

msgid "In the <<_ldap,LDAP settings>> of LDAP-based user federation."
msgstr "LDAPベースのユーザー・フェデレーションの<<_ldap,LDAP設定>>内。"

msgid "OIDC identity provider secret"
msgstr "OIDCアイデンティティー・プロバイダー・シークレット"

msgid ""
"In the _Client Secret_ inside identity provider "
"<<_identity_broker_oidc,OpenID Connect Config>>"
msgstr ""
"アイデンティティー・プロバイダー<<_identity_broker_oidc,OpenID Connect設定>>内の _Client Secret_"
" 内。"

msgid ""
"To use a vault, register a vault provider in {project_name}. You can use the"
" providers described <<_providers, here>> or implement your provider. See "
"the link:{developerguide_link}[{developerguide_name}] for more information."
msgstr ""
"ボールトを使用するには、{project_name}にボールト・プロバイダーを登録します。プロバイダーは<<_providers, "
"ここ>>で説明されているものを使用するか、自分で実装することができます。詳しくは "
"link:{developerguide_link}[{developerguide_name}] を参照してください。"

msgid ""
"{project_name} permits a maximum of one active vault provider per "
"{project_name} instance at a time. Configure the vault provider in each "
"instance within the cluster consistently."
msgstr ""
"{project_name}では、{project_name}インスタンスごとに、一度に最大1つのアクティブなデータ・ボールト・プロバイダーが許可され "
"ます。クラスター内の各インスタンスでデータ・ボールト・プロバイダーを一貫して設定します。"

msgid "Kubernetes / OpenShift files plain-text vault provider"
msgstr "Kubernetes / OpenShift files plain-text ボールト・プロバイダー"

msgid ""
"{project_name} supports vault implementation for "
"https://kubernetes.io/docs/concepts/configuration/secret/[Kubernetes "
"secrets]. You can mount Kubernetes secrets as data volumes, and they appear "
"as a directory with a flat-file structure. {project_name} represents each "
"secret as a file with the file's name as the secret name and the file's "
"contents as the secret value."
msgstr ""
"{project_name}は、https://kubernetes.io/docs/concepts/configuration/secret/[Kubernetes"
" secrets]のVault実装をサポートしています。Kubernetes "
"secretsはデータボリュームとしてマウントでき、フラットファイル構造を持つディレクトリとして表示されます。{project_name} "
"は、各シークレットをファイルとして表現し、ファイル名をシークレット名、ファイルの内容をシークレット値として表現します。"

msgid ""
"You must name the files within this directory as the secret name prefixed by"
" the realm name and an underscore. Double all underscores within the secret "
"name or the realm name in the file name. For example, for a field within a "
"realm named `sso_realm`, a reference to a secret with the name `secret-name`"
" would be written as `${vault.secret-name}`, and the file name looked up "
"would be `sso+++__+++realm+++_+++secret-name`. Note the underscore doubled "
"in realm name."
msgstr ""
"このディレクトリ内のファイル名は、secret名の前にrealm名とアンダースコアを付けた名前にする必要があります。ファイル名中の秘密名またはレルム名中のアンダースコアをすべてダブルにします。たとえば、`sso_realm`というrealm内のフィールドで、"
" `secret-name` という名前のsecretを参照する場合、 `${vault.secret-name}` と書き、検索するファイル名は "
"`sso+++__+realm+++_+++secret-name` となります。realm名のアンダースコアが2つであることに注意してください。"

msgid ""
"To use this type of secret store, you must declare the `files-plaintext` "
"vault provider in the standalone.xml file and set its parameter for the "
"directory containing the mounted volume. This example shows the `files-"
"plaintext` provider with the directory where vault files are searched set to"
" `standalone/configuration/vault` relative to the {project_name} base "
"directory:"
msgstr ""
"このタイプの秘密結社を使用するには、standalone.xml ファイルで `files-plaintext` "
"プロバイダを宣言し、マウントされたボリュームを含むディレクトリをそのパラメータに設定する必要があります。この例では、`files-plaintext` "
"プロバイダーが、{project_name} ベースディレクトリからの相対パスで、データ保管庫ファイルが検索されるディレクトリを "
"`standalone/configuration/vault` に設定したものを示しています。"

msgid ""
"<spi name=\"vault\">\n"
"    <default-provider>files-plaintext</default-provider>\n"
"    <provider name=\"files-plaintext\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"dir\" value=\"${jboss.home.dir}/standalone/configuration/vault/\" />\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"vault\">\n"
"    <default-provider>files-plaintext</default-provider>\n"
"    <provider name=\"files-plaintext\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"dir\" value=\"${jboss.home.dir}/standalone/configuration/vault/\" />\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid "Here is the equivalent configuration using CLI commands:"
msgstr "CLIコマンドを使用した同等の設定は以下になります。"

msgid ""
"/subsystem=keycloak-server/spi=vault/:add\n"
"/subsystem=keycloak-server/spi=vault/provider=files-plaintext/:add(enabled=true,properties={dir => \"${jboss.home.dir}/standalone/configuration/vault\"})\n"
"/subsystem=keycloak-server/spi=vault:write-attribute(name=default-provider,value=files-plaintext)"
msgstr ""
"/subsystem=keycloak-server/spi=vault/:add\n"
"/subsystem=keycloak-server/spi=vault/provider=files-plaintext/:add(enabled=true,properties={dir => \"${jboss.home.dir}/standalone/configuration/vault\"})\n"
"/subsystem=keycloak-server/spi=vault:write-attribute(name=default-provider,value=files-plaintext)"

msgid "Elytron credential store vault provider"
msgstr "Elytron Credential Storeボールト・プロバイダー"

msgid ""
"{project_name} also provides support for reading secrets stored in an "
"Elytron credential store. The `elytron-cs-keystore` vault provider can "
"retrieve secrets from the credential store's keystore based implementation, "
"which is also the default implementation Elytron provides."
msgstr ""
"{project_name}はElytronのクレデンシャルストアに保存されているシークレットの読み込みもサポートしています。elytron-cs-"
"keystore`データ保管庫プロバイダは、Elytronが提供するデフォルトの実装である、キーストアに基づく実装から秘密を取得することが可能です。"

msgid ""
"A keystore backs this credential store. `JCEKS` is the default format, but "
"you can use other formats such as `PKCS12`. Users can create and manage the "
"store contents using the `elytron` subsystem in WildFly/JBoss EAP, or the "
"`elytron-tool.sh` script."
msgstr ""
"このクレデンシャルストアをバックアップするのがキーストアである。JCEKS` がデフォルトのフォーマットですが、`PKCS12` "
"などの他のフォーマットも使用できます。ユーザーは WildFly/JBoss EAP の `elytron` サブシステム、または `elytron-"
"tool.sh` スクリプトを使用してストアのコンテンツを作成および管理することができます。"

msgid ""
"To use this provider, you must declare the `elytron-cs-keystore` in the "
"`keycloak-server` subsystem and set the location and master secret of the "
"keystore created by Elytron. An example of the minimal configuration for the"
" provider follows:"
msgstr ""
"このプロバイダーを使用するには、 `keycloak-server` サブシステムで `elytron-cs-keystore` "
"を宣言し、Elytronによって作成されたキーストアの場所とマスター・シークレットを設定する必要があります。プロバイダーの最小設定の例を以下に示します。"

msgid ""
"<spi name=\"vault\">\n"
"    <default-provider>elytron-cs-keystore</default-provider>\n"
"    <provider name=\"elytron-cs-keystore\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"location\" value=\"${jboss.home.dir}/standalone/configuration/vault/credential-store.jceks\" />\n"
"            <property name=\"secret\" value=\"secretpw1!\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"vault\">\n"
"    <default-provider>elytron-cs-keystore</default-provider>\n"
"    <provider name=\"elytron-cs-keystore\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"location\" value=\"${jboss.home.dir}/standalone/configuration/vault/credential-store.jceks\" />\n"
"            <property name=\"secret\" value=\"secretpw1!\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid ""
"If the underlying keystore has a format different from `JCEKS`, you must "
"specify this format by using the `keyStoreType`:"
msgstr ""
"もし、基盤となるキーストアが `JCEKS` と異なるフォーマットである場合、 `keyStoreType` "
"を使ってそのフォーマットを指定する必要があります。"

msgid ""
"<spi name=\"vault\">\n"
"    <default-provider>elytron-cs-keystore</default-provider>\n"
"    <provider name=\"elytron-cs-keystore\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"location\" value=\"${jboss.home.dir}/standalone/configuration/vault/credential-store.p12\" />\n"
"            <property name=\"secret\" value=\"secretpw1!\"/>\n"
"            <property name=\"keyStoreType\" value=\"PKCS12\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"vault\">\n"
"    <default-provider>elytron-cs-keystore</default-provider>\n"
"    <provider name=\"elytron-cs-keystore\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"location\" value=\"${jboss.home.dir}/standalone/configuration/vault/credential-store.p12\" />\n"
"            <property name=\"secret\" value=\"secretpw1!\"/>\n"
"            <property name=\"keyStoreType\" value=\"PKCS12\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid ""
"For the secret, the `elytron-cs-keystore` provider supports clear-text "
"values and masked values by using the `elytron-tool.sh` script:"
msgstr ""
"secretについては、`elytron-cs-keystore` プロバイダが `elytron-tool.sh` "
"スクリプトを用いてクリアテキストの値とマスクされた値をサポートしています。"

msgid ""
"<spi name=\"vault\">\n"
"   ...\n"
"            <property name=\"secret\" value=\"MASK-3u2HNQaMogJJ8VP7J6gRIl;12345678;321\"/>\n"
"   ...\n"
"</spi>"
msgstr ""
"<spi name=\"vault\">\n"
"   ...\n"
"            <property name=\"secret\" value=\"MASK-3u2HNQaMogJJ8VP7J6gRIl;12345678;321\"/>\n"
"   ...\n"
"</spi>"

msgid ""
"For more information about creating and managing elytron credential stores "
"and masking keystore secrets, see the Elytron documentation."
msgstr ""
"elytronのクレデンシャルストアの作成と管理、およびキーストアの秘密のマスキングに関する詳細については、Elytronのドキュメントを参照してください。"

msgid ""
"{project_name} implements the `elytron-cs-keystore` vault provider as a "
"WildFly extension and is available if the {project_name} server runs on "
"WildFly/JBoss EAP only."
msgstr ""
"{project_name} は `elytron-cs-keystore` データ保管庫プロバイダーを WildFly "
"拡張として実装し、{project_name} サーバが WildFly/JBoss EAP 上でのみ動作する場合に利用可能です。"

msgid "Key resolvers"
msgstr "キーリゾルバー"

msgid ""
"All built-in providers support the configuration of key resolvers. A key "
"resolver implements the algorithm or strategy for combining the realm name "
"with the key, obtained from the `${vault.key}` expression, into the final "
"entry name used to retrieve the secret from the vault. {project_name} uses "
"the `keyResolvers` property to configure the resolvers that the provider "
"uses. The value is a comma-separated list of resolver names. An example of "
"the configuration for the `files-plaintext` provider follows:"
msgstr ""
"すべての組み込みプロバイダはキーリゾルバの設定をサポートしています。キーリゾルバは、レルム名と `${vault.key}` "
"式から得られるキーを組み合わせて、データ保管庫から秘密を取得するための最終的なエントリ名にするアルゴリズムや戦略を実装しています。{project_name}は"
" `keyResolvers` "
"プロパティを使用して、プロバイダが使用するリゾルバを設定します。この値は、カンマで区切られたリゾルバ名のリストです。files-plaintext` "
"プロバイダの設定の例を以下に示します。"

msgid ""
"<spi name=\"vault\">\n"
"    <default-provider>files-plaintext</default-provider>\n"
"    <provider name=\"files-plaintext\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"dir\" value=\"${jboss.home.dir}/standalone/configuration/vault/\" />\n"
"            <property name=\"keyResolvers\" value=\"REALM_UNDERSCORE_KEY, KEY_ONLY\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"vault\">\n"
"    <default-provider>files-plaintext</default-provider>\n"
"    <provider name=\"files-plaintext\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"dir\" value=\"${jboss.home.dir}/standalone/configuration/vault/\" />\n"
"            <property name=\"keyResolvers\" value=\"REALM_UNDERSCORE_KEY, KEY_ONLY\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid ""
"The resolvers run in the same order you declare them in the configuration. "
"For each resolver, {project_name} uses the last entry name the resolver "
"produces, which combines the realm with the vault key to search for the "
"vault's secret. If {project_name} finds a secret, it returns the secret. If "
"not, {project_name} uses the next resolver. This search continues until "
"{project_name} finds a non-empty secret or runs out of resolvers. If "
"{project_name} finds no secret, {project_name} returns an empty secret."
msgstr ""
"リゾルバは、構成で宣言したのと同じ順序で実行される。各リゾルバに対して、{project_name} "
"はリゾルバが最後に生成したエントリ名を使用し、レルムとデータ保管庫の鍵を組み合わせてデータ保管庫の秘密を検索する。project_name} "
"が秘密を見つけた場合、その秘密を返す。見つからない場合、{project_name} は次のリゾルバを使用する。この探索は {project_name}"
" が空でない秘密を見つけるか、リゾルバを使い果たすまで続けられる。project_name} が秘密を見つけない場合、{project_name} "
"は空の秘密を返す。"

msgid ""
"In the previous example, {project_name} uses the `REALM_UNDERSCORE_KEY` "
"resolver first. If {project_name} finds an entry in the vault that using "
"that resolver, {project_name} returns that entry. If not, {project_name} "
"searches again using the `KEY_ONLY` resolver. If {project_name} finds an "
"entry by using the `KEY_ONLY` resolver, {project_name} returns that entry. "
"If {project_name} uses all resolvers, {project_name} returns an empty "
"secret."
msgstr ""
"先ほどの例では、{project_name} が最初に `REALM_UNDERSCORE_KEY` リゾルバを使用します。もし "
"{project_name} がそのリゾルバを使ったエントリを金庫の中に見つけたら、 {project_name} "
"はそのエントリを返します。見つからない場合、{project_name} は `KEY_ONLY` "
"リゾルバを使って再度検索を行います。project_name} が `KEY_ONLY` リゾルバを使ってエントリーを見つけた場合、 "
"{project_name} はそのエントリーを返します。project_name} が全てのリゾルバを使用した場合、{project_name} "
"は空の秘密を返す。"

msgid "A list of the currently available resolvers follows:"
msgstr "現在利用可能なリゾルバーのリストは次のとおりです。"

msgid "KEY_ONLY"
msgstr "KEY_ONLY"

msgid ""
"{project_name} ignores the realm name and uses the key from the vault "
"expression."
msgstr "{project_name}はrealm名を無視し、vault式のキーを使用します。"

msgid "REALM_UNDERSCORE_KEY"
msgstr "REALM_UNDERSCORE_KEY"

msgid ""
"{project_name} combines the realm and key by using an underscore character. "
"{project_name} escapes occurrences of underscores in the realm or key with "
"another underscore character. For example, if the realm is called "
"`master_realm` and the key is `smtp_key`, the combined key is "
"`master+++__+++realm_smtp+++__+++key`."
msgstr ""
"{project_name} は、レルムとキーをアンダースコア文字で結合したものです。{project_name} は、realm や key "
"に含まれるアンダースコアを別のアンダースコア文字でエスケープします。たとえば、realmが `master_realm` で key が "
"`smtp_key` であれば、結合された key は `master+++__+++realm_smtp+++__+++key` となります。"

msgid "REALM_FILESEPARATOR_KEY"
msgstr "REALM_FILESEPARATOR_KEY"

msgid ""
"{project_name} combines the realm and key by using the platform file "
"separator character."
msgstr "{project_name} は、プラットフォームファイルのセパレータ文字を使用して、レルムとキーを結合します。"

msgid "FACTORY_PROVIDED"
msgstr "FACTORY_PROVIDED"

msgid ""
"{project_name} combines the realm and key by using the vault provider "
"factory's `VaultKeyResolver`, allowing the creation of a custom key resolver"
" by extending an existing factory and implementing the `getFactoryResolver` "
"method."
msgstr ""
"{project_name} は、Vaultプロバイダのファクトリーの `VaultKeyResolver` "
"を使ってレルムとキーを結合します。既存のファクトリーを拡張して `getFactoryResolver` "
"メソッドを実装すれば、カスタムキーリゾルバーを作成することも可能です。"

msgid ""
"If you have not configured a resolver for the built-in providers, "
"{project_name} selects the `REALM_UNDERSCORE_KEY`."
msgstr ""
"ビルトインプロバイダのリゾルバを設定していない場合、{project_name} は `REALM_UNDERSCORE_KEY` を選択します。"

msgid ""
"The `FACTORY_PROVIDED` resolver provides a hook that you can use to "
"implement a custom resolver by extending the provider factory of choice and "
"overriding the `getFactoryResolver` method, so it returns the custom "
"resolver. For example, if you want to use the `elytron-cs-keystore` provider"
" but the built-in resolvers do not match the format used in your keystore, "
"you can extend the `ElytronCSKeystoreProvider` and implement the "
"`getFactoryResolver` method:"
msgstr ""
"FACTORY_PROVIDED` リゾルバは、任意のプロバイダーファクトリを拡張して `getFactoryResolver` "
"メソッドをオーバーライドすることで、カスタムリゾルバを実装するために使用するフックを提供します。たとえば、 `elytron-cs-keystore` "
"プロバイダを使用したいが、組み込みのリゾルバはキーストアで使用するフォーマットにマッチしない場合、 "
"`ElytronCSKeystoreProvider` を拡張して `getFactoryResolver` メソッドを実装すればよいでしょう。"

msgid ""
"    public class CustomElytronProviderFactory extends ElytronCSKeyStoreProviderFactory {\n"
"        ...\n"
"        @Override\n"
"        protected VaultKeyResolver getFactoryResolver() {\n"
"            return (realm, key) -> realm + \"###\" + key;\n"
"        }\n"
"\n"
"        @Override\n"
"        public String getId() {\n"
"            return \"custom-elytron-cs-keystore;\n"
"        }\n"
"\n"
"        ...\n"
"    }"
msgstr ""
"    public class CustomElytronProviderFactory extends ElytronCSKeyStoreProviderFactory {\n"
"        ...\n"
"        @Override\n"
"        protected VaultKeyResolver getFactoryResolver() {\n"
"            return (realm, key) -> realm + \"###\" + key;\n"
"        }\n"
"\n"
"        @Override\n"
"        public String getId() {\n"
"            return \"custom-elytron-cs-keystore;\n"
"        }\n"
"\n"
"        ...\n"
"    }"

msgid ""
"The custom factory returns a key resolver that combines the realm and key "
"with a triple # character. For example, an entry would be "
"`master_realm###smtp_key`. Install this factory like any custom provider."
msgstr ""
"カスタムファクトリは、realmとkeyをトリプル#文字で結合したキーリゾルバを返します。たとえば、`master_realm##smtp_key` "
"のようなエントリーがあります。このファクトリーは、他のカスタムプロバイダと同様にインストールします。"

msgid ""
"The custom factory must override both the `getFactoryResolver` and `getId` "
"methods. The second method is necessary so that you can properly configure "
"the custom factory in {project_name}."
msgstr ""
"カスタムファクトリは `getFactoryResolver` と `getId` メソッドの両方をオーバーライドする必要があります。2番目のメソッドは"
" {project_name} でカスタムファクトリを適切に設定できるようにするために必要です。"

msgid ""
"To install and use the previous custom provider, the configuration would "
"look similar to this:"
msgstr "以前のカスタムプロバイダをインストールして使用するには、次のような構成になります。"

msgid ""
"<spi name=\"vault\">\n"
"    <default-provider>custom-elytron-cs-keystore</default-provider>\n"
"    <provider name=\"custom-elytron-cs-keystore\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"location\" value=\"${jboss.home.dir}/standalone/configuration/vault/credential-store.p12\" />\n"
"            <property name=\"secret\" value=\"MASK-3u2HNQaMogJJ8VP7J6gRIl;12345678;321\"/>\n"
"            <property name=\"keyStoreType\" value=\"PKCS12\"/>\n"
"            <property name=\"keyResolvers\" value=\"FACTORY_PROVIDED\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"vault\">\n"
"    <default-provider>custom-elytron-cs-keystore</default-provider>\n"
"    <provider name=\"custom-elytron-cs-keystore\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"location\" value=\"${jboss.home.dir}/standalone/configuration/vault/credential-store.p12\" />\n"
"            <property name=\"secret\" value=\"MASK-3u2HNQaMogJJ8VP7J6gRIl;12345678;321\"/>\n"
"            <property name=\"keyStoreType\" value=\"PKCS12\"/>\n"
"            <property name=\"keyResolvers\" value=\"FACTORY_PROVIDED\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid ""
"This configuration makes {project_name} set up the custom Elytron provider "
"and use the key resolver that the custom factory creates."
msgstr ""
"この設定により、{project_name} "
"はカスタムElytronプロバイダを設定し、カスタムファクトリが作成するキーリゾルバを使用するようになります。"

msgid "Sample Configuration"
msgstr "サンプル設定"

msgid ""
"The following is an example of configuring a vault and credential store.  "
"The procedure involves two parts:"
msgstr "以下は、ボールトとクレデンシャル・ストアを構成する例です。この手順には次の2つの部分があります。"

msgid ""
"Creating the credential store and a vault, where the credential store and "
"vault passwords are in plain text."
msgstr "クレデンシャル・ストアとボールトを作成します。クレデンシャル・ストアとボールトのパスワードは平文です。"

msgid ""
"Updating the credential store and vault to have the password use a mask "
"provided by `elytron-tool.sh`."
msgstr "パスワードに `elytron-tool.sh` で提供されたマスクを使用するように、クレデンシャル・ストアとボールトを更新します。"

msgid ""
"In this example, the test target used is an LDAP instance with `BIND DN "
"credential: secret12`. The target is mapped using user federation in the "
"realm `ldaptest`."
msgstr ""
"この例では、 `BIND DN credential: secret12` "
"を設定したLDAPインスタンスをテスト対象として使用します。このテスト対象は、レルム `ldaptest` "
"のユーザー・フェデレーションを使用してマッピングされています。"

msgid "Configuring the credential store and vault without a mask"
msgstr "マスクを使用しないクレデンシャル・ストアおよびボールトの設定"

msgid ""
"You create the credential store and a vault where the credential store and "
"vault passwords are in plain text."
msgstr "クレデンシャル・ストアとボールトを作成し、クレデンシャル・ストアとボールトのパスワードをプレーンテキストにします。"

msgid "A running LDAP instance has `BIND DN credential: secret12`."
msgstr "稼働中のLDAPインスタンスは、 `BIND DN credential: secret12` を持っています。"

msgid ""
"The alias uses the format <realm-name>_< key-value> when using the default "
"key resolver. In this case, the instance is running in the realm `ldaptest` "
"and `ldaptest_ldap_secret` is the alias that corresponds to the value "
"`ldap_secret` in that realm."
msgstr ""
"デフォルトのキーリゾルバーを使用する場合、エイリアスは<realm-name>_<key-"
"value>という形式を使用します。この例では、インスタンスはレルム `ldaptest` で動作しており、 "
"`ldaptest_ldap_secret` はそのレルムの `ldap_secret` の値に対応するエイリアスです。"

msgid ""
"The resolver replaces underscore characters with double underscore "
"characters in the realm and key names. For example, for the key "
"`ldaptest_ldap_secret`, the final key will be `ldaptest_ldap__secret`."
msgstr ""
"リゾルバーは、レルム名とキー名のアンダースコア文字をダブル・アンダースコア文字に置き換えます。たとえば、キーが "
"`ldaptest_ldap_secret` の場合、最終的なキーは `ldaptest_ldap__secret` となります。"

msgid "Create the Elytron credential store."
msgstr "Elytronのクレデンシャル・ストアを作成します。"

msgid ""
"[standalone@localhost:9990 /] /subsystem=elytron/credential-store=test-"
"store:add(create=true, location=/home/test/test-store.p12, credential-"
"reference={clear-text=testpwd1!},implementation-"
"properties={keyStoreType=PKCS12})"
msgstr ""
"[standalone@localhost:9990 /] /subsystem=elytron/credential-store=test-"
"store:add(create=true, location=/home/test/test-store.p12, credential-"
"reference={clear-text=testpwd1!},implementation-"
"properties={keyStoreType=PKCS12})"

msgid "Add an alias to the credential store."
msgstr "クレデンシャル・ストアにエイリアスを追加します。"

msgid ""
"/subsystem=elytron/credential-store=test-store:add-"
"alias(alias=ldaptest_ldap__secret,secret-value=secret12)"
msgstr ""
"/subsystem=elytron/credential-store=test-store:add-"
"alias(alias=ldaptest_ldap__secret,secret-value=secret12)"

msgid ""
"Notice how the resolver causes the key `ldaptest_ldap__secret` to use double"
" underscores."
msgstr "リゾルバーでは、キー `ldaptest_ldap__secret` にダブル・アンダースコアが使われていることに注目してください。"

msgid ""
"List the aliases from the credential store to inspect the contents of the "
"keystore that is produced by Elytron."
msgstr "クレデンシャル・ストアからエイリアスをリストアップして、Elytronが生成するキーストアのコンテンツを検査します。"

msgid ""
"keytool -list -keystore /home/test/test-store.p12 -storetype PKCS12 -storepass testpwd1!\n"
"Keystore type: PKCS12\n"
"Keystore provider: SUN\n"
"\n"
"Your keystore contains 1 entries\n"
"\n"
"ldaptest_ldap__secret/passwordcredential/clear/, Oct 12, 2020, SecretKeyEntry,"
msgstr ""
"keytool -list -keystore /home/test/test-store.p12 -storetype PKCS12 -storepass testpwd1!\n"
"Keystore type: PKCS12\n"
"Keystore provider: SUN\n"
"\n"
"Your keystore contains 1 entries\n"
"\n"
"ldaptest_ldap__secret/passwordcredential/clear/, Oct 12, 2020, SecretKeyEntry,"

msgid "Configure the vault SPI in {project_name}."
msgstr "{project_name}でボールトSPIを設定します。"

msgid ""
"/subsystem=keycloak-server/spi=vault:add(default-provider=elytron-cs-keystore)\n"
"\n"
"/subsystem=keycloak-server/spi=vault/provider=elytron-cs-keystore:add(enabled=true, properties={location=>/home/test/test-store.p12, secret=>testpwd1!, keyStoreType=>PKCS12})"
msgstr ""
"/subsystem=keycloak-server/spi=vault:add(default-provider=elytron-cs-keystore)\n"
"\n"
"/subsystem=keycloak-server/spi=vault/provider=elytron-cs-keystore:add(enabled=true, properties={location=>/home/test/test-store.p12, secret=>testpwd1!, keyStoreType=>PKCS12})"

msgid ""
"At this point, the vault and credentials store passwords are not masked."
msgstr "この時点では、ボールトとクレデンシャル・ストアのパスワードはマスクされていません。"

msgid ""
"        <spi name=\"vault\">\n"
"                <default-provider>elytron-cs-keystore</default-provider>\n"
"                <provider name=\"elytron-cs-keystore\" enabled=\"true\">\n"
"                    <properties>\n"
"                        <property name=\"location\" value=\"/home/test/test-store.p12\"/>\n"
"                        <property name=\"secret\" value=\"testpwd1!\"/>\n"
"                        <property name=\"keyStoreType\" value=\"PKCS12\"/>\n"
"                    </properties>\n"
"                </provider>\n"
"            </spi>\n"
"\n"
"         <credential-stores>\n"
"                <credential-store name=\"test-store\" location=\"/home/test/test-store.p12\" create=\"true\">\n"
"                    <implementation-properties>\n"
"                        <property name=\"keyStoreType\" value=\"PKCS12\"/>\n"
"                    </implementation-properties>\n"
"                    <credential-reference clear-text=\"testpwd1!\"/>\n"
"                </credential-store>\n"
"         </credential-stores>"
msgstr ""
"        <spi name=\"vault\">\n"
"                <default-provider>elytron-cs-keystore</default-provider>\n"
"                <provider name=\"elytron-cs-keystore\" enabled=\"true\">\n"
"                    <properties>\n"
"                        <property name=\"location\" value=\"/home/test/test-store.p12\"/>\n"
"                        <property name=\"secret\" value=\"testpwd1!\"/>\n"
"                        <property name=\"keyStoreType\" value=\"PKCS12\"/>\n"
"                    </properties>\n"
"                </provider>\n"
"            </spi>\n"
"\n"
"         <credential-stores>\n"
"                <credential-store name=\"test-store\" location=\"/home/test/test-store.p12\" create=\"true\">\n"
"                    <implementation-properties>\n"
"                        <property name=\"keyStoreType\" value=\"PKCS12\"/>\n"
"                    </implementation-properties>\n"
"                    <credential-reference clear-text=\"testpwd1!\"/>\n"
"                </credential-store>\n"
"         </credential-stores>"

msgid ""
"In the LDAP provider, replace `binDN credential` with "
"`${vault.ldap_secret}`."
msgstr "LDAPプロバイダーで、 `binDN credential` を `${vault.ldap_secret}` に置き換えてください。"

msgid "Test your LDAP connection."
msgstr "LDAP接続をテストしてください。"

msgid "LDAP Vault"
msgstr "LDAPボールト"

msgid "image:images/ldap-vault.png[LDAP Vault]"
msgstr "image:images/ldap-vault.png[LDAP Vault]"

msgid "Masking the password in the credential store and vault"
msgstr "クレデンシャル・ストアとボールトでのパスワードのマスキング"

msgid ""
"You can now update the credential store and vault to have passwords that use"
" a mask provided by `elytron-tool.sh`."
msgstr ""
"`elytron-tool.sh` が提供するマスクを使用したパスワードを設定するように、クレデンシャル・ストアとボールトを更新することができます。"

msgid ""
"Create a masked password using values for the `salt` and the `iteration` "
"parameters:"
msgstr "`salt` と `iteration` パラメーターの値を使用して、マスクされたパスワードを作成します。"

msgid ""
"$ EAP_HOME/bin/elytron-tool.sh mask --salt SALT --iteration ITERATION_COUNT "
"--secret PASSWORD"
msgstr ""
"$ EAP_HOME/bin/elytron-tool.sh mask --salt SALT --iteration ITERATION_COUNT "
"--secret PASSWORD"

msgid ""
"elytron-tool.sh mask --salt 12345678 --iteration 123 --secret testpwd1!\n"
"MASK-3BUbFEyWu0lRAu8.fCqyUk;12345678;123"
msgstr ""
"elytron-tool.sh mask --salt 12345678 --iteration 123 --secret testpwd1!\n"
"MASK-3BUbFEyWu0lRAu8.fCqyUk;12345678;123"

msgid ""
"Update the Elytron credential store configuration to use the masked "
"password."
msgstr "マスクされたパスワードを使用するように、Elytronのクレデンシャル・ストアの設定を更新します。"

msgid ""
"/subsystem=elytron/credential-store=cs-store:write-"
"attribute(name=credential-reference.clear-"
"text,value=\"MASK-3BUbFEyWu0lRAu8.fCqyUk;12345678;123\")"
msgstr ""
"/subsystem=elytron/credential-store=cs-store:write-"
"attribute(name=credential-reference.clear-"
"text,value=\"MASK-3BUbFEyWu0lRAu8.fCqyUk;12345678;123\")"

msgid ""
"Update the {project_name} vault configuration to use the masked password."
msgstr "マスクされたパスワードを使用するように{project_name}ボールトの設定を更新します。"

msgid ""
"/subsystem=keycloak-server/spi=vault/provider=elytron-cs-keystore:remove()\n"
"/subsystem=keycloak-server/spi=vault/provider=elytron-cs-keystore:add(enabled=true, properties={location=>/home/test/test-store.p12, secret=>”MASK-3BUbFEyWu0lRAu8.fCqyUk;12345678;123”, keyStoreType=>PKCS12})"
msgstr ""
"/subsystem=keycloak-server/spi=vault/provider=elytron-cs-keystore:remove()\n"
"/subsystem=keycloak-server/spi=vault/provider=elytron-cs-keystore:add(enabled=true, properties={location=>/home/test/test-store.p12, secret=>”MASK-3BUbFEyWu0lRAu8.fCqyUk;12345678;123”, keyStoreType=>PKCS12})"

msgid "The vault and credential store are now masked:"
msgstr "ボールトとクレデンシャル・ストアが次のようにマスクされます。"

msgid ""
"        <spi name=\"vault\">\n"
"                <default-provider>elytron-cs-keystore</default-provider>\n"
"                <provider name=\"elytron-cs-keystore\" enabled=\"true\">\n"
"                    <properties>\n"
"                        <property name=\"location\" value=\"/home/test/test-store.p12\"/>\n"
"                        <property name=\"secret\" value=\"MASK-3BUbFEyWu0lRAu8.fCqyUk;12345678;123\"/>\n"
"                        <property name=\"keyStoreType\" value=\"PKCS12\"/>\n"
"                    </properties>\n"
"                </provider>\n"
"            </spi>\n"
"         ....\n"
"         .....\n"
"         <credential-stores>\n"
"                <credential-store name=\"test-store\" location=\"/home/test/test-store.p12\" create=\"true\">\n"
"                    <implementation-properties>\n"
"                        <property name=\"keyStoreType\" value=\"PKCS12\"/>\n"
"                    </implementation-properties>\n"
"                    <credential-reference clear-text=\"MASK-3BUbFEyWu0lRAu8.fCqyUk;12345678;123\"/>\n"
"                </credential-store>\n"
"         </credential-stores>"
msgstr ""
"        <spi name=\"vault\">\n"
"                <default-provider>elytron-cs-keystore</default-provider>\n"
"                <provider name=\"elytron-cs-keystore\" enabled=\"true\">\n"
"                    <properties>\n"
"                        <property name=\"location\" value=\"/home/test/test-store.p12\"/>\n"
"                        <property name=\"secret\" value=\"MASK-3BUbFEyWu0lRAu8.fCqyUk;12345678;123\"/>\n"
"                        <property name=\"keyStoreType\" value=\"PKCS12\"/>\n"
"                    </properties>\n"
"                </provider>\n"
"            </spi>\n"
"         ....\n"
"         .....\n"
"         <credential-stores>\n"
"                <credential-store name=\"test-store\" location=\"/home/test/test-store.p12\" create=\"true\">\n"
"                    <implementation-properties>\n"
"                        <property name=\"keyStoreType\" value=\"PKCS12\"/>\n"
"                    </implementation-properties>\n"
"                    <credential-reference clear-text=\"MASK-3BUbFEyWu0lRAu8.fCqyUk;12345678;123\"/>\n"
"                </credential-store>\n"
"         </credential-stores>"

msgid ""
"You can now test the connection to the LDAP using `${vault.ldap_secret}`."
msgstr "これで、 `${vault.ldap_secret}` を使用してLDAPへの接続をテストすることができます。"

msgid ""
"For more information about the Elytron tool, see "
"link:https://access.redhat.com/documentation/en-"
"us/red_hat_jboss_enterprise_application_platform/7.3/html/how_to_configure_server_security/securely_storing_credentials#cred_store_elytron_client[Using"
" Credential Stores with Elytron Client]."
msgstr ""
"Elytronツールの詳細については、 link:https://access.redhat.com/documentation/en-"
"us/red_hat_jboss_enterprise_application_platform/7.3/html/how_to_configure_server_security/securely_storing_credentials#cred_store_elytron_client[Using"
" Credential Stores with Elytron Client] を参照してください。"

msgid "Configuring auditing to track events"
msgstr "イベントを追跡するための監査の設定"

msgid ""
"{project_name} includes a suite of auditing capabilities. You can record "
"every login and administrator action and review those actions in the Admin "
"Console. {project_name} also includes a Listener SPI that listens for events"
" and can trigger actions. Examples of built-in listeners include log files "
"and sending emails if an event occurs."
msgstr ""
"{project_name}には、一連の監査機能が含まれています。ログインや管理者の操作をすべて記録し、管理コンソールでその操作を確認することができます。{project_name}には、イベントをリッスンしてアクションを起こすことができるリスナーSPIも含まれています。組み込みのリスナーの例としては、ログファイルやイベント発生時のメール送信などがあります。"

msgid "Login events"
msgstr "ログインイベント"

msgid ""
"You can record and view every event that affects users. {project_name} "
"triggers login events for actions such as successful user login, a user "
"entering an incorrect password, or a user account updating. By default, "
"{project_name} does not store or display events in the Admin Console. Only "
"the error events are logged to the Admin Console and the server’s log file."
msgstr ""
"ユーザーに影響を与えるすべてのイベントを記録し、表示することができます。{project_name}は、ユーザーのログイン成功、ユーザーの不正なパスワード入力、ユーザー・アカウントの更新などのアクションに対してログインイベントをトリガーします。デフォルトでは、{project_name}は管理コンソールにイベントを保存または表示しません。エラーイベントのみが管理コンソールとサーバーのログファイルに記録されます。"

msgid "To start saving events, enable storage."
msgstr "イベントの保存を開始するには、ストレージを有効にします。"

msgid "Click *Events* in the menu."
msgstr "メニューの *Events* をクリックします。"

msgid "Click the *Config* tab."
msgstr "*Config* タブをクリックします。"

msgid "Event Configuration"
msgstr "イベントの設定"

msgid "image:{project_images}/login-events-config.png[Event Configuration]"
msgstr "image:{project_images}/login-events-config.png[Event Configuration]"

msgid "Toggle *Save Events* to *ON*."
msgstr "*Save Events* を *ON* に切り替えます。"

msgid "Save Events"
msgstr "イベントの保存"

msgid "image:{project_images}/login-events-settings.png[Save Events]"
msgstr "image:{project_images}/login-events-settings.png[Save Events]"

msgid "Specify the events to store in the *Saved Types* field."
msgstr "保存するイベントを *Saved Types* フィールドに指定します。"

msgid "You can click the *Clear events* button to delete all events."
msgstr "*Clear events* ボタンをクリックすると、すべてのイベントを消去できます。"

msgid ""
"Specify the length of time to store events in the *Expiration* field. When "
"you enable login event storage and enable your settings, click the *Save* "
"button."
msgstr ""
"*Expiration* 欄に、イベントを保存する期間を指定します。ログインイベントの保存を有効にし、設定を有効にしたら、 *Save* "
"ボタンをクリックします。"

msgid "Click the *Login Events* tab to view the events."
msgstr "ログインイベント*タブをクリックすると、イベントが表示されます。"

msgid "Login Events"
msgstr "ログインイベント"

msgid "image:{project_images}/login-events.png[Login Events]"
msgstr "image:{project_images}/login-events.png[Login Events]"

msgid "You can filter events using the *Filter* button."
msgstr "*Filter* ボタンを使って、イベントをフィルターできます。"

msgid "Login Events Filter"
msgstr "ログインイベント・フィルター"

msgid "image:{project_images}/login-events-filter.png[Login Events Filter]"
msgstr "image:{project_images}/login-events-filter.png[Login Events Filter]"

msgid ""
"In this example, we filter only `Login` events. Click *Update* to run the "
"filter."
msgstr "この例では、 `Login` イベントのみをフィルタリングします。フィルターを実行するには、 *Update* をクリックします。"

msgid "Event types"
msgstr "イベントの種類"

msgid "*Login events:*"
msgstr "*ログインイベント：*"

msgid "Event"
msgstr "イベント"

msgid "Login"
msgstr "Login"

msgid "A user logs in."
msgstr "ユーザーがログインした。"

msgid "Register"
msgstr "Register"

msgid "A user registers."
msgstr "ユーザーが登録された。"

msgid "Logout"
msgstr "ログアウト"

msgid "A user logs out."
msgstr "ユーザーがログアウトした。"

msgid "Code to Token"
msgstr "Code to Token"

msgid "An application, or client, exchanges a code for a token."
msgstr "アプリケーション（クライアント）がコードとトークンを交換した。"

msgid "Refresh Token"
msgstr "Refresh Token"

msgid "An application, or client, refreshes a token."
msgstr "アプリケーション、またはクライアントがトークンをリフレッシュした。"

msgid "*Account events:*"
msgstr "*アカウントイベント：*"

msgid "Social Link"
msgstr "Social Link"

msgid "A user account links to a social media provider."
msgstr "ユーザー・アカウントが、ソーシャル・メディア・プロバイダーとリンクされた。"

msgid "Remove Social Link"
msgstr "Remove Social Link"

msgid "The link from a social media account to a user account severs."
msgstr "ソーシャル・メディア・アカウントからユーザー・アカウントへのリンクが切れた。"

msgid "Update Email"
msgstr "Update Email"

msgid "An email address for an account changes."
msgstr "アカウントのメールアドレスが変更された。"

msgid "A profile for an account changes."
msgstr "アカウントのプロファイルが変更された。"

msgid "Send Password Reset"
msgstr "Send Password Reset"

msgid "{project_name} sends a password reset email."
msgstr "{project_name}がパスワード・リセット・メールを送信した。"

msgid "The password for an account changes."
msgstr "アカウントのパスワードが変更された。"

msgid "Update TOTP"
msgstr "Update TOTP"

msgid ""
"The Time-based One-time Password (TOTP) settings for an account changes."
msgstr "アカウントのTOTP（Time-based One-time Password）の設定が変更された。"

msgid "Remove TOTP"
msgstr "Remove TOTP"

msgid "{project_name} removes TOTP from an account."
msgstr "{project_name}がアカウントからTOTPを削除した。"

msgid "Send Verify Email"
msgstr "Send Verify Email"

msgid "{project_name} sends an email verification email."
msgstr "{project_name}が確認メールを送信した。"

msgid "{project_name} verifies the email address for an account."
msgstr "{project_name}がアカウントのメールアドレスを確認した。"

msgid "Each event has a corresponding error event."
msgstr "各イベントには、対応するエラーイベントがあります。"

msgid "Event listener"
msgstr "イベントリスナー"

msgid ""
"Event listeners listen for events and perform actions based on that event. "
"{project_name} includes two built-in listeners, the Logging Event Listener "
"and Email Event Listener."
msgstr ""
"イベントリスナーは、イベントをリスニングし、そのイベントに基づいてアクションを実行します。{project_name}には、ロギング・イベント・リスナーと電子メール・イベント・リスナーという2つの組み込みリスナーがあります。"

msgid "The logging event listener"
msgstr "ロギング・イベント・リスナー"

msgid ""
"When the Logging Event Listener is enabled, this listener writes to a log "
"file when an error event occurs."
msgstr "Logging Event Listenerが有効な場合、このリスナーはエラーイベントが発生したときにログファイルに書き込みます。"

msgid "An example log message from a Logging Event Listener:"
msgstr "ロギング・イベント・リスナーからのログメッセージの例です。"

msgid ""
"11:36:09,965 WARN  [org.keycloak.events] (default task-51) type=LOGIN_ERROR, realmId=master,\n"
"                    clientId=myapp,\n"
"                    userId=19aeb848-96fc-44f6-b0a3-59a17570d374, ipAddress=127.0.0.1,\n"
"                    error=invalid_user_credentials, auth_method=openid-connect, auth_type=code,\n"
"                    redirect_uri=http://localhost:8180/myapp,\n"
"                    code_id=b669da14-cdbb-41d0-b055-0810a0334607, username=admin"
msgstr ""
"11:36:09,965 WARN  [org.keycloak.events] (default task-51) type=LOGIN_ERROR, realmId=master,\n"
"                    clientId=myapp,\n"
"                    userId=19aeb848-96fc-44f6-b0a3-59a17570d374, ipAddress=127.0.0.1,\n"
"                    error=invalid_user_credentials, auth_method=openid-connect, auth_type=code,\n"
"                    redirect_uri=http://localhost:8180/myapp,\n"
"                    code_id=b669da14-cdbb-41d0-b055-0810a0334607, username=admin"

msgid ""
"You can use the Logging Event Listener to protect against hacker bot "
"attacks:"
msgstr "ロギング・イベント・リスナーを使用すると、ハッカーボット攻撃から保護することができます。"

msgid "Parse the log file for the `LOGIN_ERROR` event."
msgstr "`LOGIN_ERROR` イベントのログファイルを解析します。"

msgid "Extract the IP Address of the failed login event."
msgstr "ログインに失敗したイベントのIPアドレスを抽出します。"

msgid ""
"Send the IP address to an intrusion prevention software framework tool."
msgstr "侵入防止ソフトウェア・フレームワーク・ツールにIPアドレスを送信します。"

msgid ""
"The Logging Event Listener logs events to the `org.keycloak.events` log "
"category. {project_name} does not include debug log events in server logs, "
"by default."
msgstr ""
"ロギング・イベント・リスナーはイベントを `org.keycloak.events` "
"ログカテゴリーに記録します。{project_name}は、デフォルトでは、デバッグ・ログ・イベントをサーバーログに含めません。"

msgid "To include debug log events in server logs:"
msgstr "サーバーログにデバッグログイベントを含めるには、以下のようにします。"

msgid "Edit the `standalone.xml` file."
msgstr "`standalone.xml` ファイルを編集します。"

msgid "Change the log level used by the Logging Event listener."
msgstr "ロギング・イベント・リスナーが使用するログレベルを変更します。"

msgid ""
"Alternately, you can configure the log level for `org.keycloak.events`."
msgstr "代わりに、 `org.keycloak.events` のログレベルを設定できます。"

msgid "For example, to change the log level add the following:"
msgstr "たとえば、ログレベルを変更するには、以下を追加します。"

msgid ""
"<subsystem xmlns=\"urn:jboss:domain:logging:...\">\n"
"    ...\n"
"    <logger category=\"org.keycloak.events\">\n"
"        <level name=\"DEBUG\"/>\n"
"    </logger>\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"urn:jboss:domain:logging:...\">\n"
"    ...\n"
"    <logger category=\"org.keycloak.events\">\n"
"        <level name=\"DEBUG\"/>\n"
"    </logger>\n"
"</subsystem>"

msgid ""
"To change the log level used by the Logging Event listener, add the "
"following:"
msgstr "ロギング・イベントリスナーが使用するログレベルを変更するには、以下を追加します。"

msgid ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:...\">\n"
"    ...\n"
"    <spi name=\"eventsListener\">\n"
"      <provider name=\"jboss-logging\" enabled=\"true\">\n"
"        <properties>\n"
"          <property name=\"success-level\" value=\"info\"/>\n"
"          <property name=\"error-level\" value=\"error\"/>\n"
"        </properties>\n"
"      </provider>\n"
"    </spi>\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:...\">\n"
"    ...\n"
"    <spi name=\"eventsListener\">\n"
"      <provider name=\"jboss-logging\" enabled=\"true\">\n"
"        <properties>\n"
"          <property name=\"success-level\" value=\"info\"/>\n"
"          <property name=\"error-level\" value=\"error\"/>\n"
"        </properties>\n"
"      </provider>\n"
"    </spi>\n"
"</subsystem>"

msgid ""
"The valid values for log levels are `debug`, `info`, `warn`, `error`, and "
"`fatal`."
msgstr "ログレベルに有効な値は `debug`、`info`、`warn`、`error`、および `fatal` です。"

msgid "The Email Event Listener"
msgstr "電子メール・イベント・リスナー"

msgid ""
"The Email Event Listener sends an email to the user's account when an event "
"occurs and supports the following events:"
msgstr "電子メール・イベント・リスナーは、イベントが発生するとユーザーのアカウントにメールを送信し、以下のイベントをサポートします。"

msgid "Login Error."
msgstr "ログインエラー。"

msgid "Update Password."
msgstr "パスワードの更新。"

msgid "Update Time-based One-time Password (TOTP)."
msgstr "タイムベースワンタイムパスワード（TOTP）の更新。"

msgid "Remove Time-based One-time Password (TOTP)."
msgstr "時間ベースのワンタイムパスワード（TOTP）の削除。"

msgid "To enable the Email Listener:"
msgstr "電子メール・イベント・リスナーを有効にするには、次のようにします。"

msgid "Click *Events* from the menu."
msgstr "メニューから *Events* をクリックします。"

msgid "Click the *Event Listeners* field."
msgstr "*Event Listeners* フィールドをクリックします。"

msgid "Select `email`."
msgstr "`email` を選択します。"

msgid ""
"You can exclude events by editing the `standalone.xml`, `standalone-ha.xml`,"
" or `domain.xml` configuration files included in your distribution. For "
"example:"
msgstr ""
"イベントを除外するには、配布物に含まれる `standalone.xml` 、 `standalone-ha.xml` 、 `domain.xml` "
"の設定ファイルを編集してください。たとえば、以下のようにします。"

msgid ""
"<spi name=\"eventsListener\">\n"
"  <provider name=\"email\" enabled=\"true\">\n"
"    <properties>\n"
"      <property name=\"exclude-events\" value=\"[&quot;UPDATE_TOTP&quot;,&quot;REMOVE_TOTP&quot;]\"/>\n"
"    </properties>\n"
"  </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"eventsListener\">\n"
"  <provider name=\"email\" enabled=\"true\">\n"
"    <properties>\n"
"      <property name=\"exclude-events\" value=\"[&quot;UPDATE_TOTP&quot;,&quot;REMOVE_TOTP&quot;]\"/>\n"
"    </properties>\n"
"  </provider>\n"
"</spi>"

msgid ""
"You can set a maximum length of the Event detail in the database by editing "
"the `standalone.xml`, `standalone-ha.xml`, or `domain.xml` configuration "
"files. This setting is useful if a field (for example, redirect_uri) is "
"long. For example:"
msgstr ""
"`standalone.xml` 、 `standalone-ha.xml` または `domain.xml` "
"設定ファイルを編集することで、データベース内のイベント詳細の最大長を設定することができます。この設定は、あるフィールド（たとえば、redirect_uri）が長い場合に便利です。たとえば、以下のようにします。"

msgid ""
"<spi name=\"eventsStore\">\n"
"    <provider name=\"jpa\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"max-detail-length\" value=\"1000\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"eventsStore\">\n"
"    <provider name=\"jpa\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"max-detail-length\" value=\"1000\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid ""
"See the link:{installguide_link}[{installguide_name}] for more details on "
"the location of the `standalone.xml`, `standalone-ha.xml`, or `domain.xml` "
"files."
msgstr ""
"`standalone.xml` 、 `standalone-ha.xml` 、 `domain.xml` ファイルの場所については "
"link:{installguide_link}[{installguide_name}] を参照してください。"

msgid "Admin events"
msgstr "管理イベント"

msgid ""
"You can record all actions that are performed by an administrator in the "
"Admin Console. The Admin Console performs administrative actions by invoking"
" the {project_name} REST interface and {project_name} audits these REST "
"invocations. You can view the resulting events in the Admin Console."
msgstr ""
"管理者が管理コンソールで実行したすべてのアクションを記録することができます。管理コンソールは、{project_name}のRESTインターフェイスを呼び出して管理アクションを実行します。RESTインターフェイスを呼び出し、{project_name}はこれらのREST呼び出しを監査します。結果のイベントは、管理コンソールで確認できます。"

msgid "To enable auditing of Admin actions:"
msgstr "管理アクションの監査を有効にするには以下を行います。"

msgid "Event configuration"
msgstr "イベントの設定"

msgid ""
"Toggle *Save Events* to *ON* in the *Admin Events Settings* section. "
"{project_name} displays the *Include Representation* switch."
msgstr ""
"*Admin Events Settings* のセクションで、 *Save Events* を *ON* "
"に切り替えます。{project_name}は、 *Include Representation* スイッチを表示します。"

msgid "Admin event configuration"
msgstr "管理イベントの設定"

msgid ""
"image:{project_images}/admin-events-settings.png[Admin Event Configuration]"
msgstr ""
"image:{project_images}/admin-events-settings.png[Admin Event Configuration]"

msgid "Toggle *Include Representation* to *ON*."
msgstr "*Include Representation* を*ON*に切り替えます。"

msgid ""
"The `Include Representation` switch includes JSON documents sent through the"
" admin REST API so you can view the administrators actions. To clear the "
"database of stored actions, click *Clear admin events*."
msgstr ""
"`Include Representation` スイッチは、管理者のアクションを表示できるように、管理REST "
"APIを通して送られたJSONドキュメントを含みます。データベースに保存されているアクションをクリアするには、 *Clear admin events*"
" をクリックします。"

msgid "To view the admin events, click the *Admin Events* tab."
msgstr "管理イベントを表示するには、 *Admin Events* タブをクリックします。"

msgid "image:{project_images}/admin-events.png[Admin Events]"
msgstr "image:{project_images}/admin-events.png[Admin Events]"

msgid ""
"If the `Details` column has a *Representation* button, click the "
"*Representation* button to view the JSON {project_name} sent with the "
"operation."
msgstr ""
"`Details` 列に *Representation* ボタンがある場合、 *Representation* "
"ボタンをクリックして、{project_name}が操作で送信したJSONを表示します。"

msgid "Admin representation"
msgstr "管理イベントの表現"

msgid ""
"image:{project_images}/admin-events-representation.png[Admin Representation]"
msgstr ""
"image:{project_images}/admin-events-representation.png[Admin Representation]"

msgid "Click `Filter` to view specific events."
msgstr "特定のイベントを表示するには、 `Filter` をクリックします。"

msgid "Admin event filter"
msgstr "管理イベントのフィルター"

msgid "image:{project_images}/admin-events-filter.png[Admin Event Filter]"
msgstr "image:{project_images}/admin-events-filter.png[Admin Event Filter]"

msgid "Importing and exporting the database"
msgstr "データベースのインポートとエクスポート"

msgid ""
"{project_name} includes the ability to export and import its entire "
"database."
msgstr "{project_name}には、データベース全体をエクスポート、インポートする機能があります。"

msgid ""
"You can migrate the whole {project_name} database from one environment to "
"another or migrate to another database. The export/import triggers at server"
" boot time, and its parameters pass through Java properties."
msgstr ""
"{project_name}のデータベース全体をある環境から別の環境に移行したり、別のデータベースに移行することができます。エクスポート/インポートはサーバーの起動時にトリガーされ、そのパラメーターはJavaプロパティーを介して渡されます。"

msgid ""
"Because import and export trigger at server startup, take no actions on the "
"server or the database during export/import."
msgstr "インポートとエクスポートはサーバーの起動時に行われるため、エクスポート/インポート中はサーバーやデータベースに対して何もしないでください。"

msgid "You can export/import your database to:"
msgstr "データベースをエクスポート/インポートすることができます。"

msgid "A directory on the filesystem."
msgstr "ファイルシステム上のディレクトリーです。"

msgid "A single JSON file on your filesystem."
msgstr "ファイルシステム上の単一のJSONファイル"

msgid ""
"When importing from a directory, the filenames must follow this naming "
"convention:"
msgstr "ディレクトリーからインポートする場合、ファイル名はこの命名規則に従わなければなりません。"

msgid ""
"<REALM_NAME>-realm.json. For example, \"acme-roadrunner-affairs-realm.json\""
" for the realm named \"acme-roadrunner-affairs\"."
msgstr ""
"<REALM_NAME>-realm.json. For example, \"acme-roadrunner-affairs-realm.json\""
" for the realm named \"acme-roadrunner-affairs\"."

msgid ""
"<REALM_NAME>-users-<INDEX>.json. For example, \"acme-roadrunner-affairs-"
"users-0.json\" for the first user's file of the realm named \"acme-"
"roadrunner-affairs\""
msgstr ""
"<REALM_NAME>-users-<INDEX>.json. For example, \"acme-roadrunner-affairs-"
"users-0.json\" for the first user's file of the realm named \"acme-"
"roadrunner-affairs\""

msgid ""
"If you export to a directory, you can specify the number of users stored in "
"each JSON file."
msgstr "ディレクトリーにエクスポートする場合は、各JSONファイルに保存されるユーザー数を指定できます。"

msgid ""
"Exporting into single files can produce large files, so if your database "
"contains more than 500 users, export to a directory and not a single file. "
"Exporting many users into a directory performs optimally as the directory "
"provider uses a separate transaction for each \"page\" (a file of users)."
msgstr ""
"1つのファイルにエクスポートするとファイルサイズが大きくなるため、データベースに500人以上のユーザーが含まれる場合は、1つのファイルではなくディレクトリーにエクスポートしてください。多数のユーザーをディレクトリーにエクスポートすると、ディレクトリー・プロバイダーが各「ページ」（ユーザーのファイル）に対して個別のトランザクションを使用するため、最適なパフォーマンスが得られます。"

msgid ""
"The default count of users per file and per transaction is fifty, but you "
"can override this number. See <<_keycloak-migration-usersPerFile, "
"keycloak.migration.usersPerFile>> for more information."
msgstr ""
"1ファイル、1トランザクションあたりのユーザー数のデフォルトは50人ですが、この数を上書きすることができます。詳しくは <<_keycloak-"
"migration-usersPerFile, keycloak.migration.usersPerFile>> を参照してください。"

msgid ""
"Exporting to or importing from a single file uses one transaction, which can"
" impair performance if the database contains many users."
msgstr ""
"1つのファイルへのエクスポート、または1つのファイルからのインポートは1つのトランザクションを使用するため、データベースに多くのユーザーが含まれている場合、パフォーマンスが低下する可能性があります。"

msgid "To export into an unencrypted directory:"
msgstr "暗号化されていないディレクトリーにエクスポートするには以下のようにします。"

msgid ""
"bin/standalone.sh -Dkeycloak.migration.action=export\n"
"-Dkeycloak.migration.provider=dir -Dkeycloak.migration.dir=<DIR TO EXPORT TO>"
msgstr ""
"bin/standalone.sh -Dkeycloak.migration.action=export\n"
"-Dkeycloak.migration.provider=dir -Dkeycloak.migration.dir=<DIR TO EXPORT TO>"

msgid "To export into single JSON file:"
msgstr "単一のJSONファイルにエクスポートするには、以下のようにします。"

msgid ""
"bin/standalone.sh -Dkeycloak.migration.action=export\n"
"-Dkeycloak.migration.provider=singleFile -Dkeycloak.migration.file=<FILE TO EXPORT TO>"
msgstr ""
"bin/standalone.sh -Dkeycloak.migration.action=export\n"
"-Dkeycloak.migration.provider=singleFile -Dkeycloak.migration.file=<FILE TO EXPORT TO>"

msgid ""
"Similarly, for importing,use `-Dkeycloak.migration.action=import` rather "
"than `export`. For example:"
msgstr ""
"同様に、インポートする場合は、 `export` ではなく、 `-Dkeycloak.migration.action=import` "
"としてください。たとえば、以下のようになります。"

msgid ""
"bin/standalone.sh -Dkeycloak.migration.action=import\n"
"-Dkeycloak.migration.provider=singleFile -Dkeycloak.migration.file=<FILE TO IMPORT>\n"
"-Dkeycloak.migration.strategy=OVERWRITE_EXISTING"
msgstr ""
"bin/standalone.sh -Dkeycloak.migration.action=import\n"
"-Dkeycloak.migration.provider=singleFile -Dkeycloak.migration.file=<FILE TO IMPORT>\n"
"-Dkeycloak.migration.strategy=OVERWRITE_EXISTING"

msgid "Other command line options include:"
msgstr "その他のコマンドラインオプションは以下の通りです。"

msgid "-Dkeycloak.migration.realmName"
msgstr "-Dkeycloak.migration.realmName"

msgid ""
"Use this property to export one specifically named realm. If this parameter "
"is not specified, all realms export."
msgstr ""
"このプロパティーを使用して、指定された 1 "
"つのレルムをエクスポートします。このパラメーターが指定されていない場合は、すべてのレルムがエクスポートされます。"

msgid "-Dkeycloak.migration.usersExportStrategy"
msgstr "-Dkeycloak.migration.usersExportStrategy"

msgid ""
"This property specifies where users export to. Possible values include:"
msgstr "このプロパティーは、ユーザーがどこにエクスポートするかを指定します。可能な値は次のとおりです。"

msgid ""
"DIFFERENT_FILES - Users export into different files subject to the maximum "
"<<_keycloak-migration-usersPerFile, number of users per file>>. "
"DIFFERENT_FILES is the default value for this property."
msgstr ""
"DIFFERENT_FILES - ユーザーは、最大の<<_keycloak-migration-usersPerFile, "
"ファイルあたりのユーザー数>>を条件として、異なるファイルにエクスポートします。DIFFERENT_FILESは、このプロパティーのデフォルト値です。"

msgid "SKIP - {project_name} skips exporting users."
msgstr "SKIP - {project_name}ユーザーのエクスポートをスキップします。"

msgid ""
"REALM_FILE - Users export to the same file with the realm settings. The file"
" is similar to \"foo-realm.json\" with realm data and users."
msgstr ""
"REALM_FILE - ユーザーは、レルム設定のある同じファイルにエクスポートします。このファイルは「foo-"
"realm.json」と同様に、レルムデータとユーザーが含まれています。"

msgid ""
"SAME_FILE - Users export to the same file but different from the realm file."
" The result is similar to \"foo-realm.json\" with realm data and \"foo-"
"users.json\" with users."
msgstr ""
"SAME_FILE - ユーザーは同じファイルにエクスポートされますが、レルムファイルとは異なります。レルムのデータは「foo-"
"realm.json」、ユーザーは「foo-users.json」のような結果になります。"

msgid "-Dkeycloak.migration.usersPerFile"
msgstr "-Dkeycloak.migration.usersPerFile"

msgid ""
"This property specifies the number of users per file and database "
"transaction. By default, its value is fifty. {project_name} uses this "
"property if keycloak.migration.usersExportStrategy is DIFFERENT_FILES."
msgstr ""
"このプロパティーは、ファイルおよびデータベース・トランザクションごとのユーザー数を指定します。デフォルト値は 50 "
"です。{project_name}は、keycloak.migration.usersExportStrategyがDIFFERENT_FILESの場合に、このプロパティーを使用します。"

msgid "-Dkeycloak.migration.strategy"
msgstr "-Dkeycloak.migration.strategy"

msgid ""
"{project_name} uses this property when importing. It specifies how to "
"proceed when a realm with the same name already exists in the database."
msgstr ""
"{project_name}はインポート時にこのプロパティーを使用します。同じ名前のレルムがすでにデータベースに存在する場合の処理方法を指定します。"

msgid "Possible values are:"
msgstr "設定可能な値は以下の通りです。"

msgid ""
"IGNORE_EXISTING - Do not import a realm if a realm with the same name "
"already exists."
msgstr "IGNORE_EXISTING - 同じ名前のレルムがすでに存在する場合、そのレルムをインポートしません。"

msgid ""
"OVERWRITE_EXISTING - Remove the existing realm and import the realm again "
"with new data from the JSON file. Use this value to migrate from one "
"environment to another fully."
msgstr ""
"OVERWRITE_EXISTING - "
"既存のレルムを削除し、JSONファイルからの新しいデータで再びレルムをインポートします。ある環境から別の環境に完全に移行するために、この値を使用します。"

msgid ""
"If you are importing files that are not from a {project_name} export, use "
"the `keycloak.import` option. If you are importing more than one realm file,"
" specify a comma-separated list of filenames. A list of filenames is more "
"suitable than the previous cases because this happens after {project_name} "
"initializes the master realm."
msgstr ""
"{project_name}のエクスポートからではないファイルをインポートする場合は、 `keycloak.import` "
"オプションを使用してください。複数のレルムファイルをインポートする場合は、カンマで区切ったファイル名のリストを指定します。これは{project_name}がmasterレルムを初期化した後に行われるので、ファイル名のリストはこれまでのケースよりも適しています。"

msgid "Examples:"
msgstr "例"

msgid "-Dkeycloak.import=/tmp/realm1.json"
msgstr "-Dkeycloak.import=/tmp/realm1.json"

msgid "-Dkeycloak.import=/tmp/realm1.json,/tmp/realm2.json"
msgstr "-Dkeycloak.import=/tmp/realm1.json,/tmp/realm2.json"

msgid ""
"You cannot use the `keycloak.import` parameter with `keycloak.migration.X` "
"parameters. If you use these parameters together, {project_name} ignores the"
" `keycloak.import` parameter. The `keycloak.import` mechanism ignores the "
"realms which already exist in {project_name}. The `keycloak.import` "
"mechanism is convenient for development purposes, but if more flexibility is"
" needed, use the `keycloak.migration.X` parameters."
msgstr ""
"`keycloak.import` パラメーターを `keycloak.migration.X` "
"パラメーターと一緒に使用することはできません。これらのパラメーターを一緒に使った場合、{project_name}は `keycloak.import`"
" パラメーターを無視します。 `keycloak.import` の機構は{project_name}に既に存在するレルムを無視します。 "
"`keycloak.import` の機構は開発目的には便利ですが、より柔軟性が必要な場合は `keycloak.migration.X` "
"パラメーターを使用してください。"

msgid "Admin console export/import"
msgstr "管理コンソールでのエクスポート/インポート"

msgid ""
"{project_name} imports most resources from the Admin Console as well as "
"exporting most resources. {project_name} does not support the export of "
"users."
msgstr ""
"{project_name}管理コンソールからほとんどのリソースをインポートし、またほとんどのリソースをエクスポートしています。{project_name}は、ユーザーのエクスポートをサポートしていません。"

msgid ""
"{project_name} masks attributes containing secrets or private information in"
" the export file. Export files from the Admin Console are not suitable for "
"backups or data transfer between servers. Only boot-time exports are "
"suitable for backups or data transfer between servers."
msgstr ""
"{project_name}のエクスポートファイルに含まれるシークレットやプライベートな情報を含む属性をマスクします。管理コンソールからのエクスポートしたファイルは、バックアップやサーバー間のデータ転送には適していません。バックアップやサーバー間のデータ転送に適しているのは、起動時のエクスポートのみです。"

msgid ""
"You can use the files created during an export to import from the Admin "
"Console. You can export from one realm and import to another realm, or you "
"can export from one server and import to another."
msgstr ""
"エクスポート時に作成されたファイルを使用して、管理コンソールからインポートすることができます。あるレルムからエクスポートして別のレルムにインポートしたり、あるサーバーからエクスポートして別のサーバーにインポートしたりすることができます。"

msgid "The admin console export/import permits one realm per file only."
msgstr "管理コンソールのエクスポート/インポートでは、1ファイルにつき1つのレルムのみが許可されます。"

msgid ""
"The Admin Console import can overwrite resources. Use this feature with "
"caution, especially on a production server. JSON files from the Admin "
"Console Export operation are not appropriate for data import because they "
"contain invalid values for secrets."
msgstr ""
"管理コンソールのインポートでは、リソースを上書きすることができます。この機能は、特に運用サーバーでは注意して使用してください。管理コンソールのエクスポート操作によるJSONファイルには、シークレットの無効な値が含まれているため、データのインポートには適していません。"

msgid ""
"You can use the Admin Console to export clients, groups, and roles. If the "
"database in your realm contains many clients, groups, and roles, the export "
"may take a long time to conclude, and the {project_name} server may not "
"respond to user requests. Use this feature with caution, especially on a "
"production server."
msgstr ""
"管理コンソールを使用して、クライアント、グループ、およびロールをエクスポートすることができます。レルムのデータベースに多数のクライアント、グループ、およびロールが含まれている場合、エクスポートの完了までに時間がかかり、{project_name}サーバーがユーザーのリクエストに応答しないことがあります。この機能は、特に本番サーバーでは注意して使用してください。"

msgid "Mitigating security threats"
msgstr "セキュリティー上の脅威の軽減"

msgid ""
"Security vulnerabilities exist in any authentication server. See the "
"Internet Engineering Task Force's (IETF) "
"https://datatracker.ietf.org/doc/html/rfc6819[OAuth 2.0 Threat Model] and "
"the https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-"
"topics-15[OAuth 2.0 Security Best Current Practice] for more information."
msgstr ""
"セキュリティーの脆弱性は、どのような認証サーバーにも存在します。詳しくはInternet Engineering Task Force (IETF)の "
"https://datatracker.ietf.org/doc/html/rfc6819[OAuth 2.0 Threat Model] と "
"https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-"
"topics-15[OAuth 2.0 Security Best Current Practice] を参照してください。"

msgid ""
"{project_name} uses the public hostname in several ways, such as within "
"token issuer fields and URLs in password reset emails."
msgstr ""
"{project_name}は、トークン発行者のフィールドやパスワード・リセット・メールのURL内など、いくつかの方法で公開ホスト名を使用しています。"

msgid ""
"By default, the hostname derives from request headers. No validation exists "
"to ensure a hostname is valid. If you are not using a load balancer, or "
"proxy, with {project_name} to prevent invalid host headers, configure the "
"acceptable hostnames."
msgstr ""
"デフォルトでは、ホスト名はリクエスト・ヘッダーから取得できます。ホスト名が有効であることを確認する検証機能はありません。ロードバランサーやプロキシーを使用していない場合は、"
" {project_name}で無効なホストヘッダーを防ぐために、許容できるホスト名を設定してください。"

msgid ""
"The hostname's Service Provider Interface (SPI) provides a way to configure "
"the hostname for requests. You can use this built-in provider to set a fixed"
" URL for frontend requests while allowing backend requests based on the "
"request URI. If the built-in provider does not have the required capability,"
" you can develop a customized provider."
msgstr ""
"ホスト名のサービス・プロバイダー・インターフェイス（SPI）は、リクエスト用にホスト名を設定する方法を提供します。この組み込みのプロバイダーを使用すると、フロントエンドのリクエストには固定のURLを設定しつつ、リクエストURIに基づいてバックエンドのリクエストを許可することができます。組み込みのプロバイダーに必要な機能が備わっていない場合は、カスタマイズしたプロバイダーを開発することができます。"

msgid "Admin endpoints and Admin Console"
msgstr "管理エンドポイントと管理コンソール"

msgid ""
"{project_name} exposes the administrative REST API and the web console on "
"the same port as non-administrative usage by default. Do not expose "
"administrative endpoints externally if external access is not necessary. If "
"you need to expose administrative endpoints externally, you can expose them "
"directly in {project_name} or use a proxy."
msgstr ""
"デフォルトで{project_name}は、管理用REST "
"APIとWebコンソールを、非管理用と同じポートで公開します。外部からのアクセスが必要でない場合は、管理用エンドポイントを外部に公開しないでください。管理用エンドポイントを外部に公開する必要がある場合は、{project_name}で直接公開するか、プロキシーを使用します。"

msgid ""
"To expose endpoints by using a proxy, consult the documentation for the "
"proxy. You need to control access to requests to the `/auth/admin` endpoint."
msgstr ""
"プロキシーを使ってエンドポイントを公開するには、そのプロキシーのドキュメントを参照してください。 `/auth/admin` "
"エンドポイントへのリクエストへのアクセスを制御する必要があります。"

msgid ""
"Two options are available in {project_name} to expose endpoints directly, IP"
" restriction and separate ports."
msgstr "{project_name}では、エンドポイントを直接公開するために、IP制限とセパレートポートの2つのオプションが用意されています。"

msgid ""
"When the Admin Console becomes inaccessible on the frontend URL of "
"{project_name}, configure a fixed admin URL in the default hostname "
"provider."
msgstr ""
"{project_name}のフロントエンドのURLで管理コンソールにアクセスできなくなった場合は、デフォルトのホストネーム・プロバイダーに固定の管理URLを設定してください。"

msgid "IP restriction"
msgstr "IP制限"

msgid ""
"You can restrict access to `/auth/admin` to only specific IP addresses. For "
"example, restrict access to `/auth/admin` to IP addresses in the range "
"`10.0.0.1` to `10.0.0.255`."
msgstr ""
"特定のIPアドレスのみに `/auth/admin` へのアクセスを制限することができます。たとえば、 `/auth/admin` へのアクセスを、 "
"`10.0.0.1` から `10.0.0.255` の範囲のIPアドレスに制限することができます。"

msgid ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"    ...\n"
"    <server name=\"default-server\">\n"
"        ...\n"
"        <host name=\"default-host\" alias=\"localhost\">\n"
"            ...\n"
"            <filter-ref name=\"ipAccess\"/>\n"
"        </host>\n"
"    </server>\n"
"    <filters>\n"
"        <expression-filter name=\"ipAccess\" expression=\"path-prefix('/auth/admin') -> ip-access-control(acl={'10.0.0.0/24 allow'})\"/>\n"
"    </filters>\n"
"    ...\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"    ...\n"
"    <server name=\"default-server\">\n"
"        ...\n"
"        <host name=\"default-host\" alias=\"localhost\">\n"
"            ...\n"
"            <filter-ref name=\"ipAccess\"/>\n"
"        </host>\n"
"    </server>\n"
"    <filters>\n"
"        <expression-filter name=\"ipAccess\" expression=\"path-prefix('/auth/admin') -> ip-access-control(acl={'10.0.0.0/24 allow'})\"/>\n"
"    </filters>\n"
"    ...\n"
"</subsystem>"

msgid ""
"You can also restrict access to specific IP addresses by using these CLI "
"commands.:"
msgstr "また、これらのCLIコマンドを使って、特定のIPアドレスへのアクセスを制限することもできます。"

msgid ""
"/subsystem=undertow/configuration=filter/expression-filter=ipAccess:add(,expression=\"path-prefix[/auth/admin] -> ip-access-control(acl={'10.0.0.0/24 allow'})\")\n"
"/subsystem=undertow/server=default-server/host=default-host/filter-ref=ipAccess:add()"
msgstr ""
"/subsystem=undertow/configuration=filter/expression-filter=ipAccess:add(,expression=\"path-prefix[/auth/admin] -> ip-access-control(acl={'10.0.0.0/24 allow'})\")\n"
"/subsystem=undertow/server=default-server/host=default-host/filter-ref=ipAccess:add()"

msgid ""
"For IP restriction using a proxy, configure the proxy to ensure "
"{project_name} receives the client IP address and not the proxy IP address."
msgstr ""
"プロキシーを使用してIP制限を行う場合は、{project_name}がプロキシーのIPアドレスではなく、クライアントのIPアドレスを受信するようにプロキシーを設定してください。"

msgid "Port restriction"
msgstr "ポート制限"

msgid ""
"You can expose `/auth/admin` to a different unexposed port. For example, "
"expose `/auth/admin` on port `8444` and prevent access to the default port "
"`8443`."
msgstr ""
"`/auth/admin` を別の未公開ポートに公開することができます。たとえば、`/auth/admin` をポート `8444` "
"で公開し、デフォルトポート `8443` へのアクセスを防ぐことができます。"

msgid ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"    ...\n"
"    <server name=\"default-server\">\n"
"        ...\n"
"        <https-listener name=\"https\" socket-binding=\"https\" security-realm=\"ApplicationRealm\" enable-http2=\"true\"/>\n"
"        <https-listener name=\"https-admin\" socket-binding=\"https-admin\" security-realm=\"ApplicationRealm\" enable-http2=\"true\"/>\n"
"        <host name=\"default-host\" alias=\"localhost\">\n"
"            ...\n"
"            <filter-ref name=\"portAccess\"/>\n"
"        </host>\n"
"    </server>\n"
"    <filters>\n"
"        <expression-filter name=\"portAccess\" expression=\"path-prefix('/auth/admin') and not equals(%p, 8444) -> response-code(403)\"/>\n"
"    </filters>\n"
"    ...\n"
"</subsystem>\n"
"\n"
"...\n"
"\n"
"<socket-binding-group name=\"standard-sockets\" default-interface=\"public\" port-offset=\"${jboss.socket.binding.port-offset:0}\">\n"
"    ...\n"
"    <socket-binding name=\"https\" port=\"${jboss.https.port:8443}\"/>\n"
"    <socket-binding name=\"https-admin\" port=\"${jboss.https.port:8444}\"/>\n"
"    ...\n"
"</socket-binding-group>"
msgstr ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"    ...\n"
"    <server name=\"default-server\">\n"
"        ...\n"
"        <https-listener name=\"https\" socket-binding=\"https\" security-realm=\"ApplicationRealm\" enable-http2=\"true\"/>\n"
"        <https-listener name=\"https-admin\" socket-binding=\"https-admin\" security-realm=\"ApplicationRealm\" enable-http2=\"true\"/>\n"
"        <host name=\"default-host\" alias=\"localhost\">\n"
"            ...\n"
"            <filter-ref name=\"portAccess\"/>\n"
"        </host>\n"
"    </server>\n"
"    <filters>\n"
"        <expression-filter name=\"portAccess\" expression=\"path-prefix('/auth/admin') and not equals(%p, 8444) -> response-code(403)\"/>\n"
"    </filters>\n"
"    ...\n"
"</subsystem>\n"
"\n"
"...\n"
"\n"
"<socket-binding-group name=\"standard-sockets\" default-interface=\"public\" port-offset=\"${jboss.socket.binding.port-offset:0}\">\n"
"    ...\n"
"    <socket-binding name=\"https\" port=\"${jboss.https.port:8443}\"/>\n"
"    <socket-binding name=\"https-admin\" port=\"${jboss.https.port:8444}\"/>\n"
"    ...\n"
"</socket-binding-group>"

msgid ""
"You can expose `/auth/admin` on port `8444` and prevent access to the "
"default port `8443` by using CLI commands:"
msgstr ""
"CLIコマンドを使って、`/auth/admin`をポート`8444`に公開し、デフォルトのポート`8443`にはアクセスできないようにすることができます。"

msgid ""
"/socket-binding-group=standard-sockets/socket-binding=https-admin/:add(port=8444)\n"
"\n"
"/subsystem=undertow/server=default-server/https-listener=https-admin:add(socket-binding=https-admin, security-realm=ApplicationRealm, enable-http2=true)\n"
"\n"
"/subsystem=undertow/configuration=filter/expression-filter=portAccess:add(,expression=\"path-prefix('/auth/admin') and not equals(%p, 8444) -> response-code(403)\")\n"
"/subsystem=undertow/server=default-server/host=default-host/filter-ref=portAccess:add()"
msgstr ""
"/socket-binding-group=standard-sockets/socket-binding=https-admin/:add(port=8444)\n"
"\n"
"/subsystem=undertow/server=default-server/https-listener=https-admin:add(socket-binding=https-admin, security-realm=ApplicationRealm, enable-http2=true)\n"
"\n"
"/subsystem=undertow/configuration=filter/expression-filter=portAccess:add(,expression=\"path-prefix('/auth/admin') and not equals(%p, 8444) -> response-code(403)\")\n"
"/subsystem=undertow/server=default-server/host=default-host/filter-ref=portAccess:add()"

msgid "Brute force attacks"
msgstr "ブルートフォースアタック"

msgid ""
"A brute force attack attempts to guess a user's password by trying to log in"
" multiple times. {project_name} has brute force detection capabilities and "
"can temporarily disable a user account if the number of login failures "
"exceeds a specified threshold."
msgstr ""
"ブルートフォース攻撃とは、何度もログインを試みてユーザーのパスワードを推測しようとする攻撃のことです。{project_name}にはブルートフォース検知機能があり、ログイン失敗回数が指定した閾値を超えた場合、ユーザー・アカウントを一時的に無効にすることができます。"

msgid ""
"{project_name} disables brute force detection by default. Enable this "
"feature to protect against brute force attacks."
msgstr ""
"{project_name}はデフォルトで、ブルートフォース検知を無効にします。この機能を有効にすると、ブルートフォース攻撃から保護されます。"

msgid "To enable this protection:"
msgstr "この保護機能を有効にするには以下のようにします。"

msgid "Click *Realm Settings* in the menu"
msgstr "メニューの *Realm Settings* をクリックします。"

msgid "Click the *Brute Force Detection* tab."
msgstr "*Brute Force Detection* タブをクリックします。"

msgid "Brute force detection"
msgstr "ブルートフォース検出"

msgid "image:{project_images}/brute-force.png[]"
msgstr "image:{project_images}/brute-force.png[]"

msgid ""
"{project_name} can deploy permanent lockout and temporary lockout actions "
"when it detects an attack. Permanent lockout disables a user account until "
"an administrator re-enables it. Temporary lockout disables a user account "
"for a specific period of time. The time period that the account is disabled "
"increases as the attack continues."
msgstr ""
"{project_name}は、攻撃を検知すると、永久ロックアウトと一時ロックアウトのアクションを配備できます。永久ロックアウトは、管理者が再び有効にするまでユーザー・アカウントを無効にします。一時的ロックアウトは、一定期間、ユーザー・アカウントを無効にします。攻撃が続くと、アカウントが無効になる期間は長くなります。"

msgid ""
"When a user is temporarily locked and attempts to log in, {project_name} "
"displays the default `Invalid username or password` error message. This "
"message is the same error message as the message displayed for an invalid "
"username or invalid password to ensure the attacker is unaware the account "
"is disabled."
msgstr ""
"ユーザーが一時的にロックされている状態でログインしようとすると、{project_name}はデフォルトの `Invalid username or "
"password` "
"エラーメッセージを表示します。このメッセージは、無効なユーザー名や無効なパスワードの場合に表示されるメッセージと同じもので、攻撃者がアカウントが無効になっていることに気づかないようになっています。"

msgid "*Common Parameters*"
msgstr "*共通パラメーター*"

msgid "Default"
msgstr "デフォルト"

msgid "Max Login Failures"
msgstr "Max Login Failures"

msgid "The maximum number of login failures."
msgstr "ログイン失敗の最大回数。"

msgid "30 failures."
msgstr "30回失敗"

msgid "Quick Login Check Milliseconds"
msgstr "Quick Login Check Milliseconds"

msgid "The minimum time between login attempts."
msgstr "ログインを試みるまでの最小時間。"

msgid "1000 milliseconds."
msgstr "1000ミリ秒"

msgid "Minimum Quick Login Wait"
msgstr "Minimum Quick Login Wait"

msgid ""
"The minimum time the user is disabled when login attempts are quicker than "
"_Quick Login Check Milliseconds_."
msgstr ""
"ログイン試行が _Quick Login Check Milliseconds_ よりも早かった場合に、ユーザーを無効にする最小の時間です。"

msgid "1 minute."
msgstr "1分"

msgid "*Permanent Lockout Flow*"
msgstr "*永続的ロックアウト・フロー*"

msgid "On successful login"
msgstr "ログインに成功した場合"

msgid "Reset `count`"
msgstr "`count` のリセット"

msgid "On failed login"
msgstr "ログインに失敗した場合"

msgid "Increment `count`"
msgstr "`count` のインクリメント"

msgid "If `count` greater than _Max Login Failures_"
msgstr "`count` が _Max Login Failures_ より大きい場合 ..."

msgid "Permanently disable user"
msgstr "ユーザーを永続的に無効にします"

msgid ""
"Else if the time between this failure and the last failure is less than "
"_Quick Login Check Milliseconds_"
msgstr "今回の失敗と前回の失敗の間の時間が _Quick Login Check Milliseconds_ よりも短ければ ..."

msgid "Temporarily disable user for _Minimum Quick Login Wait_"
msgstr "_Minimum Quick Login Wait_ の間、ユーザーを一時的に無効にします"

msgid ""
"When {project_name} disables a user, the user cannot log in until an "
"administrator enables the user. Enabling an account resets the `count`."
msgstr ""
"{project_name}がユーザーを無効にすると、管理者がそのユーザーを有効にするまで、そのユーザーはログインできなくなります。アカウントを有効にすると、`count`がリセットされます。"

msgid "*Temporary Lockout Parameters*"
msgstr "*一時ロックアウト・パラメーター*"

msgid "Wait Increment"
msgstr "Wait Increment"

msgid ""
"The time added to the time a user is temporarily disabled when the user's "
"login attempts exceed _Max Login Failures_."
msgstr "ユーザーのログイン試行回数が _Max Login Failures_ を超えたときに、ユーザーが一時的に無効になる時間を加算した時間。"

msgid "Max Wait"
msgstr "Max Wait"

msgid "The maximum time a user is temporarily disabled."
msgstr "ユーザーが一時的に無効になる最大時間。"

msgid "15 minutes."
msgstr "15分"

msgid "Failure Reset Time"
msgstr "Failure Reset Time"

msgid ""
"The time when the failure count resets. The timer runs from the last failed "
"login."
msgstr "失敗回数がリセットされる時間です。このタイマーは、最後に失敗したログインから実行されます。"

msgid "12 hours."
msgstr "12時間"

msgid "*Temporary Lockout Algorithm*"
msgstr "*一時的ロックアウト・アルゴリズム*"

msgid ""
"If the time between this failure and the last failure is greater than "
"_Failure Reset Time_"
msgstr "今回の故障から前回の故障までの時間が _Failure Reset Time_ よりも長い場合 ..."

msgid ""
"Calculate `wait` using _Wait Increment_ * (`count` / _Max Login Failures_). "
"The division is an integer division rounded down to a whole number"
msgstr ""
"_Wait Increment_ * (`count` / _Max Login Failures_) を使って `wait` "
"を計算します。除算は整数に切り捨てられた整数除算です。"

msgid ""
"If `wait` equals 0 and the time between this failure and the last failure is"
" less than _Quick Login Check Milliseconds_, set `wait` to _Minimum Quick "
"Login Wait_."
msgstr ""
"`wait` が0で、今回の失敗と前回の失敗の間の時間が  _Quick Login Check Milliseconds_ 以下の場合、 `wait`"
" を _Minimum Quick Login Wait_ に設定します。"

msgid ""
"Temporarily disable the user for the smaller of `wait` and _Max Wait_ "
"seconds"
msgstr "`wait` と _Max Wait_ の秒数が小さい間、ユーザーを一時的に無効にします"

msgid ""
"'count` does not increment when a temporarily disabled account commits a "
"login failure."
msgstr "一時的に無効化されたアカウントがログインに失敗しても、 'count` は増加しません。"

msgid ""
"The downside of {project_name} brute force detection is that the server "
"becomes vulnerable to denial of service attacks. When implementing a denial "
"of service attack, an attacker can attempt to log in by guessing passwords "
"for any accounts it knows and eventually causing {project_name} to disable "
"the accounts."
msgstr ""
"{project_name}のブルートフォース検出の欠点は、サーバーがサービス拒否攻撃に対して脆弱になることです。サービス拒否攻撃を行う場合、攻撃者は知っているアカウントのパスワードを推測してログインを試み、最終的に{project_name}のアカウントを無効にすることができます。"

msgid ""
"Consider using intrusion prevention software (IPS). {project_name} logs "
"every login failure and client IP address failure. You can point the IPS to "
"the {project_name} server's log file, and the IPS can modify firewalls to "
"block connections from these IP addresses."
msgstr ""
"侵入防止ソフトウェア（IPS）の使用を検討します。{project_name}は、ログインの失敗やクライアントのIPアドレスの失敗をすべて記録します。IPSは{project_name}サーバーのログファイルを指定することができ、IPSはこれらのIPアドレスからの接続をブロックするようにファイアウォールを変更することができます。"

msgid ""
"Ensure you have a complex password policy to force users to choose complex "
"passwords. See the <<_password-policies, Password Policies>> chapter for "
"more information. Prevent password guessing by setting up the {project_name}"
" server to use one-time-passwords."
msgstr ""
"複雑なパスワード・ポリシーを設定して、ユーザーに複雑なパスワードを選択させるようにしてください。詳しくは<<_password-policies, "
"Password "
"Policies>>を参照してください。{project_name}サーバーでワンタイムパスワードを使用するように設定することで、パスワードの推測を防ぐことができます。"

msgid "Read-only user attributes"
msgstr "読み取り専用のユーザー属性"

msgid ""
"Typical users who are stored in {project_name} have various attributes "
"related to their user profiles. Such attributes include email, firstName or "
"lastName. However users may also have attributes, which are not typical "
"profile data, but rather metadata. The metadata attributes usually should be"
" read-only for the users and the typical users never should have a way to "
"update those attributes from the {project_name} user interface or Account "
"REST API. Some of the attributes should be even read-only for the "
"administrators when creating or updating user with the Admin REST API."
msgstr ""
"{project_name}に保存されている一般的なユーザーには、ユーザー・プロファイルに関連するさまざまな属性があります。このような属性には、email、firstName、またはlastnameが含まれます。ただし、ユーザーは、一般的なプロファイル・データではなく、メタデータである属性を持っている場合もあります。メタデータ属性は通常、ユーザーに対して読み取り専用である必要があり、通常のユーザーは、{project_name}ユーザー・インターフェイスまたはアカウントREST"
" APIからこれらの属性を更新する方法を持ってはなりません。一部の属性は、管理REST "
"APIを使用してユーザーを作成または更新するときに、管理者に対して読み取り専用にする必要があります。"

msgid "The metadata attributes are usually attributes from those groups:"
msgstr "メタデータ属性は通常、これらのグループの属性です。"

msgid ""
"Various links or metadata related to the user storage providers. For example"
" in case of the LDAP integration, the `LDAP_ID` attribute contains the ID of"
" the user in the LDAP server."
msgstr ""
"ユーザー・ストレージ・プロバイダーに関連するさまざまなリンクまたはメタデータ。たとえば、LDAP統合の場合、 `LDAP_ID` "
"属性にはLDAPサーバー内のユーザーのIDが含まれます。"

msgid ""
"Metadata provisioned by User Storage. For example `createdTimestamp` "
"provisioned from the LDAP should be always read-only by user or "
"administrator."
msgstr ""
"ユーザー・ストレージによってプロビジョニングされたメタデータ。たとえば、LDAPからプロビジョニングされた `createdTimestamp` "
"は、ユーザーまたは管理者が常に読み取り専用にする必要があります。"

msgid ""
"Metadata related to various authenticators. For example `KERBEROS_PRINCIPAL`"
" attribute can contain the kerberos principal name of the particular user. "
"Similarly attribute `usercertificate` can contain metadata related to "
"binding the user with the data from the X.509 certificate, which is used "
"typically when X.509 certificate authentication is enabled."
msgstr ""
"さまざまなオーセンティケーターに関連するメタデータ。たとえば、 `KERBEROS_PRINCIPAL` "
"属性には、特定のユーザーのKerberosプリンシパル名を含めることができます。同様に、 `usercertificate` "
"属性には、X.509証明書からのデータを使用してユーザーをバインドすることに関連するメタデータを含めることができます。これは通常、X.509証明書認証が有効になっている場合に使用されます。"

msgid ""
"Metadata related to the identificator of users by the applications/clients. "
"For example `saml.persistent.name.id.for.my_app` can contain SAML NameID, "
"which will be used by the client application `my_app` as the identifier of "
"the user."
msgstr ""
"アプリケーション/クライアントによるユーザーの識別子に関連するメタデータ。たとえば、 "
"`saml.persistent.name.id.for.my_app` には、クライアント・アプリケーション `my_app` "
"がユーザーの識別子として使用するSAMLNameIDを含めることができます。"

msgid ""
"Metadata related to the authorization policies, which are used for the "
"attribute based access control (ABAC). Values of those attributes may be "
"used for the authorization decisions. Hence it is important that those "
"attributes cannot be updated by the users."
msgstr ""
"属性ベースのアクセス・コントロール（ABAC）に使用される認可ポリシーに関連するメタデータ。これらの属性の値は、認可の決定に使用できます。したがって、これらの属性をユーザーが更新できないことが重要です。"

msgid ""
"From the long term perspective, {project_name} will have a proper User "
"Profile SPI, which will allow fine-grained configuration of every user "
"attribute. Currently this capability is not fully available yet. So "
"{project_name} has the internal list of user attributes, which are read-only"
" for the users and read-only for the administrators configured at the server"
" level."
msgstr ""
"長期的な観点から、{project_name}には適切なユーザープロファイルSPIがあり、すべてのユーザー属性をきめ細かく設定できます。現在、この機能はまだ完全には利用できません。したがって、{project_name}には、ユーザー属性の内部リストがあります。これは、ユーザーに対しては読み取り専用であり、サーバーレベルで設定された管理者に対しては読み取り専用です。"

msgid ""
"This is the list of the read-only attributes, which are used internally by "
"the {project_name} default providers and functionalities and hence are "
"always read-only:"
msgstr ""
"これは読み取り専用属性のリストです。これらは{project_name}のデフォルトのプロバイダーと機能によって内部的に使用されるため、常に読み取り専用です。"

msgid ""
"For users: `KERBEROS_PRINCIPAL`, `LDAP_ID`, `LDAP_ENTRY_DN`, "
"`CREATED_TIMESTAMP`, `createTimestamp`, `modifyTimestamp`, "
"`userCertificate`, `saml.persistent.name.id.for.*`, `ENABLED`, "
"`EMAIL_VERIFIED`"
msgstr ""
"ユーザーの場合: `KERBEROS_PRINCIPAL`, `LDAP_ID`, `LDAP_ENTRY_DN`, "
"`CREATED_TIMESTAMP`, `createTimestamp`, `modifyTimestamp`, "
"`userCertificate`, `saml.persistent.name.id.for.*`, `ENABLED`, "
"`EMAIL_VERIFIED`"

msgid ""
"For administrators: `KERBEROS_PRINCIPAL`, `LDAP_ID`, `LDAP_ENTRY_DN`, "
"`CREATED_TIMESTAMP`, `createTimestamp`, `modifyTimestamp`"
msgstr ""
"管理者の場合: `KERBEROS_PRINCIPAL`, `LDAP_ID`, `LDAP_ENTRY_DN`, "
"`CREATED_TIMESTAMP`, `createTimestamp`, `modifyTimestamp`"

msgid ""
"System administrators have a way to add additional attributes to this list. "
"The configuration is currently available at the server level. You can add "
"this configuration to your `standalone(-*).xml` files to the configuration "
"of the {project_name} server subsystem:"
msgstr ""
"システム管理者は、このリストに属性を追加する方法があります。設定は現在、サーバーレベルで利用できます。この設定を  "
"`standalone(-*).xml` ファイルの{project_name}サーバー・サブシステムの設定に追加できます。"

msgid ""
"<spi name=\"userProfile\">\n"
"    <provider name=\"legacy-user-profile\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"read-only-attributes\" value=\"[&quot;foo&quot;,&quot;bar*&quot;]\"/>\n"
"            <property name=\"admin-read-only-attributes\" value=\"[&quot;foo&quot;]\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"userProfile\">\n"
"    <provider name=\"legacy-user-profile\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"read-only-attributes\" value=\"[&quot;foo&quot;,&quot;bar*&quot;]\"/>\n"
"            <property name=\"admin-read-only-attributes\" value=\"[&quot;foo&quot;]\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid ""
"The same can be configured with the usage of the JBoss CLI with the "
"commands:"
msgstr "次のコマンドでJBoss CLIを使用して、同じ設定を行うことができます。"

msgid ""
"/subsystem=keycloak-server/spi=userProfile/:add\n"
"/subsystem=keycloak-server/spi=userProfile/provider=legacy-user-profile/:add(properties={},enabled=true)\n"
"/subsystem=keycloak-server/spi=userProfile/provider=legacy-user-profile/:map-put(name=properties,key=read-only-attributes,value=[foo,bar*])\n"
"/subsystem=keycloak-server/spi=userProfile/provider=legacy-user-profile/:map-put(name=properties,key=admin-read-only-attributes,value=[foo])"
msgstr ""
"/subsystem=keycloak-server/spi=userProfile/:add\n"
"/subsystem=keycloak-server/spi=userProfile/provider=legacy-user-profile/:add(properties={},enabled=true)\n"
"/subsystem=keycloak-server/spi=userProfile/provider=legacy-user-profile/:map-put(name=properties,key=read-only-attributes,value=[foo,bar*])\n"
"/subsystem=keycloak-server/spi=userProfile/provider=legacy-user-profile/:map-put(name=properties,key=admin-read-only-attributes,value=[foo])"

msgid ""
"For this example, users and administrators would not be able to update "
"attribute `foo`. Users would not be able to edit any attributes starting "
"with the `bar`. So for example `bar` or `barrier`. Configuration is case "
"insensitive, so attributes like `FOO` or `BarRier` will be denied as well "
"for this example. The wildcard character `\\*` is supported only at the end "
"of the attribute name, so the administrator can effectively deny all the "
"attributes starting with the specified character. The `*` in the middle of "
"the attribute is considered as a normal character."
msgstr ""
"この例では、ユーザーと管理者は属性 `foo` を更新できません。ユーザーは、 `bar` で始まる属性を編集することはできません。たとえば、 "
"`bar` や `barrier` です。設定では大文字と小文字が区別されないため、この例では `FOO` や `BarRier` "
"などの属性も拒否されます。ワイルドカード文字  `\\*` "
"は属性名の末尾でのみサポートされるため、管理者は指定された文字で始まるすべての属性を効果的に拒否できます。属性の中央にある `*` "
"は通常の文字と見なされます。"

msgid "Clickjacking"
msgstr "クリック・ジャッキング"

msgid ""
"Clickjacking is a technique of tricking users into clicking on a user "
"interface element different from what users perceive. A malicious site loads"
" the target site in a transparent iFrame, overlaid on top of a set of dummy "
"buttons placed directly under important buttons on the target site. When a "
"user clicks a visible button, they are clicking a button on the hidden page."
" An attacker can steal a user's authentication credentials and access their "
"resources by using this method."
msgstr ""
"クリックジャッキングとは、ユーザーが認識しているものとは異なるユーザーインターフェース要素をクリックさせて、ユーザーを騙す手法です。悪意のあるサイトでは、対象サイトの重要なボタンの直下に配置されたダミーのボタン群の上に、透明なiFrameを重ねてロードします。ユーザーが見えるボタンをクリックすると、隠れたページのボタンをクリックしたことになります。攻撃者は、この方法を使ってユーザーの認証情報を盗み、ユーザーのリソースにアクセスすることができます。"

msgid ""
"By default, every response by {project_name} sets some specific browser "
"headers that can prevent this from happening. Specifically, it sets "
"https://datatracker.ietf.org/doc/html/rfc7034[X-FRAME_OPTIONS] and "
"http://www.w3.org/TR/CSP/[Content-Security-Policy]. You should take a look "
"at the definition of both of these headers as there is a lot of fine-grain "
"browser access you can control."
msgstr ""
"デフォルトでは、{project_name}によるすべてのレスポンスは、この現象を防ぐことができるいくつかの特定のHTTPヘッダーを設定します。具体的には、"
" https://datatracker.ietf.org/doc/html/rfc7034[X-Frame-Options] と "
"http://www.w3.org/TR/CSP/[Content-Security-Policy] "
"が設定されます。この2つのヘッダーの定義を見ると、ブラウザーのアクセスを細かく制御できる部分がたくさんあるので、参考にしてください。"

msgid ""
"In the Admin Console, you can specify the values of the X-FRAME_OPTIONS and "
"Content-Security-Policy headers."
msgstr ""
"管理コンソールでは、X-Frame-OptionsヘッダーとContent-Security-Policyヘッダーの値を指定することができます。"

msgid "Click the *Realm Settings* menu item."
msgstr "メニュー項目の *Realm Settings* をクリックします。"

msgid "Security Defenses"
msgstr "セキュリティ・ディフェンス"

msgid "image:{project_images}/security-headers.png[Security Defences]"
msgstr "image:{project_images}/security-headers.png[Security Defences]"

msgid ""
"By default, {project_name} only sets up a _same-origin_ policy for iframes."
msgstr "デフォルトでは、{project_name}はIFrameの _same-origin_ ポリシーのみを設定します。"

msgid "SSL/HTTPS requirement"
msgstr "SSL/HTTPS要件"

msgid ""
"OAuth 2.0/OpenID Connect uses access tokens for security. Attackers can scan"
" your network for access tokens and use them to perform malicious operations"
" for which the token has permission. This attack is known as a man-in-the-"
"middle attack. Use SSL/HTTPS for communication between the {project_name} "
"auth server and the clients {project_name} secures to prevent man-in-the-"
"middle attacks."
msgstr ""
"OAuth 2.0/OpenID "
"Connectでは、セキュリティーのためにアクセストークンを使用しています。攻撃者は、ネットワークをスキャンしてアクセストークンを探し、それを使って、トークンが許可している悪意のある操作を実行することができます。この攻撃は、「中間者攻撃」と呼ばれています。中間者攻撃を防ぐために、{project_name}認証サーバーとクライアント間の通信にSSL"
" / HTTPSを使用してください。"

msgid ""
"{project_name} has <<_ssl_modes,three modes for SSL/HTTPS>>. SSL is complex "
"to set up, so {project_name} allows non-HTTPS communication over private IP "
"addresses such as localhost, 192.168.x.x, and other private IP addresses. In"
" production, ensure you enable SSL and SSL is compulsory for all operations."
msgstr ""
"{project_name} には <<_ssl_modes,SSL/HTTPSの3つのモード>> "
"があります。SSLは設定が複雑なので、{project_name}ではlocalhostや192.168.x.xなどのプライベートIPアドレスでの非HTTPS通信を許可しています。プロダクション環境では、SSLを有効にし、すべての操作でSSLが必須となっていることを確認してください。"

msgid ""
"On the adapter/client-side, you can disable the SSL trust manager. The trust"
" manager ensures the client's identity that {project_name} communicates with"
" is valid and ensures the DNS domain name against the server's certificate. "
"In production, ensure that each of your client adapters uses a truststore to"
" prevent DNS man-in-the-middle attacks."
msgstr ""
"アダプター/クライアントサイドでは、SSLトラスト・マネージャーを無効にすることができます。トラスト・マネージャーは、{project_name}が通信するクライアントのアイデンティティーが有効であることを確認し、サーバーの証明書に対するDNSドメイン名を確認します。プロダクション環境では、DNSの中間者攻撃を防ぐために、各クライアント・アダプターがトラストストアを使用していることを確認してください。"

msgid "CSRF attacks"
msgstr "CSRF攻撃"

msgid ""
"A Cross-site request forgery (CSRF) attack uses HTTP requests from users "
"that websites have already authenticated. Any site using cookie-based "
"authentication is vulnerable to CSRF attacks. You can mitigate these attacks"
" by matching a state cookie against a posted form or query parameter."
msgstr ""
"クロスサイト・リクエスト・フォージェリ（CSRF）攻撃は、ウェブサイトが既に認証したユーザーからのHTTPリクエストを利用します。Cookieベースの認証を使用しているサイトは、CSRF攻撃に対して脆弱です。このような攻撃は、投稿されたフォームやクエリー・パラメーターに対してstate"
" Cookieを照合することで軽減できます。"

msgid ""
"The OAuth 2.0 login specification requires that a state cookie matches "
"against a transmitted state parameter. {project_name} fully implements this "
"part of the specification, so all logins are protected."
msgstr ""
"OAuth 2.0のログイン仕様では、state "
"Cookieが送信されたstateパラメーターと一致することが要求されています。{project_name}は、この仕様の一部を完全に実装しているため、すべてのログインが保護されます。"

msgid ""
"The {project_name} Admin Console is a JavaScript/HTML5 application that "
"makes REST calls to the backend {project_name} admin REST API. These calls "
"all require bearer token authentication and consist of JavaScript Ajax "
"calls, so CSRF is impossible. You can configure the admin REST API to "
"validate the CORS origins."
msgstr ""
"{project_name}の管理コンソールは、バックエンドの{project_name}管理REST "
"APIにREST呼び出しを行うJavaScript/HTML5アプリケーションです。これらの呼び出しはすべてベアラートークン認証を必要とし、JavaScriptのAjax呼び出しで構成されているため、CSRFは不可能です。CORSオリジンを検証するように管理REST"
" APIを設定することができます。"

msgid ""
"The user account management section in {project_name} can be vulnerable to "
"CSRF. To prevent CSRF attacks, {project_name} sets a state cookie and embeds"
" the value of this cookie in hidden form fields or query parameters within "
"action links. {project_name} checks the query/form parameter against the "
"state cookie to verify that the user makes the call."
msgstr ""
"{project_name}のユーザー・アカウント管理セクションは、CSRFに対して脆弱な可能性があります。CSRF "
"攻撃を防ぐために、{project_name}は、state "
"Cookieを設定し、このCookieの値をアクションリンク内の隠しフォーム・フィールドやクエリー・パラメーターに埋め込みます。{project_name}"
" は、クエリー/フォーム・パラメーターをstate Cookieと照合して、ユーザーが呼び出しを行ったことを確認します。"

msgid "Unspecific redirect URIs"
msgstr "不特定のリダイレクトURI"

msgid ""
"Make your registered redirect URIs as specific as feasible. Registering "
"vague redirect URIs for xref:con-oidc-auth-flows_{context}[Authorization "
"Code Flows] can allow malicious clients to impersonate another client with "
"broader access. Impersonation can happen if two clients live under the same "
"domain, for example."
msgstr ""
"登録するリダイレクトURIは、できるだけ具体的なものにしてください。 xref:con-oidc-auth-"
"flows_{context}[認可コードフロー] "
"に曖昧なリダイレクトURIを登録すると、悪意のあるクライアントがより広いアクセス権を持つ別のクライアントになりすますことができます。なりすましは、たとえば、2人のクライアントが同じドメインに住んでいる場合に起こります。"

msgid "FAPI compliance"
msgstr "FAPI準拠"

msgid ""
"To make sure that {project_name} server will validate your client to be more"
" secure and FAPI compliant, you can configure client policies for the FAPI "
"support. Details are described in the FAPI section of "
"link:{adapterguide_link}#_fapi-support[{adapterguide_name}]. Among other "
"things, this ensures some security best practices described above like SSL "
"required for clients, secure redirect URI used and more of similar best "
"practices."
msgstr ""
"{project_name}サーバーがクライアントをより安全でFAPIに準拠していると検証するようにするには、FAPIサポートのためのクライアント・ポリシーを設定することができます。詳細は、"
" link:{adapterguide_link}#_fapi-support[{adapterguide_name}] "
"のFAPIセクションに記載されています。とりわけ、これにより、上述のクライアントのSSL必須、安全なリダイレクトURIの使用などのセキュリティー・ベストプラクティスが保証されます。"

msgid "Compromised access and refresh tokens"
msgstr "セキュリティー侵害されたアクセストークンとリフレッシュトークン"

msgid ""
"{project_name} includes several actions to prevent malicious actors from "
"stealing access tokens and refresh tokens. The crucial action is to enforce "
"SSL/HTTPS communication between {project_name} and its clients and "
"applications. {project_name} does not enable SSL by default."
msgstr ""
"{project_name}には、悪意のある行為者がアクセストークンやリフレッシュトークンを盗むのを防ぐためのいくつかのアクションがあります。最も重要なアクションは、{project_name}とそのクライアントやアプリケーションの間でSSL/HTTPS通信を強制することです。{project_name}はデフォルトではSSLを有効にしていません。"

msgid ""
"Another action to mitigate damage from leaked access tokens is to shorten "
"the token's lifespans. You can specify token lifespans within the "
"<<_timeouts, timeouts page>>. Short lifespans for access tokens force "
"clients and applications to refresh their access tokens after a short time. "
"If an admin detects a leak, the admin can log out all user sessions to "
"invalidate these refresh tokens or set up a revocation policy."
msgstr ""
"アクセストークンの漏洩による被害を軽減するためのもう一つのアクションは、トークンの寿命を短くすることです。トークンの寿命は、<<_timeouts, "
"timeouts "
"page>>内で指定できます。アクセストークンの寿命を短くすると、クライアントやアプリケーションは短時間でアクセストークンを更新しなければならなくなります。管理者が漏洩を検知した場合、管理者はすべてのユーザー・セッションをログアウトしてこれらのリフレッシュトークンを無効にしたり、失効ポリシーを設定したりすることができます。"

msgid ""
"Ensure refresh tokens always stay private to the client and are never "
"transmitted."
msgstr "リフレッシュトークンが常にクライアントに非公開で、決して送信されないようにします。"

msgid ""
"You can mitigate damage from leaked access tokens and refresh tokens by "
"issuing these tokens as holder-of-key tokens. See <<_mtls-client-"
"certificate-bound-tokens, OAuth 2.0 Mutual TLS Client Certificate Bound "
"Access Token>> for more information."
msgstr ""
"アクセストークンやリフレッシュトークンは、holder-of-"
"keyトークンとして発行することで、漏洩した場合の被害を軽減することができます。詳しくは、<<_mtls-client-certificate-"
"bound-tokens, OAuth 2.0 Mutual TLS Client Certificate Bound Access "
"Token>>を参照してください。"

msgid ""
"If an access token or refresh token is compromised, access the Admin Console"
" and push a not-before revocation policy to all applications. Pushing a not-"
"before policy ensures that any tokens issued before that time become "
"invalid. Pushing a new not-before policy ensures that applications must "
"download new public keys from {project_name} and mitigate damage from a "
"compromised realm signing key. See the <<realm_keys, keys chapter>> for more"
" information."
msgstr ""
"アクセストークンまたはリフレッシュトークンが侵害された場合、管理コンソールにアクセスし、not-"
"before無効化ポリシーをすべてのアプリケーションにプッシュします。not-"
"beforeポリシーをプッシュすると、それ以前に発行されたトークンが無効になります。  新しいnot-"
"beforeポリシーをプッシュすると、アプリケーションは{project_name}から新しい公開鍵をダウンロードする必要があり、レルムの署名鍵が漏洩した場合の被害を軽減することができます。詳しくは<<realm_keys,"
" 鍵の章>>を参照してください。"

msgid ""
"You can disable specific applications, clients, or users if they are "
"compromised."
msgstr "特定のアプリケーション、クライアント、またはユーザーが侵害された場合、それらを無効にすることができます。"

msgid "Compromised authorization code"
msgstr "侵害された認可コード"

msgid ""
"For the xref:con-oidc-auth-flows_{context}[OIDC Auth Code Flow], "
"{project_name} generates a cryptographically strong random value for its "
"authorization codes. An authorization code is used only once to obtain an "
"access token."
msgstr ""
"xref:con-oidc-auth-"
"flows_{context}[OIDC認可コードフロー]では、{project_name}が認可コードに暗号的に強い乱数値を生成しています。認可コードはアクセストークンの取得に一度だけ使用されます。"

msgid ""
"On the <<_timeouts, timeouts page>> in the Admin Console, you can specify "
"the length of time an authorization code is valid. Ensure that the length of"
" time is less than 10 seconds, which is long enough for a client to request "
"a token from the code."
msgstr ""
"管理コンソールの<<_timeouts, "
"タイムアウトのページ>>では、認可コードの有効期間を指定することができます。時間の長さは、クライアントがコードからトークンを要求するのに十分な長さである、10秒以下であることを確認してください。"

msgid ""
"You can also defend against leaked authorization codes by applying <<_proof-"
"key-for-code-exchange, Proof Key for Code Exchange (PKCE)>> to clients."
msgstr ""
"また、<<_proof-key-for-code-exchange, Proof Key for Code Exchange "
"(PKCE)>>を適用することで、認可コードの漏洩を防ぐことができます。"

msgid "Open redirectors"
msgstr "オープン・リダイレクター"

msgid ""
"An open redirector is an endpoint using a parameter to automatically "
"redirect a user agent to the location specified by the parameter value "
"without validation. An attacker can use the end-user authorization endpoint "
"and the redirect URI parameter to use the authorization server as an open "
"redirector, using a user's trust in an authorization server to launch a "
"phishing attack."
msgstr ""
"オープン・リダイレクターとは、パラメーターを使用して、検証を行わずにパラメーター値で指定された場所にユーザー・エージェントを自動的にリダイレクトするエンドポイントのことです。攻撃者は、認可エンドポイントとリダイレクトURIパラメーターを使って、認可サーバーをオープン・リダイレクターとして使用し、認可サーバーに対するユーザーの信頼を利用してフィッシング攻撃を仕掛けることができます。"

msgid ""
"{project_name} requires that all registered applications and clients "
"register at least one redirection URI pattern. When a client requests that "
"{project_name} performs a redirect, {project_name} checks the redirect URI "
"against the list of valid registered URI patterns. Clients and applications "
"must register as specific a URI pattern as possible to mitigate open "
"redirector attacks."
msgstr ""
"{project_name}は、登録されたすべてのアプリケーションとクライアントが、少なくとも1つのリダイレクトURIパターンを登録することを要求しています。クライアントが{project_name}にリダイレクトの実行を要求すると、{project_name}はリダイレクトURIを有効な登録URIパターンのリストと照合します。クライアントやアプリケーションは、オープンリダイレクター攻撃を軽減するために、できるだけ特定のURIパターンを登録する必要があります。"

msgid "Password database compromised"
msgstr "パスワード・データベースの侵害"

msgid ""
"{project_name} does not store passwords in raw text but as hashed text, "
"using the PBKDF2 hashing algorithm. {project_name} performs 27,500 hashing "
"iterations, the number of iterations recommended by the security community. "
"This number of hashing iterations can adversely affect performance as PBKDF2"
" hashing uses a significant amount of CPU resources."
msgstr ""
"{project_name}は、パスワードを平文のテキストではなく、PBKDF2ハッシングアルゴリズムを用いてハッシュ化したテキストとして保存します。{project_name}は、セキュリティー・コミュニティーで推奨されている回数である27,500回のハッシュ反復を行います。PBKDF2ハッシュ化は大量の"
" CPUリソースを使用するため、このハッシュ化の反復回数はパフォーマンスに悪影響を及ぼします。"

msgid "Limiting scope"
msgstr "スコープの制限"

msgid ""
"By default, new client applications have unlimited `role scope mappings`. "
"Every access token for that client contains all permissions that the user "
"has. If an attacker compromises the client and obtains the client's access "
"tokens, each system that the user can access is compromised."
msgstr ""
"デフォルトでは、新しいクライアント・アプリケーションは無制限の `role scope mappings` "
"を持ちます。そのクライアントのアクセストークンには、そのユーザーが持つすべてのパーミッションが含まれています。攻撃者がクライアントを侵害し、クライアントのアクセストークンを取得した場合、そのユーザーがアクセスできる各システムが危険にさらされます。"

msgid ""
"Limit the roles of an access token by using the <<_role_scope_mappings, "
"Scope menu>> for each client. Alternatively, you can set role scope mappings"
" at the Client Scope level and assign Client Scopes to your client by using "
"the <<_client_scopes_linking, Client Scope menu>>."
msgstr ""
"アクセストークンのロールを制限するには、クライアントごとに<<_role_scope_mappings, "
"Scopeメニュ－>>を使用します。また、クライアント・スコープ・レベルでロールスコープのマッピングを設定し、<<_client_scopes_linking,"
" Client Scopeメニュ－>>を使用してクライアント・スコープを割り当てることもできます。"

msgid "Limit token audience"
msgstr "トークンのAudienceの制限"

msgid ""
"In environments with low levels of trust among services, limit the audiences"
" on the token. See the "
"https://datatracker.ietf.org/doc/html/rfc6819#section-5.1.5.5[OAuth2 Threat "
"Model] and the <<audience-support, Audience Support>> section for more "
"information."
msgstr ""
"サービス間の信頼度が低い環境では、トークンのオーディエンスを制限してください。詳しくは、 "
"https://datatracker.ietf.org/doc/html/rfc6819#section-5.1.5.5[OAuth2 Threat "
"Model] と<<audience-support, Audienceサポート>>を参照して覧ください。"

msgid "Limit Authentication Sessions"
msgstr "Limit Authentication Sessions"

msgid ""
"When a login page is opened for the first time in a web browser, "
"{project_name} creates an object called authentication session that stores "
"some useful information about the request. Whenever a new login page is "
"opened from a different tab in the same browser, {project_name} creates a "
"new record called authentication sub-session that is stored within the "
"authentication session. Authentication requests can come from any type of "
"clients such as the Admin CLI. In that case, a new authentication session is"
" also created with one authentication sub-session. Please note that "
"authentication sessions can be created also in other ways than using a "
"browser flow. The text below is applicable regardless of the source flow."
msgstr ""
"Webブラウザーで初めてログインページを開くと、{project_name}は認証中セッションと呼ばれるオブジェクトを作成し、リクエストに関するいくつかの有用な情報を保存します。同じブラウザーの別のタブから新しいログインページを開くたびに、{project_name}は認証中サブセッションと呼ばれる新しいレコードを作成し、認証中セッション内に保存されます。認証リクエストは、管理CLIなどのあらゆるタイプのクライアントから来る可能性があります。その場合、新しい認証中セッションも1つの認証中サブセッションで作成されます。認証中セッションは、ブラウザーフローを使用する以外の方法でも作成されることに注意してください。以下の文章は、ソースフローに関係なく適用されます。"

msgid ""
"This section describes deployments that use the {jdgserver_name} provider "
"for authentication sessions."
msgstr "このセクションでは、認証中セッションに{jdgserver_name}プロバイダーを使用するデプロイメントについて説明します。"

msgid ""
"Authentication session is internally stored as "
"`RootAuthenticationSessionEntity`. Each `RootAuthenticationSessionEntity` "
"can have multiple authentication sub-sessions stored within the "
"`RootAuthenticationSessionEntity` as a collection of "
"`AuthenticationSessionEntity` objects. {project_name} stores authentication "
"sessions in a dedicated {jdgserver_name} cache. The number of "
"`AuthenticationSessionEntity` per `RootAuthenticationSessionEntity` "
"contributes to the size of each cache entry. Total memory footprint of "
"authentication session cache is determined by the number of stored "
"`RootAuthenticationSessionEntity` and by the number of "
"`AuthenticationSessionEntity` within each `RootAuthenticationSessionEntity`."
msgstr ""
"認証中セッションは、内部的には `RootAuthenticationSessionEntity` として格納されます。各 "
"`RootAuthenticationSessionEntity` には、複数の認証中サブセッションを "
"`AuthenticationSessionEntity` "
"オブジェクトの集合として格納することができます。{project_name}は、認証中セッションを専用の{jdgserver_name}キャッシュに保存します。"
" `RootAuthenticationSessionEntity` に含まれる `AuthenticationSessionEntity` "
"の数は、各キャッシュ・エントリーのサイズに影響します。認証中セッション・キャッシュの総メモリー使用量は、保存された "
"`RootAuthenticationSessionEntity` の数と、各 `RootAuthenticationSessionEntity` 内の"
" `AuthenticationSessionEntity` の数によって決定されます。"

msgid ""
"The number of maintained `RootAuthenticationSessionEntity` objects "
"corresponds to the number of unfinished login flows from the browser. To "
"keep the number of `RootAuthenticationSessionEntity` under control, using an"
" advanced firewall control to limit ingress network traffic is recommended."
msgstr ""
"維持される `RootAuthenticationSessionEntity` "
"オブジェクトの数は、ブラウザーからの未完了のログインフローの数に対応します。 `RootAuthenticationSessionEntity` "
"の数を制御するために、高度なファイアウォール制御を使用して、入口のネットワーク・トラフィックを制限することが推奨されます。"

msgid ""
"Higher memory usage may occur for deployments where there are many active "
"`RootAuthenticationSessionEntity` with a lot of "
"`AuthenticationSessionEntity`. If the load balancer does not support or is "
"not configured for link:{installguide_stickysessions_link}[session "
"stickiness], the load over network in a cluster can increase significantly. "
"The reason for this load is that each request that lands on a node that does"
" not own the appropriate authentication session needs to retrieve and update"
" the authentication session record in the owner node which involves a "
"separate network transmission for both the retrieval and the storage."
msgstr ""
"多くのアクティブな `RootAuthenticationSessionEntity` と多くの "
"`AuthenticationSessionEntity` が存在する環境では、より高いメモリ使用量が発生する可能性があります。ロードバランサーが "
"link:{installguide_stickysessions_link}[セッション・スティッキネス] "
"をサポートしないか、設定されていない場合、クラスター内のネットワーク上の負荷が大幅に増加する可能性があります。この負荷の理由は、適切な認証中セッションを所有していないノードに到着した各リクエストは、所有ノード内の認証中セッション・レコードを検索して更新する必要があり、検索と保存の両方に個別のネットワーク伝送が含まれるからです。"

msgid ""
"The maximum number of `AuthenticationSessionEntity` per "
"`RootAuthenticationSessionEntity` can be configured in "
"`authenticationSessions` SPI by setting property `authSessionsLimit`. The "
"default value is set to 300 `AuthenticationSessionEntity` per a "
"`RootAuthenticationSessionEntity`. When this limit is reached, the oldest "
"authentication sub-session will be removed after a new authentication "
"session request."
msgstr ""
"SPI の `authenticationSessions` で `authSessionsLimit` プロパティーを設定することで、 "
"`RootAuthenticationSessionEntity` あたりの `AuthenticationSessionEntity` "
"の最大個数を設定することができます。デフォルトでは、1つの `RootAuthenticationSessionEntity` に対して300の "
"`AuthenticationSessionEntity` "
"が設定されています。この制限に達すると、新しい認証中セッションの要求があったときに、最も古い認証中サブセッションが削除されます。"

msgid ""
"The following example shows how to limit the number of active "
"`AuthenticationSessionEntity` per a `RootAuthenticationSessionEntity` to "
"100."
msgstr ""
"次の例では、 `RootAuthenticationSessionEntity` ごとにアクティブな "
"`AuthenticationSessionEntity` の数を100に制限する方法を示しています。"

msgid ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:1.1\">\n"
"    ...\n"
"    <spi name=\"authenticationSessions\">\n"
"        <default-provider>infinispan</default-provider>\n"
"        <provider name=\"infinispan\" enabled=\"true\">\n"
"            <properties>\n"
"                <property name=\"authSessionsLimit\" value=\"100\"/>\n"
"            </properties>\n"
"        </provider>\n"
"    </spi>\n"
"    ...\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:1.1\">\n"
"    ...\n"
"    <spi name=\"authenticationSessions\">\n"
"        <default-provider>infinispan</default-provider>\n"
"        <provider name=\"infinispan\" enabled=\"true\">\n"
"            <properties>\n"
"                <property name=\"authSessionsLimit\" value=\"100\"/>\n"
"            </properties>\n"
"        </provider>\n"
"    </spi>\n"
"    ...\n"
"</subsystem>"

msgid ""
"/subsystem=keycloak-server/spi=authenticationSessions:add(default-provider=infinispan)\n"
"/subsystem=keycloak-server/spi=authenticationSessions/provider=infinispan:add(properties={authSessionsLimit => \"100\"},enabled=true)"
msgstr ""
"/subsystem=keycloak-server/spi=authenticationSessions:add(default-provider=infinispan)\n"
"/subsystem=keycloak-server/spi=authenticationSessions/provider=infinispan:add(properties={authSessionsLimit => \"100\"},enabled=true)"

msgid "SQL injection attacks"
msgstr "SQLインジェクション攻撃"

msgid "Currently, {project_name} has no known SQL injection vulnerabilities."
msgstr "現在、 {project_name} には、既知の SQL インジェクションの脆弱性はありません。"

msgid "Account Console"
msgstr "アカウント・コンソール"

msgid ""
"{project_name} users can manage their accounts through the Account Console. "
"Users can manage their profiles, add two-factor authentication, include "
"identity provider acounts, and manage device activity."
msgstr ""
"{project_name}のユーザーは、アカウント・コンソールで自分のアカウントを管理できます。ユーザーは、プロファイルの管理、2要素認証の追加、アイデンティティー・プロバイダー・アカウントの追加、デバイスのアクティビティー管理を行うことができます。"

msgid ""
"The Account Console is completely themeable and internationalizable as is "
"the case with all {project_name} user interfaces. For example, you can add "
"attributes to the *Personal Info* page. For more details, see the "
"link:{developerguide_link}[{developerguide_name}]."
msgstr ""
"アカウント・コンソールは、すべての{project_name}ユーザー・インターフェイスと同様に、完全にテーマ化および国際化可能です。たとえば、*Personal"
" Info* ページに属性を追加することができます。詳しくは、 "
"link:{developerguide_link}[{developerguide_name}] を参照してください。"

msgid "Accessing the Account Console"
msgstr "アカウント・コンソールへのアクセス"

msgid "Any user can access the Account Console."
msgstr "アカウント・コンソールには、どのユーザーもアクセスできます。"

msgid ""
"Make note of the realm name and IP address for the {project_name} server "
"where your account exists."
msgstr "アカウントが存在する{project_name}サーバーのレルム名とIPアドレスを控えておきます。"

msgid ""
"In a web browser, enter a URL in this format: `<server-"
"root>/auth/realms/{realm-name}/account`."
msgstr ""
"Webブラウザーで、 `<server-root>/auth/realms/{realm-name}/account` "
"のような形式のURLを入力します。"

msgid "Enter your login name and password."
msgstr "ログイン名とパスワードを入力してください。"

msgid "image:images/account-console-intro.png[Account Console]"
msgstr "image:images/account-console-intro.png[Account Console]"

msgid "Configuring ways to sign in"
msgstr "サインイン方法の設定"

msgid ""
"You can sign in to this console using basic authentication (a login name and"
" password) or two-factor authentication. For two-factor authentication, use "
"one of the following procedures."
msgstr ""
"このコンソールには、BASIC認証（ログイン名とパスワード）または2要素認証を使用してサインインすることができます。2要素認証の場合は、以下の手順のいずれかを使用します。"

msgid "Two-factor authentication with OTP"
msgstr "OTPによる2要素認証"

msgid "OTP is a valid authentication mechanism for your realm."
msgstr "OTPは、あなたのレルムにとって有効な認証メカニズムです。"

msgid "Click *Account Security* in the menu."
msgstr "メニューの *Account Security* をクリックします。"

msgid "Click *Signing In*."
msgstr "*Signing In* をクリックします。"

msgid "Click *Set Up Authenticator Application*."
msgstr "*Set Up Authenticator Application* をクリックします。"

msgid "Signing In"
msgstr "サインイン"

msgid "image:images/account-console-signing-in.png[Signing In]"
msgstr "image:images/account-console-signing-in.png[Signing In]"

msgid ""
"Follow the directions that appear on the screen to use either "
"https://freeotp.github.io/[FreeOTP] or "
"https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2[Google"
" Authenticator] on your mobile device as your OTP generator."
msgstr ""
"画面に表示される案内に従って、 https://freeotp.github.io/[FreeOTP] または "
"https://play.google.com/store/apps/details?id=com.google.android.apps.authenticator2[Google"
" Authenticator] をのどちらかをOTPジェネレーターとしてモバイル端末で使用します。"

msgid ""
"Scan the QR code in the screen shot into the OTP generator on your mobile "
"device."
msgstr "スクリーンショットにあるQRコードをモバイル端末のOTPジェネレーターに読み込ませてください。"

msgid "Log out and log in again."
msgstr "一度ログアウトして、再度ログインしてください。"

msgid ""
"Respond to the prompt by entering an OTP that is provided on your mobile "
"device."
msgstr "プロンプトに応答して、モバイルデバイスで提供されるOTPを入力してください。"

msgid "Two-factor authentication with WebAuthn"
msgstr "WebAuthnによる2要素認証"

msgid ""
"WebAuthn is a valid two-factor authentication mechanism for your realm. "
"Please follow the <<_webauthn,WebAuthn section>> for more details."
msgstr ""
"WebAuthnは、あなたのレルムで有効な二要素認証のメカニズムです。詳しくは<<_webauthn,WebAuthnのセクション>>を参照してください。"

msgid "Click *Set up Security Key*."
msgstr "*Set up Security Key* をクリックします。"

msgid ""
"image:images/account-console-signing-in-webauthn-2factor.png[Signing In With"
" Security Key]"
msgstr ""
"image:images/account-console-signing-in-webauthn-2factor.png[Signing In With"
" Security Key]"

msgid ""
"Prepare your WebAuthn Security Key. How you prepare this key depends on the "
"type of WebAuthn security key you use. For example, for a USB based Yubikey,"
" you may need to put your key into the USB port on your laptop."
msgstr ""
"WebAuthnのセキュリティーキーを準備します。このキーの準備方法は、使用するWebAuthnセキュリティーキーの種類によって異なります。たとえば、USBベースのYubikeyの場合、ラップトップのUSBポートにキーを入れる必要があるかもしれません。"

msgid "Click *Register* to register your security key."
msgstr "セキュリティーキーを登録する場合は、 *Register* をクリックしてください。"

msgid ""
"Assuming authentication flow was correctly set, a message appears asking you"
" to authenticate with your Security Key as second factor."
msgstr "認証フローが正しく設定されている場合、第2要素としてセキュリティーキーで認証するようメッセージが表示されます。"

msgid "Passwordless authentication with WebAuthn"
msgstr "WebAuthnによるパスワードレス認証"

msgid ""
"WebAuthn is a valid passwordless authentication mechanism for your realm. "
"Please follow the <<_webauthn_passwordless,Passwordless WebAuthn section>> "
"for more details."
msgstr ""
"WebAuthnは、あなたのレルムで有効なパスワードレス認証メカニズムです。詳しくは<<_webauthn_passwordless,Passwordless"
" WebAuthn のセクション>>を参照してください。"

msgid "Click *Set up Security Key* in the *Passwordless* section."
msgstr "*Passwordless* のセクションで、 *Set up Security Key* をクリックします。"

msgid ""
"image:images/account-console-signing-in-webauthn-passwordless.png[Signing In"
" With Security Key]"
msgstr ""
"image:images/account-console-signing-in-webauthn-passwordless.png[Signing In"
" With Security Key]"

msgid ""
"Assuming authentication flow was correctly set, a message appears asking you"
" to authenticate with your Security Key as second factor. You no longer need"
" to provide your password to log in."
msgstr ""
"認証フローが正しく設定されている場合、第2要素であるセキュリティーキーによる認証を促すメッセージが表示されます。これでログイン時にパスワードを入力する必要はありません。"

msgid "Viewing device activity"
msgstr "デバイスのアクティビティーの表示"

msgid "You can view the devices that are logged in to your account."
msgstr "アカウントにログインしているデバイスを表示することができます。"

msgid "Click *Device Activity*."
msgstr "デバイスアクティビティ*をクリックします。"

msgid "Log out a device if it looks suspicious."
msgstr "不審な点があれば、デバイスをログアウトする。"

msgid "Devices"
msgstr "デバイス"

msgid "image:images/account-console-device.png[Devices]"
msgstr "image:images/account-console-device.png[Devices]"

msgid "Adding an identity provider acccount"
msgstr "アイデンティティー・プロバイダー・アカウントの追加"

msgid ""
"You can link your account with an <<_identity_broker, identity broker>>. "
"This option is often used to link social provider accounts."
msgstr ""
"アカウントに&lt;&gt;を付けてリンクすることができます<_identity_broker, identity "
"broker>。このオプションは、ソーシャルプロバイダーのアカウントをリンクするためによく使用されます。</_identity_broker,>"

msgid "Log into the Admin Console."
msgstr "管理コンソールにログインします。"

msgid "Click *Add provider*."
msgstr "プロバイダーを追加する」をクリックします。"

msgid "Select a provider and complete the fields."
msgstr "プロバイダーを選択し、各項目を入力します。"

msgid "Return to the Account Console."
msgstr "アカウントコンソールに戻る。"

msgid "Click *Linked Accounts*."
msgstr "Linked Accounts* をクリックします。"

msgid "The identity provider you added appears in this page."
msgstr "追加したアイデンティティー・プロバイダーはこのページに表示されます。"

msgid "Linked Accounts"
msgstr "リンクされたアカウント"

msgid "image:images/account-console-linked.png[Linked Accounts]"
msgstr "image:images/account-console-linked.png[Linked Accounts]"

msgid "Accessing other applications"
msgstr "他のアプリケーションにアクセスする"

msgid ""
"The *Applications* menu item shows users which applications you can access. "
"In this case, only the Account Console is available."
msgstr ""
"アプリケーション*」メニューは、ユーザーがアクセスできるアプリケーションを表示します。この場合、Account Consoleのみ利用可能です。"

msgid "Applications"
msgstr "Applications"

msgid "image:images/account-console-applications.png[Applications]"
msgstr "image:images/account-console-applications.png[Applications]"

msgid "Admin CLI"
msgstr "管理CLI"

msgid ""
"With {project_name}, you can perform administration tasks from the command-"
"line interface (CLI) by using the Admin CLI command-line tool."
msgstr ""
"{project_name}では、コマンドライン・ツール「管理CLI」を使って、コマンドライン・インターフェイス（CLI）から管理タスクを実行することができます。"

msgid "Installing the Admin CLI"
msgstr "管理CLIのインストール"

msgid ""
"{project_name} packages the Admin CLI server distribution with the execution"
" scripts in the `bin` directory."
msgstr "{project_name}は、管理CLI サーバーの配布物と実行スクリプトを `bin` ディレクトリーにパッケージ化します。"

msgid ""
"The Linux script is called `kcadm.sh`, and the script for Windows is called "
"`kcadm.bat`. Add the {project_name} server directory to your `PATH` to use "
"the client from any location on your file system."
msgstr ""
"Linux用のスクリプトは `kcadm.sh` 、Windows用のスクリプトは `kcadm.bat` "
"といいます。ファイルシステム上の任意の場所からクライアントを使用するために、{project_name} サーバー・ディレクトリーを `PATH` "
"に追加してください。"

msgid "Linux:"
msgstr "Linuxの場合："

msgid ""
"$ export PATH=$PATH:$KEYCLOAK_HOME/bin\n"
"$ kcadm.sh"
msgstr ""
"$ export PATH=$PATH:$KEYCLOAK_HOME/bin\n"
"$ kcadm.sh"

msgid "Windows:"
msgstr "Windowsの場合："

msgid ""
"c:\\> set PATH=%PATH%;%KEYCLOAK_HOME%\\bin\n"
"c:\\> kcadm"
msgstr ""
"c:\\> set PATH=%PATH%;%KEYCLOAK_HOME%\\bin\n"
"c:\\> kcadm"

msgid ""
"You must set the `KEYCLOAK_HOME` environment variable to the path where you "
"extracted the {project_name} Server distribution."
msgstr "環境変数 `KEYCLOAK_HOME` に{project_name}サーバーの配布物を解凍したパスを設定する必要があります。"

msgid ""
"To avoid repetition, the rest of this document only uses Windows examples in"
" places where the CLI differences are more than just in the `kcadm` command "
"name."
msgstr ""
"繰り返しを避けるために、このドキュメントの残りの部分では、CLIの違いが `kcadm` "
"コマンド名だけではない場所でのみ、Windowsの例を使用しています。"

msgid "Using the Admin CLI"
msgstr "管理CLIの利用"

msgid ""
"The Admin CLI makes HTTP requests to Admin REST endpoints. Access to the "
"Admin REST endpoints requires authentication."
msgstr "管理CLIは、管理RESTエンドポイントにHTTPリクエストを行います。管理RESTエンドポイントへのアクセスには認証が必要です。"

msgid ""
"Consult the Admin REST API documentation for details about JSON attributes "
"for specific endpoints."
msgstr "特定のエンドポイントのJSON属性の詳細については、管理REST APIのドキュメントを参照してください。"

msgid ""
"Start an authenticated session by logging in. You can now perform create, "
"read, update, and delete (CRUD) operations."
msgstr "ログインして認証されたセッションを開始します。CRUD（Create、Read、Update、Delete）操作ができるようになります。"

msgid ""
"$ kcadm.sh config credentials --server http://localhost:8080/auth --realm demo --user admin --client admin\n"
"$ kcadm.sh create realms -s realm=demorealm -s enabled=true -o\n"
"$ CID=$(kcadm.sh create clients -r demorealm -s clientId=my_client -s 'redirectUris=[\"http://localhost:8980/myapp/*\"]' -i)\n"
"$ kcadm.sh get clients/$CID/installation/providers/keycloak-oidc-keycloak-json"
msgstr ""
"$ kcadm.sh config credentials --server http://localhost:8080/auth --realm demo --user admin --client admin\n"
"$ kcadm.sh create realms -s realm=demorealm -s enabled=true -o\n"
"$ CID=$(kcadm.sh create clients -r demorealm -s clientId=my_client -s 'redirectUris=[\"http://localhost:8980/myapp/*\"]' -i)\n"
"$ kcadm.sh get clients/$CID/installation/providers/keycloak-oidc-keycloak-json"

msgid ""
"c:\\> kcadm config credentials --server http://localhost:8080/auth --realm demo --user admin --client admin\n"
"c:\\> kcadm create realms -s realm=demorealm -s enabled=true -o\n"
"c:\\> kcadm create clients -r demorealm -s clientId=my_client -s \"redirectUris=[\\\"http://localhost:8980/myapp/*\\\"]\" -i > clientid.txt\n"
"c:\\> set /p CID=<clientid.txt\n"
"c:\\> kcadm get clients/%CID%/installation/providers/keycloak-oidc-keycloak-json"
msgstr ""
"c:\\> kcadm config credentials --server http://localhost:8080/auth --realm demo --user admin --client admin\n"
"c:\\> kcadm create realms -s realm=demorealm -s enabled=true -o\n"
"c:\\> kcadm create clients -r demorealm -s clientId=my_client -s \"redirectUris=[\\\"http://localhost:8980/myapp/*\\\"]\" -i > clientid.txt\n"
"c:\\> set /p CID=<clientid.txt\n"
"c:\\> kcadm get clients/%CID%/installation/providers/keycloak-oidc-keycloak-json"

msgid ""
"In a production environment, access {project_name} by using `https:` to "
"avoid exposing tokens. If a trusted certificate authority, included in "
"Java's default certificate truststore, has not issued a server's "
"certificate, prepare a `truststore.jks` file and instruct the Admin CLI to "
"use it."
msgstr ""
"プロダクション環境では、トークンの公開を避けるために、`https:` "
"を使って{project_name}にアクセスしてください。Javaのデフォルト証明書トラストストアに含まれる信頼できる認証局がサーバーの証明書を発行していない場合は、"
" `truststore.jks` ファイルを用意して、それを使用するように管理CLIに指示します。"

msgid ""
"$ kcadm.sh config truststore --trustpass $PASSWORD "
"~/.keycloak/truststore.jks"
msgstr ""
"$ kcadm.sh config truststore --trustpass $PASSWORD "
"~/.keycloak/truststore.jks"

msgid ""
"c:\\> kcadm config truststore --trustpass %PASSWORD% "
"%HOMEPATH%\\.keycloak\\truststore.jks"
msgstr ""
"c:\\> kcadm config truststore --trustpass %PASSWORD% "
"%HOMEPATH%\\.keycloak\\truststore.jks"

msgid "Authenticating"
msgstr "認証"

msgid "When you log in with the Admin CLI, you specify:"
msgstr "管理CLIでログインする際に、以下のように指定します。"

msgid "A server endpoint URL"
msgstr "サーバー・エンドポイントURL"

msgid "A realm"
msgstr "レルム"

msgid "A user name"
msgstr "ユーザー名"

msgid ""
"Another option is to specify a clientId only, which creates a unique service"
" account for you to use."
msgstr "clientIdのみを指定する方法もあります。この場合、使用する固有のサービス・アカウントが作成されます。"

msgid ""
"When you log in using a user name, use a password for the specified user. "
"When you log in using a clientId, you need the client secret only, not the "
"user password. You can also use the `Signed JWT` rather than the client "
"secret."
msgstr ""
"ユーザー名でログインする場合は、指定したユーザーのパスワードを使用します。clientIdを使ってログインする場合は、ユーザーのパスワードではなく、クライアント・シークレットのみが必要です。また、クライアント・シークレットの代わりに"
" `Signed JWT` を使用することもできます。"

msgid ""
"Ensure the account used for the session has the proper permissions to invoke"
" Admin REST API operations. For example, the `realm-admin` role of the "
"`realm-management` client can  administer the realm of the user."
msgstr ""
"セッションに使用されるアカウントが、管理REST "
"APIの操作を呼び出すための適切なパーミッションを持っていることを確認してください。たとえば、`realm-management` クライアントの "
"`realm-admin` ロールは、ユーザーのレルムを管理できます。"

msgid ""
"Two primary mechanisms are available for authentication. One mechanism uses "
"`kcadm config credentials` to start an authenticated session."
msgstr ""
"認証には主に2つのメカニズムがあります。一つは、`kcadm config credentials` を使って、認証されたセッションを開始するものです。"

msgid ""
"$ kcadm.sh config credentials --server http://localhost:8080/auth --realm "
"master --user admin --password admin"
msgstr ""
"$ kcadm.sh config credentials --server http://localhost:8080/auth --realm "
"master --user admin --password admin"

msgid ""
"This mechanism maintains an authenticated session between the `kcadm` "
"command invocations by saving the obtained access token and its associated "
"refresh token. It can maintain other secrets in a private configuration "
"file. See the <<_working_with_alternative_configurations, next chapter>> for"
" more information."
msgstr ""
"この機構は、取得したアクセストークンとそれに関連するリフレッシュトークンを保存することで、 `kcadm` "
"コマンドの呼び出しの間に認証済みセッションを維持します。他にも、プライベートな設定ファイルにシークレットを保持することができます。詳細は "
"<<_working_with_alternative_configurations, 次の章>> を参照してください。"

msgid ""
"The second mechanism authenticates each command invocation for the duration "
"of the invocation. This mechanism increases the load on the server and the "
"time spent on round trips obtaining tokens. The benefit of this approach is "
"that it is unnecessary to save tokens between invocations, so nothing is "
"saved to disk. {project_name} uses this mode when the `--no-config` argument"
" is specified."
msgstr ""
"2つ目のメカニズムは、各コマンドの呼び出しをその間だけ認証するものです。このメカニズムでは、サーバーの負荷が高まり、トークンを取得するためのラウンドトリップにかかる時間が長くなります。この方法の利点は、起動の間にトークンを保存する必要がないため、ディスクに何も保存されないことです。{project_name}では、`--no-"
"config` という引数を指定すると、このモードを使用します。"

msgid ""
"For example, when performing an operation, specify all the information "
"required for authentication."
msgstr "たとえば、操作を行う際には、認証に必要なすべての情報を指定します。"

msgid ""
"$ kcadm.sh get realms --no-config --server http://localhost:8080/auth "
"--realm master --user admin --password admin"
msgstr ""
"$ kcadm.sh get realms --no-config --server http://localhost:8080/auth "
"--realm master --user admin --password admin"

msgid ""
"Run the `kcadm.sh help` command for more information on using the Admin CLI."
msgstr "管理CLIの使い方の詳細については、 `kcadm.sh help` コマンドを実行してください。"

msgid ""
"Run the `kcadm.sh config credentials --help` command for more information "
"about starting an authenticated session."
msgstr ""
"認証済みセッションの開始に関する詳細は、 `kcadm.sh config credentials --help` コマンドを実行してください。"

msgid "Working with alternative configurations"
msgstr "代替設定の使用"

msgid ""
"By default, the Admin CLI maintains a configuration file named "
"`kcadm.config`. {project_name} places this file in the user's home "
"directory. In Linux-based systems, the full pathname is "
"`$HOME/.keycloak/kcadm.config`. In Windows, the full pathname is "
"`%HOMEPATH%\\.keycloak\\kcadm.config`."
msgstr ""
"デフォルトでは、管理CLIは `kcadm.config` という名前の設定ファイルを管理しています。{project_name} "
"は、このファイルをユーザのホーム・ディレクトリーに置きます。 Linuxベースのシステムでは、フルパス名は "
"`$HOME/.keycloak/kcadm.config` です。  Windowsでは、フルパス名は "
"`%HOMEPATH%\\.keycloak\\kcadm.config` となります。"

msgid ""
"You can use the `--config` option to point to a different file or location "
"so you can maintain multiple authenticated sessions in parallel."
msgstr "また、 `--config` オプションを使って別のファイルや場所を指定すれば、複数の認証済みセッションを並行して維持することができます。"

msgid ""
"Perform operations tied to a single configuration file from a single thread."
msgstr "1つの設定ファイルに結びついた操作を1つのスレッドから行います。"

msgid ""
"Ensure the configuration file is invisible to other users on the system. It "
"contains access tokens and secrets that must be private. {project_name} "
"creates the `~/.keycloak` directory and its contents automatically with "
"proper access limits. If the directory already exists, {project_name} does "
"not update the directory's permissions."
msgstr ""
"設定ファイルは、システム上の他のユーザーからは見えないようにしてください。このファイルには、プライベートでなければならないアクセストークンとシークレットが含まれています。{project_name}は、"
" `~/.keycloak`  "
"ディレクトリーとそのコンテンツを適切なアクセス制限で自動的に作成します。ディレクトリーがすでに存在する場合、{project_name}はディレクトリーのパーミッションを更新しません。"

msgid ""
"It is possible to avoid storing secrets inside a configuration file, but "
"doing so is inconvenient and increases the number of token requests. Use the"
" `--no-config` option with all commands and specify the authentication "
"information the `config credentials` command requires with each invocation "
"of `kcadm`."
msgstr ""
"設定ファイル内にシークレットを保存しないようにすることも可能ですが、そうすると不便で、かつトークンのリクエスト数も増えてしまいます。すべてのコマンドで "
"`--no-config` オプションを使用し、 `config credentials` コマンドが要求する認証情報を `kcadm` "
"の起動時に指定してください。"

msgid "Basic operations and resource URIs"
msgstr "基本操作とリソースURI"

msgid ""
"The Admin CLI can generically perform CRUD operations against Admin REST API"
" endpoints with additional commands that simplify particular tasks."
msgstr ""
"管理CLIは、特定のタスクを簡略化する追加のコマンドを使用して、管理REST APIエンドポイントに対して一般的にCRUD操作を実行できます。"

msgid "The main usage pattern is listed here:"
msgstr "主な使用パターンをご紹介します。"

msgid ""
"$ kcadm.sh create ENDPOINT [ARGUMENTS]\n"
"$ kcadm.sh get ENDPOINT [ARGUMENTS]\n"
"$ kcadm.sh update ENDPOINT [ARGUMENTS]\n"
"$ kcadm.sh delete ENDPOINT [ARGUMENTS]"
msgstr ""
"$ kcadm.sh create ENDPOINT [ARGUMENTS]\n"
"$ kcadm.sh get ENDPOINT [ARGUMENTS]\n"
"$ kcadm.sh update ENDPOINT [ARGUMENTS]\n"
"$ kcadm.sh delete ENDPOINT [ARGUMENTS]"

msgid ""
"The `create`, `get`, `update`, and `delete` commands map to the HTTP verbs "
"`POST`, `GET`, `PUT`, and `DELETE`, respectively. ENDPOINT is a target "
"resource URI and can be absolute (starting with `http:` or `https:`) or "
"relative, that {project_name} uses to compose absolute URLs in the following"
" format:"
msgstr ""
"create` 、 `get` 、 `update` 、 `delete` コマンドは、それぞれHTTPの `POST` 、 `GET` 、 `PUT`"
" 、 `DELETE` に対応しています。ENDPOINTはターゲットとなるリソースのURIで、絶対指定（ `http:` または `https:` "
"で始まる）または相対指定が可能で、{project_name}では以下の形式で絶対指定のURLを構成しています。"

msgid "SERVER_URI/admin/realms/REALM/ENDPOINT"
msgstr "SERVER_URI/admin/realms/REALM/ENDPOINT"

msgid ""
"For example, if you authenticate against the server "
"http://localhost:8080/auth and realm is `master`, using `users` as ENDPOINT "
"creates the http://localhost:8080/auth/admin/realms/master/users resource "
"URL."
msgstr ""
"たとえば、サーバーhttp://localhost:8080/authに対して認証を行い、レルムが `master` である場合、 `users` "
"をENDPOINTとして使用すると、http://localhost:8080/auth/admin/realms/master/usersのリソースURLが作成されます。"

msgid ""
"If you set ENDPOINT to `clients`, the effective resource URI is "
"http://localhost:8080/auth/admin/realms/master/clients."
msgstr ""
"ENDPOINTを `clients` "
"に設定した場合、有効なリソースURIはhttp://localhost:8080/auth/admin/realms/master/clientsです。"

msgid ""
"{project_name} has a `realms` endpoint that is the container for realms. It "
"resolves to:"
msgstr ""
"{project_name}には、 `realms` というエンドポイントがあり、これはレルムに対するコンテナーです。これは以下のように解決されます。"

msgid "SERVER_URI/admin/realms"
msgstr "SERVER_URI/admin/realms"

msgid ""
"{project_name} has a `serverinfo` endpoint. This endpoint is independent of "
"realms."
msgstr "{project_name} は `serverinfo` というエンドポイントを持っています。このエンドポイントはレルムとは無関係です。"

msgid ""
"When you authenticate as a user with realm-admin powers, you may need to "
"perform commands on multiple realms. If so, specify the `-r` option to tell "
"the CLI which realm the command is to execute against explicitly. Instead of"
" using `REALM` as specified by the `--realm` option of `kcadm.sh config "
"credentials`, the command uses `TARGET_REALM`."
msgstr ""
"realm-admin権限を持つユーザーとして認証された場合、複数のレルムに対してコマンドを実行する必要があるかもしれません。その場合は、`-r` "
"オプションを指定して、どのレルムに対してコマンドを実行するのかをCLIに明示的に伝えます。このコマンドは、 `kcadm.sh config "
"credentials` の `--realm` オプションで指定された `REALM` を使用する代わりに、 `TARGET_REALM` "
"を使用します。"

msgid "SERVER_URI/admin/realms/TARGET_REALM/ENDPOINT"
msgstr "SERVER_URI/admin/realms/TARGET_REALM/ENDPOINT"

msgid ""
"$ kcadm.sh config credentials --server http://localhost:8080/auth --realm master --user admin --password admin\n"
"$ kcadm.sh create users -s username=testuser -s enabled=true -r demorealm"
msgstr ""
"$ kcadm.sh config credentials --server http://localhost:8080/auth --realm master --user admin --password admin\n"
"$ kcadm.sh create users -s username=testuser -s enabled=true -r demorealm"

msgid ""
"In this example, you start a session authenticated as the `admin` user in "
"the `master` realm. You then perform a POST call against the resource URL "
"`http://localhost:8080/auth/admin/realms/demorealm/users`."
msgstr ""
"この例では、 `master` レルムの `admin` ユーザーとして認証されたセッションを開始します。その後、リソースURL  "
"`http://localhost:8080/auth/admin/realms/demorealm/users` に対してPOSTコールを実行します。"

msgid ""
"The `create` and `update` commands send a JSON body to the server. You can "
"use `-f FILENAME` to read a pre-made document from a file. When you can use "
"the `-f -` option, {project_name} reads the message body from the standard "
"input. You can specify individual attributes and their values, as seen in "
"the `create users` example. {project_name} composes the attributes into a "
"JSON body and sends them to the server."
msgstr ""
"`create` と `update` のコマンドは、JSONのボディーをサーバーに送信します。また、 `-f FILENAME` "
"を使うと、あらかじめ作成しておいたドキュメントをファイルから読み込むことができます。`-f -` "
"オプションを使用できるとき、{project_name}は標準入力からメッセージ本文を読み込みます。 `create users` "
"の例のように，個々の属性とその値を指定することができます。{project_name}は属性をJSONボディーにまとめてサーバーに送信します。"

msgid ""
"Several methods are available in {project_name} to update a resource using "
"the `update` command. You can determine the current state of a resource and "
"save it to a file, edit that file, and send it to the server for an update."
msgstr ""
"{project_name}では、 `update` "
"コマンドを使ってリソースを更新する方法がいくつか用意されています。リソースの現在の状態を判断してファイルに保存し、そのファイルを編集して、サーバーに送信して更新することができます。"

msgid ""
"$ kcadm.sh get realms/demorealm > demorealm.json\n"
"$ vi demorealm.json\n"
"$ kcadm.sh update realms/demorealm -f demorealm.json"
msgstr ""
"$ kcadm.sh get realms/demorealm > demorealm.json\n"
"$ vi demorealm.json\n"
"$ kcadm.sh update realms/demorealm -f demorealm.json"

msgid ""
"This method updates the resource on the server with the attributes in the "
"sent JSON document."
msgstr "このメソッドは、サーバー上のリソースを、送信されたJSONドキュメントの属性で更新します。"

msgid ""
"Another method is to perform an on-the-fly update by using the `-s, --set` "
"options to set new values."
msgstr "もう一つの方法は、 `-s, -set` オプションを使って新しい値を設定し、オンザフライでアップデートを行う方法です。"

msgid "$ kcadm.sh update realms/demorealm -s enabled=false"
msgstr "$ kcadm.sh update realms/demorealm -s enabled=false"

msgid "This method sets the `enabled` attribute to `false`."
msgstr "このメソッドは、`enabled` 属性を `false` に設定します。"

msgid ""
"By default, the `update` command performs a `get` and then merges the new "
"attribute values with existing values. In some cases, the endpoint may "
"support the `put` command but not the `get` command. You can use the `-n` "
"option to perform a no-merge update, which performs a `put` command without "
"first running a `get` command."
msgstr ""
"デフォルトでは、 `update` コマンドは `get` を実行して、新しい属性値を既存の値にマージします。場合によっては、エンドポイントが "
"`put` コマンドをサポートしていても `get` コマンドをサポートしていないことがあります。 `-n`オプションを使用すると、 `get` "
"コマンドを実行せずに `put` コマンドを実行する、マージなしのアップデートを実行できます。"

msgid "Realm operations"
msgstr "レルム操作"

msgid "Creating a new realm"
msgstr "新しいレルムを作成する"

msgid ""
"Use the `create` command on the `realms` endpoint to create a new enabled "
"realm. Set the attributes to `realm` and `enabled`."
msgstr ""
"`realms` エンドポイントで `create` コマンドを使用して、新しい有効なレルムを作成します。属性を `realm` と `enabled`"
" に設定します。"

msgid "$ kcadm.sh create realms -s realm=demorealm -s enabled=true"
msgstr "$ kcadm.sh create realms -s realm=demorealm -s enabled=true"

msgid ""
"{project_name} disables realms by default. You can use a realm immediately "
"for authentication by enabling it."
msgstr "{project_name}はデフォルトでレルムを無効にします。レルムを有効にすることで、すぐに認証に使用することができます。"

msgid "A description for a new object can also be in JSON format."
msgstr "新しいオブジェクトの説明は、JSON形式でもよい。"

msgid "$ kcadm.sh create realms -f demorealm.json"
msgstr "$ kcadm.sh create realms -f demorealm.json"

msgid ""
"You can send a JSON document with realm attributes directly from a file or "
"pipe the document to standard input."
msgstr "レルム属性を持つJSONドキュメントをファイルから直接送信したり、ドキュメントを標準入力にパイプすることができます。"

msgid ""
"$ kcadm.sh create realms -f - << EOF\n"
"{ \"realm\": \"demorealm\", \"enabled\": true }\n"
"EOF"
msgstr ""
"$ kcadm.sh create realms -f - << EOF\n"
"{ \"realm\": \"demorealm\", \"enabled\": true }\n"
"EOF"

msgid ""
"c:\\> echo { \"realm\": \"demorealm\", \"enabled\": true } | kcadm create "
"realms -f -"
msgstr ""
"c:\\> echo { \"realm\": \"demorealm\", \"enabled\": true } | kcadm create "
"realms -f -"

msgid "Listing existing realms"
msgstr "既存レルムの一覧表示"

msgid "This command returns a list of all realms."
msgstr "このコマンドは、すべてのレルムのリストを返します。"

msgid "$ kcadm.sh get realms"
msgstr "$ kcadm.sh get realms"

msgid ""
"{project_name} filters the list of realms on the server to return realms a "
"user can see only."
msgstr "{project_name}サーバー上のレルムのリストをフィルタリングして、ユーザーが見ることのできるレルムのみを返すようにします。"

msgid ""
"The list of all realm attributes can be verbose, and most users are "
"interested in a subset of attributes, such as the realm name and the enabled"
" status of the realm. You can specify the attributes to return by using the "
"`--fields` option."
msgstr ""
"すべてのレルム属性のリストは冗長になる可能性があり、ほとんどのユーザーは、レルム名やレルムの有効化状態などの属性のサブセットに興味を持っています。また、"
" `--fields` オプションを使って、返す属性を指定することもできます。"

msgid "$ kcadm.sh get realms --fields realm,enabled"
msgstr "$ kcadm.sh get realms --fields realm,enabled"

msgid "You can display the result as comma-separated values."
msgstr "結果をカンマ区切りの値で表示することができます。"

msgid "$ kcadm.sh get realms --fields realm --format csv --noquotes"
msgstr "$ kcadm.sh get realms --fields realm --format csv --noquotes"

msgid "Getting a specific realm"
msgstr "特定のレルムを取得する"

msgid "Append a realm name to a collection URI to get an individual realm."
msgstr "コレクションURIにレルム名を追加して、個々のレルムを取得します。"

msgid "$ kcadm.sh get realms/master"
msgstr "$ kcadm.sh get realms/master"

msgid "Updating a realm"
msgstr "レルムの更新"

msgid ""
"Use the `-s` option to set new values for the attributes when you do not "
"want to change all of the realm's attributes."
msgstr "レルムのすべての属性を変更したくない場合は、 `-s` オプションを使って属性に新しい値を設定します。"

msgid "If you want to set all writable attributes to new values:"
msgstr "すべての書き込み可能な属性に新しい値を設定したい場合は、次の通りです。"

msgid "Run a `get` command."
msgstr "`get` コマンドを実行します。"

msgid "Edit the current values in the JSON file."
msgstr "JSONファイルの現在の値を編集します。"

msgid "Resubmit."
msgstr "再送信。"

msgid "Deleting a realm"
msgstr "レルムの削除"

msgid "Run the following command to delete a realm:"
msgstr "以下のコマンドを実行して、レルムを削除してください。"

msgid "$ kcadm.sh delete realms/demorealm"
msgstr "$ kcadm.sh delete realms/demorealm"

msgid "Turning on all login page options for the realm"
msgstr "レルムのすべてのログイン・ページ・オプションを有効にする"

msgid "Set the attributes that control specific capabilities to `true`."
msgstr "特定の機能を制御する属性を `true` に設定します。"

msgid ""
"$ kcadm.sh update realms/demorealm -s registrationAllowed=true -s "
"registrationEmailAsUsername=true -s rememberMe=true -s verifyEmail=true -s "
"resetPasswordAllowed=true -s editUsernameAllowed=true"
msgstr ""
"$ kcadm.sh update realms/demorealm -s registrationAllowed=true -s "
"registrationEmailAsUsername=true -s rememberMe=true -s verifyEmail=true -s "
"resetPasswordAllowed=true -s editUsernameAllowed=true"

msgid "Listing the realm keys"
msgstr "レルム鍵の一覧表示"

msgid "Use the `get` operation on the `keys` endpoint of the target realm."
msgstr "ターゲットレルムの `keys` エンドポイントに対して `get` オペレーションを使用します。"

msgid "$ kcadm.sh get keys -r demorealm"
msgstr "$ kcadm.sh get keys -r demorealm"

msgid "Generating new realm keys"
msgstr "新しいレルム鍵の生成"

msgid ""
"Get the ID of the target realm before adding a new RSA-generated key pair."
msgstr "新しいRSA生成キーペアを追加する前に、対象レルムのIDを取得します。"

msgid "$ kcadm.sh get realms/demorealm --fields id --format csv --noquotes"
msgstr "$ kcadm.sh get realms/demorealm --fields id --format csv --noquotes"

msgid ""
"Add a new key provider with a higher priority than the existing providers as"
" revealed by `kcadm.sh get keys -r demorealm`."
msgstr ""
"`kcadm.sh get keys -r demorealm` "
"で明らかになった既存のプロバイダーよりも高い優先度で、新しい鍵プロバイダーを追加します。"

msgid ""
"$ kcadm.sh create components -r demorealm -s name=rsa-generated -s "
"providerId=rsa-generated -s providerType=org.keycloak.keys.KeyProvider -s "
"parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s 'config.priority=[\"101\"]'"
" -s 'config.enabled=[\"true\"]' -s 'config.active=[\"true\"]' -s "
"'config.keySize=[\"2048\"]'"
msgstr ""
"$ kcadm.sh create components -r demorealm -s name=rsa-generated -s "
"providerId=rsa-generated -s providerType=org.keycloak.keys.KeyProvider -s "
"parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s 'config.priority=[\"101\"]'"
" -s 'config.enabled=[\"true\"]' -s 'config.active=[\"true\"]' -s "
"'config.keySize=[\"2048\"]'"

msgid ""
"c:\\> kcadm create components -r demorealm -s name=rsa-generated -s "
"providerId=rsa-generated -s providerType=org.keycloak.keys.KeyProvider -s "
"parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s "
"\"config.priority=[\\\"101\\\"]\" -s \"config.enabled=[\\\"true\\\"]\" -s "
"\"config.active=[\\\"true\\\"]\" -s \"config.keySize=[\\\"2048\\\"]\""
msgstr ""
"c:\\> kcadm create components -r demorealm -s name=rsa-generated -s "
"providerId=rsa-generated -s providerType=org.keycloak.keys.KeyProvider -s "
"parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s "
"\"config.priority=[\\\"101\\\"]\" -s \"config.enabled=[\\\"true\\\"]\" -s "
"\"config.active=[\\\"true\\\"]\" -s \"config.keySize=[\\\"2048\\\"]\""

msgid "Set the `parentId` attribute to the value of the target realm's ID."
msgstr "`parentId` 属性を対象レルムのIDの値に設定します。"

msgid ""
"The newly added key is now the active key, as revealed by `kcadm.sh get keys"
" -r demorealm`."
msgstr ""
"新たに追加された鍵は、 `kcadm.sh get keys -r demorealm` で明らかにされるように、アクティブな鍵になっています。"

msgid "Adding new realm keys from a Java Key Store file"
msgstr "Javaキーストア・ファイルから新しいレルム鍵を追加する"

msgid ""
"Add a new key provider to add a new key pair pre-prepared as a JKS file."
msgstr "新しい鍵プロバイダーを追加すると、JKSファイルとしてあらかじめ用意された新しいキーペアを追加することができます。"

msgid "For example, on:"
msgstr "以下に例を示します。"

msgid ""
"$ kcadm.sh create components -r demorealm -s name=java-keystore -s "
"providerId=java-keystore -s providerType=org.keycloak.keys.KeyProvider -s "
"parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s 'config.priority=[\"101\"]'"
" -s 'config.enabled=[\"true\"]' -s 'config.active=[\"true\"]' -s "
"'config.keystore=[\"/opt/keycloak/keystore.jks\"]' -s "
"'config.keystorePassword=[\"secret\"]' -s 'config.keyPassword=[\"secret\"]' "
"-s 'config.keyAlias=[\"localhost\"]'"
msgstr ""
"$ kcadm.sh create components -r demorealm -s name=java-keystore -s "
"providerId=java-keystore -s providerType=org.keycloak.keys.KeyProvider -s "
"parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s 'config.priority=[\"101\"]'"
" -s 'config.enabled=[\"true\"]' -s 'config.active=[\"true\"]' -s "
"'config.keystore=[\"/opt/keycloak/keystore.jks\"]' -s "
"'config.keystorePassword=[\"secret\"]' -s 'config.keyPassword=[\"secret\"]' "
"-s 'config.keyAlias=[\"localhost\"]'"

msgid ""
"c:\\> kcadm create components -r demorealm -s name=java-keystore -s "
"providerId=java-keystore -s providerType=org.keycloak.keys.KeyProvider -s "
"parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s "
"\"config.priority=[\\\"101\\\"]\" -s \"config.enabled=[\\\"true\\\"]\" -s "
"\"config.active=[\\\"true\\\"]\" -s "
"\"config.keystore=[\\\"/opt/keycloak/keystore.jks\\\"]\" -s "
"\"config.keystorePassword=[\\\"secret\\\"]\" -s "
"\"config.keyPassword=[\\\"secret\\\"]\" -s "
"\"config.keyAlias=[\\\"localhost\\\"]\""
msgstr ""
"c:\\> kcadm create components -r demorealm -s name=java-keystore -s "
"providerId=java-keystore -s providerType=org.keycloak.keys.KeyProvider -s "
"parentId=959844c1-d149-41d7-8359-6aa527fca0b0 -s "
"\"config.priority=[\\\"101\\\"]\" -s \"config.enabled=[\\\"true\\\"]\" -s "
"\"config.active=[\\\"true\\\"]\" -s "
"\"config.keystore=[\\\"/opt/keycloak/keystore.jks\\\"]\" -s "
"\"config.keystorePassword=[\\\"secret\\\"]\" -s "
"\"config.keyPassword=[\\\"secret\\\"]\" -s "
"\"config.keyAlias=[\\\"localhost\\\"]\""

msgid ""
"Ensure you change the attribute values for `keystore`, `keystorePassword`, "
"`keyPassword`, and `alias` to match your specific keystore."
msgstr ""
"`keystore` 、 `keystorePassword` 、 `keyPassword` 、 `alias` "
"の属性値を、使用するキーストアに合わせて変更してください。"

msgid "Making the key passive or disabling the key"
msgstr "鍵をパッシブにする、または無効にする"

msgid "Identify the key you want to make passive."
msgstr "パッシブにする鍵を特定します。"

msgid ""
"Use the key's `providerId` attribute to construct an endpoint URI, such as "
"`components/PROVIDER_ID`."
msgstr "鍵の `providerId` 属性を使って、`components/PROVIDER_ID` のようなエンドポイントURIを構築します。"

msgid "Perform an `update`."
msgstr "`update` を行う。"

msgid ""
"$ kcadm.sh update components/PROVIDER_ID -r demorealm -s "
"'config.active=[\"false\"]'"
msgstr ""
"$ kcadm.sh update components/PROVIDER_ID -r demorealm -s "
"'config.active=[\"false\"]'"

msgid ""
"c:\\> kcadm update components/PROVIDER_ID -r demorealm -s "
"\"config.active=[\\\"false\\\"]\""
msgstr ""
"c:\\> kcadm update components/PROVIDER_ID -r demorealm -s "
"\"config.active=[\\\"false\\\"]\""

msgid "You can update other key attributes:"
msgstr "以下のように、他の主要な属性を更新することができます。"

msgid ""
"Set a new `enabled` value to disable the key, for example, "
"`config.enabled=[\"false\"]`."
msgstr "たとえば、 `config.enabled=[\"false\"]` のように、鍵を無効にするために `enabled` の値を設定してください。"

msgid ""
"Set a new `priority` value to change the key's priority, for example, "
"`config.priority=[\"110\"]`."
msgstr "鍵の優先度を変更するために新しい `priority` 値を設定します。たとえば、 `config.priority=[\"110\"]` です。"

msgid "Deleting an old key"
msgstr "古い鍵を削除する"

msgid ""
"Ensure the key you are deleting is inactive and you have disabled it. This "
"action is to prevent existing tokens held by applications and users from "
"failing."
msgstr ""
"削除する鍵が非アクティブであり、無効化されていることを確認してください。このアクションは、アプリケーションやユーザーが保持する既存のトークンが失敗するのを防ぐためのものです。"

msgid "Identify the key to delete."
msgstr "削除する鍵を特定します。"

msgid "Use the `providerId` of the key to perform the delete."
msgstr "削除を実行するには、鍵の `providerId` を使用します。"

msgid "$ kcadm.sh delete components/PROVIDER_ID -r demorealm"
msgstr "$ kcadm.sh delete components/PROVIDER_ID -r demorealm"

msgid "Configuring event logging for a realm"
msgstr "レルムのイベントログの設定"

msgid "Use the `update` command on the `events/config` endpoint."
msgstr "`events/config` エンドポイントで `update` コマンドを使用してください。"

msgid ""
"The `eventsListeners` attribute contains a list of "
"EventListenerProviderFactory IDs, specifying all event listeners that "
"receive events. Attributes are available that control built-in event "
"storage, so you can query past events using the Admin REST API. "
"{project_name} has separate control over the logging of service calls "
"(`eventsEnabled`) and the  auditing events triggered by the Admin Console or"
" Admin REST API (`adminEventsEnabled`). You can set up the "
"`eventsExpiration` event to expire to prevent your database from filling. "
"{project_name} sets `eventsExpiration` to time-to-live expressed in seconds."
msgstr ""
"`eventsListeners` "
"属性には、イベントを受信するすべてのイベントリスナーを指定するEventListenerProviderFactoryのIDのリストが含まれています。ビルトインのイベント・ストレージを制御する属性が用意されているので、管理REST"
" APIを使って過去のイベントを照会することができます。{project_name}は、サービスコールのロギング（ `eventsEnabled` "
"）と、管理コンソールや管理REST APIでトリガーされる監査イベント（ `adminEventsEnabled` "
"）を個別に制御します。データベースがいっぱいにならないように、 `eventsExpiration` "
"イベントの有効期限を設定することができます。{project_name}は `eventsExpiration` に秒単位で表現されたtime-to-"
"liveを設定します。"

msgid ""
"You can set up a built-in event listener that receives all events and logs "
"the events through JBoss-logging. Using the `org.keycloak.events` logger, "
"{project_name} logs error events as `WARN` and other events as `DEBUG`."
msgstr ""
"すべてのイベントを受信し、JBoss-loggingを介してイベントを記録する組み込みイベントリスナーを設定できます。 "
"`org.keycloak.events` のロガーを使用して、{project_name}はエラーイベントを `WARN` として、その他のイベントを"
" `DEBUG` として記録します。"

msgid ""
"$ kcadm.sh update events/config -r demorealm -s 'eventsListeners=[\"jboss-"
"logging\"]'"
msgstr ""
"$ kcadm.sh update events/config -r demorealm -s 'eventsListeners=[\"jboss-"
"logging\"]'"

msgid ""
"c:\\> kcadm update events/config -r demorealm -s "
"\"eventsListeners=[\\\"jboss-logging\\\"]\""
msgstr ""
"c:\\> kcadm update events/config -r demorealm -s "
"\"eventsListeners=[\\\"jboss-logging\\\"]\""

msgid ""
"You can turn on storage for all available ERROR events, not including "
"auditing events, for two days so you can retrieve the events through Admin "
"REST."
msgstr ""
"監査イベントを含まない、すべての利用可能なERRORイベントのストレージを2日間オンにして、管理RESTでイベントを取得できるようにすることができます。"

msgid ""
"$ kcadm.sh update events/config -r demorealm -s eventsEnabled=true -s "
"'enabledEventTypes=[\"LOGIN_ERROR\",\"REGISTER_ERROR\",\"LOGOUT_ERROR\",\"CODE_TO_TOKEN_ERROR\",\"CLIENT_LOGIN_ERROR\",\"FEDERATED_IDENTITY_LINK_ERROR\",\"REMOVE_FEDERATED_IDENTITY_ERROR\",\"UPDATE_EMAIL_ERROR\",\"UPDATE_PROFILE_ERROR\",\"UPDATE_PASSWORD_ERROR\",\"UPDATE_TOTP_ERROR\",\"VERIFY_EMAIL_ERROR\",\"REMOVE_TOTP_ERROR\",\"SEND_VERIFY_EMAIL_ERROR\",\"SEND_RESET_PASSWORD_ERROR\",\"SEND_IDENTITY_PROVIDER_LINK_ERROR\",\"RESET_PASSWORD_ERROR\",\"IDENTITY_PROVIDER_FIRST_LOGIN_ERROR\",\"IDENTITY_PROVIDER_POST_LOGIN_ERROR\",\"CUSTOM_REQUIRED_ACTION_ERROR\",\"EXECUTE_ACTIONS_ERROR\",\"CLIENT_REGISTER_ERROR\",\"CLIENT_UPDATE_ERROR\",\"CLIENT_DELETE_ERROR\"]'"
" -s eventsExpiration=172800"
msgstr ""
"$ kcadm.sh update events/config -r demorealm -s eventsEnabled=true -s "
"'enabledEventTypes=[\"LOGIN_ERROR\",\"REGISTER_ERROR\",\"LOGOUT_ERROR\",\"CODE_TO_TOKEN_ERROR\",\"CLIENT_LOGIN_ERROR\",\"FEDERATED_IDENTITY_LINK_ERROR\",\"REMOVE_FEDERATED_IDENTITY_ERROR\",\"UPDATE_EMAIL_ERROR\",\"UPDATE_PROFILE_ERROR\",\"UPDATE_PASSWORD_ERROR\",\"UPDATE_TOTP_ERROR\",\"VERIFY_EMAIL_ERROR\",\"REMOVE_TOTP_ERROR\",\"SEND_VERIFY_EMAIL_ERROR\",\"SEND_RESET_PASSWORD_ERROR\",\"SEND_IDENTITY_PROVIDER_LINK_ERROR\",\"RESET_PASSWORD_ERROR\",\"IDENTITY_PROVIDER_FIRST_LOGIN_ERROR\",\"IDENTITY_PROVIDER_POST_LOGIN_ERROR\",\"CUSTOM_REQUIRED_ACTION_ERROR\",\"EXECUTE_ACTIONS_ERROR\",\"CLIENT_REGISTER_ERROR\",\"CLIENT_UPDATE_ERROR\",\"CLIENT_DELETE_ERROR\"]'"
" -s eventsExpiration=172800"

msgid ""
"c:\\> kcadm update events/config -r demorealm -s eventsEnabled=true -s "
"\"enabledEventTypes=[\\\"LOGIN_ERROR\\\",\\\"REGISTER_ERROR\\\",\\\"LOGOUT_ERROR\\\",\\\"CODE_TO_TOKEN_ERROR\\\",\\\"CLIENT_LOGIN_ERROR\\\",\\\"FEDERATED_IDENTITY_LINK_ERROR\\\",\\\"REMOVE_FEDERATED_IDENTITY_ERROR\\\",\\\"UPDATE_EMAIL_ERROR\\\",\\\"UPDATE_PROFILE_ERROR\\\",\\\"UPDATE_PASSWORD_ERROR\\\",\\\"UPDATE_TOTP_ERROR\\\",\\\"VERIFY_EMAIL_ERROR\\\",\\\"REMOVE_TOTP_ERROR\\\",\\\"SEND_VERIFY_EMAIL_ERROR\\\",\\\"SEND_RESET_PASSWORD_ERROR\\\",\\\"SEND_IDENTITY_PROVIDER_LINK_ERROR\\\",\\\"RESET_PASSWORD_ERROR\\\",\\\"IDENTITY_PROVIDER_FIRST_LOGIN_ERROR\\\",\\\"IDENTITY_PROVIDER_POST_LOGIN_ERROR\\\",\\\"CUSTOM_REQUIRED_ACTION_ERROR\\\",\\\"EXECUTE_ACTIONS_ERROR\\\",\\\"CLIENT_REGISTER_ERROR\\\",\\\"CLIENT_UPDATE_ERROR\\\",\\\"CLIENT_DELETE_ERROR\\\"]\""
" -s eventsExpiration=172800"
msgstr ""
"c:\\> kcadm update events/config -r demorealm -s eventsEnabled=true -s "
"\"enabledEventTypes=[\\\"LOGIN_ERROR\\\",\\\"REGISTER_ERROR\\\",\\\"LOGOUT_ERROR\\\",\\\"CODE_TO_TOKEN_ERROR\\\",\\\"CLIENT_LOGIN_ERROR\\\",\\\"FEDERATED_IDENTITY_LINK_ERROR\\\",\\\"REMOVE_FEDERATED_IDENTITY_ERROR\\\",\\\"UPDATE_EMAIL_ERROR\\\",\\\"UPDATE_PROFILE_ERROR\\\",\\\"UPDATE_PASSWORD_ERROR\\\",\\\"UPDATE_TOTP_ERROR\\\",\\\"VERIFY_EMAIL_ERROR\\\",\\\"REMOVE_TOTP_ERROR\\\",\\\"SEND_VERIFY_EMAIL_ERROR\\\",\\\"SEND_RESET_PASSWORD_ERROR\\\",\\\"SEND_IDENTITY_PROVIDER_LINK_ERROR\\\",\\\"RESET_PASSWORD_ERROR\\\",\\\"IDENTITY_PROVIDER_FIRST_LOGIN_ERROR\\\",\\\"IDENTITY_PROVIDER_POST_LOGIN_ERROR\\\",\\\"CUSTOM_REQUIRED_ACTION_ERROR\\\",\\\"EXECUTE_ACTIONS_ERROR\\\",\\\"CLIENT_REGISTER_ERROR\\\",\\\"CLIENT_UPDATE_ERROR\\\",\\\"CLIENT_DELETE_ERROR\\\"]\""
" -s eventsExpiration=172800"

msgid ""
"You can reset stored event types to *all available event types*. Setting the"
" value to an empty list is the same as enumerating all."
msgstr ""
"保存されているイベントタイプを、 *すべての利用可能なイベントタイプ* "
"にリセットすることができます。値を空のリストにすることは、すべてを列挙することと同じです。"

msgid "$ kcadm.sh update events/config -r demorealm -s enabledEventTypes=[]"
msgstr "$ kcadm.sh update events/config -r demorealm -s enabledEventTypes=[]"

msgid "You can enable storage of auditing events."
msgstr "監査イベントの保存を有効にすることができます。"

msgid ""
"$ kcadm.sh update events/config -r demorealm -s adminEventsEnabled=true -s "
"adminEventsDetailsEnabled=true"
msgstr ""
"$ kcadm.sh update events/config -r demorealm -s adminEventsEnabled=true -s "
"adminEventsDetailsEnabled=true"

msgid ""
"You can get the last 100 events. The events are ordered from newest to "
"oldest."
msgstr "過去100件のイベントを取得できます。イベントは新しいものから順に表示されます。"

msgid "$ kcadm.sh get events --offset 0 --limit 100"
msgstr "$ kcadm.sh get events --offset 0 --limit 100"

msgid "You can delete all saved events."
msgstr "保存したイベントをすべて削除することができます。"

msgid "$ kcadm delete events"
msgstr "$ kcadm delete events"

msgid "Flushing the caches"
msgstr "キャッシュのフラッシュ"

msgid "Use the `create` command with one of these endpoints to clear caches:"
msgstr "キャッシュをクリアするには、これらのエンドポイントのいずれかで `create` コマンドを使用します。"

msgid "`clear-realm-cache`"
msgstr "`clear-realm-cache`"

msgid "`clear-user-cache`"
msgstr "`clear-user-cache`"

msgid "`clear-keys-cache`"
msgstr "`clear-keys-cache`"

msgid "Set `realm` to the same value as the target realm."
msgstr "`realm` を対象のレルムと同じ値に設定します。"

msgid ""
"$ kcadm.sh create clear-realm-cache -r demorealm -s realm=demorealm\n"
"$ kcadm.sh create clear-user-cache -r demorealm -s realm=demorealm\n"
"$ kcadm.sh create clear-keys-cache -r demorealm -s realm=demorealm"
msgstr ""
"$ kcadm.sh create clear-realm-cache -r demorealm -s realm=demorealm\n"
"$ kcadm.sh create clear-user-cache -r demorealm -s realm=demorealm\n"
"$ kcadm.sh create clear-keys-cache -r demorealm -s realm=demorealm"

msgid "Importing a realm from exported .json file"
msgstr "エクスポートされた.jsonファイルからのレルムのインポート"

msgid "Use the `create` command on the `partialImport` endpoint."
msgstr "`partialImport` エンドポイントで `create` コマンドを使用します。"

msgid "Set `ifResourceExists` to `FAIL`, `SKIP`, or `OVERWRITE`."
msgstr "`ifResourceExists` を `FAIL` 、 `SKIP` 、 `OVERWRITE` のいずれかに設定します。"

msgid "Use `-f` to submit the exported realm `.json` file."
msgstr "エクスポートされたレルム `.json` ファイルを送信するには、 `-f` を使います。"

msgid ""
"$ kcadm.sh create partialImport -r demorealm2 -s ifResourceExists=FAIL -o -f"
" demorealm.json"
msgstr ""
"$ kcadm.sh create partialImport -r demorealm2 -s ifResourceExists=FAIL -o -f"
" demorealm.json"

msgid "If the realm does not yet exist, create it first."
msgstr "レルムが存在しない場合は、まずそれを作成します。"

msgid "$ kcadm.sh create realms -s realm=demorealm2 -s enabled=true"
msgstr "$ kcadm.sh create realms -s realm=demorealm2 -s enabled=true"

msgid "Role operations"
msgstr "ロール操作"

msgid "Use the `roles` endpoint to create a realm role."
msgstr "`roles` エンドポイントを使って、レルムロールを作成します。"

msgid ""
"$ kcadm.sh create roles -r demorealm -s name=user -s 'description=Regular "
"user with a limited set of permissions'"
msgstr ""
"$ kcadm.sh create roles -r demorealm -s name=user -s 'description=Regular "
"user with a limited set of permissions'"

msgid "Creating a client role"
msgstr "クライアントロールの作成"

msgid "Identify the client."
msgstr "クライアントを特定します。"

msgid "Use the `get` command to list the available clients."
msgstr "利用可能なクライアントの一覧を表示するには、 `get` コマンドを使用します。"

msgid "$ kcadm.sh get clients -r demorealm --fields id,clientId"
msgstr "$ kcadm.sh get clients -r demorealm --fields id,clientId"

msgid ""
"Create a new role by using the `clientId` attribute to construct an endpoint"
" URI, such as `clients/ID/roles`."
msgstr "`clients/ID/roles`のように、 `clientId` 属性を使ってエンドポイントURIを構築し、新しいロールを作成します。"

msgid ""
"$ kcadm.sh create clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles -r "
"demorealm -s name=editor -s 'description=Editor can edit, and publish any "
"article'"
msgstr ""
"$ kcadm.sh create clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles -r "
"demorealm -s name=editor -s 'description=Editor can edit, and publish any "
"article'"

msgid "Listing realm roles"
msgstr "レルムロールの一覧表示"

msgid ""
"Use the `get` command on the `roles` endpoint to list existing realm roles."
msgstr "既存のレルムロールをリストアップするには、 `roles` エンドポイントの `get` コマンドを使います。"

msgid "$ kcadm.sh get roles -r demorealm"
msgstr "$ kcadm.sh get roles -r demorealm"

msgid "You can use the `get-roles` command also."
msgstr "また、 `get-roles` コマンドを使用することもできます。"

msgid "$ kcadm.sh get-roles -r demorealm"
msgstr "$ kcadm.sh get-roles -r demorealm"

msgid "Listing client roles"
msgstr "クライアントロールの一覧表示"

msgid ""
"{project_name} has a dedicated `get-roles` command to simplify the listing "
"of realm and client roles. The command is an extension of the `get` command "
"and behaves the same as the `get` command but with additional semantics for "
"listing roles."
msgstr ""
"{project_name}には、専用の `get-roles` "
"コマンドが用意されており、レルムやクライアントロールのリストアップを簡単に行うことができます。このコマンドは、 `get` コマンドを拡張したもので、 "
"`get` コマンドと同じ動作をしますが、ロールのリスト化には追加のセマンティクスが必要です。"

msgid ""
"Use the `get-roles` command by passing it the clientId (`--cclientid`) "
"option or the `id` (`--cid`) option to identify the client to list client "
"roles."
msgstr ""
"`get-roles` コマンドに `clientId` （ `--cclientid` ）オプションまたは `id` （`--cid` "
"）オプションを渡してクライアントを識別し、クライアントロールをリストアップします。"

msgid "$ kcadm.sh get-roles -r demorealm --cclientid realm-management"
msgstr "$ kcadm.sh get-roles -r demorealm --cclientid realm-management"

msgid "Getting a specific realm role"
msgstr "特定のレルムロールを取得する"

msgid ""
"Use the `get` command and the role `name` to construct an endpoint URI for a"
" specific realm role, `roles/ROLE_NAME`, where `user` is the existing role's"
" name."
msgstr ""
"特定のレルムロールのエンドポイントURIを構築するには、 `get` コマンドとロール `name` を使用します。 `roles/ROLE_NAME`"
" （ `user` は既存ロールの名前）。"

msgid "$ kcadm.sh get roles/user -r demorealm"
msgstr "$ kcadm.sh get roles/user -r demorealm"

msgid ""
"You can use the `get-roles` command, passing it a role name (`--rolename` "
"option) or ID (`--roleid` option)."
msgstr ""
"ロール名（ `--rolename` オプション）またはID（ `--roleid` オプション）を渡して、 `get-roles` "
"コマンドを使用することができます。"

msgid "$ kcadm.sh get-roles -r demorealm --rolename user"
msgstr "$ kcadm.sh get-roles -r demorealm --rolename user"

msgid "Getting a specific client role"
msgstr "特定のクライアントロールを取得する"

msgid ""
"Use the `get-roles` command, passing it the clientId attribute "
"(`--cclientid` option) or ID attribute (`--cid` option) to identify the "
"client, and pass the role name (`--rolename` option) or the role ID "
"attribute (`--roleid`) to identify a specific client role."
msgstr ""
"`get-roles` コマンドを使用して、クライアントを識別するためにclientId属性（ `--cclientid` オプション）またはID属性（"
" `--cid` オプション）を渡し、特定のクライアントロールを識別するためにロール名（ `--rolename` オプション）またはロールID属性（ "
"`--roleid` ）を渡します。"

msgid ""
"$ kcadm.sh get-roles -r demorealm --cclientid realm-management --rolename "
"manage-clients"
msgstr ""
"$ kcadm.sh get-roles -r demorealm --cclientid realm-management --rolename "
"manage-clients"

msgid "Updating a realm role"
msgstr "レルムロールの更新"

msgid ""
"Use the `update` command with the endpoint URI you used to get a specific "
"realm role."
msgstr "特定のレルムロールを取得するために使用したエンドポイントURIで、 `update` コマンドを使用します。"

msgid ""
"$ kcadm.sh update roles/user -r demorealm -s 'description=Role representing "
"a regular user'"
msgstr ""
"$ kcadm.sh update roles/user -r demorealm -s 'description=Role representing "
"a regular user'"

msgid "Updating a client role"
msgstr "クライアントロールの更新"

msgid ""
"Use the `update` command with the endpoint URI that you used to get a "
"specific client role."
msgstr "特定のクライアントロールを取得するために使用したエンドポイントURIを指定して、 `update` コマンドを使用します。"

msgid ""
"$ kcadm.sh update clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles/editor "
"-r demorealm -s 'description=User that can edit, and publish articles'"
msgstr ""
"$ kcadm.sh update clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles/editor "
"-r demorealm -s 'description=User that can edit, and publish articles'"

msgid "Deleting a realm role"
msgstr "レルムロールの削除"

msgid ""
"Use the `delete` command with the endpoint URI that you used to get a "
"specific realm role."
msgstr "特定のレルムロールを取得する際に使用したエンドポイントURIを指定して、`delete` コマンドを使用します。"

msgid "$ kcadm.sh delete roles/user -r demorealm"
msgstr "$ kcadm.sh delete roles/user -r demorealm"

msgid "Deleting a client role"
msgstr "クライアントロールの削除"

msgid ""
"Use the `delete` command with the endpoint URI that you used to get a "
"specific client role."
msgstr "特定のクライアントロールを取得するために使用したエンドポイントURIを指定して、 `delete` コマンドを使用します。"

msgid ""
"$ kcadm.sh delete clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles/editor "
"-r demorealm"
msgstr ""
"$ kcadm.sh delete clients/a95b6af3-0bdc-4878-ae2e-6d61a4eca9a0/roles/editor "
"-r demorealm"

msgid ""
"Listing assigned, available, and effective realm roles for a composite role"
msgstr "複合ロールに割り当てられた、利用可能な、有効なレルムロールの一覧表示"

msgid ""
"Use the `get-roles` command to list assigned, available, and effective realm"
" roles for a composite role."
msgstr "複合ロールが割り当てられ、利用可能かつ有効なレルムロールを一覧表示するには、 `get-roles` コマンドを使用します。"

msgid ""
"To list *assigned* realm roles for the composite role, specify the target "
"composite role by name (`--rname` option) or ID (`--rid` option)."
msgstr ""
"複合ロールに対して *割り当てられた* レルムロールを一覧表示するには、対象となる複合ロールを名前（ `--rname` オプション）またはID（ "
"`--rid` オプション）で指定します。"

msgid "$ kcadm.sh get-roles -r demorealm --rname testrole"
msgstr "$ kcadm.sh get-roles -r demorealm --rname testrole"

msgid "Use the `--effective` option to list *effective* realm roles."
msgstr "*有効な* レルムロールをリストアップするには、 `--effective` オプションを使用します。"

msgid "$ kcadm.sh get-roles -r demorealm --rname testrole --effective"
msgstr "$ kcadm.sh get-roles -r demorealm --rname testrole --effective"

msgid ""
"Use the `--available` option to list realm roles that you can add to the "
"composite role."
msgstr "複合ロールに追加できるレルムロールの一覧を表示するには、 `--available` オプションを使用します。"

msgid "$ kcadm.sh get-roles -r demorealm --rname testrole --available"
msgstr "$ kcadm.sh get-roles -r demorealm --rname testrole --available"

msgid ""
"Listing assigned, available, and effective client roles for a composite role"
msgstr "複合ロールに割り当てられた、利用可能な、有効なクライアントロールの一覧表示"

msgid ""
"Use the `get-roles` command to list assigned, available, and effective "
"client roles for a composite role."
msgstr "複合ロールが割り当てられ、利用可能かつ有効なクライアントロールを一覧表示するには、 `get-roles` コマンドを使用します。"

msgid ""
"To list *assigned* client roles for the composite role, you can specify the "
"target composite role by name (`--rname` option) or ID (`--rid` option) and "
"client by the clientId attribute (`--cclientid` option) or ID (`--cid` "
"option)."
msgstr ""
"複合ロールに対して *割り当てられた* クライアントロールを一覧表示するには、対象となる複合ロールを名前（ `--rname` オプション）またはID（"
" `--rid` オプション）で、クライアントをclientId属性（ `--cclientid` オプション）またはID（ `--cid` "
"オプション）で指定します。"

msgid ""
"$ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-"
"management"
msgstr ""
"$ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-"
"management"

msgid ""
"$ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-"
"management --effective"
msgstr ""
"$ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-"
"management --effective"

msgid ""
"Use the `--available` option to list realm roles that you can add to the "
"target composite role."
msgstr "対象となる複合ロールに追加できるレルムロールの一覧を表示するには、 `--available` オプションを使用します。"

msgid ""
"$ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-"
"management --available"
msgstr ""
"$ kcadm.sh get-roles -r demorealm --rname testrole --cclientid realm-"
"management --available"

msgid "Adding realm roles to a composite role"
msgstr "レルムロールを複合ロールに追加する"

msgid ""
"{project_name} provides an `add-roles` command for adding realm roles and "
"client roles."
msgstr "{project_name}は、レルムロールやクライアントロールを追加するための `add-roles` コマンドを提供します。"

msgid "This example adds the `user` role to the composite role `testrole`."
msgstr "この例では、 `testrole` という複合ロールに `user` というロールを追加しています。"

msgid "$ kcadm.sh add-roles --rname testrole --rolename user -r demorealm"
msgstr "$ kcadm.sh add-roles --rname testrole --rolename user -r demorealm"

msgid "Removing realm roles from a composite role"
msgstr "複合ロールからレルムロールを削除する"

msgid ""
"{project_name} provides a `remove-roles` command for removing realm roles "
"and client roles."
msgstr "{project_name}は、レルムロールやクライアントロールを削除するための `remove-roles` コマンドを提供します。"

msgid ""
"The following example removes the `user` role from the target composite role"
" `testrole`."
msgstr "次の例では、ターゲットの複合ロール `testrole` から `user` ロールを削除します。"

msgid "$ kcadm.sh remove-roles --rname testrole --rolename user -r demorealm"
msgstr "$ kcadm.sh remove-roles --rname testrole --rolename user -r demorealm"

msgid "Adding client roles to a realm role"
msgstr "レルムロールへのクライアントロールの追加"

msgid ""
"The following example adds the roles defined on the client `realm-"
"management`, `create-client`, and `view-users`, to the `testrole` composite "
"role."
msgstr ""
"次の例では、クライアントに定義されたロールと `realm-management` 、 `create-client` 、 `view-users` "
"ロールを `testrole` 複合ロールに追加します。"

msgid ""
"$ kcadm.sh add-roles -r demorealm --rname testrole --cclientid realm-"
"management --rolename create-client --rolename view-users"
msgstr ""
"$ kcadm.sh add-roles -r demorealm --rname testrole --cclientid realm-"
"management --rolename create-client --rolename view-users"

msgid "Adding client roles to a client role"
msgstr "クライアントロールへのクライアントロールの追加"

msgid ""
"Determine the ID of the composite client role by using the `get-roles` "
"command."
msgstr "`get-roles` コマンドを使用して複合クライアントロールのIDを特定します。"

msgid ""
"$ kcadm.sh get-roles -r demorealm --cclientid test-client --rolename "
"operations"
msgstr ""
"$ kcadm.sh get-roles -r demorealm --cclientid test-client --rolename "
"operations"

msgid ""
"Assume that a client exists with a clientId attribute named `test-client`, a"
" client role named `support`, and a client role named `operations` which "
"becomes a composite role that has an ID of "
"\"fc400897-ef6a-4e8c-872b-1581b7fa8a71\"."
msgstr ""
"`test-client` というclientId属性、 `support` というクライアントロール、 `operations` "
"というクライアントロールを持つクライアントが存在し、IDが \"fc400897-ef6a-4e8c-872b-1581b7fa8a71\" "
"である複合ロールになっているとします。"

msgid "Use the following example to add another role to the composite role."
msgstr "次の例を使用して、複合ロールに別のロールを追加します。"

msgid ""
"$ kcadm.sh add-roles -r demorealm --cclientid test-client --rid "
"fc400897-ef6a-4e8c-872b-1581b7fa8a71 --rolename support"
msgstr ""
"$ kcadm.sh add-roles -r demorealm --cclientid test-client --rid "
"fc400897-ef6a-4e8c-872b-1581b7fa8a71 --rolename support"

msgid ""
"List the roles of a composite role by using the `get-roles --all` command."
msgstr "`get-roles --all` コマンドを使用して、複合ロールのロールを一覧表示します。"

msgid "$ kcadm.sh get-roles --rid fc400897-ef6a-4e8c-872b-1581b7fa8a71 --all"
msgstr "$ kcadm.sh get-roles --rid fc400897-ef6a-4e8c-872b-1581b7fa8a71 --all"

msgid "Removing client roles from a composite role"
msgstr "複合ロールからのクライアントロールの削除"

msgid ""
"Use the `remove-roles` command to remove client roles from a composite role."
msgstr "複合ロールからクライアントロールを削除するには、`remove-roles` コマンドを使用します。"

msgid ""
"Use the following example to remove two roles defined on the client `realm-"
"management`, the `create-client` role and the `view-users` role, from the "
"`testrole` composite role."
msgstr ""
"次の例を使用して、 `realm-management` クライアントに定義された `create-client` と `view-users` "
"の2つのロールを複合ロール `testrole` から削除します。"

msgid ""
"$ kcadm.sh remove-roles -r demorealm --rname testrole --cclientid realm-"
"management --rolename create-client --rolename view-users"
msgstr ""
"$ kcadm.sh remove-roles -r demorealm --rname testrole --cclientid realm-"
"management --rolename create-client --rolename view-users"

msgid "Adding client roles to a group"
msgstr "グループへのクライアント・ロールの追加"

msgid "Use the `add-roles` command to add realm roles and client roles."
msgstr "レルムロールとクライアントロールを追加するには、 `add-roles` コマンドを使用します。"

msgid ""
"The following example adds the roles defined on the client `realm-"
"management`, `create-client` and `view-users`, to the `Group` group "
"(`--gname` option). Alternatively, you can specify the group by ID (`--gid` "
"option)."
msgstr ""
"次の例では、クライアントに定義された `realm-management`、`create-client` および `view-users` ロールを "
"`Group` グループに追加しています ( `--gname` オプション)。また、IDでグループを指定することもできます（ `--gid` "
"オプション）。"

msgid "See <<_group_operations, Group operations>> for more information."
msgstr "詳しくは、<<_group_operations, グループ操作>>を参照してください。"

msgid ""
"$ kcadm.sh add-roles -r demorealm --gname Group --cclientid realm-management"
" --rolename create-client --rolename view-users"
msgstr ""
"$ kcadm.sh add-roles -r demorealm --gname Group --cclientid realm-management"
" --rolename create-client --rolename view-users"

msgid "Removing client roles from a group"
msgstr "グループからのクライアントロールの削除"

msgid "Use the `remove-roles` command to remove client roles from a group."
msgstr "グループからクライアントロールを削除するには、`remove-roles` コマンドを使います。"

msgid ""
"The following example removes two roles defined on the client `realm "
"management`, `create-client` and `view-users`, from the `Group` group."
msgstr ""
"次の例では、クライアントの `realm management` に定義された2つのロール、 `creat-client` と `view-users`"
" を `Group` グループから削除しています。"

msgid ""
"$ kcadm.sh remove-roles -r demorealm --gname Group --cclientid realm-"
"management --rolename create-client --rolename view-users"
msgstr ""
"$ kcadm.sh remove-roles -r demorealm --gname Group --cclientid realm-"
"management --rolename create-client --rolename view-users"

msgid "Client operations"
msgstr "クライアント操作"

msgid "Creating a client"
msgstr "クライアントの作成"

msgid ""
"Run the `create` command on a `clients` endpoint to create a new client."
msgstr "`clients` のエンドポイントで `create` コマンドを実行して、新しいクライアントを作成します。"

msgid ""
"$ kcadm.sh create clients -r demorealm -s clientId=myapp -s enabled=true"
msgstr ""
"$ kcadm.sh create clients -r demorealm -s clientId=myapp -s enabled=true"

msgid "Specify a secret if to set a secret for adapters to authenticate."
msgstr "アダプターに認証用のシークレットを設定する場合は、シークレットを指定します。"

msgid ""
"$ kcadm.sh create clients -r demorealm -s clientId=myapp -s enabled=true -s "
"clientAuthenticatorType=client-secret -s "
"secret=d0b8122f-8dfb-46b7-b68a-f5cc4e25d000"
msgstr ""
"$ kcadm.sh create clients -r demorealm -s clientId=myapp -s enabled=true -s "
"clientAuthenticatorType=client-secret -s "
"secret=d0b8122f-8dfb-46b7-b68a-f5cc4e25d000"

msgid "Listing clients"
msgstr "クライアントの一覧表示"

msgid "Use the `get` command on the `clients` endpoint to list clients."
msgstr "クライアントの一覧を表示するには、 `clients` エンドポイントで `get` コマンドを使用します。"

msgid ""
"This example filters the output to list only the `id` and `clientId` "
"attributes:"
msgstr "この例では、出力をフィルタリングして、 `id` と `clientId` の属性だけをリストアップしています。"

msgid "Getting a specific client"
msgstr "特定のクライアントを取得する"

msgid ""
"Use the client ID to construct an endpoint URI that targets a specific "
"client, such as `clients/ID`."
msgstr "クライアントIDを使って、`clients/ID` のような特定のクライアントを対象としたエンドポイントURIを構築します。"

msgid ""
"$ kcadm.sh get clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm"
msgstr ""
"$ kcadm.sh get clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm"

msgid "Getting the current secret for a specific client"
msgstr "特定のクライアントの現在のシークレットの取得"

msgid ""
"Use the client ID to construct an endpoint URI, such as `clients/ID/client-"
"secret`."
msgstr "クライアントIDを使って、`clients/ID/client-secret` のようなエンドポイントURIを構築します。"

msgid "$ kcadm.sh get clients/$CID/client-secret"
msgstr "$ kcadm.sh get clients/$CID/client-secret"

msgid "Generate a new secret for a specific client"
msgstr "特定のクライアントの新しいシークレットを生成する"

msgid "$ kcadm.sh create clients/$CID/client-secret"
msgstr "$ kcadm.sh create clients/$CID/client-secret"

msgid "Updating the current secret for a specific client"
msgstr "特定のクライアントの現在のシークレットを更新する"

msgid "Use the client ID to construct an endpoint URI, such as `clients/ID`."
msgstr "クライアントIDを使用して、`clients/ID` のようなエンドポイントURIを構築します。"

msgid "$ kcadm.sh update clients/$CID -s \"secret=newSecret\""
msgstr "$ kcadm.sh update clients/$CID -s \"secret=newSecret\""

msgid ""
"Getting an adapter configuration file (keycloak.json) for a specific client"
msgstr "特定のクライアントのアダプター設定ファイル（keycloak.json）の取得"

msgid ""
"Use the client ID to construct an endpoint URI that targets a specific "
"client, such as `clients/ID/installation/providers/keycloak-oidc-keycloak-"
"json`."
msgstr ""
"クライアントIDを使用して、 `clients/ID/installation/providers/keycloak-oidc-keycloak-"
"json` のように、特定のクライアントを対象としたエンドポイントURIを構築します。"

msgid ""
"$ kcadm.sh get "
"clients/c7b8547f-e748-4333-95d0-410b76b3f4a3/installation/providers/keycloak-"
"oidc-keycloak-json -r demorealm"
msgstr ""
"$ kcadm.sh get "
"clients/c7b8547f-e748-4333-95d0-410b76b3f4a3/installation/providers/keycloak-"
"oidc-keycloak-json -r demorealm"

msgid ""
"Getting a WildFly subsystem adapter configuration for a specific client"
msgstr "特定のクライアントのためのWildFlyサブシステム・アダプター設定の取得"

msgid ""
"Use the client ID to construct an endpoint URI that targets a specific "
"client, such as `clients/ID/installation/providers/keycloak-oidc-jboss-"
"subsystem`."
msgstr ""
"クライアントIDを使用して、 `clients/ID/installation/providers/keycloak-oidc-jboss-"
"subsystem` のような、特定のクライアントを対象としたエンドポイントURIを構築します。"

msgid ""
"$ kcadm.sh get "
"clients/c7b8547f-e748-4333-95d0-410b76b3f4a3/installation/providers/keycloak-"
"oidc-jboss-subsystem -r demorealm"
msgstr ""
"$ kcadm.sh get "
"clients/c7b8547f-e748-4333-95d0-410b76b3f4a3/installation/providers/keycloak-"
"oidc-jboss-subsystem -r demorealm"

msgid "Getting a Docker-v2 example configuration for a specific client"
msgstr "特定のクライアントのためのDocker-v2のサンプル設定の取得"

msgid ""
"Use the client ID to construct an endpoint URI that targets a specific "
"client, such as `clients/ID/installation/providers/docker-v2-compose-yaml`."
msgstr ""
"クライアントIDを使用して、 `clients/ID/installation/providers/docker-v2-compose-yaml` "
"のような、特定のクライアントを対象としたエンドポイントURIを構築します。"

msgid "The response is in `.zip` format."
msgstr "応答は `.zip` 形式です。"

msgid ""
"$ kcadm.sh get "
"http://localhost:8080/auth/admin/realms/demorealm/clients/8f271c35-44e3-446f-8953-b0893810ebe7/installation/providers/docker-v2-compose-"
"yaml -r demorealm > keycloak-docker-compose-yaml.zip"
msgstr ""
"$ kcadm.sh get "
"http://localhost:8080/auth/admin/realms/demorealm/clients/8f271c35-44e3-446f-8953-b0893810ebe7/installation/providers/docker-v2-compose-"
"yaml -r demorealm > keycloak-docker-compose-yaml.zip"

msgid ""
"Use the `update` command with the same endpoint URI that you use to get a "
"specific client."
msgstr "特定のクライアントを取得するのに使ったのと同じエンドポイントURIで、 `update` コマンドを使います。"

msgid ""
"$ kcadm.sh update clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm "
"-s enabled=false -s publicClient=true -s "
"'redirectUris=[\"http://localhost:8080/myapp/*\"]' -s "
"baseUrl=http://localhost:8080/myapp -s adminUrl=http://localhost:8080/myapp"
msgstr ""
"$ kcadm.sh update clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm "
"-s enabled=false -s publicClient=true -s "
"'redirectUris=[\"http://localhost:8080/myapp/*\"]' -s "
"baseUrl=http://localhost:8080/myapp -s adminUrl=http://localhost:8080/myapp"

msgid ""
"c:\\> kcadm update clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm"
" -s enabled=false -s publicClient=true -s "
"\"redirectUris=[\\\"http://localhost:8080/myapp/*\\\"]\" -s "
"baseUrl=http://localhost:8080/myapp -s adminUrl=http://localhost:8080/myapp"
msgstr ""
"c:\\> kcadm update clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm"
" -s enabled=false -s publicClient=true -s "
"\"redirectUris=[\\\"http://localhost:8080/myapp/*\\\"]\" -s "
"baseUrl=http://localhost:8080/myapp -s adminUrl=http://localhost:8080/myapp"

msgid "Deleting a client"
msgstr "クライアントの削除"

msgid ""
"Use the `delete` command with the same endpoint URI that you use to get a "
"specific client."
msgstr "`delete` コマンドを、特定のクライアントを取得するのに使ったのと同じエンドポイントURIで使います。"

msgid ""
"$ kcadm.sh delete clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm"
msgstr ""
"$ kcadm.sh delete clients/c7b8547f-e748-4333-95d0-410b76b3f4a3 -r demorealm"

msgid "Adding or removing roles for client's service account"
msgstr "クライアントのサービス・アカウントのロールの追加または削除"

msgid ""
"A client's service account is a user account with username `service-account-"
"CLIENT_ID`. You can perform the same user operations on this account as a "
"regular account."
msgstr ""
"クライアントのサービス・アカウントは、ユーザ名が `service-account-CLIENT_ID` "
"のユーザー・アカウントです。このアカウントに対して、通常のアカウントと同様のユーザー操作を行うことができます。"

msgid "User operations"
msgstr "ユーザー操作"

msgid "Run the `create` command on the `users` endpoint to create a new user."
msgstr "`users` エンドポイントで `create` コマンドを実行して、新しいユーザーを作成します。"

msgid ""
"$ kcadm.sh create users -r demorealm -s username=testuser -s enabled=true"
msgstr ""
"$ kcadm.sh create users -r demorealm -s username=testuser -s enabled=true"

msgid "Listing users"
msgstr "ユーザーの一覧表示"

msgid ""
"Use the `users` endpoint to list users. The target user must change their "
"password the next time they log in."
msgstr ""
"ユーザーをリストアップするには、 `users` エンドポイントを使います。対象となるユーザーは、次回ログイン時にパスワードを変更する必要があります。"

msgid "$ kcadm.sh get users -r demorealm --offset 0 --limit 1000"
msgstr "$ kcadm.sh get users -r demorealm --offset 0 --limit 1000"

msgid ""
"You can filter users by `username`, `firstName`, `lastName`, or `email`."
msgstr "ユーザーは `username` 、 `firstName` 、 `lastName` または `email` でフィルタリングできます。"

msgid ""
"$ kcadm.sh get users -r demorealm -q email=google.com\n"
"$ kcadm.sh get users -r demorealm -q username=testuser"
msgstr ""
"$ kcadm.sh get users -r demorealm -q email=google.com\n"
"$ kcadm.sh get users -r demorealm -q username=testuser"

msgid ""
"Filtering does not use exact matching. This example matches the value of the"
" `username` attribute against the `\\*testuser*` pattern."
msgstr ""
"フィルタリングでは、完全一致は使用しません。この例では、 `username` 属性の値を `\\*testuser*` パターンと照合しています。"

msgid ""
"You can filter across multiple attributes by specifying multiple `-q` "
"options. {project_name} returns users that match the condition for all the "
"attributes only."
msgstr ""
"複数の `-q` "
"オプションを指定することで、複数の属性でフィルタリングすることができます。{project_name}は、すべての属性で条件に一致するユーザーのみを返します。"

msgid "Getting a specific user"
msgstr "特定のユーザーを取得する"

msgid "Use the user ID to compose an endpoint URI, such as `users/USER_ID`."
msgstr "`users/USER_ID` のように、エンドポイントのURIを構成するためにユーザーIDを使用します。"

msgid "$ kcadm.sh get users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm"
msgstr ""
"$ kcadm.sh get users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm"

msgid "Updating a user"
msgstr "ユーザーの更新"

msgid ""
"Use the `update` command with the same endpoint URI that you use to get a "
"specific user."
msgstr "特定のユーザーを取得するのに使ったのと同じエンドポイントURIで、 `update` コマンドを使います。"

msgid ""
"$ kcadm.sh update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm -s"
" "
"'requiredActions=[\"VERIFY_EMAIL\",\"UPDATE_PROFILE\",\"CONFIGURE_TOTP\",\"UPDATE_PASSWORD\"]'"
msgstr ""
"$ kcadm.sh update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm -s"
" "
"'requiredActions=[\"VERIFY_EMAIL\",\"UPDATE_PROFILE\",\"CONFIGURE_TOTP\",\"UPDATE_PASSWORD\"]'"

msgid ""
"c:\\> kcadm update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm "
"-s "
"\"requiredActions=[\\\"VERIFY_EMAIL\\\",\\\"UPDATE_PROFILE\\\",\\\"CONFIGURE_TOTP\\\",\\\"UPDATE_PASSWORD\\\"]\""
msgstr ""
"c:\\> kcadm update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm "
"-s "
"\"requiredActions=[\\\"VERIFY_EMAIL\\\",\\\"UPDATE_PROFILE\\\",\\\"CONFIGURE_TOTP\\\",\\\"UPDATE_PASSWORD\\\"]\""

msgid ""
"Use the `delete` command with the same endpoint URI that you use to get a "
"specific user."
msgstr "`delete` コマンドを、特定のユーザーを取得するのに使ったのと同じエンドポイントURIで使います。"

msgid ""
"$ kcadm.sh delete users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm"
msgstr ""
"$ kcadm.sh delete users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2 -r demorealm"

msgid "Resetting a user's password"
msgstr "ユーザー・パスワードのリセット"

msgid "Use the dedicated `set-password` command to reset a user's password."
msgstr "ユーザーのパスワードをリセットするには、専用の `set-password` コマンドを使います。"

msgid ""
"$ kcadm.sh set-password -r demorealm --username testuser --new-password "
"NEWPASSWORD --temporary"
msgstr ""
"$ kcadm.sh set-password -r demorealm --username testuser --new-password "
"NEWPASSWORD --temporary"

msgid ""
"This command sets a temporary password for the user. The target user must "
"change the password the next time they log in."
msgstr "このコマンドは、対象ユーザーに仮パスワードを設定します。対象となるユーザーは、次回ログイン時にパスワードを変更する必要があります。"

msgid ""
"You can use `--userid` to specify the user by using the `id` attribute."
msgstr "また、 `--userid` を使うと、 `id` 属性でユーザーを指定することができます。"

msgid ""
"You can achieve the same result using the `update` command on an endpoint "
"constructed from the one you used to get a specific user, such as "
"`users/USER_ID/reset-password`."
msgstr ""
"`users/USER_ID/reset-password` "
"のように、特定のユーザーを取得するために使用したエンドポイントから構築されたエンドポイントで `update` "
"コマンドを使用しても、同じ結果を得ることができます。"

msgid ""
"$ kcadm.sh update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2/reset-password "
"-r demorealm -s type=password -s value=NEWPASSWORD -s temporary=true -n"
msgstr ""
"$ kcadm.sh update users/0ba7a3fd-6fd8-48cd-a60b-2e8fd82d56e2/reset-password "
"-r demorealm -s type=password -s value=NEWPASSWORD -s temporary=true -n"

msgid ""
"The `-n` parameter ensures that {project_name} performs the `PUT` command "
"without performing a `GET` command before the `PUT` command. This is "
"necessary because the `reset-password` endpoint does not support `GET`."
msgstr ""
"`n` パラメーターは、{project_name}が `PUT` コマンドの前に `GET` コマンドを実行することなく、 `PUT` "
"コマンドを実行することを保証します。これは、 `reset-password` エンドポイントが `GET` をサポートしていないために必要です。"

msgid "Listing assigned, available, and effective realm roles for a user"
msgstr "ユーザーに割り当てられた、使用可能な、有効なレルムロールの一覧表示"

msgid ""
"You can use a `get-roles` command to list assigned, available, and effective"
" realm roles for a user."
msgstr "`get-roles` コマンドを使うと、ユーザーに割り当てられた、利用可能かつ有効なレルムロールをリストアップできます。"

msgid ""
"Specify the target user by user name or ID to list the user's *assigned* "
"realm roles."
msgstr "対象となるユーザーをユーザー名またはIDで指定すると、そのユーザーに *割り当てられた* レルムロールが一覧表示されます。"

msgid "$ kcadm.sh get-roles -r demorealm --uusername testuser"
msgstr "$ kcadm.sh get-roles -r demorealm --uusername testuser"

msgid "$ kcadm.sh get-roles -r demorealm --uusername testuser --effective"
msgstr "$ kcadm.sh get-roles -r demorealm --uusername testuser --effective"

msgid ""
"Use the `--available` option to list realm roles that you can add to a user."
msgstr "ユーザーに追加できるレルムロールの一覧を表示するには、 `--available` オプションを使用します。"

msgid "$ kcadm.sh get-roles -r demorealm --uusername testuser --available"
msgstr "$ kcadm.sh get-roles -r demorealm --uusername testuser --available"

msgid "Listing assigned, available, and effective client roles for a user"
msgstr "ユーザーに割り当てられた、利用可能な、有効なクライアントロールの一覧表示"

msgid ""
"Use a `get-roles` command to list assigned, available, and effective client "
"roles for a user."
msgstr "ユーザーに割り当てられた、利用可能かつ有効なクライアントロールの一覧を表示するには、 `get-roles` コマンドを使用します。"

msgid ""
"Specify the target user by user name (`--uusername` option) or ID (`--uid` "
"option) and client by a clientId attribute (`--cclientid` option) or an ID "
"(`--cid` option) to list *assigned* client roles for the user."
msgstr ""
"対象となるユーザーをユーザー名（ `--uusername` オプション）またはID（ `--uid` "
"オプション）で、クライアントをclientId属性（ `--cclientid` オプション）またはID（ `--cid` "
"オプション）で指定すると、そのユーザーに *割り当てられた* クライアントロールの一覧が表示されます。"

msgid ""
"$ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-"
"management"
msgstr ""
"$ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-"
"management"

msgid ""
"$ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-"
"management --effective"
msgstr ""
"$ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-"
"management --effective"

msgid ""
"$ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-"
"management --available"
msgstr ""
"$ kcadm.sh get-roles -r demorealm --uusername testuser --cclientid realm-"
"management --available"

msgid "Adding realm roles to a user"
msgstr "ユーザーにレルムロールを追加する"

msgid "Use an `add-roles` command to add realm roles to a user."
msgstr "ユーザーにレルムロールを追加するには、 `add-roles` コマンドを使用します。"

msgid "Use the following example to add the `user` role to user `testuser`:"
msgstr "次の例では，ユーザー `testuser` に `user` ロールを追加しています。"

msgid "$ kcadm.sh add-roles --uusername testuser --rolename user -r demorealm"
msgstr ""
"$ kcadm.sh add-roles --uusername testuser --rolename user -r demorealm"

msgid "Removing realm roles from a user"
msgstr "ユーザーからレルムロールを削除する"

msgid "Use a `remove-roles` command to remove realm roles from a user."
msgstr "ユーザーからレルムロールを削除するには、 `remove-roles` コマンドを使用します。"

msgid ""
"Use the following example to remove the `user` role from the user "
"`testuser`:"
msgstr "ユーザー `testuser` から `user` ロールを削除するには，次のようにします。"

msgid ""
"$ kcadm.sh remove-roles --uusername testuser --rolename user -r demorealm"
msgstr ""
"$ kcadm.sh remove-roles --uusername testuser --rolename user -r demorealm"

msgid "Adding client roles to a user"
msgstr "ユーザーにクライアントロールを追加する"

msgid "Use an `add-roles` command to add client roles to a user."
msgstr "ユーザーにクライアントロールを追加するには、 `add-roles` コマンドを使用します。"

msgid ""
"Use the following example to add two roles defined on the client `realm "
"management`, the `create-client` role and the `view-users` role, to the user"
" `testuser`."
msgstr ""
"次の例を使用して、クライアント `realm-management` に定義された2つのロール（`create-client` ロールと `view-"
"users` ロール）を `testuser` ユーザーに追加します。"

msgid ""
"$ kcadm.sh add-roles -r demorealm --uusername testuser --cclientid realm-"
"management --rolename create-client --rolename view-users"
msgstr ""
"$ kcadm.sh add-roles -r demorealm --uusername testuser --cclientid realm-"
"management --rolename create-client --rolename view-users"

msgid "Removing client roles from a user"
msgstr "ユーザーからのクライアントロールの削除"

msgid "Use a `remove-roles` command to remove client roles from a user."
msgstr "ユーザーからクライアントロールを削除するには、 `remove-roles` コマンドを使用します。"

msgid ""
"Use the following example to remove two roles defined on the realm "
"management client:"
msgstr "次の例を使用して、レルム管理クライアントで定義されている2つのロールを削除します。"

msgid ""
"$ kcadm.sh remove-roles -r demorealm --uusername testuser --cclientid realm-"
"management --rolename create-client --rolename view-users"
msgstr ""
"$ kcadm.sh remove-roles -r demorealm --uusername testuser --cclientid realm-"
"management --rolename create-client --rolename view-users"

msgid "Listing a user's sessions"
msgstr "ユーザー・セッションの一覧表示"

msgid "Identify the user's ID,"
msgstr "ユーザーのIDを特定する。"

msgid "Use the ID to compose an endpoint URI, such as `users/ID/sessions`."
msgstr "IDを使用して、 `users/ID/sessions` のようなエンドポイントURIを構成することができます。"

msgid "Use the `get` command to retrieve a list of the user's sessions."
msgstr "ユーザーのセッションの一覧を取得するには、 `get` コマンドを使用します。"

msgid "$kcadm get users/6da5ab89-3397-4205-afaa-e201ff638f9e/sessions"
msgstr "$kcadm get users/6da5ab89-3397-4205-afaa-e201ff638f9e/sessions"

msgid "Logging out a user from a specific session"
msgstr "特定のセッションからユーザーをログアウトする"

msgid "Determine the session's ID as described earlier."
msgstr "上記のセッションのIDを決定します。"

msgid ""
"Use the session's ID to compose an endpoint URI, such as `sessions/ID`."
msgstr "セッションのIDを使用して、 `sessions/ID` のようなエンドポイントURIを構成します。"

msgid "Use the `delete` command to invalidate the session."
msgstr "セッションを無効にするには、 `delete` コマンドを使用します。"

msgid "$ kcadm.sh delete sessions/d0eaa7cc-8c5d-489d-811a-69d3c4ec84d1"
msgstr "$ kcadm.sh delete sessions/d0eaa7cc-8c5d-489d-811a-69d3c4ec84d1"

msgid "Logging out a user from all sessions"
msgstr "すべてのセッションからユーザーをログアウトする"

msgid ""
"Use the user's ID to construct an endpoint URI, such as `users/ID/logout`."
msgstr "ユーザーのIDを使用して、 `users/ID/logout` のようなエンドポイントURIを構築します。"

msgid "Use the `create` command to perform `POST` on that endpoint URI."
msgstr "そのエンドポイントURIに対して `POST` を実行するには、 `create` コマンドを使用します。"

msgid ""
"$ kcadm.sh create users/6da5ab89-3397-4205-afaa-e201ff638f9e/logout -r "
"demorealm -s realm=demorealm -s user=6da5ab89-3397-4205-afaa-e201ff638f9e"
msgstr ""
"$ kcadm.sh create users/6da5ab89-3397-4205-afaa-e201ff638f9e/logout -r "
"demorealm -s realm=demorealm -s user=6da5ab89-3397-4205-afaa-e201ff638f9e"

msgid "Group operations"
msgstr "グループの操作"

msgid "Creating a group"
msgstr "グループの作成"

msgid ""
"Use the `create` command on the `groups` endpoint to create a new group."
msgstr "新しいグループを作成するには、 `groups` エンドポイントで `create` コマンドを使用します。"

msgid "$ kcadm.sh create groups -r demorealm -s name=Group"
msgstr "$ kcadm.sh create groups -r demorealm -s name=Group"

msgid "Listing groups"
msgstr "グループの一覧表示"

msgid "Use the `get` command on the `groups` endpoint to list groups."
msgstr "グループの一覧を表示するには、 `groups` エンドポイントで `get` コマンドを使用します。"

msgid "$ kcadm.sh get groups -r demorealm"
msgstr "$ kcadm.sh get groups -r demorealm"

msgid "Getting a specific group"
msgstr "特定のグループを取得する"

msgid ""
"Use the group's ID to construct an endpoint URI, such as `groups/GROUP_ID`."
msgstr "グループのIDを使用して、 `groups/GROUP_ID` のようなのエンドポイントURIを作成します。"

msgid ""
"$ kcadm.sh get groups/51204821-0580-46db-8f2d-27106c6b5ded -r demorealm"
msgstr ""
"$ kcadm.sh get groups/51204821-0580-46db-8f2d-27106c6b5ded -r demorealm"

msgid "Updating a group"
msgstr "グループの更新"

msgid ""
"Use the `update` command with the same endpoint URI that you use to get a "
"specific group."
msgstr "特定のグループを取得するために使用するのと同じエンドポイントURIで、 `update` コマンドを使用します。"

msgid ""
"$ kcadm.sh update groups/51204821-0580-46db-8f2d-27106c6b5ded -s "
"'attributes.email=[\"group@example.com\"]' -r demorealm"
msgstr ""
"$ kcadm.sh update groups/51204821-0580-46db-8f2d-27106c6b5ded -s "
"'attributes.email=[\"group@example.com\"]' -r demorealm"

msgid "Deleting a group"
msgstr "グループの削除"

msgid ""
"Use the `delete` command with the same endpoint URI that you use to get a "
"specific group."
msgstr "特定のグループを取得するために使用するのと同じエンドポイントURIで、`delete`コマンドを使用します。"

msgid ""
"$ kcadm.sh delete groups/51204821-0580-46db-8f2d-27106c6b5ded -r demorealm"
msgstr ""
"$ kcadm.sh delete groups/51204821-0580-46db-8f2d-27106c6b5ded -r demorealm"

msgid "Creating a subgroup"
msgstr "サブグループの作成"

msgid ""
"Find the ID of the parent group by listing groups. Use that ID to construct "
"an endpoint URI, such as `groups/GROUP_ID/children`."
msgstr ""
"グループをリストアップして親グループのIDを検索します。そのIDを使って、 `groups/GROUP_ID/children` "
"のようなエンドポイントURIを作成します。"

msgid ""
"$ kcadm.sh create groups/51204821-0580-46db-8f2d-27106c6b5ded/children -r "
"demorealm -s name=SubGroup"
msgstr ""
"$ kcadm.sh create groups/51204821-0580-46db-8f2d-27106c6b5ded/children -r "
"demorealm -s name=SubGroup"

msgid "Moving a group under another group"
msgstr "グループを別のグループの下に移動する"

msgid ""
"Find the ID of an existing parent group and the ID of an existing child "
"group."
msgstr "既存の親グループのID、既存の子グループのIDを検索します。"

msgid ""
"Use the parent group's ID to construct an endpoint URI, such as "
"`groups/PARENT_GROUP_ID/children`."
msgstr "親グループのIDを使って、 `groups/PARENT_GROUP_ID/children` のようなエンドポイントURIを作成します。"

msgid ""
"Run the `create` command on this endpoint and pass the child group's ID as a"
" JSON body."
msgstr "このエンドポイントで `create` コマンドを実行し、子グループのIDをJSONのボディーとして渡します。"

msgid ""
"$ kcadm.sh create groups/51204821-0580-46db-8f2d-27106c6b5ded/children -r "
"demorealm -s id=08d410c6-d585-4059-bb07-54dcb92c5094"
msgstr ""
"$ kcadm.sh create groups/51204821-0580-46db-8f2d-27106c6b5ded/children -r "
"demorealm -s id=08d410c6-d585-4059-bb07-54dcb92c5094"

msgid "Get groups for a specific user"
msgstr "特定のユーザーのグループを取得する"

msgid ""
"Use a user's ID to determine a user's membership in groups to compose an "
"endpoint URI, such as `users/USER_ID/groups`."
msgstr ""
"ユーザーのIDを使用して、ユーザーのグループへの所属を判断し、 `users/USER_ID/groups` のようなエンドポイントURIを構成します。"

msgid ""
"$ kcadm.sh get users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups -r "
"demorealm"
msgstr ""
"$ kcadm.sh get users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups -r "
"demorealm"

msgid "Adding a user to a group"
msgstr "グループにユーザーを追加する"

msgid ""
"Use the `update` command with an endpoint URI composed of a user's ID and a "
"group's ID, such as `users/USER_ID/groups/GROUP_ID`, to add a user to a "
"group."
msgstr ""
"ユーザーをグループに追加するには、 `users/USER_ID/groups/GROUP_ID` "
"のように、ユーザーのIDとグループのIDからなるエンドポイントURIを指定して、 `update` コマンドを使用します。"

msgid ""
"$ kcadm.sh update "
"users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups/ce01117a-7426-4670-a29a-5c118056fe20"
" -r demorealm -s realm=demorealm -s "
"userId=b544f379-5fc4-49e5-8a8d-5cfb71f46f53 -s "
"groupId=ce01117a-7426-4670-a29a-5c118056fe20 -n"
msgstr ""
"$ kcadm.sh update "
"users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups/ce01117a-7426-4670-a29a-5c118056fe20"
" -r demorealm -s realm=demorealm -s "
"userId=b544f379-5fc4-49e5-8a8d-5cfb71f46f53 -s "
"groupId=ce01117a-7426-4670-a29a-5c118056fe20 -n"

msgid "Removing a user from a group"
msgstr "グループからユーザーを削除する"

msgid ""
"Use the `delete` command on the same endpoint URI you use for adding a user "
"to a group, such as `users/USER_ID/groups/GROUP_ID`, to remove a user from a"
" group."
msgstr ""
"ユーザーをグループから削除するには、 `users/USER_ID/groups/GROUP_ID` "
"のように、ユーザーをグループに追加するときに使うのと同じエンドポイントURIで `delete` コマンドを使用します。"

msgid ""
"$ kcadm.sh delete "
"users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups/ce01117a-7426-4670-a29a-5c118056fe20"
" -r demorealm"
msgstr ""
"$ kcadm.sh delete "
"users/b544f379-5fc4-49e5-8a8d-5cfb71f46f53/groups/ce01117a-7426-4670-a29a-5c118056fe20"
" -r demorealm"

msgid "Listing assigned, available, and effective realm roles for a group"
msgstr "グループに割り当てられた、使用可能で、有効なレルムロールの一覧表示"

msgid ""
"Use a dedicated `get-roles` command to list assigned, available, and "
"effective realm roles for a group."
msgstr "あるグループに割り当てられた、利用可能かつ有効なレルムロールを一覧表示するには、専用の `get-roles` コマンドを使用します。"

msgid ""
"Specify the target group by name (`--gname` option), path (`--gpath` "
"option), or ID (`--gid` option) to list *assigned* realm roles for the "
"group."
msgstr ""
"ターゲットグループを名前 ( `--gname` オプション)、パス ( `--gpath` オプション)、または ID ( `--gid` "
"オプション) で指定すると、そのグループに *割り当てられた* レルムロールを一覧表示します。"

msgid "$ kcadm.sh get-roles -r demorealm --gname Group"
msgstr "$ kcadm.sh get-roles -r demorealm --gname Group"

msgid "$ kcadm.sh get-roles -r demorealm --gname Group --effective"
msgstr "$ kcadm.sh get-roles -r demorealm --gname Group --effective"

msgid ""
"Use the `--available` option to list realm roles that you can add to the "
"group."
msgstr "グループに追加できるレルムロールを一覧表示するには、`--available` オプションを使用します。"

msgid "$ kcadm.sh get-roles -r demorealm --gname Group --available"
msgstr "$ kcadm.sh get-roles -r demorealm --gname Group --available"

msgid "Listing assigned, available, and effective client roles for a group"
msgstr "グループに割り当てられた、利用可能で、有効なクライアントロールの一覧表示"

msgid ""
"Use the `get-roles` command to list assigned, available, and effective "
"client roles for a group."
msgstr "グループに割り当てられた、利用可能かつ有効なクライアントロールを一覧するには `get-roles` コマンドを使用します。"

msgid ""
"Specify the target group by name (`--gname` option) or ID (`--gid` option),"
msgstr "ターゲットグループを名前 ( `--gname` オプション) または ID ( `--gid` オプション) で指定します。"

msgid ""
"Specify the client by the clientId attribute (`--cclientid` option) or ID "
"(`--id` option) to list *assigned* client roles for the user."
msgstr ""
"クライアントをclientId属性 ( `--cclientid` オプション) またはID ( `--id` オプション) "
"で指定すると、そのユーザーに *割り当てられた* クライアントロールを一覧表示します。"

msgid ""
"$ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management"
msgstr ""
"$ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management"

msgid ""
"$ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management"
" --effective"
msgstr ""
"$ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management"
" --effective"

msgid ""
"Use the `--available` option to list realm roles that you can still add to "
"the group."
msgstr "まだグループに追加できるレルムロールを一覧表示するには、`--available` オプションを使用します。"

msgid ""
"$ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management"
" --available"
msgstr ""
"$ kcadm.sh get-roles -r demorealm --gname Group --cclientid realm-management"
" --available"

msgid "Identity provider operations"
msgstr " アイデンティティー・プロバイダーの操作"

msgid "Listing available identity providers"
msgstr "使用可能なアイデンティティー・プロバイダー の一覧表示"

msgid "Use the `serverinfo` endpoint to list available identity providers."
msgstr "利用可能なアイデンティティー・プロバイダーを一覧表示するには、 `serverinfo` エンドポイントを使用します。"

msgid "$ kcadm.sh get serverinfo -r demorealm --fields 'identityProviders(*)'"
msgstr ""
"$ kcadm.sh get serverinfo -r demorealm --fields 'identityProviders(*)'"

msgid ""
"{project_name} processes the `serverinfo` endpoint similarly to the `realms`"
" endpoint. {project_name} does not resolve the endpoint relative to a target"
" realm because it exists outside any specific realm."
msgstr ""
"{project_name} は `serverinfo` エンドポイントを `realms` "
"エンドポイントと同様に処理します。{project_name}は、エンドポイントが特定のレルムの外側に存在するため、ターゲットのレルムに対する相対的な解決を行いません。"

msgid "Listing configured identity providers"
msgstr "設定済みアイデンティティー・プロバイダー の一覧表示"

msgid "Use the `identity-provider/instances` endpoint."
msgstr "`Identity-provider/instances` エンドポイントを使用します。"

msgid ""
"$ kcadm.sh get identity-provider/instances -r demorealm --fields "
"alias,providerId,enabled"
msgstr ""
"$ kcadm.sh get identity-provider/instances -r demorealm --fields "
"alias,providerId,enabled"

msgid "Getting a specific configured identity provider"
msgstr "特定の設定済みアイデンティティー・プロバイダーの取得"

msgid ""
"Use the identity provider's `alias` attribute to construct an endpoint URI, "
"such as `identity-provider/instances/ALIAS`, to get a specific identity "
"provider."
msgstr ""
"アイデンティティー・プロバイダーの `alias` 属性を使用して、 `identity-provider/instances/ALIAS` "
"のようなエンドポイントURIを作成し、特定のアイデンティティー・プロバイダーを取得します。"

msgid "$ kcadm.sh get identity-provider/instances/facebook -r demorealm"
msgstr "$ kcadm.sh get identity-provider/instances/facebook -r demorealm"

msgid "Removing a specific configured identity provider"
msgstr "特定の設定済みアイデンティティー・プロバイダーの削除"

msgid ""
"Use the `delete` command with the same endpoint URI that you use to get a "
"specific configured identity provider to remove a specific configured "
"identity provider."
msgstr ""
"特定の設定されたアイデンティティー・プロバイダーを削除するには、それを取得するために使用するのと同じエンドポイントURIで `delete` "
"コマンドを使用します。"

msgid "$ kcadm.sh delete identity-provider/instances/facebook -r demorealm"
msgstr "$ kcadm.sh delete identity-provider/instances/facebook -r demorealm"

msgid "Configuring a Keycloak OpenID Connect identity provider"
msgstr "Keycloak OpenID Connect アイデンティティー・プロバイダーの設定"

msgid ""
"Use `keycloak-oidc` as the `providerId` when you create a new identity "
"provider instance."
msgstr ""
"新しいアイデンティティー・プロバイダーのインスタンスを作成する際には、 `keycloak-oidc` を `providerId` として使用します。"

msgid ""
"Provide the `config` attributes: `authorizationUrl`, `tokenUrl`, `clientId`,"
" and `clientSecret`."
msgstr ""
"`config` 属性に `authorizationUrl` 、 `tokenUrl `、 `clientId` 、 `clientSecret` "
"を指定します。"

msgid ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s "
"alias=keycloak-oidc -s providerId=keycloak-oidc -s enabled=true -s "
"'config.useJwksUrl=\"true\"' -s "
"config.authorizationUrl=http://localhost:8180/auth/realms/demorealm/protocol/openid-"
"connect/auth -s "
"config.tokenUrl=http://localhost:8180/auth/realms/demorealm/protocol/openid-"
"connect/token -s config.clientId=demo-oidc-provider -s "
"config.clientSecret=secret"
msgstr ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s "
"alias=keycloak-oidc -s providerId=keycloak-oidc -s enabled=true -s "
"'config.useJwksUrl=\"true\"' -s "
"config.authorizationUrl=http://localhost:8180/auth/realms/demorealm/protocol/openid-"
"connect/auth -s "
"config.tokenUrl=http://localhost:8180/auth/realms/demorealm/protocol/openid-"
"connect/token -s config.clientId=demo-oidc-provider -s "
"config.clientSecret=secret"

msgid "Configuring an OpenID Connect identity provider"
msgstr "OpenID Connect アイデンティティー・プロバイダーの設定"

msgid ""
"Configure the generic OpenID Connect provider the same way you configure the"
" Keycloak OpenID Connect provider, except you set the `providerId` attribute"
" value to `oidc`."
msgstr ""
"一般的なOpenID Connectプロバイダーを、Keycloak OpenID "
"Connectプロバイダーを設定するのと同じ方法で設定します。ただし、 `providerId` 属性の値を `oidc` に設定します。"

msgid "Configuring a SAML 2 identity provider"
msgstr "SAML 2 アイデンティティー・プロバイダーの設定"

msgid "Use `saml` as the `providerId`."
msgstr "`providerId` には、 `saml` を使用します。"

msgid ""
"Provide the `config` attributes: `singleSignOnServiceUrl`, "
"`nameIDPolicyFormat`, and `signatureAlgorithm`."
msgstr ""
"`config` 属性に `singleSignOnServiceUrl` 、 `nameIDPolicyFormat` 、  "
"`signatureAlgorithm` を指定します。"

msgid ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s alias=saml -s "
"providerId=saml -s enabled=true -s 'config.useJwksUrl=\"true\"' -s "
"config.singleSignOnServiceUrl=http://localhost:8180/auth/realms/saml-broker-"
"realm/protocol/saml -s "
"config.nameIDPolicyFormat=urn:oasis:names:tc:SAML:2.0:nameid-"
"format:persistent -s config.signatureAlgorithm=RSA_SHA256"
msgstr ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s alias=saml -s "
"providerId=saml -s enabled=true -s 'config.useJwksUrl=\"true\"' -s "
"config.singleSignOnServiceUrl=http://localhost:8180/auth/realms/saml-broker-"
"realm/protocol/saml -s "
"config.nameIDPolicyFormat=urn:oasis:names:tc:SAML:2.0:nameid-"
"format:persistent -s config.signatureAlgorithm=RSA_SHA256"

msgid "Configuring a Facebook identity provider"
msgstr "Facebookアイデンティティー・プロバイダーの設定"

msgid "Use `facebook` as the `providerId`."
msgstr "`ProviderId` には `facebook` を使用します。"

msgid ""
"Provide the `config` attributes: `clientId` and `clientSecret`. You can find"
" these attributes in the Facebook Developers application configuration page "
"for your application. See see the <<_facebook, facebook identity broker>> "
"page for more information."
msgstr ""
"`config` 属性を指定します。 `clientId` と `clientSecret` を指定します。これらの属性は、Facebook "
"Developersのアプリケーション設定ページで確認することができます。詳細は<<_facebook, "
"facebookアイデンティティー・ブローカー>>のページを参照してください。"

msgid ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s alias=facebook"
" -s providerId=facebook -s enabled=true  -s 'config.useJwksUrl=\"true\"' -s "
"config.clientId=FACEBOOK_CLIENT_ID -s "
"config.clientSecret=FACEBOOK_CLIENT_SECRET"
msgstr ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s alias=facebook"
" -s providerId=facebook -s enabled=true  -s 'config.useJwksUrl=\"true\"' -s "
"config.clientId=FACEBOOK_CLIENT_ID -s "
"config.clientSecret=FACEBOOK_CLIENT_SECRET"

msgid "Configuring a Google identity provider"
msgstr "Googleアイデンティティー・プロバイダーの設定"

msgid "Use `google` as the `providerId`."
msgstr "`ProviderId` には `google` を使用します。"

msgid ""
"Provide the `config` attributes: `clientId` and `clientSecret`. You can find"
" these attributes in the Google Developers application configuration page "
"for your application. See the <<_google, Google identity broker>> page for "
"more information."
msgstr ""
"`config` 属性に `clientId` と `clientSecret` を指定します。これらの属性は、Google "
"Developersのアプリケーション設定ページで確認することができます。詳細は<<_google, "
"Googleアイデンティティー・ブローカー>>のページを参照ください。"

msgid ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s alias=google "
"-s providerId=google -s enabled=true  -s 'config.useJwksUrl=\"true\"' -s "
"config.clientId=GOOGLE_CLIENT_ID -s config.clientSecret=GOOGLE_CLIENT_SECRET"
msgstr ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s alias=google "
"-s providerId=google -s enabled=true  -s 'config.useJwksUrl=\"true\"' -s "
"config.clientId=GOOGLE_CLIENT_ID -s config.clientSecret=GOOGLE_CLIENT_SECRET"

msgid "Configuring a Twitter identity provider"
msgstr "Twitterアイデンティティー・プロバイダーの設定"

msgid "Use `twitter` as the `providerId`."
msgstr "`providerId` には、 `twitter` を使用します。"

msgid ""
"Provide the `config` attributes `clientId` and `clientSecret`. You can find "
"these attributes in the Twitter Application Management application "
"configuration page for your application. See the <<_twitter, Twitter "
"identity broker>> page for more information."
msgstr ""
"`config` 属性に `clientId` と `clientSecret` を指定します。これらの属性は、Twitter Application "
"Managementのアプリケーション設定ページで確認することができます。詳細は<<_twitter, "
"Twitterアイデンティティー・ブローカー>>のページを参照ください。"

msgid ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s alias=google "
"-s providerId=google -s enabled=true  -s 'config.useJwksUrl=\"true\"' -s "
"config.clientId=TWITTER_API_KEY -s config.clientSecret=TWITTER_API_SECRET"
msgstr ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s alias=google "
"-s providerId=google -s enabled=true  -s 'config.useJwksUrl=\"true\"' -s "
"config.clientId=TWITTER_API_KEY -s config.clientSecret=TWITTER_API_SECRET"

msgid "Configuring a GitHub identity provider"
msgstr "GitHubアイデンティティー・プロバイダーの設定"

msgid "Use `github` as the `providerId`."
msgstr "`providerId` には、 `github` を使用します。"

msgid ""
"Provide the `config` attributes `clientId` and `clientSecret`. You can find "
"these attributes in the GitHub Developer Application Settings page for your "
"application. See the <<_github, Github identity broker>> page for more "
"information."
msgstr ""
"`config` 属性の `clientId` と `clientSecret` を指定します。これらの属性は、GitHub Developer "
"Application Settingsページで確認することができます。詳しくは<<_github, "
"Githubアイデンティティー・ブローカー>>のページを参照してください。"

msgid ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s alias=github "
"-s providerId=github -s enabled=true  -s 'config.useJwksUrl=\"true\"' -s "
"config.clientId=GITHUB_CLIENT_ID -s config.clientSecret=GITHUB_CLIENT_SECRET"
msgstr ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s alias=github "
"-s providerId=github -s enabled=true  -s 'config.useJwksUrl=\"true\"' -s "
"config.clientId=GITHUB_CLIENT_ID -s config.clientSecret=GITHUB_CLIENT_SECRET"

msgid "Configuring a LinkedIn identity provider"
msgstr "LinkedInアイデンティティー・プロバイダーの設定"

msgid "Use `linkedin` as the `providerId`."
msgstr "`providerId` には、 `linkedin` を使用します。"

msgid ""
"Provide the `config` attributes `clientId` and `clientSecret`. You can find "
"these attributes in the LinkedIn Developer Console application page for your"
" application. See the <<_linkedin, LinkedIn identity broker>> page for more "
"information."
msgstr ""
"config` 属性の `clientId` と `clientSecret` を指定します。これらの属性は、アプリケーションの LinkedIn "
"Developer Console アプリケーションページで見つけることができます。詳細は &lt;&gt;<_linkedin, LinkedIn "
"identity broker>ページを</_linkedin,>参照してください。"

msgid ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s alias=linkedin"
" -s providerId=linkedin -s enabled=true  -s 'config.useJwksUrl=\"true\"' -s "
"config.clientId=LINKEDIN_CLIENT_ID -s "
"config.clientSecret=LINKEDIN_CLIENT_SECRET"
msgstr ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s alias=linkedin"
" -s providerId=linkedin -s enabled=true  -s 'config.useJwksUrl=\"true\"' -s "
"config.clientId=LINKEDIN_CLIENT_ID -s "
"config.clientSecret=LINKEDIN_CLIENT_SECRET"

msgid "Configuring a Microsoft Live identity provider"
msgstr "Microsoft Live アイデンティティー・プロバイダーの設定"

msgid "Use `microsoft` as the `providerId`."
msgstr "`ProviderId` には `microsoft` を使用します。"

msgid ""
"Provide the `config` attributes `clientId` and `clientSecret`. You can find "
"these attributes in the Microsoft Application Registration Portal page for "
"your application. See the <<_microsoft, Microsoft identity broker>> page for"
" more information."
msgstr ""
"config` 属性の `clientId` と `clientSecret` を指定します。これらの属性は、アプリケーションの Microsoft "
"Application Registration Portal ページで確認することができます。詳細は &lt;&gt;<_microsoft, "
"Microsoft identity broker>ページを</_microsoft,>参照してください。"

msgid ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s "
"alias=microsoft -s providerId=microsoft -s enabled=true  -s "
"'config.useJwksUrl=\"true\"' -s config.clientId=MICROSOFT_APP_ID -s "
"config.clientSecret=MICROSOFT_PASSWORD"
msgstr ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s "
"alias=microsoft -s providerId=microsoft -s enabled=true  -s "
"'config.useJwksUrl=\"true\"' -s config.clientId=MICROSOFT_APP_ID -s "
"config.clientSecret=MICROSOFT_PASSWORD"

msgid "Configuring a Stack Overflow identity provider"
msgstr "Stack Overflowアイデンティティー・プロバイダーの設定"

msgid "Use `stackoverflow` command as the `providerId`."
msgstr "`providerId` にとして、 `stackoverflow` コマンドを使用します。"

msgid ""
"Provide the `config` attributes `clientId`, `clientSecret`, and `key`. You "
"can find these attributes in the Stack Apps OAuth page for your application."
" See the <<_stackoverflow, Stack Overflow identity broker>> page for more "
"information."
msgstr ""
"`config` 属性の `clientId` 、`clientSecret` 、および `key` を指定します。これらの属性は、Stack Apps"
" OAuthページで確認することができます。詳細は <<_stackoverflow, Stack "
"Overflowアイデンティティー・ブローカー>>のページを参照してください。"

msgid ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s "
"alias=stackoverflow -s providerId=stackoverflow -s enabled=true  -s "
"'config.useJwksUrl=\"true\"' -s config.clientId=STACKAPPS_CLIENT_ID -s "
"config.clientSecret=STACKAPPS_CLIENT_SECRET -s config.key=STACKAPPS_KEY"
msgstr ""
"$ kcadm.sh create identity-provider/instances -r demorealm -s "
"alias=stackoverflow -s providerId=stackoverflow -s enabled=true  -s "
"'config.useJwksUrl=\"true\"' -s config.clientId=STACKAPPS_CLIENT_ID -s "
"config.clientSecret=STACKAPPS_CLIENT_SECRET -s config.key=STACKAPPS_KEY"

msgid "Storage provider operations"
msgstr "ストレージ・プロバイダーの操作"

msgid "Configuring a Kerberos storage provider"
msgstr "Kerberosストレージ・プロバイダーの設定"

msgid "Use the `create` command against the `components` endpoint."
msgstr "`components` エンドポイントに対して `create` コマンドを使用します。"

msgid "Specify the realm id as a value of the `parentId` attribute."
msgstr "`parentId` 属性の値として、レルムIDを指定します。"

msgid ""
"Specify `kerberos` as the value of the `providerId` attribute, and "
"`org.keycloak.storage.UserStorageProvider` as the value of the "
"`providerType` attribute."
msgstr ""
"`providerId` 属性の値として `kerberos` を指定し、`providerType` 属性の値として "
"`org.keycloak.storage.UserStorageProvider` を指定します。"

msgid ""
"$ kcadm.sh create components -r demorealm -s parentId=demorealmId -s "
"id=demokerberos -s name=demokerberos -s providerId=kerberos -s "
"providerType=org.keycloak.storage.UserStorageProvider -s "
"'config.priority=[\"0\"]' -s 'config.debug=[\"false\"]' -s "
"'config.allowPasswordAuthentication=[\"true\"]' -s "
"'config.editMode=[\"UNSYNCED\"]' -s "
"'config.updateProfileFirstLogin=[\"true\"]' -s "
"'config.allowKerberosAuthentication=[\"true\"]' -s "
"'config.kerberosRealm=[\"KEYCLOAK.ORG\"]' -s "
"'config.keyTab=[\"http.keytab\"]' -s "
"'config.serverPrincipal=[\"HTTP/localhost@KEYCLOAK.ORG\"]' -s "
"'config.cachePolicy=[\"DEFAULT\"]'"
msgstr ""
"$ kcadm.sh create components -r demorealm -s parentId=demorealmId -s "
"id=demokerberos -s name=demokerberos -s providerId=kerberos -s "
"providerType=org.keycloak.storage.UserStorageProvider -s "
"'config.priority=[\"0\"]' -s 'config.debug=[\"false\"]' -s "
"'config.allowPasswordAuthentication=[\"true\"]' -s "
"'config.editMode=[\"UNSYNCED\"]' -s "
"'config.updateProfileFirstLogin=[\"true\"]' -s "
"'config.allowKerberosAuthentication=[\"true\"]' -s "
"'config.kerberosRealm=[\"KEYCLOAK.ORG\"]' -s "
"'config.keyTab=[\"http.keytab\"]' -s "
"'config.serverPrincipal=[\"HTTP/localhost@KEYCLOAK.ORG\"]' -s "
"'config.cachePolicy=[\"DEFAULT\"]'"

msgid "Configuring an LDAP user storage provider"
msgstr "LDAPユーザー・ストレージ・プロバイダーの設定"

msgid ""
"Specify `ldap` as the value of the `providerId` attribute, and "
"`org.keycloak.storage.UserStorageProvider` as the value of the "
"`providerType` attribute."
msgstr ""
"`providerId` 属性の値として `ldap` を指定し、 `providerType` 属性の値として "
"`org.keycloak.storage.UserStorageProvider` を指定します。"

msgid "Provide the realm ID as the value of the `parentId` attribute."
msgstr "`parentId` 属性の値として、レルムIDを指定します。"

msgid ""
"Use the following example to create a Kerberos-integrated LDAP provider."
msgstr "次の例を使用して、Kerberos統合LDAPプロバイダーを作成します。"

msgid ""
"$ kcadm.sh create components -r demorealm -s name=kerberos-ldap-provider -s "
"providerId=ldap -s providerType=org.keycloak.storage.UserStorageProvider -s "
"parentId=3d9c572b-8f33-483f-98a6-8bb421667867  -s 'config.priority=[\"1\"]' "
"-s 'config.fullSyncPeriod=[\"-1\"]' -s 'config.changedSyncPeriod=[\"-1\"]' "
"-s 'config.cachePolicy=[\"DEFAULT\"]' -s config.evictionDay=[] -s "
"config.evictionHour=[] -s config.evictionMinute=[] -s config.maxLifespan=[] "
"-s 'config.batchSizeForSync=[\"1000\"]' -s 'config.editMode=[\"WRITABLE\"]' "
"-s 'config.syncRegistrations=[\"false\"]' -s 'config.vendor=[\"other\"]' -s "
"'config.usernameLDAPAttribute=[\"uid\"]' -s "
"'config.rdnLDAPAttribute=[\"uid\"]' -s "
"'config.uuidLDAPAttribute=[\"entryUUID\"]' -s "
"'config.userObjectClasses=[\"inetOrgPerson, organizationalPerson\"]' -s "
"'config.connectionUrl=[\"ldap://localhost:10389\"]'  -s "
"'config.usersDn=[\"ou=People,dc=keycloak,dc=org\"]' -s "
"'config.authType=[\"simple\"]' -s 'config.bindDn=[\"uid=admin,ou=system\"]' "
"-s 'config.bindCredential=[\"secret\"]' -s 'config.searchScope=[\"1\"]' -s "
"'config.useTruststoreSpi=[\"ldapsOnly\"]' -s "
"'config.connectionPooling=[\"true\"]' -s 'config.pagination=[\"true\"]' -s "
"'config.allowKerberosAuthentication=[\"true\"]' -s "
"'config.serverPrincipal=[\"HTTP/localhost@KEYCLOAK.ORG\"]' -s "
"'config.keyTab=[\"http.keytab\"]' -s "
"'config.kerberosRealm=[\"KEYCLOAK.ORG\"]' -s 'config.debug=[\"true\"]' -s "
"'config.useKerberosForPasswordAuthentication=[\"true\"]'"
msgstr ""
"$ kcadm.sh create components -r demorealm -s name=kerberos-ldap-provider -s "
"providerId=ldap -s providerType=org.keycloak.storage.UserStorageProvider -s "
"parentId=3d9c572b-8f33-483f-98a6-8bb421667867  -s 'config.priority=[\"1\"]' "
"-s 'config.fullSyncPeriod=[\"-1\"]' -s 'config.changedSyncPeriod=[\"-1\"]' "
"-s 'config.cachePolicy=[\"DEFAULT\"]' -s config.evictionDay=[] -s "
"config.evictionHour=[] -s config.evictionMinute=[] -s config.maxLifespan=[] "
"-s 'config.batchSizeForSync=[\"1000\"]' -s 'config.editMode=[\"WRITABLE\"]' "
"-s 'config.syncRegistrations=[\"false\"]' -s 'config.vendor=[\"other\"]' -s "
"'config.usernameLDAPAttribute=[\"uid\"]' -s "
"'config.rdnLDAPAttribute=[\"uid\"]' -s "
"'config.uuidLDAPAttribute=[\"entryUUID\"]' -s "
"'config.userObjectClasses=[\"inetOrgPerson, organizationalPerson\"]' -s "
"'config.connectionUrl=[\"ldap://localhost:10389\"]'  -s "
"'config.usersDn=[\"ou=People,dc=keycloak,dc=org\"]' -s "
"'config.authType=[\"simple\"]' -s 'config.bindDn=[\"uid=admin,ou=system\"]' "
"-s 'config.bindCredential=[\"secret\"]' -s 'config.searchScope=[\"1\"]' -s "
"'config.useTruststoreSpi=[\"ldapsOnly\"]' -s "
"'config.connectionPooling=[\"true\"]' -s 'config.pagination=[\"true\"]' -s "
"'config.allowKerberosAuthentication=[\"true\"]' -s "
"'config.serverPrincipal=[\"HTTP/localhost@KEYCLOAK.ORG\"]' -s "
"'config.keyTab=[\"http.keytab\"]' -s "
"'config.kerberosRealm=[\"KEYCLOAK.ORG\"]' -s 'config.debug=[\"true\"]' -s "
"'config.useKerberosForPasswordAuthentication=[\"true\"]'"

msgid "Removing a user storage provider instance"
msgstr "ユーザー・ストレージ・プロバイダー・インスタンスの削除"

msgid ""
"Use the storage provider instance's `id` attribute to compose an endpoint "
"URI, such as `components/ID`."
msgstr ""
"ストレージ・プロバイダー・インスタンスの `id` 属性を使用して、  `components/ID` のようなエンドポイントURIを構成します。"

msgid "Run the `delete` command against this endpoint."
msgstr "このエンドポイントに対して `delete` コマンドを実行します。"

msgid ""
"$ kcadm.sh delete components/3d9c572b-8f33-483f-98a6-8bb421667867 -r "
"demorealm"
msgstr ""
"$ kcadm.sh delete components/3d9c572b-8f33-483f-98a6-8bb421667867 -r "
"demorealm"

msgid ""
"Triggering synchronization of all users for a specific user storage provider"
msgstr "特定のユーザー・ストレージ・プロバイダーのすべてのユーザーの同期をトリガーする"

msgid ""
"Use the storage provider's `id` attribute to compose an endpoint URI, such "
"as `user-storage/ID_OF_USER_STORAGE_INSTANCE/sync`."
msgstr ""
"ストレージ・プロバイダーの `id` 属性を用いて、 `user-storage/ID_OF_USER_STORAGE_INSTANCE/sync` "
"のようなエンドポイントURIを構成します。"

msgid "Add the `action=triggerFullSync` query parameter."
msgstr "`action=triggerFullSync` クエリー・パラメーターを追加します。"

msgid "Run the `create` command."
msgstr "`create` コマンドを実行します。"

msgid ""
"$ kcadm.sh create user-"
"storage/b7c63d02-b62a-4fc1-977c-947d6a09e1ea/sync?action=triggerFullSync"
msgstr ""
"$ kcadm.sh create user-"
"storage/b7c63d02-b62a-4fc1-977c-947d6a09e1ea/sync?action=triggerFullSync"

msgid ""
"Triggering synchronization of changed users for a specific user storage "
"provider"
msgstr "特定のユーザー・ストレージ・プロバイダーに対して、変更されたユーザーの同期をトリガーする"

msgid "Add the `action=triggerChangedUsersSync` query parameter."
msgstr "`action=triggerChangedUsersSync` のクエリー・パラメーターを追加します。"

msgid ""
"$ kcadm.sh create user-"
"storage/b7c63d02-b62a-4fc1-977c-947d6a09e1ea/sync?action=triggerChangedUsersSync"
msgstr ""
"$ kcadm.sh create user-"
"storage/b7c63d02-b62a-4fc1-977c-947d6a09e1ea/sync?action=triggerChangedUsersSync"

msgid "Test LDAP user storage connectivity"
msgstr "LDAPユーザー・ストレージの接続をテストする"

msgid "Run the `get` command on the `testLDAPConnection` endpoint."
msgstr "`testLDAPConnection` のエンドポイントに対して `get` コマンドを実行します。"

msgid ""
"Provide query parameters `bindCredential`, `bindDn`, `connectionUrl`, and "
"`useTruststoreSpi`."
msgstr ""
"クエリー・パラメーター `bindCredential` 、 `bindDn` 、 `connectionUrl` 、 "
"`useTruststoreSpi` を指定します。"

msgid "Set the `action` query parameter to `testConnection`."
msgstr "クエリー・パラメーター `action` に `testConnection` を設定します。"

msgid ""
"$ kcadm.sh create testLDAPConnection -s action=testConnection -s "
"bindCredential=secret -s bindDn=uid=admin,ou=system -s "
"connectionUrl=ldap://localhost:10389 -s useTruststoreSpi=ldapsOnly"
msgstr ""
"$ kcadm.sh create testLDAPConnection -s action=testConnection -s "
"bindCredential=secret -s bindDn=uid=admin,ou=system -s "
"connectionUrl=ldap://localhost:10389 -s useTruststoreSpi=ldapsOnly"

msgid "Test LDAP user storage authentication"
msgstr "LDAPユーザー・ストレージ認証をテストする"

msgid ""
"Provide the query parameters `bindCredential`, `bindDn`, `connectionUrl`, "
"and `useTruststoreSpi`."
msgstr ""
"クエリー・パラメーターとして、 `bindCredential` 、 `bindDn` 、  `connectionUrl` 、  "
"`useTruststoreSpi` を指定します。"

msgid "Set the `action` query parameter to `testAuthentication`."
msgstr "クエリー・パラメーター `action` に `testAuthentication` を設定します。"

msgid ""
"$ kcadm.sh create testLDAPConnection -s action=testAuthentication -s "
"bindCredential=secret -s bindDn=uid=admin,ou=system -s "
"connectionUrl=ldap://localhost:10389 -s useTruststoreSpi=ldapsOnly"
msgstr ""
"$ kcadm.sh create testLDAPConnection -s action=testAuthentication -s "
"bindCredential=secret -s bindDn=uid=admin,ou=system -s "
"connectionUrl=ldap://localhost:10389 -s useTruststoreSpi=ldapsOnly"

msgid "Adding mappers"
msgstr "マッパーの追加"

msgid "Adding a hard-coded role LDAP mapper"
msgstr "ハードコードされたロールLDAPマッパーの追加"

msgid "Run the `create` command on the `components` endpoint."
msgstr "`components` エンドポイントに対して `create` コマンドを実行します。"

msgid ""
"Set the `providerType` attribute to "
"`org.keycloak.storage.ldap.mappers.LDAPStorageMapper`."
msgstr ""
"`ProviderType` 属性を  `org.keycloak.storage.ldap.mappers.LDAPStorageMapper` "
"に設定します。"

msgid "Set the `parentId` attribute to the ID of the LDAP provider instance."
msgstr "`parentId` 属性にLDAPプロバイダー・インスタンスのIDを設定します。"

msgid ""
"Set the `providerId` attribute to `hardcoded-ldap-role-mapper`. Ensure you "
"provide a value of `role` configuration parameter."
msgstr ""
"`providerId` 属性に `hardcoded-ldap-role-mapper` を設定します。設定パラメーターに `role` "
"の値を指定することを確認してください。"

msgid ""
"$ kcadm.sh create components -r demorealm -s name=hardcoded-ldap-role-mapper"
" -s providerId=hardcoded-ldap-role-mapper -s "
"providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s "
"parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config.role=[\"realm-"
"management.create-client\"]'"
msgstr ""
"$ kcadm.sh create components -r demorealm -s name=hardcoded-ldap-role-mapper"
" -s providerId=hardcoded-ldap-role-mapper -s "
"providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s "
"parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config.role=[\"realm-"
"management.create-client\"]'"

msgid "Adding an MS Active Directory mapper"
msgstr "MS Active Directoryマッパーの追加"

msgid "Set the `providerId` attribute to `msad-user-account-control-mapper`."
msgstr "`providerId` 属性を `msad-user-account-control-mapper` に設定します。"

msgid ""
"$ kcadm.sh create components -r demorealm -s name=msad-user-account-control-"
"mapper -s providerId=msad-user-account-control-mapper -s "
"providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s "
"parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea"
msgstr ""
"$ kcadm.sh create components -r demorealm -s name=msad-user-account-control-"
"mapper -s providerId=msad-user-account-control-mapper -s "
"providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s "
"parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea"

msgid "Adding a user attribute LDAP mapper"
msgstr "ユーザー属性LDAPマッパーの追加"

msgid "Set the `providerId` attribute to `user-attribute-ldap-mapper`."
msgstr "`user-attribute-ldap-mapper` に `providerId` 属性を設定します。"

msgid ""
"$ kcadm.sh create components -r demorealm -s name=user-attribute-ldap-mapper"
" -s providerId=user-attribute-ldap-mapper -s "
"providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s "
"parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s "
"'config.\"user.model.attribute\"=[\"email\"]' -s "
"'config.\"ldap.attribute\"=[\"mail\"]' -s 'config.\"read.only\"=[\"false\"]'"
" -s 'config.\"always.read.value.from.ldap\"=[\"false\"]' -s "
"'config.\"is.mandatory.in.ldap\"=[\"false\"]'"
msgstr ""
"$ kcadm.sh create components -r demorealm -s name=user-attribute-ldap-mapper"
" -s providerId=user-attribute-ldap-mapper -s "
"providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s "
"parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s "
"'config.\"user.model.attribute\"=[\"email\"]' -s "
"'config.\"ldap.attribute\"=[\"mail\"]' -s 'config.\"read.only\"=[\"false\"]'"
" -s 'config.\"always.read.value.from.ldap\"=[\"false\"]' -s "
"'config.\"is.mandatory.in.ldap\"=[\"false\"]'"

msgid "Adding a group LDAP mapper"
msgstr "グループLDAPマッパーの追加"

msgid "Set the `providerId` attribute to `group-ldap-mapper`."
msgstr "`providerId` 属性に `group-ldap-mapper` を設定します。"

msgid ""
"$ kcadm.sh create components -r demorealm -s name=group-ldap-mapper -s "
"providerId=group-ldap-mapper -s "
"providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s "
"parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config.\"groups.dn\"=[]' "
"-s 'config.\"group.name.ldap.attribute\"=[\"cn\"]' -s "
"'config.\"group.object.classes\"=[\"groupOfNames\"]' -s "
"'config.\"preserve.group.inheritance\"=[\"true\"]' -s "
"'config.\"membership.ldap.attribute\"=[\"member\"]' -s "
"'config.\"membership.attribute.type\"=[\"DN\"]' -s "
"'config.\"groups.ldap.filter\"=[]' -s 'config.mode=[\"LDAP_ONLY\"]' -s "
"'config.\"user.roles.retrieve.strategy\"=[\"LOAD_GROUPS_BY_MEMBER_ATTRIBUTE\"]'"
" -s 'config.\"mapped.group.attributes\"=[\"admins-group\"]' -s "
"'config.\"drop.non.existing.groups.during.sync\"=[\"false\"]' -s "
"'config.roles=[\"admins\"]' -s 'config.groups=[\"admins-group\"]' -s "
"'config.group=[]' -s 'config.preserve=[\"true\"]' -s "
"'config.membership=[\"member\"]'"
msgstr ""
"$ kcadm.sh create components -r demorealm -s name=group-ldap-mapper -s "
"providerId=group-ldap-mapper -s "
"providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s "
"parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s 'config.\"groups.dn\"=[]' "
"-s 'config.\"group.name.ldap.attribute\"=[\"cn\"]' -s "
"'config.\"group.object.classes\"=[\"groupOfNames\"]' -s "
"'config.\"preserve.group.inheritance\"=[\"true\"]' -s "
"'config.\"membership.ldap.attribute\"=[\"member\"]' -s "
"'config.\"membership.attribute.type\"=[\"DN\"]' -s "
"'config.\"groups.ldap.filter\"=[]' -s 'config.mode=[\"LDAP_ONLY\"]' -s "
"'config.\"user.roles.retrieve.strategy\"=[\"LOAD_GROUPS_BY_MEMBER_ATTRIBUTE\"]'"
" -s 'config.\"mapped.group.attributes\"=[\"admins-group\"]' -s "
"'config.\"drop.non.existing.groups.during.sync\"=[\"false\"]' -s "
"'config.roles=[\"admins\"]' -s 'config.groups=[\"admins-group\"]' -s "
"'config.group=[]' -s 'config.preserve=[\"true\"]' -s "
"'config.membership=[\"member\"]'"

msgid "Adding a full name LDAP mapper"
msgstr "フルネームLDAPマッパーの追加"

msgid "Set the `providerId` attribute to `full-name-ldap-mapper`."
msgstr "`providerId` 属性に `full-name-ldap-mapper` を設定します。"

msgid ""
"$ kcadm.sh create components -r demorealm -s name=full-name-ldap-mapper -s "
"providerId=full-name-ldap-mapper -s "
"providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s "
"parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s "
"'config.\"ldap.full.name.attribute\"=[\"cn\"]' -s "
"'config.\"read.only\"=[\"false\"]' -s 'config.\"write.only\"=[\"true\"]'"
msgstr ""
"$ kcadm.sh create components -r demorealm -s name=full-name-ldap-mapper -s "
"providerId=full-name-ldap-mapper -s "
"providerType=org.keycloak.storage.ldap.mappers.LDAPStorageMapper -s "
"parentId=b7c63d02-b62a-4fc1-977c-947d6a09e1ea -s "
"'config.\"ldap.full.name.attribute\"=[\"cn\"]' -s "
"'config.\"read.only\"=[\"false\"]' -s 'config.\"write.only\"=[\"true\"]'"

msgid "Authentication operations"
msgstr "認証の操作"

msgid "Setting a password policy"
msgstr "パスワード・ポリシーの設定"

msgid ""
"Set the realm's `passwordPolicy` attribute to an enumeration expression that"
" includes the specific policy provider ID and optional configuration."
msgstr "`realm の `passwordPolicy` 属性に、特定のポリシー・プロバイダーIDとオプションの設定を含む列挙式を設定します。"

msgid ""
"Use the following example to set a password policy to default values. The "
"default values include:"
msgstr "次の例を使用して、パスワード・ポリシーをデフォルト値に設定します。デフォルト値は次のとおりです。"

msgid "27,500 hashing iterations"
msgstr "27,500ハッシュ反復"

msgid "at least one special character"
msgstr "少なくとも1つの特殊文字"

msgid "at least one uppercase character"
msgstr "少なくとも1つの大文字"

msgid "at least one digit character"
msgstr "少なくとも1つの数字"

msgid "not be equal to a user's `username`"
msgstr "ユーザーの `username` と同じでないこと。"

msgid "be at least eight characters long"
msgstr "8文字以上の長さ"

msgid ""
"$ kcadm.sh update realms/demorealm -s 'passwordPolicy=\"hashIterations and "
"specialChars and upperCase and digits and notUsername and length\"'"
msgstr ""
"$ kcadm.sh update realms/demorealm -s 'passwordPolicy=\"hashIterations and "
"specialChars and upperCase and digits and notUsername and length\"'"

msgid ""
"To use values different from defaults, pass the configuration in brackets."
msgstr "デフォルトと異なる値を使用する場合は、設定を括弧で囲んで渡します。"

msgid "Use the following example to set a password policy to:"
msgstr "パスワードポリシーを次のように設定するには、以下の例を使用します。"

msgid "25,000 hash iterations"
msgstr "25,000ハッシュ反復"

msgid "at least two special characters"
msgstr "少なくとも2つの特殊文字"

msgid "at least two uppercase characters"
msgstr "少なくとも2つの大文字"

msgid "at least two lowercase characters"
msgstr "少なくとも2つの小文字"

msgid "at least two digits"
msgstr "少なくとも2つの数字"

msgid "be at least nine characters long"
msgstr "9文字以上の長さ"

msgid "not repeat for at least four changes back"
msgstr "過去4回の変更履歴の重複を許可しない"

msgid ""
"$ kcadm.sh update realms/demorealm -s "
"'passwordPolicy=\"hashIterations(25000) and specialChars(2) and upperCase(2)"
" and lowerCase(2) and digits(2) and length(9) and notUsername and "
"passwordHistory(4)\"'"
msgstr ""
"$ kcadm.sh update realms/demorealm -s "
"'passwordPolicy=\"hashIterations(25000) and specialChars(2) and upperCase(2)"
" and lowerCase(2) and digits(2) and length(9) and notUsername and "
"passwordHistory(4)\"'"

msgid "Obtaining the current password policy"
msgstr "現在のパスワードポリシーの取得"

msgid ""
"You can get the current realm configuration by filtering all output except "
"for the `passwordPolicy` attribute."
msgstr "`passwordPolicy` 属性以外のすべての出力をフィルタリングすることで、現在のレルム設定を取得することができます。"

msgid "For example, display `passwordPolicy` for `demorealm`."
msgstr "たとえば、`demorealm` の `passwordPolicy` を表示します。"

msgid "$ kcadm.sh get realms/demorealm --fields passwordPolicy"
msgstr "$ kcadm.sh get realms/demorealm --fields passwordPolicy"

msgid "Listing authentication flows"
msgstr "認証フローの一覧表示"

msgid "Run the `get` command on the `authentication/flows` endpoint."
msgstr "`authentication/flows` エンドポイントに対して `get` コマンドを実行します。"

msgid "$ kcadm.sh get authentication/flows -r demorealm"
msgstr "$ kcadm.sh get authentication/flows -r demorealm"

msgid "Getting a specific authentication flow"
msgstr "特定の認証フローの取得"

msgid "Run the `get` command on the `authentication/flows/FLOW_ID` endpoint."
msgstr "`authentication/flows/FLOW_ID` エンドポイントに対して `get` コマンドを実行します。"

msgid ""
"$ kcadm.sh get authentication/flows/febfd772-e1a1-42fb-b8ae-00c0566fafb8 -r "
"demorealm"
msgstr ""
"$ kcadm.sh get authentication/flows/febfd772-e1a1-42fb-b8ae-00c0566fafb8 -r "
"demorealm"

msgid "Listing executions for a flow"
msgstr "フローのエグゼキューションの一覧表示"

msgid ""
"Run the `get` command on the `authentication/flows/FLOW_ALIAS/executions` "
"endpoint."
msgstr ""
"`Authentication/flows/FLOW_ALIAS/executions` エンドポイントで `get` コマンドを実行します。"

msgid ""
"$ kcadm.sh get authentication/flows/Copy%20of%20browser/executions -r "
"demorealm"
msgstr ""
"$ kcadm.sh get authentication/flows/Copy%20of%20browser/executions -r "
"demorealm"

msgid "Adding configuration to an execution"
msgstr "エグゼキューションに対する設定の追加"

msgid "Get execution for a flow."
msgstr "フローのエグゼキューションを取得します。"

msgid "Note the ID of the flow."
msgstr "フローのIDをメモします。"

msgid ""
"Run the `create` command on the "
"`authentication/executions/{executionId}/config` endpoint."
msgstr ""
"`authentication/executions/{executionId}/config` エンドポイントにて `create` "
"コマンドを実行します。"

msgid ""
"$ kcadm create "
"\"authentication/executions/a3147129-c402-4760-86d9-3f2345e401c7/config\" -r"
" examplerealm -b '{\"config\":{\"x509-cert-auth.mapping-source-"
"selection\":\"Match SubjectDN using regular expression\",\"x509-cert-"
"auth.regular-expression\":\"(.*?)(?:$)\",\"x509-cert-auth.mapper-"
"selection\":\"Custom Attribute Mapper\",\"x509-cert-auth.mapper-"
"selection.user-attribute-name\":\"usercertificate\",\"x509-cert-auth.crl-"
"checking-enabled\":\"\",\"x509-cert-auth.crldp-checking-"
"enabled\":false,\"x509-cert-auth.crl-relative-"
"path\":\"crl.pem\",\"x509-cert-auth.ocsp-checking-"
"enabled\":\"\",\"x509-cert-auth.ocsp-responder-uri\":\"\",\"x509-cert-"
"auth.keyusage\":\"\",\"x509-cert-auth.extendedkeyusage\":\"\",\"x509-cert-"
"auth.confirmation-page-disallowed\":\"\"},\"alias\":\"my_otp_config\"}'"
msgstr ""
"$ kcadm create "
"\"authentication/executions/a3147129-c402-4760-86d9-3f2345e401c7/config\" -r"
" examplerealm -b '{\"config\":{\"x509-cert-auth.mapping-source-"
"selection\":\"Match SubjectDN using regular expression\",\"x509-cert-"
"auth.regular-expression\":\"(.*?)(?:$)\",\"x509-cert-auth.mapper-"
"selection\":\"Custom Attribute Mapper\",\"x509-cert-auth.mapper-"
"selection.user-attribute-name\":\"usercertificate\",\"x509-cert-auth.crl-"
"checking-enabled\":\"\",\"x509-cert-auth.crldp-checking-"
"enabled\":false,\"x509-cert-auth.crl-relative-"
"path\":\"crl.pem\",\"x509-cert-auth.ocsp-checking-"
"enabled\":\"\",\"x509-cert-auth.ocsp-responder-uri\":\"\",\"x509-cert-"
"auth.keyusage\":\"\",\"x509-cert-auth.extendedkeyusage\":\"\",\"x509-cert-"
"auth.confirmation-page-disallowed\":\"\"},\"alias\":\"my_otp_config\"}'"

msgid "Getting configuration for an execution"
msgstr "エグゼキューションの設定の取得"

msgid ""
"Note its `authenticationConfig` attribute, which contains the config ID."
msgstr "その `authenticationConfig` 属性に注目してください。この属性には、設定IDが含まれています。"

msgid "Run the `get` command on the `authentication/config/ID` endpoint."
msgstr "`authentication/config/ID` エンドポイントに対して `get` コマンドを実行します。"

msgid ""
"$ kcadm get \"authentication/config/dd91611a-d25c-421a-87e2-227c18421833\" "
"-r examplerealm"
msgstr ""
"$ kcadm get \"authentication/config/dd91611a-d25c-421a-87e2-227c18421833\" "
"-r examplerealm"

msgid "Updating configuration for an execution"
msgstr "エグゼキューションの設定の更新"

msgid "Get the execution for the flow."
msgstr "フローのエグゼキューションを取得します。"

msgid "Get the flow's `authenticationConfig` attribute."
msgstr "フローの `authenticationConfig` 属性を取得します。"

msgid "Note the config ID from the attribute."
msgstr "属性から設定IDをメモします。"

msgid "Run the `update` command on the `authentication/config/ID` endpoint."
msgstr "`authentication/config/ID` エンドポイントで `update` コマンドを実行します。"

msgid ""
"$ kcadm update "
"\"authentication/config/dd91611a-d25c-421a-87e2-227c18421833\" -r "
"examplerealm -b "
"'{\"id\":\"dd91611a-d25c-421a-87e2-227c18421833\",\"alias\":\"my_otp_config\",\"config\":{\"x509-cert-"
"auth.extendedkeyusage\":\"\",\"x509-cert-auth.mapper-selection.user-"
"attribute-name\":\"usercertificate\",\"x509-cert-auth.ocsp-responder-"
"uri\":\"\",\"x509-cert-auth.regular-expression\":\"(.*?)(?:$)\",\"x509-cert-"
"auth.crl-checking-enabled\":\"true\",\"x509-cert-auth.confirmation-page-"
"disallowed\":\"\",\"x509-cert-auth.keyusage\":\"\",\"x509-cert-auth.mapper-"
"selection\":\"Custom Attribute Mapper\",\"x509-cert-auth.crl-relative-"
"path\":\"crl.pem\",\"x509-cert-auth.crldp-checking-"
"enabled\":\"false\",\"x509-cert-auth.mapping-source-selection\":\"Match "
"SubjectDN using regular expression\",\"x509-cert-auth.ocsp-checking-"
"enabled\":\"\"}}'"
msgstr ""
"$ kcadm update "
"\"authentication/config/dd91611a-d25c-421a-87e2-227c18421833\" -r "
"examplerealm -b "
"'{\"id\":\"dd91611a-d25c-421a-87e2-227c18421833\",\"alias\":\"my_otp_config\",\"config\":{\"x509-cert-"
"auth.extendedkeyusage\":\"\",\"x509-cert-auth.mapper-selection.user-"
"attribute-name\":\"usercertificate\",\"x509-cert-auth.ocsp-responder-"
"uri\":\"\",\"x509-cert-auth.regular-expression\":\"(.*?)(?:$)\",\"x509-cert-"
"auth.crl-checking-enabled\":\"true\",\"x509-cert-auth.confirmation-page-"
"disallowed\":\"\",\"x509-cert-auth.keyusage\":\"\",\"x509-cert-auth.mapper-"
"selection\":\"Custom Attribute Mapper\",\"x509-cert-auth.crl-relative-"
"path\":\"crl.pem\",\"x509-cert-auth.crldp-checking-"
"enabled\":\"false\",\"x509-cert-auth.mapping-source-selection\":\"Match "
"SubjectDN using regular expression\",\"x509-cert-auth.ocsp-checking-"
"enabled\":\"\"}}'"

msgid "Deleting configuration for an execution"
msgstr "エグゼキューションの設定の削除"

msgid "Get the flows `authenticationConfig` attribute."
msgstr "フローの `authenticationConfig` 属性を取得します。"

msgid "Run the `delete` command on the `authentication/config/ID` endpoint."
msgstr "`authentication/config/ID` エンドポイントで `delete` コマンドを実行します。"

msgid ""
"$ kcadm delete "
"\"authentication/config/dd91611a-d25c-421a-87e2-227c18421833\" -r "
"examplerealm"
msgstr ""
"$ kcadm delete "
"\"authentication/config/dd91611a-d25c-421a-87e2-227c18421833\" -r "
"examplerealm"
