# 
# Translators:
# jic_m_mito <jic-m-mito@nri.co.jp>, 2023
# Tsukasa Amano <t.amano@pro-japan.co.jp>, 2023
# KojiNose <knose.dev@gmail.com>, 2023
# Naoki Ueda, 2023
# Kohei Tamura <ktamura.biz.80@gmail.com>, 2023
# Hiroyuki Wada <wadahiro@gmail.com>, 2023
# 
msgid ""
msgstr ""
"Last-Translator: Hiroyuki Wada <wadahiro@gmail.com>, 2023\n"
"Language-Team: Japanese (Japan) (https://app.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid "{adapterguide_name}"
msgstr "{adapterguide_name}"

msgid "*{release_header_guide}* icon:angle-down[]"
msgstr "*{release_header_guide}* icon:angle-down[]"

msgid "{gettingstarted_link}[{gettingstarted_name_short}]"
msgstr "{gettingstarted_link}[{gettingstarted_name_short}]"

msgid "{installguide_link}[{installguide_name_short}]"
msgstr "{installguide_link}[{installguide_name_short}]"

msgid "{adminguide_link}[{adminguide_name_short}]"
msgstr "{adminguide_link}[{adminguide_name_short}]"

msgid "{developerguide_link}[{developerguide_name_short}]"
msgstr "{developerguide_link}[{developerguide_name_short}]"

msgid "{authorizationguide_link}[{authorizationguide_name_short}]"
msgstr "{authorizationguide_link}[{authorizationguide_name_short}]"

msgid "{upgradingguide_link}[{upgradingguide_name_short}]"
msgstr "{upgradingguide_link}[{upgradingguide_name_short}]"

msgid "{releasenotes_link}[{releasenotes_name_short}]"
msgstr "{releasenotes_link}[{releasenotes_name_short}]"

msgid ""
"Version *{project_version}* _{release_header_latest_link}[Click here for "
"latest]_"
msgstr "バージョン *{project_version}* _{release_header_latest_link}[最新はこちらをクリック]_"

msgid "Planning for securing applications and services"
msgstr "アプリケーションやサービスをセキュリティー保護するための計画"

msgid ""
"{project_name} supports both OpenID Connect (an extension to OAuth 2.0) and "
"SAML 2.0. When securing clients and services the first thing you need to "
"decide is which of the two you are going to use. If you want you can also "
"choose to secure some with OpenID Connect and others with SAML."
msgstr ""
"{project_name}は、OpenID Connect（OAuth 2.0 への拡張）とSAML "
"2.0の両方をサポートしています。クライアントとサービスをセキュリティー保護する際に最初に決定すべきことは、どちらを使用するのかということです。必要に応じて、一部をOpenID"
" Connectで、それ以外をSAMLでセキュリティー保護することも選択できます。"

msgid ""
"To secure clients and services you are also going to need an adapter or "
"library for the protocol you've selected. {project_name} comes with its own "
"adapters for selected platforms, but it is also possible to use generic "
"OpenID Connect Relying Party and SAML Service Provider libraries."
msgstr ""
"クライアントとサービスをセキュリティー保護するためには、選択したプロトコルに対応するアダプターやライブラリーも必要になります。{project_name}には選択したプラットフォームに対応する独自のアダプターが付属していますが、一般的なOpenID"
" Connectのリライング・パーティーやSAMLのサービス・プロバイダーのライブラリーを使用することもできます。"

msgid "Client adapters"
msgstr "クライアント・アダプター"

msgid ""
"{project_name} client adapters are libraries that make it very easy to "
"secure applications and services with {project_name}. We call them adapters "
"rather than libraries as they provide a tight integration to the underlying "
"platform and framework. This makes our adapters easy to use and they require"
" less boilerplate code than what is typically required by a library."
msgstr ""
"{project_name}のクライアント・アダプターは、{project_name}とともに使用してアプリケーションとサービスを非常に簡単にセキュリティー保護できるライブラリーです。基盤となるプラットフォームやフレームワークとのタイトな統合を提供するので、ライブラリーではなく、アダプターと呼んでいます。このような考え方により、アダプターは使いやすく、一般的にライブラリーが必要とするよりも定型コードが少なくて済みます。"

msgid "Supported Platforms"
msgstr "サポートされているプラットフォーム"

msgid ""
"{project_name} enables you to protect applications running on different "
"platforms and using different technology stacks using OpenID Connect and "
"SAML protocols."
msgstr ""
"{project_name}は、OpenID "
"ConnectとSAMLプロトコルを使用して、異なるプラットフォームや異なるテクノロジー・スタックを使用して実行されるアプリケーションをセキュリティー保護することができます。"

msgid "OpenID Connect"
msgstr "OpenID Connect"

msgid "Java"
msgstr "Java"

msgid "<<_jboss_adapter,JBoss EAP>>"
msgstr "<<_jboss_adapter,JBoss EAP>>"

msgid "<<_jboss_adapter,WildFly>>"
msgstr "<<_jboss_adapter,WildFly>>"

msgid "<<_fuse_adapter,Fuse>>"
msgstr "<<_fuse_adapter,Fuse>>"

msgid "<<_tomcat_adapter,Tomcat>>"
msgstr "<<_tomcat_adapter,Tomcat>>"

msgid "<<_jetty9_adapter,Jetty 9>>"
msgstr "<<_jetty9_adapter,Jetty 9>>"

msgid "<<_servlet_filter_adapter,Servlet Filter>>"
msgstr "<<_servlet_filter_adapter,Servlet Filter>>"

msgid "<<_spring_boot_adapter,Spring Boot>>"
msgstr "<<_spring_boot_adapter,Spring Boot>>"

msgid "<<_spring_security_adapter,Spring Security>>"
msgstr "<<_spring_security_adapter,Spring Security>>"

msgid "JavaScript (client-side)"
msgstr "JavaScript（クライアントサイド）"

msgid "<<_javascript_adapter,JavaScript>>"
msgstr "<<_javascript_adapter,JavaScript>>"

msgid "Node.js (server-side)"
msgstr "Node.js（サーバーサイド）"

msgid "<<_nodejs_adapter,Node.js>>"
msgstr "<<_nodejs_adapter,Node.js>>"

msgid "C#"
msgstr "C#"

msgid ""
"https://github.com/dylanplecki/KeycloakOwinAuthentication[OWIN] (community)"
msgstr ""
"https://github.com/dylanplecki/KeycloakOwinAuthentication[OWIN] (community)"

msgid "Python"
msgstr "Python"

msgid "https://pypi.org/project/oic/[oidc] (generic)"
msgstr "https://pypi.org/project/oic/[oidc] (generic)"

msgid "Android"
msgstr "Android"

msgid "https://github.com/openid/AppAuth-Android[AppAuth] (generic)"
msgstr "https://github.com/openid/AppAuth-Android[AppAuth] (generic)"

msgid "iOS"
msgstr "iOS"

msgid "https://github.com/openid/AppAuth-iOS[AppAuth] (generic)"
msgstr "https://github.com/openid/AppAuth-iOS[AppAuth] (generic)"

msgid "Apache HTTP Server"
msgstr "Apache HTTP Server"

msgid "https://github.com/zmartzone/mod_auth_openidc[mod_auth_openidc]"
msgstr "https://github.com/zmartzone/mod_auth_openidc[mod_auth_openidc]"

msgid "SAML"
msgstr "SAML"

msgid "<<_saml_jboss_adapter,JBoss EAP>>"
msgstr "<<_saml_jboss_adapter,JBoss EAP>>"

msgid "<<_saml_jboss_adapter,WildFly>>"
msgstr "<<_saml_jboss_adapter,WildFly>>"

msgid "<<_jetty_saml_adapter,Jetty>>"
msgstr "<<_jetty_saml_adapter,Jetty>>"

msgid "<<_mod_auth_mellon,mod_auth_mellon>>"
msgstr "<<_mod_auth_mellon,mod_auth_mellon>>"

msgid "Supported Protocols"
msgstr "サポートされているプロトコル"

msgid "{project_name} supports both OpenID Connect and SAML protocols."
msgstr "{project_name}は、OpenID ConnectとSAMLの両方のプロトコルに対応しています。"

msgid ""
"link:https://openid.net/connect/[OpenID Connect] (OIDC) is an authentication"
" protocol that is an extension of "
"link:https://datatracker.ietf.org/doc/html/rfc6749[OAuth 2.0]. While OAuth "
"2.0 is only a framework for building authorization protocols and is mainly "
"incomplete, OIDC is a full-fledged authentication and authorization "
"protocol.  OIDC also makes heavy use of the link:https://jwt.io[Json Web "
"Token] (JWT) set of standards.  These standards define an identity token "
"JSON format and ways to digitally sign and encrypt that data in a compact "
"and web-friendly way."
msgstr ""
"link:https://openid.net/connect/[OpenID Connect] （OIDC）は "
"link:https://datatracker.ietf.org/doc/html/rfc6749[OAuth 2.0] "
"を拡張した認証プロトコルです。OAuth "
"2.0が認可プロトコルのみを構築するためのフレームワークで、不完全であるのに対し、OIDCは完成された認証および認可のプロトコルです。OIDCはまた、 "
"link:https://jwt.io[Json Web Token] "
"（JWT）の標準セットを多用します。これらの標準は、コンパクトでWebフレンドリーな方法で、アイデンティティー・トークンのJSON形式とデジタル署名、データ暗号化の方法を定義します。"

msgid ""
"There are really two types of use cases when using OIDC.  The first is an "
"application that asks the {project_name} server to authenticate a user for "
"them.  After a successful login, the application will receive an _identity "
"token_ and an _access token_.  The _identity token_ contains information "
"about the user such as username, email, and other profile information.  The "
"_access token_ is digitally signed by the realm and contains access "
"information (like user role mappings) that the application can use to "
"determine what resources the user is allowed to access on the application."
msgstr ""
"OIDCを使用するユースケースは、実際には2つの種類があります。1つ目は、{project_name}サーバーにユーザーの認証を要求するアプリケーションのユースケースです。ログインが成功すると、アプリケーションは"
" _IDトークン_ と _アクセストークン_ を受け取ります。 _IDトークン_ "
"には、ユーザーに関する情報（ユーザー名、電子メール、その他のプロファイル情報など）が含まれています。 _アクセストークン_ "
"はレルムによってデジタル署名されており、アプリケーションがユーザーのアクセス可能なリソースを決定するために使用できるアクセス情報（ユーザー・ロール・マッピングのような）が含まれています。"

msgid ""
"The second type of use cases is that of a client that wants to gain access "
"to remote services.  In this case, the client asks {project_name} to obtain "
"an _access token_ it can use to invoke on other remote services on behalf of"
" the user.  {project_name} authenticates the user then asks the user for "
"consent to grant access to the client requesting it.  The client then "
"receives the _access token_.  This _access token_ is digitally signed by the"
" realm.  The client can make REST invocations on remote services using this "
"_access token_.  The REST service extracts the _access token_, verifies the "
"signature of the token, then decides based on access information within the "
"token whether or not to process the request."
msgstr ""
"2つ目のタイプは、リモートサービスへのアクセス権を取得したいクライアントのユースケースです。この場合、クライアントは、ユーザーの代理として他のリモートサービスの呼び出しに使用できる"
" _アクセストークン_ "
"の取得を{project_name}に要求します。{project_name}は、ユーザーを認証し、クライアントのアクセスを許可する同意を要求します。そして、クライアントは"
" _アクセストークン_ を受け取ります。この _アクセストークン_ はレルムによってデジタル署名されます。クライアントはこの _アクセストークン_ "
"を使用して、リモートサービスのREST呼び出しを行うことができます。REST サービスは _アクセストークン_ "
"を抽出し、トークンの署名を検証し、トークン内のアクセス情報に基づいて、リクエストを処理するかどうかを決定します。"

msgid "SAML 2.0"
msgstr "SAML 2.0"

msgid ""
"link:http://saml.xml.org/saml-specifications[SAML 2.0] is a similar "
"specification to OIDC but a lot older and more mature.  It has its roots in "
"SOAP and the plethora of WS-* specifications so it tends to be a bit more "
"verbose than OIDC.  SAML 2.0 is primarily an authentication protocol that "
"works by exchanging XML documents between the authentication server and the "
"application.  XML signatures and encryption are used to verify requests and "
"responses."
msgstr ""
"link:http://saml.xml.org/saml-specifications[SAML "
"2.0]は、OIDCに似ていますが、それよりも古く成熟した仕様です。SOAPと過多なWS-*の仕様をそのルーツを持っているため、OIDCよりも少し冗長になる傾向があります。SAML"
" "
"2.0は、主に認証サーバーとアプリケーション間のXMLドキュメントの交換によって動作する認証プロトコルです。XML署名と暗号化を使用して、リクエストとレスポンスを検証します。"

msgid ""
"In {project_name} SAML serves two types of use cases: browser applications "
"and REST invocations."
msgstr "{project_name}では、SAMLはブラウザー・アプリケーションとREST呼び出しの2種類のユースケースを提供しています 。"

msgid ""
"There are really two types of use cases when using SAML.  The first is an "
"application that asks the {project_name} server to authenticate a user for "
"them.  After a successful login, the application will receive an XML "
"document that contains something called a SAML assertion that specifies "
"various attributes about the user.  This XML document is digitally signed by"
" the realm and contains access information (like user role mappings) that "
"the application can use to determine what resources the user is allowed to "
"access on the application."
msgstr ""
"SAMLを使用するユースケースは、実際には2つの種類があります。1つ目は、{project_name}サーバーにユーザーの認証を要求するアプリケーションのユースケースです。ログインが成功すると、アプリケーションはユーザーに関する様々な属性を指定するSAMLアサーションと呼ばれるものが含まれるXMLドキュメントを受け取ります。このXMLドキュメントはレルムによってデジタル署名されており、アプリケーションがユーザーのアクセス可能なリソースを決定するために使用できるアクセス情報（ユーザー・ロール・マッピングなど）が含まれています。"

msgid ""
"The second type of use cases is that of a client that wants to gain access "
"to remote services.  In this case, the client asks {project_name} to obtain "
"a SAML assertion it can use to invoke on other remote services on behalf of "
"the user."
msgstr ""
"2つ目のタイプは、リモートサービスへのアクセス権を取得したいクライアントのユースケースです。この場合、クライアントは、ユーザーの代理として他のリモートサービスの呼び出しに使用できるSAMLアサーションの取得を{project_name}に要求します。"

msgid "OpenID Connect vs. SAML"
msgstr "OpenID Connect vs SAML"

msgid ""
"Choosing between OpenID Connect and SAML is not just a matter of using a "
"newer protocol (OIDC) instead of the older more mature protocol (SAML)."
msgstr ""
"OpenID "
"ConnectとSAMLの選択は、古いより成熟したプロトコル（SAML）の代わりに新しいプロトコル（OIDC）を使用するだけの問題ではありません。"

msgid "In most cases {project_name} recommends using OIDC."
msgstr "ほとんどの場合において、{project_name}ではOIDCを使用することをお勧めします。"

msgid "SAML tends to be a bit more verbose than OIDC."
msgstr "SAMLは、OIDCよりも少し冗長になる傾向があります。"

msgid ""
"Beyond verbosity of exchanged data, if you compare the specifications you'll"
" find that OIDC was designed to work with the web while SAML was retrofitted"
" to work on top of the web.  For example, OIDC is also more suited for "
"HTML5/JavaScript applications because it is easier to implement on the "
"client side than SAML. As tokens are in the JSON format, they are easier to "
"consume by JavaScript. You will also find several nice features that make "
"implementing security in your web applications easier. For example, check "
"out the link:https://openid.net/specs/openid-connect-"
"session-1_0.html#ChangeNotification[iframe trick] that the specification "
"uses to easily determine if a user is still logged in or not."
msgstr ""
"交換するデータの詳細度を度外視して仕様を比較した場合、OIDCはもともとWebで動作するように設計されていますが、SAMLはWeb上で動作するように改造されていることが分かります。たとえば、OIDCはSAMLよりもクライアントサイドに実装することが簡単なため、HTML5/JavaScriptアプリケーションにも適しています。トークンはJSON形式なので、JavaScriptにより簡単に扱うことができます。また、Webアプリケーションに対してセキュリティーの実装を容易にする、いくつかの素晴らしい機能があります。たとえば、ユーザーがログインしているかどうかを容易に判断するために使用する"
" link:https://openid.net/specs/openid-connect-"
"session-1_0.html#ChangeNotification[iframeトリック] の仕様をチェックしてください。"

msgid ""
"SAML has its uses though. As you see the OIDC specifications evolve you see "
"they implement more and more features that SAML has had for years. What we "
"often see is that people pick SAML over OIDC because of the perception that "
"it is more mature and also because they already have existing applications "
"that are secured with it."
msgstr ""
"SAMLにも用途はあります。OIDCの仕様の進化を見ると、SAMLが長年に渡って実装してきた多数の機能がOIDCにも実装されていることが分かります。SAMLがOIDCより成熟しているという認識と、SAMLによりセキュリティー保護されている既存のアプリケーションが存在するという理由により、OIDCよりもSAMLが選ばれることは多々あります。"

msgid "Terminology"
msgstr "用語"

msgid "These terms are used in this guide:"
msgstr "本書では、これらの用語を使用します。"

msgid ""
"`Clients` are entities that interact with {project_name} to authenticate "
"users and obtain tokens. Most often, clients are applications and services "
"acting on behalf of users that provide a single sign-on experience to their "
"users and access other services using the tokens issued by the server. "
"Clients can also be entities only interested in obtaining tokens and acting "
"on their own behalf for accessing other services."
msgstr ""
"`クライアント` "
"とは、{project_name}と対話し、ユーザーを認証してトークンを取得するエンティティーです。多くの場合、クライアントはユーザーにシングル・サインオンを提供し、サーバーが発行したトークンを使って他のサービスにアクセスする、ユーザーの代理を務めるアプリケーションやサービスです。クライアントは、トークンを取得し、他のサービスにアクセスするために自分自身の代わりに行動することだけに関心があるエンティティーであることもできます。"

msgid ""
"`Applications` include a wide range of applications that work for specific "
"platforms for each protocol"
msgstr "`アプリケーション` は、各プロトコルの特定のプラットフォームで動作する幅広いアプリケーションを含みます。"

msgid ""
"`Client adapters` are libraries that make it easy to secure applications and"
" services with {project_name}. They provide a tight integration to the "
"underlying platform and framework."
msgstr ""
"`クライアント・アダプター` "
"は、{project_name}を使ってアプリケーションやサービスを簡単にセキュリティー保護できるようにするライブラリーです。これらは、基盤となるプラットフォームやフレームワークとの緊密な統合を提供します。"

msgid ""
"`Creating a client` and `registering a client` are the same action. "
"`Creating a Client` is the term used to create a client by using the Admin "
"Console. `Registering a client` is the term used to register a client by "
"using the {project_name} Client Registration Service."
msgstr ""
"`クライアントの作成` と `クライアントの登録` は同じ動作です。 `クライアントの作成` "
"は、管理コンソールを使用してクライアントを作成する際に使用される用語です。 `クライアントの登録` "
"とは、{project_name}のクライアント登録サービスを利用してクライアントを登録することを指します。"

msgid ""
"`A service account` is a type of client that is able to obtain tokens on its"
" own behalf."
msgstr "`サービスアカウント` は、自分に代わってトークンを取得することができるクライアントの一種です。"

msgid "Basic steps to secure applications and services"
msgstr "アプリケーションとサービスのセキュリティー保護するための基本的なステップ"

msgid ""
"These are the basic steps for securing an application or a service in "
"{project_name}."
msgstr "以上が、{project_name}におけるアプリケーションやサービスのセキュリティー保護のための基本的な手順です。"

msgid "Configure a client using one of these options:"
msgstr "これらのオプションのいずれかを使用して、クライアントを設定します。"

msgid "A {project_name} adapter"
msgstr "{project_name}アダプター"

msgid "A generic OpenID connect or SAML library"
msgstr "汎用的なOpenID ConnectまたはSAMLライブラリー"

msgid "Register a client using one of these options:"
msgstr "以下のいずれかの方法でクライアントを登録します。"

msgid "The {project_name} Admin Console"
msgstr "{project_name}管理コンソール"

msgid "The client registration service"
msgstr "クライアント登録サービス"

msgid "The CLI"
msgstr "CLI"

msgid "Additional resources"
msgstr "追加のリソース"

msgid ""
"This guide provides the detailed instructions for these steps. Related "
"information exists in the link:{adminguide_link}[Server Administration "
"Guide]. That guide provides instructions for using Admin Console to create a"
" client. Creating a client is the same task as registering a client using "
"the {project_name} Client Registration Service."
msgstr ""
"このガイドでは、これらの手順の詳細について説明します。関連情報は、 link:{adminguide_link}[Server "
"Administration Guide] "
"にあります。このガイドでは、管理コンソールを使用してクライアントを作成する手順が説明されています。クライアントの作成は、{project_name}のクライアント登録サービスを使用してクライアントを登録するのと同じ作業です。"

msgid "Using OpenID Connect to secure applications and services"
msgstr "OpenID Connectを使ったアプリケーションやサービスのセキュリティー保護"

msgid ""
"This section describes how you can secure applications and services with "
"OpenID Connect using either {project_name} adapters or generic OpenID "
"Connect Relying Party libraries."
msgstr ""
"このセクションでは、{project_name}アダプターまたは汎用OpenID "
"Connectリライング・パーティーのライブラリーを使用して、アプリケーションとサービスをOpenID "
"Connectでセキュリティー保護する方法について説明します。"

msgid "Java adapters"
msgstr "Javaアダプター"

msgid ""
"{project_name} comes with a range of different adapters for Java "
"application. Selecting the correct adapter depends on the target platform."
msgstr ""
"{project_name}には、Javaアプリケーション用のさまざまなアダプターが付属しています。正しいアダプターの選択は、対象のプラットフォームによって異なります。"

msgid ""
"All Java adapters share a set of common configuration options described in "
"the <<_java_adapter_config,Java Adapters Config>> chapter."
msgstr ""
"全てのJavaアダプターは、<<_java_adapter_config,Javaアダプターの設定>>の章で説明されている共通の設定オプションのセットを共有しています。"

msgid "Java adapter configuration"
msgstr "Javaアダプターの設定"

msgid ""
"Each Java adapter supported by {project_name} can be configured by a simple "
"JSON file. This is what one might look like:"
msgstr "{project_name}でサポートされている各Javaアダプターは、単純なJSONファイルで設定できます。これは、次のようになります。"

msgid ""
"{\n"
"  \"realm\" : \"demo\",\n"
"  \"resource\" : \"customer-portal\",\n"
"  \"realm-public-key\" : \"MIGfMA0GCSqGSIb3D...31LwIDAQAB\",\n"
"  \"auth-server-url\" : \"https://localhost:8443{kc_base_path}\",\n"
"  \"ssl-required\" : \"external\",\n"
"  \"use-resource-role-mappings\" : false,\n"
"  \"enable-cors\" : true,\n"
"  \"cors-max-age\" : 1000,\n"
"  \"cors-allowed-methods\" : \"POST, PUT, DELETE, GET\",\n"
"  \"cors-exposed-headers\" : \"WWW-Authenticate, My-custom-exposed-Header\",\n"
"  \"bearer-only\" : false,\n"
"  \"enable-basic-auth\" : false,\n"
"  \"expose-token\" : true,\n"
"  \"verify-token-audience\" : true,\n"
"  \"credentials\" : {\n"
"    \"secret\" : \"234234-234234-234234\"\n"
"  },\n"
"\n"
"  \"connection-pool-size\" : 20,\n"
"  \"socket-timeout-millis\" : 5000,\n"
"  \"connection-timeout-millis\" : 6000,\n"
"  \"connection-ttl-millis\" : 500,\n"
"  \"disable-trust-manager\" : false,\n"
"  \"allow-any-hostname\" : false,\n"
"  \"truststore\" : \"path/to/truststore.jks\",\n"
"  \"truststore-password\" : \"geheim\",\n"
"  \"client-keystore\" : \"path/to/client-keystore.jks\",\n"
"  \"client-keystore-password\" : \"geheim\",\n"
"  \"client-key-password\" : \"geheim\",\n"
"  \"token-minimum-time-to-live\" : 10,\n"
"  \"min-time-between-jwks-requests\" : 10,\n"
"  \"public-key-cache-ttl\" : 86400,\n"
"  \"redirect-rewrite-rules\" : {\n"
"    \"^/wsmaster/api/(.*)$\" : \"/api/$1\"\n"
"  }\n"
"}"
msgstr ""
"{\n"
"  \"realm\" : \"demo\",\n"
"  \"resource\" : \"customer-portal\",\n"
"  \"realm-public-key\" : \"MIGfMA0GCSqGSIb3D...31LwIDAQAB\",\n"
"  \"auth-server-url\" : \"https://localhost:8443{kc_base_path}\",\n"
"  \"ssl-required\" : \"external\",\n"
"  \"use-resource-role-mappings\" : false,\n"
"  \"enable-cors\" : true,\n"
"  \"cors-max-age\" : 1000,\n"
"  \"cors-allowed-methods\" : \"POST, PUT, DELETE, GET\",\n"
"  \"cors-exposed-headers\" : \"WWW-Authenticate, My-custom-exposed-Header\",\n"
"  \"bearer-only\" : false,\n"
"  \"enable-basic-auth\" : false,\n"
"  \"expose-token\" : true,\n"
"  \"verify-token-audience\" : true,\n"
"  \"credentials\" : {\n"
"    \"secret\" : \"234234-234234-234234\"\n"
"  },\n"
"\n"
"  \"connection-pool-size\" : 20,\n"
"  \"socket-timeout-millis\" : 5000,\n"
"  \"connection-timeout-millis\" : 6000,\n"
"  \"connection-ttl-millis\" : 500,\n"
"  \"disable-trust-manager\" : false,\n"
"  \"allow-any-hostname\" : false,\n"
"  \"truststore\" : \"path/to/truststore.jks\",\n"
"  \"truststore-password\" : \"geheim\",\n"
"  \"client-keystore\" : \"path/to/client-keystore.jks\",\n"
"  \"client-keystore-password\" : \"geheim\",\n"
"  \"client-key-password\" : \"geheim\",\n"
"  \"token-minimum-time-to-live\" : 10,\n"
"  \"min-time-between-jwks-requests\" : 10,\n"
"  \"public-key-cache-ttl\" : 86400,\n"
"  \"redirect-rewrite-rules\" : {\n"
"    \"^/wsmaster/api/(.*)$\" : \"/api/$1\"\n"
"  }\n"
"}"

msgid ""
"You can use `${...}` enclosure for system property replacement. For example "
"`${jboss.server.config.dir}` would be replaced by `/path/to/{project_name}`."
" Replacement of environment variables is also supported via the `env` "
"prefix, for example `${env.MY_ENVIRONMENT_VARIABLE}`."
msgstr ""
"`${...}` エンクロージャーを使用して、システム・プロパティーの置換を行うことができます。たとえば、 "
"`${jboss.server.config.dir}` は `/path/to/{project_name}` に置換できます。環境変数の置換では、 "
"`env` プレフィックスもサポートされています。たとえば、 `${env.MY_ENVIRONMENT_VARIABLE}` です。"

msgid ""
"The initial config file can be obtained from the admin console. This can be "
"done by opening the admin console, select `Clients` from the menu and "
"clicking on the corresponding client. Once the page for the client is opened"
" click on the `Installation` tab and select `Keycloak OIDC JSON`."
msgstr ""
"初期設定ファイルは、管理コンソールから取得できます。これを行うには、管理コンソールを開き、メニューから `Clients` "
"を選択し、対応するクライアントをクリックします。クライアントのページが開かれたら、 `Installation` タブをクリックし、 `Keycloak"
" OIDC JSON` を選択します。"

msgid "Here is a description of each configuration option:"
msgstr "各設定オプションの説明は次のとおりです。"

msgid "realm"
msgstr "realm"

msgid "Name of the realm. This is _REQUIRED._"
msgstr "レルムの名前。 これは _REQUIRED_ です。"

msgid "resource"
msgstr "resource"

msgid ""
"The client-id of the application. Each application has a client-id that is "
"used to identify the application. This is _REQUIRED._"
msgstr ""
"アプリケーションのクライアントID。各アプリケーションには、アプリケーションを識別するために使用されるクライアントIDがあります。これは "
"_REQUIRED_ です。"

msgid "realm-public-key"
msgstr "realm-public-key"

msgid ""
"PEM format of the realm public key. You can obtain this from the Admin "
"Console. This is _OPTIONAL_ and it's not recommended to set it. If not set, "
"the adapter will download this from {project_name} and it will always re-"
"download it when needed (eg. {project_name} rotates its keys). However if "
"realm-public-key is set, then adapter will never download new keys from "
"{project_name}, so when {project_name} rotate it's keys, adapter will break."
msgstr ""
"レルム公開鍵のPEM形式です。これは管理コンソールから取得できます。これは _OPTIONAL_ "
"であり、設定することはお勧めしません。これが設定されていない場合、アダプターは必要に応じて（{project_name}の鍵をローテーションさせる場合など）、{project_name}から常に再ダウンロードします。しかし、realm-"
"public-"
"keyが設定されている場合、アダプターは{project_name}から新しい鍵をダウンロードすることは無いので、{project_name}の鍵をローテーションするとアダプターが正常に動作しなくなります。"

msgid "auth-server-url"
msgstr "auth-server-url"

msgid ""
"The base URL of the {project_name} server. All other {project_name} pages "
"and REST service endpoints are derived from this. It is usually of the form "
"`\\https://host:port{kc_base_path}`. This is _REQUIRED._"
msgstr ""
"{project_name}サーバーのベースURLです。すべての{project_name}ページとRESTサービスのエンドポイントは、これから派生しています。通常、"
" `\\https://host:port{kc_base_path}` の形式です。これは _REQUIRED_ です。"

msgid "ssl-required"
msgstr "ssl-required"

msgid ""
"Ensures that all communication to and from the {project_name} server is over"
" HTTPS. In production this should be set to `all`. This is _OPTIONAL_. The "
"default value is _external_ meaning that HTTPS is required by default for "
"external requests. Valid values are 'all', 'external' and 'none'."
msgstr ""
"{project_name}サーバーとの間のすべての通信がHTTPS経由であることを保証します。プロダクション環境では、これを `all` "
"に設定する必要があります。これは _OPTIONAL_ です。デフォルト値は _external_ "
"です。つまり、外部リクエストに対してデフォルトでHTTPSが必要です。有効な値は `all` 、 `external` 、 `none` です。"

msgid "confidential-port"
msgstr "confidential-port"

msgid ""
"The confidential port used by the {project_name} server for secure "
"connections over SSL/TLS. This is _OPTIONAL_. The default value is _8443_."
msgstr ""
"SSL/TLSを介した安全な接続のために、{project_name}サーバーが使用する機密ポートです。これは _OPTIONAL_ "
"です。デフォルト値は _8443_ です。"

msgid "use-resource-role-mappings"
msgstr "use-resource-role-mappings"

msgid ""
"If set to true, the adapter will look inside the token for application level"
" role mappings for the user. If false, it will look at the realm level for "
"user role mappings. This is _OPTIONAL_. The default value is _false_."
msgstr ""
"trueに設定すると、アダプターはトークン内を調べて、ユーザーのアプリケーション・レベルのロール・マッピングを探します。falseの場合、レルム・レベルのユーザー・ロール・マッピングを探します。これは"
" _OPTIONAL_ です。デフォルト値は _false_ です。 "

msgid "public-client"
msgstr "public-client"

msgid ""
"If set to true, the adapter will not send credentials for the client to "
"{project_name}. This is _OPTIONAL_. The default value is _false_."
msgstr ""
"trueに設定すると、アダプターはクライアントのクレデンシャルを{project_name}に送信しません。これは _OPTIONAL_ "
"です。デフォルト値は _false_ です。"

msgid "enable-cors"
msgstr "enable-cors"

msgid ""
"This enables CORS support. It will handle CORS preflight requests. It will "
"also look into the access token to determine valid origins. This is "
"_OPTIONAL_. The default value is _false_."
msgstr ""
"これにより、CORSサポートが有効になります。CORSプリフライト・リクエストを処理します。また、アクセス・トークンを調べて、有効なオリジンを特定します。これは"
" _OPTIONAL_ です。デフォルト値は _false_ です。"

msgid "cors-max-age"
msgstr "cors-max-age"

msgid ""
"If CORS is enabled, this sets the value of the `Access-Control-Max-Age` "
"header. This is _OPTIONAL_. If not set, this header is not returned in CORS "
"responses."
msgstr ""
"CORSが有効な場合、これは `Access-Control-Max-Age` ヘッダーの値を設定します。これは _OPTIONAL_ "
"です。設定されていない場合、このヘッダーはCORSレスポンスで返されません。"

msgid "cors-allowed-methods"
msgstr "cors-allowed-methods"

msgid ""
"If CORS is enabled, this sets the value of the `Access-Control-Allow-"
"Methods` header. This should be a comma-separated string. This is "
"_OPTIONAL_. If not set, this header is not returned in CORS responses."
msgstr ""
"CORSが有効な場合、これは `Access-Control-Allow-Methods` ヘッダーの値を設定します。 "
"これはカンマ区切りの文字列でなければなりません。これは _OPTIONAL_ "
"です。設定されていない場合、このヘッダーはCORSレスポンスで返されません。"

msgid "cors-allowed-headers"
msgstr "cors-allowed-headers"

msgid ""
"If CORS is enabled, this sets the value of the `Access-Control-Allow-"
"Headers` header. This should be a comma-separated string. This is "
"_OPTIONAL_. If not set, this header is not returned in CORS responses."
msgstr ""
"CORSが有効な場合、これは `Access-Control-Allow-Headers` ヘッダーの値を設定します。 "
"これはカンマ区切りの文字列でなければなりません。これは _OPTIONAL_ "
"です。設定されていない場合、このヘッダーはCORSレスポンスで返されません。"

msgid "cors-exposed-headers"
msgstr "cors-exposed-headers"

msgid ""
"If CORS is enabled, this sets the value of the `Access-Control-Expose-"
"Headers` header. This should be a comma-separated string. This is "
"_OPTIONAL_. If not set, this header is not returned in CORS responses."
msgstr ""
"CORSが有効な場合、これは `Access-Control-Expose-Headers` ヘッダーの値を設定します。 "
"これはカンマ区切りの文字列でなければなりません。これは _OPTIONAL_ "
"です。設定されていない場合、このヘッダーはCORSレスポンスで返されません。"

msgid "bearer-only"
msgstr "bearer-only"

msgid ""
"This should be set to _true_ for services. If enabled the adapter will not "
"attempt to authenticate users, but only verify bearer tokens. This is "
"_OPTIONAL_. The default value is _false_."
msgstr ""
"これは、サービスに対して _true_ "
"に設定する必要があります。有効にすると、アダプターはユーザーを認証しようとせず、ベアラー・トークンのみを検証します。これは _OPTIONAL_ "
"です。デフォルト値は _false_ です。"

msgid "autodetect-bearer-only"
msgstr "autodetect-bearer-only"

msgid ""
"This should be set to __true__ if your application serves both a web "
"application and web services (for example SOAP or REST). It allows you to "
"redirect unauthenticated users of the web application to the {project_name} "
"login page, but send an HTTP `401` status code to unauthenticated SOAP or "
"REST clients instead as they would not understand a redirect to the login "
"page. {project_name} auto-detects SOAP or REST clients based on typical "
"headers like `X-Requested-With`, `SOAPAction` or `Accept`. The default value"
" is _false_."
msgstr ""
"アプリケーションがWebアプリケーションとWebサービス（SOAPやRESTなど）の両方を提供する場合は、これを __true__ "
"に設定する必要があります。 "
"Webアプリケーションの未認証のユーザーを{project_name}のログインページにリダイレクトできますが、ログインページへのリダイレクトを理解できない未認証のSOAPクライアントまたはRESTクライアントにはHTTPの"
" `401` ステータスコードを送信します。{project_name}は、 `X-Requested-With` 、 `SOAPAction` 、 "
"`Accept` のような典型的なヘッダーに基づいて、SOAPクライアントまたはRESTクライアントを自動検出します。デフォルト値は _false_ "
"です。"

msgid "enable-basic-auth"
msgstr "enable-basic-auth"

msgid ""
"This tells the adapter to also support basic authentication. If this option "
"is enabled, then _secret_ must also be provided. This is _OPTIONAL_. The "
"default value is _false_."
msgstr ""
"これは、BASIC認証もサポートするようにアダプターに指示します。このオプションを有効にすると、 _secret_ も指定する必要があります。これは "
"_OPTIONAL_ です。 デフォルト値は _false_ です。"

msgid "expose-token"
msgstr "expose-token"

msgid ""
"If `true`, an authenticated browser client (via a JavaScript HTTP "
"invocation) can obtain the signed access token via the URL "
"`root/k_query_bearer_token`. This is _OPTIONAL_. The default value is "
"_false_."
msgstr ""
"`true` の場合、（JavaScriptのHTTP呼び出しを介して）認証されたブラウザー・クライアントが、 "
"`root/k_query_bearer_token` のURLを介して署名付きのアクセストークンを取得できます。これは _OPTIONAL_ "
"です。デフォルト値は _false_ です。"

msgid "credentials"
msgstr "クレデンシャル"

msgid ""
"Specify the credentials of the application. This is an object notation where"
" the key is the credential type and the value is the value of the credential"
" type. Currently password and jwt is supported. This is _REQUIRED_ only for "
"clients with 'Confidential' access type."
msgstr ""
"アプリケーションのクレデンシャルを指定します。これは、キーがクレデンシャル・タイプで、値がクレデンシャル・タイプの値であるオブジェクト表記法です。 "
"現在、パスワードとJWTがサポートされています。これは、 `Confidential` のアクセス・タイプのクライアントの場合にのみ "
"_REQUIRED_ です。"

msgid "connection-pool-size"
msgstr "connection-pool-size"

msgid ""
"This config option defines how many connections to the {project_name} server"
" should be pooled. This is _OPTIONAL_. The default value is `20`."
msgstr ""
"この設定オプションは、{project_name}サーバーにプールすべき接続数を定義します。これは _OPTIONAL_ です。デフォルトは `20` "
"です。"

msgid "socket-timeout-millis"
msgstr "socket-timeout-millis"

msgid ""
"Timeout for socket waiting for data after establishing the connection in "
"milliseconds. Maximum time of inactivity between two data packets. A timeout"
" value of zero is interpreted as an infinite timeout. A negative value is "
"interpreted as undefined (system default if applicable). The default value "
"is `-1`. This is _OPTIONAL_."
msgstr ""
"コネクション確立後のソケットのデータ待ちタイムアウトをミリ秒単位で指定します。2つのデータパケット間の最大非アクティブ時間です。タイムアウト値が0の場合、無限大のタイムアウトとして解釈されます。負の値は、未定義と解釈されます（該当する場合はシステムのデフォルト）。デフォルト値は"
" `-1` です。これは _OPTIONAL_ です。"

msgid "connection-timeout-millis"
msgstr "connection-timeout-millis"

msgid ""
"Timeout for establishing the connection with the remote host in "
"milliseconds. A timeout value of zero is interpreted as an infinite timeout."
" A negative value is interpreted as undefined (system default if "
"applicable). The default value is `-1`. This is _OPTIONAL_."
msgstr ""
"リモートホストとのコネクションを確立する際のタイムアウトをミリ秒単位で指定します。タイムアウト値0は無限大のタイムアウトとして解釈されます。負の値は未定義と解釈されます（該当する場合はシステムのデフォルト）。デフォルト値は"
" `-1` です。これは _OPTIONAL_ です。"

msgid "connection-ttl-millis"
msgstr "connection-ttl-millis"

msgid ""
"Connection time-to-live for client in milliseconds. A value less than or "
"equal to zero is interpreted as an infinite value. The default value is "
"`-1`. This is _OPTIONAL_."
msgstr ""
"クライアントのコネクション存続時間をミリ秒単位で指定します。0以下の値は無限大の値として解釈されます。デフォルト値は `-1` です。これは "
"_OPTIONAL_ です。"

msgid "disable-trust-manager"
msgstr "disable-trust-manager"

msgid ""
"If the {project_name} server requires HTTPS and this config option is set to"
" `true` you do not have to specify a truststore. This setting should only be"
" used during development and *never* in production as it will disable "
"verification of SSL certificates. This is _OPTIONAL_. The default value is "
"`false`."
msgstr ""
"{project_name}サーバーがHTTPSを必要とし、この設定オプションを `true` "
"に設定する場合は、トラストストアを指定する必要はありません。この設定は、SSL証明書の検証を無効とするため、開発時にのみ使用すべきで、プロダクション環境では"
" *決して使用してはいけません* 。これは _OPTIONAL_ です。デフォルトは `false` です。"

msgid "allow-any-hostname"
msgstr "allow-any-hostname"

msgid ""
"If the {project_name} server requires HTTPS and this config option is set to"
" `true` the {project_name} server's certificate is validated via the "
"truststore, but host name validation is not done. This setting should only "
"be used during development and *never* in production as it will disable "
"verification of SSL certificates. This seting may be useful in test "
"environments This is _OPTIONAL_. The default value is `false`."
msgstr ""
"{project_name}サーバーがHTTPSを必要とし、この設定オプションを `true` "
"に設定する場合、トラストストア経由で{project_name}サーバーの証明書は検証されますが、ホスト名の検証は行われません。SSL証明書の検証が無効となるため、この設定は開発時にのみ使用すべきで、プロダクション環境では"
" *決して使用してはいけません* 。これは _OPTIONAL_ です。デフォルトは `false` です。"

msgid "proxy-url"
msgstr "proxy-url"

msgid "The URL for the HTTP proxy if one is used."
msgstr "HTTPプロキシーを使用する場合はそのURLを設定します。"

msgid "truststore"
msgstr "truststore"

msgid ""
"The value is the file path to a truststore file. If you prefix the path with"
" `classpath:`, then the truststore will be obtained from the deployment's "
"classpath instead. Used for outgoing HTTPS communications to the "
"{project_name} server. Client making HTTPS requests need a way to verify the"
" host of the server they are talking to. This is what the trustore does. The"
" keystore contains one or more trusted host certificates or certificate "
"authorities. You can create this truststore by extracting the public "
"certificate of the {project_name} server's SSL keystore. This is _REQUIRED_ "
"unless `ssl-required` is `none` or `disable-trust-manager` is `true`."
msgstr ""
"トラストストア・ファイルへのファイルパスです。パスに `classpath:` "
"を付けると、トラストストアはデプロイメントのクラスパスから取得されます。これは{project_name}サーバーへのHTTPS通信に使用されます。HTTPSリクエストを行うクライアントは、通信を行うサーバーのホストを検証する必要があります。これがトラストストアの役割です。キーストアには、1つ以上の信頼されたホストの証明書または認証局が含まれています。このトラストストアは、{project_name}サーバーのSSLキーストアのパブリック証明書を抽出することで作成できます。これは、"
" `ssl-required` が `none` か `disable-trust-manager` が `true` でない限り、 "
"_REQUIRED_ です。"

msgid "truststore-password"
msgstr "truststore-password"

msgid ""
"Password for the truststore. This is _REQUIRED_ if `truststore` is set and "
"the truststore requires a password."
msgstr ""
"トラストストアのパスワードです。これは _REQUIRED_ で、 `truststore` を設定すると、トラストストアはパスワードを必要とします。"

msgid "client-keystore"
msgstr "client-keystore"

msgid ""
"This is the file path to a keystore file. This keystore contains client "
"certificate for two-way SSL when the adapter makes HTTPS requests to the "
"{project_name} server. This is _OPTIONAL_."
msgstr ""
"キーストア・ファイルへのファイルパスです。このキーストアには、アダプターが{project_name}サーバーにHTTPSリクエストを行う際の、双方向SSLのためのクライアント証明書を含めます。これは"
" _OPTIONAL_ です。"

msgid "client-keystore-password"
msgstr "client-keystore-password"

msgid ""
"Password for the client keystore. This is _REQUIRED_ if `client-keystore` is"
" set."
msgstr ""
"クライアント・キーストア用のパスワードです。 `client-keystore` が設定されている場合、これは _REQUIRED_ です。"

msgid "client-key-password"
msgstr "client-key-password"

msgid ""
"Password for the client's key. This is _REQUIRED_ if `client-keystore` is "
"set."
msgstr "クライアントキー用のパスワードです。 `client-keystore` が設定されている場合、これは _REQUIRED_ です。"

msgid "always-refresh-token"
msgstr "always-refresh-token"

msgid ""
"If _true_, the adapter will refresh token in every request. Warning - when "
"enabled this will result in a request to {project_name} for every request to"
" your application."
msgstr ""
"_true_ の場合、アダプターはすべてのリクエストでトークンをリフレッシュします。警告 - "
"有効にすると、アプリケーションへのすべてのリクエストに対して{project_name}へのリクエストが発生します。"

msgid "register-node-at-startup"
msgstr "register-node-at-startup"

msgid ""
"If _true_, then adapter will send registration request to {project_name}. "
"It's _false_ by default and useful only when application is clustered. See "
"<<_applicationclustering,Application Clustering>> for details"
msgstr ""
"_true_ の場合、アダプターは{project_name}に登録リクエストを送信します。これはデフォルトで _false_ "
"であり、アプリケーションがクラスター化されている場合にのみ有効です。詳細は<<_applicationclustering,アプリケーション・クラスタリング>>を参照してください。"

msgid "register-node-period"
msgstr "register-node-period"

msgid ""
"Period for re-registration adapter to {project_name}. Useful when "
"application is clustered. See <<_applicationclustering,Application "
"Clustering>> for details"
msgstr ""
"{project_name}へアダプターを再登録する期間です。アプリケーションがクラスター化されている場合に便利です。詳細は<<_applicationclustering,アプリケーション・クラスタリング>>を参照してください。"

msgid "token-store"
msgstr "token-store"

msgid ""
"Possible values are _session_ and _cookie_. Default is _session_, which "
"means that adapter stores account info in HTTP Session. Alternative _cookie_"
" means storage of info in cookie. See <<_applicationclustering,Application "
"Clustering>> for details"
msgstr ""
"設定可能な値は _session_ と _cookie_ です。デフォルトは _session_ "
"です。つまり、アダプターがアカウント情報をHTTPセッションに保管します。一方、 _cookie_ "
"は情報をクッキーに格納することを意味します。詳細は<<_applicationclustering,アプリケーション・クラスタリング>>を参照してください。"

msgid "token-cookie-path"
msgstr "token-cookie-path"

msgid ""
"When using a cookie store, this option sets the path of the cookie used to "
"store account info. If it's a relative path, then it is assumed that the "
"application is running in a context root, and is interpreted relative to "
"that context root. If it's an absolute path, then the absolute path is used "
"to set the cookie path. Defaults to use paths relative to the context root."
msgstr ""
"Cookieストアを使用する場合、このオプションにはアカウント情報を保存するために使用されるCookieのパスを設定します。相対パスの場合、アプリケーションはコンテキスト・ルートで実行されていると見なされ、そのコンテキスト・ルートに対して相対的に解釈されます。絶対パスの場合は、絶対パスを使用してCookieのパスを設定します。デフォルトではコンテキスト・ルートからの相対パスを使用します。"

msgid "principal-attribute"
msgstr "principal-attribute"

msgid ""
"OpenID Connect ID Token attribute to populate the UserPrincipal name with. "
"If token attribute is null, defaults to `sub`. Possible values are `sub`, "
"`preferred_username`, `email`, `name`, `nickname`, `given_name`, "
"`family_name`."
msgstr ""
"ユーザー・プリンシパル名とするOpenID ConnectのIDトークン属性を設定します。トークン属性がnullの場合、デフォルトは `sub` "
"になります。有効な値は `sub` 、 `preferred_username` 、 `email` 、 `name` 、 `nickname` 、 "
"`given_name` 、 `family_name` です。"

msgid "turn-off-change-session-id-on-login"
msgstr "turn-off-change-session-id-on-login"

msgid ""
"The session id is changed by default on a successful login on some platforms"
" to plug a security attack vector.  Change this to true if you want to turn "
"this off This is _OPTIONAL_. The default value is _false_."
msgstr ""
"一部のプラットフォームでは、セキュリティー攻撃口とならないように、正常にログインするとデフォルトでセッションIDが変更されます。これを無効にするには "
"_true_ に変更します。これは _OPTIONAL_ です。デフォルト値は _false_ です。"

msgid "token-minimum-time-to-live"
msgstr "token-minimum-time-to-live"

msgid ""
"Amount of time, in seconds, to preemptively refresh an active access token "
"with the {project_name} server before it expires. This is especially useful "
"when the access token is sent to another REST client where it could expire "
"before being evaluated. This value should never exceed the realm's access "
"token lifespan. This is _OPTIONAL_.  The default value is `0` seconds, so "
"adapter will refresh access token just if it's expired."
msgstr ""
"アクセストークンの有効期限が切れる前に、{project_name}サーバーでアクティブなアクセストークンを先にリフレッシュする時間です（秒単位）。これは、アクセストークンが評価される前に期限切れになる可能性がある別のRESTクライアントに送信されるときに特に便利です。この値は、レルムのアクセストークンの寿命を超えてはなりません。これは"
" _OPTIONAL_ です。デフォルト値は `0` 秒なので、アダプターは期限切れになったときだけ、アクセストークンを更新します。"

msgid "min-time-between-jwks-requests"
msgstr "min-time-between-jwks-requests"

msgid ""
"Amount of time, in seconds, specifying minimum interval between two requests"
" to {project_name} to retrieve new public keys. It is 10 seconds by default."
" Adapter will always try to download new public key when it recognize token "
"with unknown `kid` . However it won't try it more than once per 10 seconds "
"(by default). This is to avoid DoS when attacker sends lots of tokens with "
"bad `kid` forcing adapter to send lots of requests to {project_name}."
msgstr ""
"新しい公開鍵を取得するための、{project_name}への2つのリクエスト間の最小間隔を指定する時間です（秒単位）。デフォルトでは10秒です。アダプターは、未知の"
" `kid` "
"を含むトークンを認識すると、常に新しい公開鍵をダウンロードしようとします。ただし、（デフォルトでは）10秒に1回以上試行しません。これは、攻撃者が不正な"
" `kid` "
"で大量のトークンを送りつけて、アダプターから{project_name}に大量のリクエストを送信させるというDoSを防ぐために使用されます。"

msgid "public-key-cache-ttl"
msgstr "public-key-cache-ttl"

msgid ""
"Amount of time, in seconds, specifying maximum interval between two requests"
" to {project_name} to retrieve new public keys. It is 86400 seconds (1 day) "
"by default. Adapter will always try to download new public key when it "
"recognize token with unknown `kid` . If it recognize token with known `kid`,"
" it will just use the public key downloaded previously. However at least "
"once per this configured interval (1 day by default) will be new public key "
"always downloaded even if the `kid` of token is already known."
msgstr ""
"新しい公開鍵を取得するための、{project_name}への2つのリクエスト間の最大間隔を指定する時間です（秒単位）。デフォルトでは86400秒（1日）です。アダプターは、未知の"
" `kid` を含むトークンを認識すると、常に新しい公開鍵をダウンロードしようとします。既知の `kid` "
"のトークンを認識すれば、以前にダウンロードした公開鍵だけを使用します。しかし、この設定された間隔（デフォルトでは1日）に少なくとも1回は、トークンの "
"`kid` が既知でも常に新しい公開鍵がダウンロードされます。"

msgid "ignore-oauth-query-parameter"
msgstr "ignore-oauth-query-parameter"

msgid ""
"Defaults to `false`, if set to `true` will turn off processing of the "
"`access_token` query parameter for bearer token processing.  Users will not "
"be able to authenticate if they only pass in an `access_token`"
msgstr ""
"デフォルトは `false` です。 `true` に設定されていると、ベアラー・トークン処理のための `access_token` "
"クエリー・パラメーターの処理が無効になります。ユーザーは、 `access_token` を渡すだけで認証することはできません。"

msgid "redirect-rewrite-rules"
msgstr "redirect-rewrite-rules"

msgid ""
"If needed, specify the Redirect URI rewrite rule. This is an object notation"
" where the key is the regular expression to which the Redirect URI is to be "
"matched and the value is the replacement String. `$` character can be used "
"for backreferences in the replacement String."
msgstr ""
"必要に応じて、リダイレクトURIリライトのルールを指定します。キーがリダイレクトURIに一致する正規表現であり、値が置換文字列であるオブジェクト表記法で表します。置換文字列の後方参照に"
" `$` 文字を使用できます。"

msgid "verify-token-audience"
msgstr "verify-token-audience"

msgid ""
"If set to `true`, then during authentication with the bearer token, the "
"adapter will verify whether the token contains this client name (resource) "
"as an audience. The option is especially useful for services, which "
"primarily serve requests authenticated by the bearer token. This is set to "
"`false` by default, however for improved security, it is recommended to "
"enable this. See link:{adminguide_link}#audience-support[Audience Support] "
"for more details about audience support."
msgstr ""
"`true` "
"に設定されている場合、ベアラートークンによる認証中に、アダプターはトークンにこのクライアント名（リソース）がAudienceとして含まれているかどうかを検証します。このオプションは、ベアラートークンによって認証されたリクエストを主に処理するサービスに特に便利です。これはデフォルトで"
" `false` に設定されていますが、セキュリティーを強化するため、これを有効にすることをお勧めします。オーディエンス・サポートの詳細については、 "
"link:{adminguide_link}#audience-support[Audienceのサポート] を参照してください。"

msgid "JBoss EAP/WildFly adapter"
msgstr "JBoss EAP/WildFlyアダプター "

msgid "You can install this adapter from a ZIP file or from an RPM."
msgstr "このアダプターは、ZIPファイルまたはRPMからインストールすることができます。"

msgid ""
"xref:jboss_adapter_installation[Installing JBOSS EAP adapters from a ZIP "
"file]"
msgstr "xref:jboss_adapter_installation[ZIPファイルからのJBOSS EAPアダプターのインストール]"

msgid "xref:jboss7_adapter_rpm[Installing JBoss EAP 7 Adapters from an RPM]"
msgstr "xref:jboss7_adapter_rpm[RPMからのJBOSS EAP 7アダプターのインストール]"

msgid "xref:jboss6_adapter_rpm[Installing JBoss EAP 6 Adapters from an RPM]"
msgstr "xref:jboss6_adapter_rpm[RPMからのJBOSS EAP 6アダプターのインストール]"

msgid "Installing JBOSS EAP adapters from a ZIP file"
msgstr "ZIPファイルからのJBOSS EAPアダプターのインストール"

msgid ""
"To be able to secure WAR apps deployed on JBoss EAP, WildFly or JBoss AS, "
"you must install and configure the {project_name} adapter subsystem. You "
"then have two options to secure your WARs."
msgstr ""
"JBoss EAP、WildFly、またはJBoss "
"ASにデプロイされたWARアプリケーションをセキュリティー保護するには、{project_name}アダプター・サブシステムをインストールして設定する必要があります。さらに、WARをセキュリティー保護する2つのオプションがあります。"

msgid ""
"You can provide an adapter config file in your WAR and change the auth-"
"method to KEYCLOAK within web.xml."
msgstr "WARにアダプター設定ファイルを用意し、web.xml内のauth-methodをKEYCLOAKに変更することができます。"

msgid ""
"Alternatively, you do not have to modify your WAR at all and you can secure "
"it via the {project_name} adapter subsystem configuration in the "
"configuration file, such as `standalone.xml`."
msgstr ""
"あるいは、WARをまったく変更せずに、 `standalone.xml` "
"などの設定ファイルの{project_name}アダプター・サブシステム設定でセキュリティー保護することもできます。このセクションで、両方の方法について説明します。"

msgid "Both methods are described in this section."
msgstr "どちらの方法も、このセクションで説明します。"

msgid ""
"Adapters are available as a separate archive depending on what server "
"version you are using."
msgstr "アダプターは、使用しているサーバーのバージョンに応じて別個のアーカイブとして利用できます。"

msgid ""
"We test and maintain adapters only with the most recent version of WildFly "
"available upon the release. Once a new version of WildFly is released, the "
"current adapters become deprecated and support for them will be removed "
"after next WildFly release. The other alternative is to switch your "
"applications from WildFly to the JBoss EAP, as the JBoss EAP adapter is "
"supported for much longer period."
msgstr ""
"今回のリリースでは、WildFlyの最新バージョンでのみアダプターのテストとメンテナンスを行っています。WildFlyの新しいバージョンがリリースされると、現在のアダプターは非推奨になり、WildFlyの次のリリース後にサポートが削除されます。もう一つの選択肢は、JBoss"
" EAPアダプターの場合はより長期間サポートされるので、アプリケーションをWildFlyからJBoss EAPに切り替えることです。"

msgid "Procedure"
msgstr "手順"

msgid ""
"Install the adapter that applies to your application server from the "
"link:https://www.keycloak.org/downloads[Downloads] site."
msgstr ""
"link:https://www.keycloak.org/downloads[Downloads] "
"サイトより、お使いのアプリケーションサーバーに適用するアダプターをインストールします。"

msgid "Install on WildFly 9 or newer:"
msgstr "WildFly 9以上へのインストールは次のとおりです。"

msgid ""
"$ cd $WILDFLY_HOME\n"
"$ unzip keycloak-wildfly-adapter-dist-{project_version}.zip"
msgstr ""
"$ cd $WILDFLY_HOME\n"
"$ unzip keycloak-wildfly-adapter-dist-{project_version}.zip"

msgid "Install on JBoss EAP 7:"
msgstr "JBoss EAP 7へのインストールは次のとおりです。"

msgid ""
"$ cd $EAP_HOME\n"
"$ unzip keycloak-eap7-adapter-dist-{project_version}.zip"
msgstr ""
"$ cd $EAP_HOME\n"
"$ unzip keycloak-eap7-adapter-dist-{project_version}.zip"

msgid "Install on JBoss EAP 6:"
msgstr "JBoss EAP 6へのインストールは次のとおりです。"

msgid ""
"$ cd $EAP_HOME\n"
"$ unzip keycloak-eap6-adapter-dist-{project_version}.zip"
msgstr ""
"$ cd $EAP_HOME\n"
"$ unzip keycloak-eap6-adapter-dist-{project_version}.zip"

msgid "Install on JBoss AS 7.1:"
msgstr "JBoss AS 7.1へのインストールは次のとおりです。"

msgid ""
"$ cd $JBOSS_HOME\n"
"$ unzip keycloak-as7-adapter-dist-{project_version}.zip"
msgstr ""
"$ cd $JBOSS_HOME\n"
"$ unzip keycloak-as7-adapter-dist-{project_version}.zip"

msgid ""
"This ZIP archive contains JBoss Modules specific to the {project_name} "
"adapter. It also contains JBoss CLI scripts to configure the adapter "
"subsystem."
msgstr ""
"このZIPアーカイブには、{project_name}アダプター固有のJBossモジュールが含まれています。また、アダプター・サブシステムを設定するためのJBoss"
" CLIスクリプトも含まれています。"

msgid "To configure the adapter subsystem, execute the appropriate command."
msgstr "アダプター・サブシステムを設定するには、適切なコマンドを実行します。"

msgid "Install on WildFly 11 or newer if the server *is not* running"
msgstr "サーバーが動作して *いない* 場合は、WildFly 11以降にインストールしてください。"

msgid "$ ./bin/jboss-cli.sh --file=bin/adapter-elytron-install-offline.cli"
msgstr "$ ./bin/jboss-cli.sh --file=bin/adapter-elytron-install-offline.cli"

msgid "Install on WildFly 11 or newer if the server *is* running"
msgstr "サーバーが動作して *いる* 場合は、WildFly 11以降にインストールしてください。"

msgid "$ ./bin/jboss-cli.sh -c --file=bin/adapter-elytron-install.cli"
msgstr "$ ./bin/jboss-cli.sh -c --file=bin/adapter-elytron-install.cli"

msgid ""
"It is possible to use the legacy non-Elytron adapter on WildFly 11 or newer "
"as well, meaning you can use `adapter-install-offline.cli` even on those "
"versions. However, we recommend to use the newer Elytron adapter."
msgstr ""
"WildFly 11以上でもレガシーな非Elytronアダプターが使用できます。つまり、それらのバージョンでも `adapter-install-"
"offline.cli` を使用することができます。ただし、新しいElytronアダプターを使用することをお勧めします。"

msgid "Install on WildFly 10 or older if the server *is not* running"
msgstr "サーバーが動作して *いない* 場合は、WildFly 10以前にインストールしてください。"

msgid "$ ./bin/jboss-cli.sh --file=bin/adapter-install-offline.cli"
msgstr "$ ./bin/jboss-cli.sh --file=bin/adapter-install-offline.cli"

msgid "Install on WildFly 10 or older if the server *is* running"
msgstr "サーバーが動作して *いる* 場合は、WildFly 10以前にインストールしてください。"

msgid "$ ./bin/jboss-cli.sh -c --file=bin/adapter-install.cli"
msgstr "$ ./bin/jboss-cli.sh -c --file=bin/adapter-install.cli"

msgid ""
"Alternatively, you can specify the `server.config` property while installing"
" adapters from the command line to install adapters using a different "
"config, for example: `-Dserver.config=standalone-ha.xml`."
msgstr ""
"あるいは、別の設定を使用してアダプターをインストールするため、コマンドラインからアダプターをインストールする際に `server.config` "
"プロパティーを指定することもできます。たとえば、 `-Dserver.config=standalone-ha.xml` とします。"

msgid "JBoss SSO"
msgstr "JBoss SSO"

msgid ""
"{appserver_name} has built-in support for single sign-on for web "
"applications deployed to the same {appserver_name} instance. This should not"
" be enabled when using {project_name}."
msgstr ""
"{appserver_name}には、同じ{appserver_name}インスタンスにデプロイされたWebアプリケーションのシングル・サインオンのサポートが組み込まれています。これは、{project_name}を使用しているときは有効にしないでください。"

msgid "Securing a WAR"
msgstr "WARのセキュリティー保護"

msgid ""
"This section describes how to secure a WAR directly by adding configuration "
"and editing files within your WAR package."
msgstr "このセクションでは、直接WARパッケージ内に設定を追加し、ファイルを編集することで、WARをセキュリティー保護する方法について説明します。"

msgid ""
"Create a `keycloak.json` adapter configuration file within the `WEB-INF` "
"directory of your WAR."
msgstr "WAR の `WEB-INF` ディレクトリーに `keycloak.json` アダプター設定ファイルを作成します。"

msgid ""
"The format of this configuration file is described in the "
"<<_java_adapter_config,Java adapter configuration>> section."
msgstr "この設定ファイルの形式は、<<_java_adapter_config,Javaアダプターの設定>>のセクションで説明しています。"

msgid "Set the `auth-method` to `KEYCLOAK` in `web.xml`."
msgstr "`web.xml` の `auth-method` に `KEYCLOAK` を設定します。"

msgid ""
"Use standard servlet security to specify role-base constraints on your URLs."
msgstr "標準的なサーブレット・セキュリティーを使用して、URLにロールベースの制約を指定します。"

msgid "Here's an example:"
msgstr "以下は例です。"

msgid ""
"\n"
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"      version=\"3.0\">\n"
"\n"
"    <module-name>application</module-name>\n"
"\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Admins</web-resource-name>\n"
"            <url-pattern>/admin/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>admin</role-name>\n"
"        </auth-constraint>\n"
"        <user-data-constraint>\n"
"            <transport-guarantee>CONFIDENTIAL</transport-guarantee>\n"
"        </user-data-constraint>\n"
"    </security-constraint>\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Customers</web-resource-name>\n"
"            <url-pattern>/customers/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>user</role-name>\n"
"        </auth-constraint>\n"
"        <user-data-constraint>\n"
"            <transport-guarantee>CONFIDENTIAL</transport-guarantee>\n"
"        </user-data-constraint>\n"
"    </security-constraint>\n"
"\n"
"    <login-config>\n"
"        <auth-method>KEYCLOAK</auth-method>\n"
"        <realm-name>this is ignored currently</realm-name>\n"
"    </login-config>\n"
"\n"
"    <security-role>\n"
"        <role-name>admin</role-name>\n"
"    </security-role>\n"
"    <security-role>\n"
"        <role-name>user</role-name>\n"
"    </security-role>\n"
"</web-app>"
msgstr ""
"\n"
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"      version=\"3.0\">\n"
"\n"
"    <module-name>application</module-name>\n"
"\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Admins</web-resource-name>\n"
"            <url-pattern>/admin/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>admin</role-name>\n"
"        </auth-constraint>\n"
"        <user-data-constraint>\n"
"            <transport-guarantee>CONFIDENTIAL</transport-guarantee>\n"
"        </user-data-constraint>\n"
"    </security-constraint>\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Customers</web-resource-name>\n"
"            <url-pattern>/customers/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>user</role-name>\n"
"        </auth-constraint>\n"
"        <user-data-constraint>\n"
"            <transport-guarantee>CONFIDENTIAL</transport-guarantee>\n"
"        </user-data-constraint>\n"
"    </security-constraint>\n"
"\n"
"    <login-config>\n"
"        <auth-method>KEYCLOAK</auth-method>\n"
"        <realm-name>this is ignored currently</realm-name>\n"
"    </login-config>\n"
"\n"
"    <security-role>\n"
"        <role-name>admin</role-name>\n"
"    </security-role>\n"
"    <security-role>\n"
"        <role-name>user</role-name>\n"
"    </security-role>\n"
"</web-app>"

msgid "Securing WARs via adapter subsystem"
msgstr "アダプター・サブシステムによるWARの保護"

msgid ""
"You do not have to modify your WAR to secure it with {project_name}. Instead"
" you can externally secure it via the {project_name} Adapter Subsystem. "
"While you don't have to specify KEYCLOAK as an `auth-method`, you still have"
" to define the `security-constraints` in `web.xml`. You do not, however, "
"have to create a `WEB-INF/keycloak.json` file. The metadata is instead "
"defined within server configuration (`standalone.xml`) in the {project_name}"
" subsystem definition."
msgstr ""
"{project_name}でWARを修正する必要はありません。代わりに、{project_name}アダプター・サブシステムを介して外部からセキュリティー保護することができます。"
" `auth-method` に `KEYCLOAK` を指定する必要はありませんが、 `web.xml` に `security-"
"constraints` を定義する必要はあります。しかし、 `WEB-INF/keycloak.json` "
"ファイルを作成する必要はありません。メタデータは代わりに、{project_name}サブシステム定義のサーバー設定（つまり、 "
"`standalone.xml` ）内で定義されます。"

msgid ""
"<extensions>\n"
"  <extension module=\"org.keycloak.keycloak-adapter-subsystem\"/>\n"
"</extensions>\n"
"\n"
"<profile>\n"
"  <subsystem xmlns=\"urn:jboss:domain:keycloak:1.1\">\n"
"     <secure-deployment name=\"WAR MODULE NAME.war\">\n"
"        <realm>demo</realm>\n"
"        <auth-server-url>http://localhost:8081{kc_base_path}</auth-server-url>\n"
"        <ssl-required>external</ssl-required>\n"
"        <resource>customer-portal</resource>\n"
"        <credential name=\"secret\">password</credential>\n"
"     </secure-deployment>\n"
"  </subsystem>\n"
"</profile>"
msgstr ""
"<extensions>\n"
"  <extension module=\"org.keycloak.keycloak-adapter-subsystem\"/>\n"
"</extensions>\n"
"\n"
"<profile>\n"
"  <subsystem xmlns=\"urn:jboss:domain:keycloak:1.1\">\n"
"     <secure-deployment name=\"WAR MODULE NAME.war\">\n"
"        <realm>demo</realm>\n"
"        <auth-server-url>http://localhost:8081{kc_base_path}</auth-server-url>\n"
"        <ssl-required>external</ssl-required>\n"
"        <resource>customer-portal</resource>\n"
"        <credential name=\"secret\">password</credential>\n"
"     </secure-deployment>\n"
"  </subsystem>\n"
"</profile>"

msgid ""
"The `secure-deployment` `name` attribute identifies the WAR you want to "
"secure. Its value is the `module-name` defined in `web.xml` with `.war` "
"appended. The rest of the configuration corresponds pretty much one to one "
"with the `keycloak.json` configuration options defined in "
"<<_java_adapter_config,Java adapter configuration>>."
msgstr ""
"`secure-deployment` の `name` 属性は保護したいWARを識別します。 `web.xml` 内の `module-name` に"
" `.war` を付加した値となります。残りの設定は、<<_java_adapter_config,Java アダプターの設定>>で定義されている "
"`keycloak.json` 設定オプションと一対一で対応しています。"

msgid "The exception is the `credential` element."
msgstr "例外は `credential` 要素です。"

msgid ""
"To make it easier for you, you can go to the {project_name} Admin Console "
"and go to the Client/Installation tab of the application this WAR is aligned"
" with. It provides an example XML file you can cut and paste."
msgstr ""
"より簡単に行うには、{project_name}管理コンソールにアクセスし、このWARが並んでいるアプリケーションのClient/Installationタブに移動します。そこで、カット・アンド・ペーストできるサンプルXMLファイルが提供されてます。"

msgid ""
"If you have multiple deployments secured by the same realm you can share the"
" realm configuration in a separate element. For example:"
msgstr "同じレルムで複数のデプロイメントをセキュリティー保護している場合は、別の要素でレルム設定を共有できます。以下に例を示します。"

msgid ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak:1.1\">\n"
"    <realm name=\"demo\">\n"
"        <auth-server-url>http://localhost:8080{kc_base_path}</auth-server-url>\n"
"        <ssl-required>external</ssl-required>\n"
"    </realm>\n"
"    <secure-deployment name=\"customer-portal.war\">\n"
"        <realm>demo</realm>\n"
"        <resource>customer-portal</resource>\n"
"        <credential name=\"secret\">password</credential>\n"
"    </secure-deployment>\n"
"    <secure-deployment name=\"product-portal.war\">\n"
"        <realm>demo</realm>\n"
"        <resource>product-portal</resource>\n"
"        <credential name=\"secret\">password</credential>\n"
"    </secure-deployment>\n"
"    <secure-deployment name=\"database.war\">\n"
"        <realm>demo</realm>\n"
"        <resource>database-service</resource>\n"
"        <bearer-only>true</bearer-only>\n"
"    </secure-deployment>\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak:1.1\">\n"
"    <realm name=\"demo\">\n"
"        <auth-server-url>http://localhost:8080{kc_base_path}</auth-server-url>\n"
"        <ssl-required>external</ssl-required>\n"
"    </realm>\n"
"    <secure-deployment name=\"customer-portal.war\">\n"
"        <realm>demo</realm>\n"
"        <resource>customer-portal</resource>\n"
"        <credential name=\"secret\">password</credential>\n"
"    </secure-deployment>\n"
"    <secure-deployment name=\"product-portal.war\">\n"
"        <realm>demo</realm>\n"
"        <resource>product-portal</resource>\n"
"        <credential name=\"secret\">password</credential>\n"
"    </secure-deployment>\n"
"    <secure-deployment name=\"database.war\">\n"
"        <realm>demo</realm>\n"
"        <resource>database-service</resource>\n"
"        <bearer-only>true</bearer-only>\n"
"    </secure-deployment>\n"
"</subsystem>"

msgid "Security domain"
msgstr "セキュリティー・ドメイン"

msgid "The security context is propagated to the EJB tier automatically."
msgstr "セキュリティー・コンテキストは、EJB層に自動的に伝播されます。"

msgid "Installing JBoss EAP 7 adapters from an RPM"
msgstr "RPMからのJBoss EAP 7アダプターのインストール"

msgid ""
"With Red Hat Enterprise Linux 7, the term channel was replaced with the term"
" repository. In these instructions only the term repository is used."
msgstr ""
"Red Hat Enterprise Linux "
"7では、チャンネルという用語はリポジトリーという用語に置き換えられました。これらの説明では、リポジトリーという用語のみが使用されています。"

msgid "Prerequisites"
msgstr "前提条件"

msgid ""
"You must subscribe to the {appserver_name} {appserver_version} repository "
"before you can install the {appserver_name} 7 adapters from an RPM."
msgstr ""
"RPMから{appserver_name} 7アダプターをインストールする前に、{appserver_name} "
"{appserver_version}リポジトリーをサブスクライブする必要があります。"

msgid ""
"Ensure that your Red Hat Enterprise Linux system is registered to your "
"account using Red Hat Subscription Manager. For more information see the "
"link:https://access.redhat.com/documentation/en-"
"us/red_hat_subscription_management/1/html-"
"single/quick_registration_for_rhel/index[Red Hat Subscription Management "
"documentation]."
msgstr ""
"Red Hat Subscription Managerを使用して、Red Hat Enterprise "
"Linuxシステムがアカウントに登録されていることを確認してください。詳細は、link:https://access.redhat.com/documentation/en-"
"us/red_hat_subscription_management/1/html-"
"single/quick_registration_for_rhel/index[Red Hat Subscription Management "
"documentation]のリンクを参照してください。"

msgid ""
"If you are already subscribed to another JBoss EAP repository, you must "
"unsubscribe from that repository first."
msgstr "すでに別のJBoss EAPリポジトリーに登録している場合は、まずそのリポジトリーから登録を解除する必要があります。"

msgid ""
"For Red Hat Enterprise Linux 6, 7: Using Red Hat Subscription Manager, "
"subscribe to the {appserver_name} {appserver_version} repository using the "
"following command. Replace <RHEL_VERSION> with either 6 or 7 depending on "
"your Red Hat Enterprise Linux version."
msgstr ""
"Red Hat Enterprise Linux 6、7の場合：Red Hat Subscription "
"Managerを使用して、次のコマンドで{appserver_name} {appserver_version}リポジトリーに登録します。Red Hat"
" Enterprise Linuxバージョンに応じて、 <RHEL_VERSION> を6または7のいずれかに置き換えてください。"

msgid ""
"$ sudo subscription-manager repos --enable=jb-eap-7-for-"
"rhel-<RHEL_VERSION>-server-rpms"
msgstr ""
"$ sudo subscription-manager repos --enable=jb-eap-7-for-"
"rhel-<RHEL_VERSION>-server-rpms"

msgid ""
"For Red Hat Enterprise Linux 8: Using Red Hat Subscription Manager, "
"subscribe to the {appserver_name} {appserver_version} repository using the "
"following command:"
msgstr ""
"Red Hat Enterprise Linux 8の場合：Red Hat Subscription "
"Managerを使用して、次のコマンドで{appserver_name} {appserver_version}リポジトリーに登録します。"

msgid ""
"$ sudo subscription-manager repos --enable=jb-eap-{appserver_version}-for-"
"rhel-8-x86_64-rpms --enable=rhel-8-for-x86_64-baseos-rpms "
"--enable=rhel-8-for-x86_64-appstream-rpms"
msgstr ""
"$ sudo subscription-manager repos --enable=jb-eap-{appserver_version}-for-"
"rhel-8-x86_64-rpms --enable=rhel-8-for-x86_64-baseos-rpms "
"--enable=rhel-8-for-x86_64-appstream-rpms"

msgid ""
"Install the {appserver_name} 7 adapters for OIDC based on your version of "
"Red Hat Enterprise Linux."
msgstr ""
"Red Hat Enterprise Linuxのバージョンに基づき、OIDC用{appserver_name} 7アダプターをインストールします。"

msgid "Install on Red Hat Enterprise Linux 6, 7:"
msgstr "Red Hat Enterprise Linux 6または7にインストールするには、以下を実行します。"

msgid "$ sudo yum install eap7-keycloak-adapter-sso7_5"
msgstr "$ sudo yum install eap7-keycloak-adapter-sso7_5"

msgid "Install on  Red Hat Enterprise Linux 8:"
msgstr "Red Hat Enterprise Linux 8インストールするには、以下を実行します。"

msgid "$ sudo dnf install eap7-keycloak-adapter-sso7_5"
msgstr "$ sudo dnf install eap7-keycloak-adapter-sso7_5"

msgid ""
"The default EAP_HOME path for the RPM installation is "
"/opt/rh/eap7/root/usr/share/wildfly."
msgstr "RPMインストールのためのデフォルトのEAP_HOMEパスは、/opt/rh/eap7/root/usr/share/wildflyです。"

msgid "Run the installation script for the OIDC module."
msgstr "OIDCモジュールのインストールスクリプトを実行します。"

msgid ""
"$ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install.cli"
msgstr ""
"$ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install.cli"

msgid "Your installation is complete."
msgstr "インストールは完了です。"

msgid "Installing JBoss EAP 6 adapters from an RPM"
msgstr "RPMからのJBoss EAP 6アダプターのインストール"

msgid ""
"You must subscribe to the JBoss EAP 6 repository before you can install the "
"EAP 6 adapters from an RPM."
msgstr "RPMからEAP 6アダプターをインストールする前に、JBoss EAP 6リポジトリーにサブスクライブする必要があります。"

msgid ""
"Using Red Hat Subscription Manager, subscribe to the JBoss EAP 6 repository "
"using the following command. Replace <RHEL_VERSION> with either 6 or 7 "
"depending on your Red Hat Enterprise Linux version."
msgstr ""
"Red Hat Subscription Managerを使用して、次のコマンドを使用してJBoss EAP "
"6リポジトリーにサブスクライブします。Red Hat Enterprise "
"Linuxのバージョンに応じて、<RHEL_VERSION>を6または7のいずれかに置き換えてください。"

msgid ""
"$ sudo subscription-manager repos --enable=jb-eap-6-for-"
"rhel-<RHEL_VERSION>-server-rpms"
msgstr ""
"$ sudo subscription-manager repos --enable=jb-eap-6-for-"
"rhel-<RHEL_VERSION>-server-rpms"

msgid "Install the EAP 6 adapters for OIDC using the following command:"
msgstr "次のコマンドを使用して、OIDC用のEAP 6アダプターをインストールします。"

msgid "$ sudo yum install keycloak-adapter-sso7_5-eap6"
msgstr "$ sudo yum install keycloak-adapter-sso7_5-eap6"

msgid ""
"The default EAP_HOME path for the RPM installation is "
"/opt/rh/eap6/root/usr/share/wildfly."
msgstr "RPMインストールのためのデフォルトのEAP_HOMEパスは、/opt/rh/eap6/root/usr/share/wildflyです。"

msgid "JBoss Fuse 6 adapter"
msgstr "JBoss Fuse 6アダプター"

msgid ""
"{project_name} supports securing your web applications running inside "
"https://developers.redhat.com/products/fuse/overview[JBoss Fuse 6]."
msgstr ""
"{project_name}は https://developers.redhat.com/products/fuse/overview[JBoss "
"Fuse 6] 内で実行されているWebアプリケーションのセキュリティー保護をサポートしています。"

msgid ""
"JBoss Fuse 6 uses <<_jetty9_adapter,Jetty 9 adapter>> as {fuseVersion} is "
"bundled with http://www.eclipse.org/jetty/[Jetty 9.2 server] under the "
"covers and Jetty is used for running various kinds of web applications."
msgstr ""
"{fuseVersion}は http://www.eclipse.org/jetty/[Jetty 9.2 server] "
"にバンドルされており、Jettyはさまざまな種類のWebアプリケーションの実行に使用されているため、JBoss Fuse "
"6は<<_jetty9_adapter,Jetty 9アダプター>>を使用しています。"

msgid ""
"The only supported version of Fuse 6 is the latest release. If you use "
"earlier versions of Fuse 6, it is possible that some functions will not work"
" correctly. In particular, the https://hawt.io/[Hawtio] integration will not"
" work with earlier versions of Fuse 6."
msgstr ""
"サポートされているFuse 6のバージョンは最新リリースのみです。以前のバージョンのFuse "
"6を使用している場合、一部の機能が正しく動作しない可能性があります。特に、 https://hawt.io/[Hawtio] との統合は、Fuse "
"6の以前のバージョンでは機能しません。"

msgid "Security for the following items is supported for Fuse:"
msgstr "Fuseに対して、以下の項目のセキュリティーがサポートされています。"

msgid "Classic WAR applications deployed on Fuse with Pax Web War Extender"
msgstr "Pax Web War Extenderを使用して、FuseにデプロイされたクラシックWARアプリケーション"

msgid ""
"Servlets deployed on Fuse as OSGI services with Pax Web Whiteboard Extender"
msgstr "Pax Web Whiteboard Extenderを使用して、FuseにOSGIサービスとしてデプロイされたサーブレット"

msgid ""
"https://camel.apache.org/[Apache Camel] Jetty endpoints running with the "
"https://camel.apache.org/components/next/jetty-component.html[Camel Jetty] "
"component"
msgstr ""
"https://camel.apache.org/components/next/jetty-component.html[Camel Jetty]  "
"コンポーネントで動作する https://camel.apache.org/[Apache Camel] Jettyエンドポイント"

msgid ""
"https://cxf.apache.org/[Apache CXF] endpoints running on their own separate "
"https://cxf.apache.org/docs/jetty-configuration.html[Jetty engine]"
msgstr ""
"独自の分離された https://cxf.apache.org/docs/jetty-configuration.html[Jettyエンジン] "
"で動作する https://cxf.apache.org/[Apache CXF] エンドポイント"

msgid ""
"https://cxf.apache.org/[Apache CXF] endpoints running on the default engine "
"provided by the CXF servlet"
msgstr ""
"CXFサーブレットによって提供されるデフォルト・エンジンで実行されている https://cxf.apache.org/[Apache CXF] "
"エンドポイント"

msgid "SSH and JMX admin access"
msgstr "SSHおよびJMXの管理者アクセス"

msgid "https://hawt.io/[Hawtio administration console]"
msgstr "https://hawt.io/[Hawtio administration console]"

msgid "Securing your web applications inside Fuse 6"
msgstr "Fuse 6内でWebアプリケーションをセキュリティー保護する"

msgid ""
"You must first install the {project_name} Karaf feature. Next you will need "
"to perform the steps according to the type of application you want to "
"secure. All referenced web applications require injecting the {project_name}"
" Jetty authenticator into the underlying Jetty server. The steps to achieve "
"this depend on the application type. The details are described below."
msgstr ""
"最初に{project_name} "
"Karafの機能をインストールする必要があります。次に、セキュリティー保護するアプリケーションの種類に応じた手順を実行する必要があります。参照されているすべてのWebアプリケーションで、{project_name}"
" "
"Jettyオーセンティケーターを、基盤となるJettyサーバーに注入する必要があります。これを達成するための手順は、アプリケーションの種類によって異なります。詳細は以下のとおりです。"

msgid ""
"The best place to start is look at Fuse demo bundled as part of "
"{project_name} examples in directory `fuse`. Most of the steps should be "
"understandable from testing and understanding the demo."
msgstr ""
"始めるのに最適なのは、 `fuse` "
"ディレクトリー内の{project_name}のサンプルの一部としてバンドルされているFuseのデモを見ることです。ほとんどの手順はテストとデモから理解できるはずです。"

msgid "Installing the Keycloak feature"
msgstr "Keycloakフィーチャーのインストール"

msgid ""
"You must first install the `keycloak` feature in the JBoss Fuse environment."
" The keycloak feature includes the Fuse adapter and all third-party "
"dependencies. You can install it either from the Maven repository or from an"
" archive."
msgstr ""
"最初に `keycloak` フィーチャーをJBoss Fuse環境にインストールする必要があります。 `keycloak` "
"フィーチャーには、Fuseアダプターとサード・パーティーのすべての依存関係が含まれます。Mavenリポジトリーまたはアーカイブからインストールすることができます。"

msgid "Installing from the Maven repository"
msgstr "Mavenリポジトリーからのインストール"

msgid "You must be online and have access to the Maven repository."
msgstr "オンラインであり、Mavenリポジトリーにアクセスできる必要があります。"

msgid ""
"For community it is sufficient to be online as all the artifacts and 3rd "
"party dependencies should be available in the maven central repository."
msgstr ""
"コミュニティー版の場合、すべてのアーティファクトとサード・パーティーの依存関係がMavenのセントラル・リポジトリーで利用できるため、オンラインにするだけで十分です。"

msgid "Start {fuseVersion}"
msgstr "{fuseVersion}を起動します。"

msgid "In the Karaf terminal type:"
msgstr "Karaf端末で以下をタイプします。"

msgid ""
"features:addurl mvn:org.keycloak/keycloak-osgi-features/{project_versionMvn}/xml/features\n"
"features:install keycloak"
msgstr ""
"features:addurl mvn:org.keycloak/keycloak-osgi-features/{project_versionMvn}/xml/features\n"
"features:install keycloak"

msgid "You might also need to install the Jetty 9 feature:"
msgstr "以下のようにJetty 9フィーチャーをインストールする必要があるかもしれません。"

msgid "features:install keycloak-jetty9-adapter"
msgstr "features:install keycloak-jetty9-adapter"

msgid "Ensure that the features were installed:"
msgstr "以下のようにフィーチャーがインストールされていることを確認します。"

msgid "features:list | grep keycloak"
msgstr "features:list | grep keycloak"

msgid "Installing from the ZIP bundle"
msgstr "ZIPバンドルからのインストール"

msgid ""
"This installation option is useful if you are offline or do not want to use "
"Maven to obtain the JAR files and other artifacts."
msgstr ""
"このインストール・オプションは、オフラインになっている場合や、Mavenを使用してJARファイルやその他のアーティファクトを取得したくない場合に便利です。"

msgid ""
"Download the {project_name} Fuse adapter ZIP archive from the "
"link:https://www.keycloak.org/downloads[Downloads] site."
msgstr ""
"link:https://www.keycloak.org/downloads[ダウンロード]サイトより、　{project_name} "
"FuseアダプターのZIPアーカイブをダウンロードします。"

msgid ""
"Unzip it into the root directory of JBoss Fuse. The dependencies are then "
"installed under the `system` directory. You can overwrite all existing jar "
"files."
msgstr ""
"JBoss Fuseのルート・ディレクトリーに解凍します。依存関係にあるファイルは `system` "
"ディレクトリーの下にインストールされます。既存のすべてのjarファイルが上書きされます。"

msgid "Use this for {fuseVersion}:"
msgstr "{FuseVersion}には、これを使用します。"

msgid ""
"cd /path-to-fuse/jboss-fuse-6.3.0.redhat-254\n"
"unzip -q /path-to-adapter-zip/keycloak-fuse-adapter-{project_versionMvn}.zip"
msgstr ""
"cd /path-to-fuse/jboss-fuse-6.3.0.redhat-254\n"
"unzip -q /path-to-adapter-zip/keycloak-fuse-adapter-{project_versionMvn}.zip"

msgid "Start Fuse and run these commands in the fuse/karaf terminal:"
msgstr "Fuseを起動し、Fuse/Karafターミナルで次のコマンドを実行します。"

msgid ""
"Install the corresponding Jetty adapter. Since the artifacts are available "
"directly in the JBoss Fuse `system` directory, you do not need to use the "
"Maven repository."
msgstr ""
"対応するJettyアダプターをインストールします。アーティファクトはJBoss Fuseの `system` "
"ディレクトリーから直接利用できるので、Mavenリポジトリーを使う必要はありません。"

msgid "Securing a Classic WAR application"
msgstr "クラシックWARアプリケーションのセキュリティー保護"

msgid "In the `/WEB-INF/web.xml` file, declare the necessary:"
msgstr "`/WEB-INF/web.xml` ファイルで、次のように必要なものを宣言します。"

msgid "security constraints in the <security-constraint> element"
msgstr "<security-constraint>要素のセキュリティー制約"

msgid "login configuration in the <login-config> element"
msgstr "<login-config>要素のログイン設定"

msgid "security roles in the <security-role> element."
msgstr "<security-role>要素のセキュリティー・ロール。"

msgid "For example:"
msgstr "例："

msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"         version=\"3.0\">\n"
"\n"
"    <module-name>customer-portal</module-name>\n"
"\n"
"    <welcome-file-list>\n"
"        <welcome-file>index.html</welcome-file>\n"
"    </welcome-file-list>\n"
"\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Customers</web-resource-name>\n"
"            <url-pattern>/customers/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>user</role-name>\n"
"        </auth-constraint>\n"
"    </security-constraint>\n"
"\n"
"    <login-config>\n"
"        <auth-method>BASIC</auth-method>\n"
"        <realm-name>does-not-matter</realm-name>\n"
"    </login-config>\n"
"\n"
"    <security-role>\n"
"        <role-name>admin</role-name>\n"
"    </security-role>\n"
"    <security-role>\n"
"        <role-name>user</role-name>\n"
"    </security-role>\n"
"</web-app>"
msgstr ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"         version=\"3.0\">\n"
"\n"
"    <module-name>customer-portal</module-name>\n"
"\n"
"    <welcome-file-list>\n"
"        <welcome-file>index.html</welcome-file>\n"
"    </welcome-file-list>\n"
"\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Customers</web-resource-name>\n"
"            <url-pattern>/customers/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>user</role-name>\n"
"        </auth-constraint>\n"
"    </security-constraint>\n"
"\n"
"    <login-config>\n"
"        <auth-method>BASIC</auth-method>\n"
"        <realm-name>does-not-matter</realm-name>\n"
"    </login-config>\n"
"\n"
"    <security-role>\n"
"        <role-name>admin</role-name>\n"
"    </security-role>\n"
"    <security-role>\n"
"        <role-name>user</role-name>\n"
"    </security-role>\n"
"</web-app>"

msgid ""
"Add the `jetty-web.xml` file with the authenticator to the `/WEB-INF/jetty-"
"web.xml` file."
msgstr "オーセンティケーターを設定した `/WEB_INF/jetty-web.xml` ファイルを追加してください。"

msgid ""
"<?xml version=\"1.0\"?>\n"
"<!DOCTYPE Configure PUBLIC \"-//Mort Bay Consulting//DTD Configure//EN\"\n"
" \"http://www.eclipse.org/jetty/configure_9_0.dtd\">\n"
"<Configure class=\"org.eclipse.jetty.webapp.WebAppContext\">\n"
"    <Get name=\"securityHandler\">\n"
"        <Set name=\"authenticator\">\n"
"            <New class=\"org.keycloak.adapters.jetty.KeycloakJettyAuthenticator\">\n"
"            </New>\n"
"        </Set>\n"
"    </Get>\n"
"</Configure>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<!DOCTYPE Configure PUBLIC \"-//Mort Bay Consulting//DTD Configure//EN\"\n"
" \"http://www.eclipse.org/jetty/configure_9_0.dtd\">\n"
"<Configure class=\"org.eclipse.jetty.webapp.WebAppContext\">\n"
"    <Get name=\"securityHandler\">\n"
"        <Set name=\"authenticator\">\n"
"            <New class=\"org.keycloak.adapters.jetty.KeycloakJettyAuthenticator\">\n"
"            </New>\n"
"        </Set>\n"
"    </Get>\n"
"</Configure>"

msgid ""
"Within the `/WEB-INF/` directory of your WAR, create a new file, "
"keycloak.json. The format of this configuration file is described in the "
"<<_java_adapter_config,Java Adapters Config>> section. It is also possible "
"to make this file available externally as described in "
"xref:config_external_adapter[Configuring the External Adapter]."
msgstr ""
"WARの `/WEB-INF/` ディレクトリー内に、新しい `keycloak.json` "
"ファイルを作成します。この設定ファイルの形式は、<<_java_adapter_config,Javaアダプターの設定>>のセクションで説明しています。xref:config_external_adapter[外部アダプターの設定]で説明されているように、外部でこのファイルを使用することもできます。"

msgid ""
"Ensure your WAR application imports `org.keycloak.adapters.jetty` and maybe "
"some more packages in the `META-INF/MANIFEST.MF` file, under the `Import-"
"Package` header. Using `maven-bundle-plugin` in your project properly "
"generates OSGI headers in manifest. Note that \"*\" resolution for the "
"package does not import the `org.keycloak.adapters.jetty` package, since it "
"is not used by the application or the Blueprint or Spring descriptor, but is"
" rather used in the `jetty-web.xml` file."
msgstr ""
"WARアプリケーションが `org.keycloak.adapters.jetty` と `META-INF/MANIFEST.MF` ファイルの "
"`Import-Package` ヘッダーの下にあるパッケージをインポートしていることを確認してください。プロジェクトで `maven-bundle-"
"plugin` を使うと、マニフェストにOSGIヘッダーが正しく生成されます。パッケージの \"*\" による解決は "
"`org.keycloak.adapters.jetty` "
"パッケージをインポートしないことに注意してください。アプリケーションやBlueprint、Spring記述子では使用されず、 `jetty-"
"web.xml` ファイルで使用されるためです。"

msgid "The list of the packages to import might look like this:"
msgstr "インポートするパッケージのリストは次のようになります。"

msgid ""
"org.keycloak.adapters.jetty;version=\"{project_versionMvn}\",\n"
"org.keycloak.adapters;version=\"{project_versionMvn}\",\n"
"org.keycloak.constants;version=\"{project_versionMvn}\",\n"
"org.keycloak.util;version=\"{project_versionMvn}\",\n"
"org.keycloak.*;version=\"{project_versionMvn}\",\n"
"*;resolution:=optional"
msgstr ""
"org.keycloak.adapters.jetty;version=\"{project_versionMvn}\",\n"
"org.keycloak.adapters;version=\"{project_versionMvn}\",\n"
"org.keycloak.constants;version=\"{project_versionMvn}\",\n"
"org.keycloak.util;version=\"{project_versionMvn}\",\n"
"org.keycloak.*;version=\"{project_versionMvn}\",\n"
"*;resolution:=optional"

msgid "Configuring the External Adapter"
msgstr "外部アダプターの設定"

msgid ""
"If you do not want the `keycloak.json` adapter configuration file to be "
"bundled inside your WAR application, but instead made available externally "
"and loaded based on naming conventions, use this configuration method."
msgstr ""
"`keycloak.json` "
"アダプターの設定ファイルをWARアプリケーションの中にバンドルするのではなく、外部で使用可能にし、命名規則に基づいてロードする場合は、この設定方法を使用してください。"

msgid ""
"To enable the functionality, add this section to your `/WEB_INF/web.xml` "
"file:"
msgstr "この機能を有効にするには、次のセクションを `/WEB_INF/web.xml` ファイルに追加してください。"

msgid ""
"<context-param>\n"
"    <param-name>keycloak.config.resolver</param-name>\n"
"    <param-value>org.keycloak.adapters.osgi.PathBasedKeycloakConfigResolver</param-value>\n"
"</context-param>"
msgstr ""
"<context-param>\n"
"    <param-name>keycloak.config.resolver</param-name>\n"
"    <param-value>org.keycloak.adapters.osgi.PathBasedKeycloakConfigResolver</param-value>\n"
"</context-param>"

msgid ""
"That component uses `keycloak.config` or `karaf.etc` java properties to "
"search for a base folder to locate the configuration. Then inside one of "
"those folders it searches for a file called "
"`<your_web_context>-keycloak.json`."
msgstr ""
"そのコンポーネントは、 `keycloak.config` または `karaf.etc` "
"のjavaプロパティーを使って基本フォルダーを検索し、設定を探します。そして、見つけたフォルダーの中で "
"`<your_web_context>-keycloak.json` というファイルを探します。"

msgid ""
"So, for example, if your web application has context `my-portal`, then your "
"adapter configuration is loaded from the  `$FUSE_HOME/etc/my-portal-"
"keycloak.json` file."
msgstr ""
"たとえば、Webアプリケーションにコンテキスト `my-portal` がある場合、アダプターの設定は `$FUSE_HOME/etc/my-"
"portal-keycloak.json` ファイルからロードされます。"

msgid "Securing a servlet deployed as an OSGI Service"
msgstr "OSGIサービスとしてデプロイされたサーブレットのセキュリティー保護"

msgid ""
"You can use this method if you have a servlet class inside your OSGI bundled"
" project that is not deployed as a classic WAR application. Fuse uses Pax "
"Web Whiteboard Extender to deploy such servlets as web applications."
msgstr ""
"クラシックなWARアプリケーションとしてデプロイされていないOSGIバンドルされたプロジェクト内にサーブレット・クラスがある場合、この方式を使用できます。FuseはPax"
" Web Whiteboard Extenderを使用して、サーブレットをWebアプリケーションとしてデプロイします。"

msgid ""
"{project_name} provides "
"`org.keycloak.adapters.osgi.undertow.PaxWebIntegrationService`, which allows"
" injecting jetty-web.xml and configuring security constraints for your "
"application. You need to declare such services in the `OSGI-"
"INF/blueprint/blueprint.xml` file inside your application. Note that your "
"servlet needs to depend on it. An example configuration:"
msgstr ""
"{project_name}は "
"`org.keycloak.adapters.osgi.undertow.PaxWebIntegrationService` "
"を提供します。これにより、jetty-web.xmlを注入し、アプリケーションのセキュリティー制約を設定できます。アプリケーション内の `OSGI-"
"INF/blueprint/blueprint.xml` "
"ファイルでそのようなサービスを宣言する必要があります。サーブレットはそれに依存する必要があることに注意してください。設定例は次のとおりです。"

msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n"
"           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"           xsi:schemaLocation=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\n"
"           http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\">\n"
"\n"
"    <!-- Using jetty bean just for the compatibility with other fuse services -->\n"
"    <bean id=\"servletConstraintMapping\" class=\"org.eclipse.jetty.security.ConstraintMapping\">\n"
"        <property name=\"constraint\">\n"
"            <bean class=\"org.eclipse.jetty.util.security.Constraint\">\n"
"                <property name=\"name\" value=\"cst1\"/>\n"
"                <property name=\"roles\">\n"
"                    <list>\n"
"                        <value>user</value>\n"
"                    </list>\n"
"                </property>\n"
"                <property name=\"authenticate\" value=\"true\"/>\n"
"                <property name=\"dataConstraint\" value=\"0\"/>\n"
"            </bean>\n"
"        </property>\n"
"        <property name=\"pathSpec\" value=\"/product-portal/*\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"keycloakPaxWebIntegration\" class=\"org.keycloak.adapters.osgi.PaxWebIntegrationService\"\n"
"          init-method=\"start\" destroy-method=\"stop\">\n"
"        <property name=\"jettyWebXmlLocation\" value=\"/WEB-INF/jetty-web.xml\" />\n"
"        <property name=\"bundleContext\" ref=\"blueprintBundleContext\" />\n"
"        <property name=\"constraintMappings\">\n"
"            <list>\n"
"                <ref component-id=\"servletConstraintMapping\" />\n"
"            </list>\n"
"        </property>\n"
"    </bean>\n"
"\n"
"    <bean id=\"productServlet\" class=\"org.keycloak.example.ProductPortalServlet\" depends-on=\"keycloakPaxWebIntegration\">\n"
"    </bean>\n"
"\n"
"    <service ref=\"productServlet\" interface=\"javax.servlet.Servlet\">\n"
"        <service-properties>\n"
"            <entry key=\"alias\" value=\"/product-portal\" />\n"
"            <entry key=\"servlet-name\" value=\"ProductServlet\" />\n"
"            <entry key=\"keycloak.config.file\" value=\"/keycloak.json\" />\n"
"        </service-properties>\n"
"    </service>\n"
"\n"
"</blueprint>"
msgstr ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n"
"           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"           xsi:schemaLocation=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\n"
"           http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\">\n"
"\n"
"    <!-- Using jetty bean just for the compatibility with other fuse services -->\n"
"    <bean id=\"servletConstraintMapping\" class=\"org.eclipse.jetty.security.ConstraintMapping\">\n"
"        <property name=\"constraint\">\n"
"            <bean class=\"org.eclipse.jetty.util.security.Constraint\">\n"
"                <property name=\"name\" value=\"cst1\"/>\n"
"                <property name=\"roles\">\n"
"                    <list>\n"
"                        <value>user</value>\n"
"                    </list>\n"
"                </property>\n"
"                <property name=\"authenticate\" value=\"true\"/>\n"
"                <property name=\"dataConstraint\" value=\"0\"/>\n"
"            </bean>\n"
"        </property>\n"
"        <property name=\"pathSpec\" value=\"/product-portal/*\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"keycloakPaxWebIntegration\" class=\"org.keycloak.adapters.osgi.PaxWebIntegrationService\"\n"
"          init-method=\"start\" destroy-method=\"stop\">\n"
"        <property name=\"jettyWebXmlLocation\" value=\"/WEB-INF/jetty-web.xml\" />\n"
"        <property name=\"bundleContext\" ref=\"blueprintBundleContext\" />\n"
"        <property name=\"constraintMappings\">\n"
"            <list>\n"
"                <ref component-id=\"servletConstraintMapping\" />\n"
"            </list>\n"
"        </property>\n"
"    </bean>\n"
"\n"
"    <bean id=\"productServlet\" class=\"org.keycloak.example.ProductPortalServlet\" depends-on=\"keycloakPaxWebIntegration\">\n"
"    </bean>\n"
"\n"
"    <service ref=\"productServlet\" interface=\"javax.servlet.Servlet\">\n"
"        <service-properties>\n"
"            <entry key=\"alias\" value=\"/product-portal\" />\n"
"            <entry key=\"servlet-name\" value=\"ProductServlet\" />\n"
"            <entry key=\"keycloak.config.file\" value=\"/keycloak.json\" />\n"
"        </service-properties>\n"
"    </service>\n"
"\n"
"</blueprint>"

msgid ""
"You might need to have the `WEB-INF` directory inside your project (even if "
"your project is not a web application) and create the  `/WEB-INF/jetty-"
"web.xml` and `/WEB-INF/keycloak.json` files as in the "
"<<_fuse_adapter_classic_war,Classic WAR application>> section. Note you "
"don't need the `web.xml` file as the security-constraints are declared in "
"the blueprint configuration file."
msgstr ""
"プロジェクト内に `WEB-INF` "
"ディレクトリー（プロジェクトがWebアプリケーションでない場合でも）を用意し、<<_fuse_adapter_classic_war,クラシックWARアプリケーション>>のセクションのように"
" `/WEB-INF/jetty-web.xml` と `/WEB-INF/keycloak.json` "
"ファイルを作成する必要があります。security-constraintsがblueprint設定ファイルで宣言されているので、 `web.xml` "
"ファイルは必要ありません。"

msgid ""
"The `Import-Package` in `META-INF/MANIFEST.MF` must contain at least these "
"imports:"
msgstr ""
"`META-INF/MANIFEST.MF` の `Import-Package` は、少なくとも以下のインポートを含んでいなければなりません。"

msgid "Securing an Apache Camel application"
msgstr "Apache Camelアプリケーションのセキュリティー保護"

msgid ""
"You can secure Apache Camel endpoints implemented with the "
"https://camel.apache.org/components/next/jetty-component.html[camel-jetty] "
"component by adding the securityHandler with `KeycloakJettyAuthenticator` "
"and the proper security constraints injected. You can add the `OSGI-"
"INF/blueprint/blueprint.xml` file to your Camel application with a similar "
"configuration as below. The roles, security constraint mappings, and "
"{project_name} adapter configuration might differ slightly depending on your"
" environment and needs."
msgstr ""
"`KeycloakJettyAuthenticator` とsecurityHandlerを追加し、適切なセキュリティー制約を注入することで、 "
"https://camel.apache.org/components/next/jetty-component.html[camel-jetty] "
"コンポーネントで実装されたApache Camelエンドポイントをセキュリティー保護できます。 `OSGI-"
"INF/blueprint/blueprint.xml` "
"ファイルを、以下のような設定でCamelアプリケーションに追加できます。ロール、セキュリティー制約のマッピング、および{project_name}アダプターの設定は、使用する環境と必要性により若干異なる場合があります。"

msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"\n"
"<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n"
"           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"           xmlns:camel=\"http://camel.apache.org/schema/blueprint\"\n"
"           xsi:schemaLocation=\"\n"
"       http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n"
"       http://camel.apache.org/schema/blueprint http://camel.apache.org/schema/blueprint/camel-blueprint.xsd\">\n"
"\n"
"    <bean id=\"kcAdapterConfig\" class=\"org.keycloak.representations.adapters.config.AdapterConfig\">\n"
"        <property name=\"realm\" value=\"demo\"/>\n"
"        <property name=\"resource\" value=\"admin-camel-endpoint\"/>\n"
"        <property name=\"bearerOnly\" value=\"true\"/>\n"
"        <property name=\"authServerUrl\" value=\"http://localhost:8080{kc_base_path}\" />\n"
"        <property name=\"sslRequired\" value=\"EXTERNAL\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"keycloakAuthenticator\" class=\"org.keycloak.adapters.jetty.KeycloakJettyAuthenticator\">\n"
"        <property name=\"adapterConfig\" ref=\"kcAdapterConfig\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"constraint\" class=\"org.eclipse.jetty.util.security.Constraint\">\n"
"        <property name=\"name\" value=\"Customers\"/>\n"
"        <property name=\"roles\">\n"
"            <list>\n"
"                <value>admin</value>\n"
"            </list>\n"
"        </property>\n"
"        <property name=\"authenticate\" value=\"true\"/>\n"
"        <property name=\"dataConstraint\" value=\"0\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"constraintMapping\" class=\"org.eclipse.jetty.security.ConstraintMapping\">\n"
"        <property name=\"constraint\" ref=\"constraint\"/>\n"
"        <property name=\"pathSpec\" value=\"/*\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"securityHandler\" class=\"org.eclipse.jetty.security.ConstraintSecurityHandler\">\n"
"        <property name=\"authenticator\" ref=\"keycloakAuthenticator\" />\n"
"        <property name=\"constraintMappings\">\n"
"            <list>\n"
"                <ref component-id=\"constraintMapping\" />\n"
"            </list>\n"
"        </property>\n"
"        <property name=\"authMethod\" value=\"BASIC\"/>\n"
"        <property name=\"realmName\" value=\"does-not-matter\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"sessionHandler\" class=\"org.keycloak.adapters.jetty.spi.WrappingSessionHandler\">\n"
"        <property name=\"handler\" ref=\"securityHandler\" />\n"
"    </bean>\n"
"\n"
"    <bean id=\"helloProcessor\" class=\"org.keycloak.example.CamelHelloProcessor\" />\n"
"\n"
"    <camelContext id=\"blueprintContext\"\n"
"                  trace=\"false\"\n"
"                  xmlns=\"http://camel.apache.org/schema/blueprint\">\n"
"        <route id=\"httpBridge\">\n"
"            <from uri=\"jetty:http://0.0.0.0:8383/admin-camel-endpoint?handlers=sessionHandler&amp;matchOnUriPrefix=true\" />\n"
"            <process ref=\"helloProcessor\" />\n"
"            <log message=\"The message from camel endpoint contains ${body}\"/>\n"
"        </route>\n"
"    </camelContext>\n"
"\n"
"</blueprint>"
msgstr ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"\n"
"<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n"
"           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"           xmlns:camel=\"http://camel.apache.org/schema/blueprint\"\n"
"           xsi:schemaLocation=\"\n"
"       http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n"
"       http://camel.apache.org/schema/blueprint http://camel.apache.org/schema/blueprint/camel-blueprint.xsd\">\n"
"\n"
"    <bean id=\"kcAdapterConfig\" class=\"org.keycloak.representations.adapters.config.AdapterConfig\">\n"
"        <property name=\"realm\" value=\"demo\"/>\n"
"        <property name=\"resource\" value=\"admin-camel-endpoint\"/>\n"
"        <property name=\"bearerOnly\" value=\"true\"/>\n"
"        <property name=\"authServerUrl\" value=\"http://localhost:8080{kc_base_path}\" />\n"
"        <property name=\"sslRequired\" value=\"EXTERNAL\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"keycloakAuthenticator\" class=\"org.keycloak.adapters.jetty.KeycloakJettyAuthenticator\">\n"
"        <property name=\"adapterConfig\" ref=\"kcAdapterConfig\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"constraint\" class=\"org.eclipse.jetty.util.security.Constraint\">\n"
"        <property name=\"name\" value=\"Customers\"/>\n"
"        <property name=\"roles\">\n"
"            <list>\n"
"                <value>admin</value>\n"
"            </list>\n"
"        </property>\n"
"        <property name=\"authenticate\" value=\"true\"/>\n"
"        <property name=\"dataConstraint\" value=\"0\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"constraintMapping\" class=\"org.eclipse.jetty.security.ConstraintMapping\">\n"
"        <property name=\"constraint\" ref=\"constraint\"/>\n"
"        <property name=\"pathSpec\" value=\"/*\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"securityHandler\" class=\"org.eclipse.jetty.security.ConstraintSecurityHandler\">\n"
"        <property name=\"authenticator\" ref=\"keycloakAuthenticator\" />\n"
"        <property name=\"constraintMappings\">\n"
"            <list>\n"
"                <ref component-id=\"constraintMapping\" />\n"
"            </list>\n"
"        </property>\n"
"        <property name=\"authMethod\" value=\"BASIC\"/>\n"
"        <property name=\"realmName\" value=\"does-not-matter\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"sessionHandler\" class=\"org.keycloak.adapters.jetty.spi.WrappingSessionHandler\">\n"
"        <property name=\"handler\" ref=\"securityHandler\" />\n"
"    </bean>\n"
"\n"
"    <bean id=\"helloProcessor\" class=\"org.keycloak.example.CamelHelloProcessor\" />\n"
"\n"
"    <camelContext id=\"blueprintContext\"\n"
"                  trace=\"false\"\n"
"                  xmlns=\"http://camel.apache.org/schema/blueprint\">\n"
"        <route id=\"httpBridge\">\n"
"            <from uri=\"jetty:http://0.0.0.0:8383/admin-camel-endpoint?handlers=sessionHandler&amp;matchOnUriPrefix=true\" />\n"
"            <process ref=\"helloProcessor\" />\n"
"            <log message=\"The message from camel endpoint contains ${body}\"/>\n"
"        </route>\n"
"    </camelContext>\n"
"\n"
"</blueprint>"

msgid ""
"The `Import-Package` in `META-INF/MANIFEST.MF` needs to contain these "
"imports:"
msgstr "`META-INF/MANIFEST.MF` の `Import-Package` には、以下のインポートが含まれている必要があります。"

msgid ""
"javax.servlet;version=\"[3,4)\",\n"
"javax.servlet.http;version=\"[3,4)\",\n"
"org.apache.camel.*,\n"
"org.apache.camel;version=\"[2.13,3)\",\n"
"org.eclipse.jetty.security;version=\"[9,10)\",\n"
"org.eclipse.jetty.server.nio;version=\"[9,10)\",\n"
"org.eclipse.jetty.util.security;version=\"[9,10)\",\n"
"org.keycloak.*;version=\"{project_versionMvn}\",\n"
"org.osgi.service.blueprint,\n"
"org.osgi.service.blueprint.container,\n"
"org.osgi.service.event,"
msgstr ""
"javax.servlet;version=\"[3,4)\",\n"
"javax.servlet.http;version=\"[3,4)\",\n"
"org.apache.camel.*,\n"
"org.apache.camel;version=\"[2.13,3)\",\n"
"org.eclipse.jetty.security;version=\"[9,10)\",\n"
"org.eclipse.jetty.server.nio;version=\"[9,10)\",\n"
"org.eclipse.jetty.util.security;version=\"[9,10)\",\n"
"org.keycloak.*;version=\"{project_versionMvn}\",\n"
"org.osgi.service.blueprint,\n"
"org.osgi.service.blueprint.container,\n"
"org.osgi.service.event,"

msgid "Camel RestDSL"
msgstr "Camel RestDSL"

msgid ""
"Camel RestDSL is a Camel feature used to define your REST endpoints in a "
"fluent way. But you must still use specific implementation classes and "
"provide instructions on how to integrate with {project_name}."
msgstr ""
"Camel "
"RestDSLは、流暢な方法でRESTエンドポイントを定義するために使用されるCamelの機能です。しかし、依然として特定の実装クラスを使用し、{project_name}との統合方法に関する指示を提供する必要があります。"

msgid ""
"The way to configure the integration mechanism depends on the Camel "
"component for which you configure your RestDSL-defined routes."
msgstr "統合機構を設定する方法は、RestDSLで定義されたルートを設定するCamelコンポーネントによって異なります。"

msgid ""
"The following example shows how to configure integration using the Jetty "
"component, with references to some of the beans defined in previous "
"Blueprint example."
msgstr ""
"次の例は、Jettyコンポーネントを使用して統合を設定する方法を示しています（以前のBlueprintの例で定義されているBeanの一部を参照）。"

msgid ""
"<bean id=\"securityHandlerRest\" class=\"org.eclipse.jetty.security.ConstraintSecurityHandler\">\n"
"    <property name=\"authenticator\" ref=\"keycloakAuthenticator\" />\n"
"    <property name=\"constraintMappings\">\n"
"        <list>\n"
"            <ref component-id=\"constraintMapping\" />\n"
"        </list>\n"
"    </property>\n"
"    <property name=\"authMethod\" value=\"BASIC\"/>\n"
"    <property name=\"realmName\" value=\"does-not-matter\"/>\n"
"</bean>\n"
"\n"
"<bean id=\"sessionHandlerRest\" class=\"org.keycloak.adapters.jetty.spi.WrappingSessionHandler\">\n"
"    <property name=\"handler\" ref=\"securityHandlerRest\" />\n"
"</bean>\n"
"\n"
"\n"
"<camelContext id=\"blueprintContext\"\n"
"              trace=\"false\"\n"
"              xmlns=\"http://camel.apache.org/schema/blueprint\">\n"
"\n"
"    <restConfiguration component=\"jetty\" contextPath=\"/restdsl\"\n"
"                       port=\"8484\">\n"
"        <!--the link with Keycloak security handlers happens here-->\n"
"        <endpointProperty key=\"handlers\" value=\"sessionHandlerRest\"></endpointProperty>\n"
"        <endpointProperty key=\"matchOnUriPrefix\" value=\"true\"></endpointProperty>\n"
"    </restConfiguration>\n"
"\n"
"    <rest path=\"/hello\" >\n"
"        <description>Hello rest service</description>\n"
"        <get uri=\"/{id}\" outType=\"java.lang.String\">\n"
"            <description>Just an helllo</description>\n"
"            <to uri=\"direct:justDirect\" />\n"
"        </get>\n"
"\n"
"    </rest>\n"
"\n"
"    <route id=\"justDirect\">\n"
"        <from uri=\"direct:justDirect\"/>\n"
"        <process ref=\"helloProcessor\" />\n"
"        <log message=\"RestDSL correctly invoked ${body}\"/>\n"
"        <setBody>\n"
"            <constant>(__This second sentence is returned from a Camel RestDSL endpoint__)</constant>\n"
"        </setBody>\n"
"    </route>\n"
"\n"
"</camelContext>\n"
msgstr ""
"<bean id=\"securityHandlerRest\" class=\"org.eclipse.jetty.security.ConstraintSecurityHandler\">\n"
"    <property name=\"authenticator\" ref=\"keycloakAuthenticator\" />\n"
"    <property name=\"constraintMappings\">\n"
"        <list>\n"
"            <ref component-id=\"constraintMapping\" />\n"
"        </list>\n"
"    </property>\n"
"    <property name=\"authMethod\" value=\"BASIC\"/>\n"
"    <property name=\"realmName\" value=\"does-not-matter\"/>\n"
"</bean>\n"
"\n"
"<bean id=\"sessionHandlerRest\" class=\"org.keycloak.adapters.jetty.spi.WrappingSessionHandler\">\n"
"    <property name=\"handler\" ref=\"securityHandlerRest\" />\n"
"</bean>\n"
"\n"
"\n"
"<camelContext id=\"blueprintContext\"\n"
"              trace=\"false\"\n"
"              xmlns=\"http://camel.apache.org/schema/blueprint\">\n"
"\n"
"    <restConfiguration component=\"jetty\" contextPath=\"/restdsl\"\n"
"                       port=\"8484\">\n"
"        <!--the link with Keycloak security handlers happens here-->\n"
"        <endpointProperty key=\"handlers\" value=\"sessionHandlerRest\"></endpointProperty>\n"
"        <endpointProperty key=\"matchOnUriPrefix\" value=\"true\"></endpointProperty>\n"
"    </restConfiguration>\n"
"\n"
"    <rest path=\"/hello\" >\n"
"        <description>Hello rest service</description>\n"
"        <get uri=\"/{id}\" outType=\"java.lang.String\">\n"
"            <description>Just an helllo</description>\n"
"            <to uri=\"direct:justDirect\" />\n"
"        </get>\n"
"\n"
"    </rest>\n"
"\n"
"    <route id=\"justDirect\">\n"
"        <from uri=\"direct:justDirect\"/>\n"
"        <process ref=\"helloProcessor\" />\n"
"        <log message=\"RestDSL correctly invoked ${body}\"/>\n"
"        <setBody>\n"
"            <constant>(__This second sentence is returned from a Camel RestDSL endpoint__)</constant>\n"
"        </setBody>\n"
"    </route>\n"
"\n"
"</camelContext>\n"

msgid "Securing an Apache CXF endpoint on a separate Jetty engine"
msgstr "独立したJettyエンジンでのApache CXFエンドポイントのセキュリティー保護"

msgid ""
"To run your CXF endpoints secured by {project_name} on separate Jetty "
"engines, perform the following procedure."
msgstr "別々のJettyエンジンで{project_name}でセキュリティー保護されたCXFエンドポイントを実行するには、次の手順を実行します。"

msgid ""
"Add `META-INF/spring/beans.xml` to your application, and in it,  declare "
"`httpj:engine-factory` with Jetty SecurityHandler with injected "
"`KeycloakJettyAuthenticator`. The configuration for a CFX JAX-WS application"
" might resemble this one:"
msgstr ""
"アプリケーションに `META-INF/spring/beans.xml` を追加し、 `KeycloakJettyAuthenticator` "
"を注入したJettyの `SecurityHandler` で `httpj:engine-factory` を宣言してください。CFXのJAX-"
"WSアプリケーションの設定は、次のようになります。"

msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"\n"
"<beans xmlns=\"http://www.springframework.org/schema/beans\"\n"
"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"       xmlns:jaxws=\"http://cxf.apache.org/jaxws\"\n"
"       xmlns:httpj=\"http://cxf.apache.org/transports/http-jetty/configuration\"\n"
"       xsi:schemaLocation=\"\n"
"        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n"
"        http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd\n"
"        http://www.springframework.org/schema/osgi http://www.springframework.org/schema/osgi/spring-osgi.xsd\n"
"        http://cxf.apache.org/transports/http-jetty/configuration http://cxf.apache.org/schemas/configuration/http-jetty.xsd\">\n"
"\n"
"    <import resource=\"classpath:META-INF/cxf/cxf.xml\" />\n"
"\n"
"    <bean id=\"kcAdapterConfig\" class=\"org.keycloak.representations.adapters.config.AdapterConfig\">\n"
"        <property name=\"realm\" value=\"demo\"/>\n"
"        <property name=\"resource\" value=\"custom-cxf-endpoint\"/>\n"
"        <property name=\"bearerOnly\" value=\"true\"/>\n"
"        <property name=\"authServerUrl\" value=\"http://localhost:8080{kc_base_path}\" />\n"
"        <property name=\"sslRequired\" value=\"EXTERNAL\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"keycloakAuthenticator\" class=\"org.keycloak.adapters.jetty.KeycloakJettyAuthenticator\">\n"
"        <property name=\"adapterConfig\">\n"
"            <ref local=\"kcAdapterConfig\" />\n"
"        </property>\n"
"    </bean>\n"
"\n"
"    <bean id=\"constraint\" class=\"org.eclipse.jetty.util.security.Constraint\">\n"
"        <property name=\"name\" value=\"Customers\"/>\n"
"        <property name=\"roles\">\n"
"            <list>\n"
"                <value>user</value>\n"
"            </list>\n"
"        </property>\n"
"        <property name=\"authenticate\" value=\"true\"/>\n"
"        <property name=\"dataConstraint\" value=\"0\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"constraintMapping\" class=\"org.eclipse.jetty.security.ConstraintMapping\">\n"
"        <property name=\"constraint\" ref=\"constraint\"/>\n"
"        <property name=\"pathSpec\" value=\"/*\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"securityHandler\" class=\"org.eclipse.jetty.security.ConstraintSecurityHandler\">\n"
"        <property name=\"authenticator\" ref=\"keycloakAuthenticator\" />\n"
"        <property name=\"constraintMappings\">\n"
"            <list>\n"
"                <ref local=\"constraintMapping\" />\n"
"            </list>\n"
"        </property>\n"
"        <property name=\"authMethod\" value=\"BASIC\"/>\n"
"        <property name=\"realmName\" value=\"does-not-matter\"/>\n"
"    </bean>\n"
"\n"
"    <httpj:engine-factory bus=\"cxf\" id=\"kc-cxf-endpoint\">\n"
"        <httpj:engine port=\"8282\">\n"
"            <httpj:handlers>\n"
"                <ref local=\"securityHandler\" />\n"
"            </httpj:handlers>\n"
"            <httpj:sessionSupport>true</httpj:sessionSupport>\n"
"        </httpj:engine>\n"
"    </httpj:engine-factory>\n"
"\n"
"    <jaxws:endpoint\n"
"                    implementor=\"org.keycloak.example.ws.ProductImpl\"\n"
"                    address=\"http://localhost:8282/ProductServiceCF\" depends-on=\"kc-cxf-endpoint\" />\n"
"\n"
"</beans>"
msgstr ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"\n"
"<beans xmlns=\"http://www.springframework.org/schema/beans\"\n"
"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"       xmlns:jaxws=\"http://cxf.apache.org/jaxws\"\n"
"       xmlns:httpj=\"http://cxf.apache.org/transports/http-jetty/configuration\"\n"
"       xsi:schemaLocation=\"\n"
"        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n"
"        http://cxf.apache.org/jaxws http://cxf.apache.org/schemas/jaxws.xsd\n"
"        http://www.springframework.org/schema/osgi http://www.springframework.org/schema/osgi/spring-osgi.xsd\n"
"        http://cxf.apache.org/transports/http-jetty/configuration http://cxf.apache.org/schemas/configuration/http-jetty.xsd\">\n"
"\n"
"    <import resource=\"classpath:META-INF/cxf/cxf.xml\" />\n"
"\n"
"    <bean id=\"kcAdapterConfig\" class=\"org.keycloak.representations.adapters.config.AdapterConfig\">\n"
"        <property name=\"realm\" value=\"demo\"/>\n"
"        <property name=\"resource\" value=\"custom-cxf-endpoint\"/>\n"
"        <property name=\"bearerOnly\" value=\"true\"/>\n"
"        <property name=\"authServerUrl\" value=\"http://localhost:8080{kc_base_path}\" />\n"
"        <property name=\"sslRequired\" value=\"EXTERNAL\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"keycloakAuthenticator\" class=\"org.keycloak.adapters.jetty.KeycloakJettyAuthenticator\">\n"
"        <property name=\"adapterConfig\">\n"
"            <ref local=\"kcAdapterConfig\" />\n"
"        </property>\n"
"    </bean>\n"
"\n"
"    <bean id=\"constraint\" class=\"org.eclipse.jetty.util.security.Constraint\">\n"
"        <property name=\"name\" value=\"Customers\"/>\n"
"        <property name=\"roles\">\n"
"            <list>\n"
"                <value>user</value>\n"
"            </list>\n"
"        </property>\n"
"        <property name=\"authenticate\" value=\"true\"/>\n"
"        <property name=\"dataConstraint\" value=\"0\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"constraintMapping\" class=\"org.eclipse.jetty.security.ConstraintMapping\">\n"
"        <property name=\"constraint\" ref=\"constraint\"/>\n"
"        <property name=\"pathSpec\" value=\"/*\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"securityHandler\" class=\"org.eclipse.jetty.security.ConstraintSecurityHandler\">\n"
"        <property name=\"authenticator\" ref=\"keycloakAuthenticator\" />\n"
"        <property name=\"constraintMappings\">\n"
"            <list>\n"
"                <ref local=\"constraintMapping\" />\n"
"            </list>\n"
"        </property>\n"
"        <property name=\"authMethod\" value=\"BASIC\"/>\n"
"        <property name=\"realmName\" value=\"does-not-matter\"/>\n"
"    </bean>\n"
"\n"
"    <httpj:engine-factory bus=\"cxf\" id=\"kc-cxf-endpoint\">\n"
"        <httpj:engine port=\"8282\">\n"
"            <httpj:handlers>\n"
"                <ref local=\"securityHandler\" />\n"
"            </httpj:handlers>\n"
"            <httpj:sessionSupport>true</httpj:sessionSupport>\n"
"        </httpj:engine>\n"
"    </httpj:engine-factory>\n"
"\n"
"    <jaxws:endpoint\n"
"                    implementor=\"org.keycloak.example.ws.ProductImpl\"\n"
"                    address=\"http://localhost:8282/ProductServiceCF\" depends-on=\"kc-cxf-endpoint\" />\n"
"\n"
"</beans>"

msgid ""
"For the CXF JAX-RS application, the only difference might be in the "
"configuration of the endpoint dependent on engine-factory:"
msgstr "CXFのJAX-RSアプリケーションの場合、engine-factortyに依存するエンドポイントの設定にのみ違いがある可能性があります。"

msgid ""
"<jaxrs:server serviceClass=\"org.keycloak.example.rs.CustomerService\" address=\"http://localhost:8282/rest\"\n"
"    depends-on=\"kc-cxf-endpoint\">\n"
"    <jaxrs:providers>\n"
"        <bean class=\"com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider\" />\n"
"    </jaxrs:providers>\n"
"</jaxrs:server>"
msgstr ""
"<jaxrs:server serviceClass=\"org.keycloak.example.rs.CustomerService\" address=\"http://localhost:8282/rest\"\n"
"    depends-on=\"kc-cxf-endpoint\">\n"
"    <jaxrs:providers>\n"
"        <bean class=\"com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider\" />\n"
"    </jaxrs:providers>\n"
"</jaxrs:server>"

msgid ""
"The `Import-Package` in `META-INF/MANIFEST.MF` must contain those imports:"
msgstr "`META-INF/MANIFEST.MF` の `Import-Package` は以下のインポートを含まなければなりません。"

msgid ""
"META-INF.cxf;version=\"[2.7,3.2)\",\n"
"META-INF.cxf.osgi;version=\"[2.7,3.2)\";resolution:=optional,\n"
"org.apache.cxf.bus;version=\"[2.7,3.2)\",\n"
"org.apache.cxf.bus.spring;version=\"[2.7,3.2)\",\n"
"org.apache.cxf.bus.resource;version=\"[2.7,3.2)\",\n"
"org.apache.cxf.transport.http;version=\"[2.7,3.2)\",\n"
"org.apache.cxf.*;version=\"[2.7,3.2)\",\n"
"org.springframework.beans.factory.config,\n"
"org.eclipse.jetty.security;version=\"[9,10)\",\n"
"org.eclipse.jetty.util.security;version=\"[9,10)\",\n"
"org.keycloak.*;version=\"{project_versionMvn}\""
msgstr ""
"META-INF.cxf;version=\"[2.7,3.2)\",\n"
"META-INF.cxf.osgi;version=\"[2.7,3.2)\";resolution:=optional,\n"
"org.apache.cxf.bus;version=\"[2.7,3.2)\",\n"
"org.apache.cxf.bus.spring;version=\"[2.7,3.2)\",\n"
"org.apache.cxf.bus.resource;version=\"[2.7,3.2)\",\n"
"org.apache.cxf.transport.http;version=\"[2.7,3.2)\",\n"
"org.apache.cxf.*;version=\"[2.7,3.2)\",\n"
"org.springframework.beans.factory.config,\n"
"org.eclipse.jetty.security;version=\"[9,10)\",\n"
"org.eclipse.jetty.util.security;version=\"[9,10)\",\n"
"org.keycloak.*;version=\"{project_versionMvn}\""

msgid "Securing an Apache CXF endpoint on the default Jetty Engine"
msgstr "デフォルトのJettyエンジンでのApache CXFエンドポイントのセキュリティー保護"

msgid ""
"Some services automatically come with deployed servlets on startup. One such"
" service is the CXF servlet running in the $$http://localhost:8181/cxf$$ "
"context. Securing such endpoints can be complicated. One approach, which "
"{project_name} is currently using, is ServletReregistrationService, which "
"undeploys a built-in servlet at startup, enabling you to redeploy it on a "
"context secured by {project_name}."
msgstr ""
"いくつかのサービスは、起動時にデプロイされたサーブレットを自動的に提供します。そのようなサービスの1つは、 "
"$$http://localhost:8181/cxf$$ "
"コンテキストで実行されているCXFサーブレットです。そのようなエンドポイントを保護することは複雑になる可能性があります。{project_name}が現在使用しているアプローチの1つは"
" `ServletReregistrationService` "
"で、これは組み込みのサーブレットを起動時にアンデプロイし、{project_name}によってセキュリティー保護されたコンテキストに再デプロイできるようにします。"

msgid ""
"The configuration file `OSGI-INF/blueprint/blueprint.xml` inside your "
"application might resemble the one below. Note that it adds the JAX-RS "
"`customerservice` endpoint, which is endpoint-specific to your application, "
"but more importantly, secures the entire `/cxf` context."
msgstr ""
"アプリケーション内の設定ファイル `OSGI-INF/blueprint/blueprint.xml` は、以下のようになります。JAX-RSの "
"`customerservice` エンドポイント（アプリケーション固有のエンドポイント）を追加しますが、もっと重要なのは、 `/cxf` "
"コンテキスト全体をセキュリティー保護することです。"

msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n"
"           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"           xmlns:jaxrs=\"http://cxf.apache.org/blueprint/jaxrs\"\n"
"           xsi:schemaLocation=\"\n"
"\t\thttp://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n"
"\t\thttp://cxf.apache.org/blueprint/jaxrs http://cxf.apache.org/schemas/blueprint/jaxrs.xsd\">\n"
"\n"
"    <!-- JAXRS Application -->\n"
"\n"
"    <bean id=\"customerBean\" class=\"org.keycloak.example.rs.CxfCustomerService\" />\n"
"\n"
"    <jaxrs:server id=\"cxfJaxrsServer\" address=\"/customerservice\">\n"
"        <jaxrs:providers>\n"
"            <bean class=\"com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider\" />\n"
"        </jaxrs:providers>\n"
"        <jaxrs:serviceBeans>\n"
"            <ref component-id=\"customerBean\" />\n"
"        </jaxrs:serviceBeans>\n"
"    </jaxrs:server>\n"
"\n"
"\n"
"    <!-- Securing of whole /cxf context by unregister default cxf servlet from paxweb and re-register with applied security constraints -->\n"
"\n"
"    <bean id=\"cxfConstraintMapping\" class=\"org.eclipse.jetty.security.ConstraintMapping\">\n"
"        <property name=\"constraint\">\n"
"            <bean class=\"org.eclipse.jetty.util.security.Constraint\">\n"
"                <property name=\"name\" value=\"cst1\"/>\n"
"                <property name=\"roles\">\n"
"                    <list>\n"
"                        <value>user</value>\n"
"                    </list>\n"
"                </property>\n"
"                <property name=\"authenticate\" value=\"true\"/>\n"
"                <property name=\"dataConstraint\" value=\"0\"/>\n"
"            </bean>\n"
"        </property>\n"
"        <property name=\"pathSpec\" value=\"/cxf/*\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"cxfKeycloakPaxWebIntegration\" class=\"org.keycloak.adapters.osgi.PaxWebIntegrationService\"\n"
"          init-method=\"start\" destroy-method=\"stop\">\n"
"        <property name=\"bundleContext\" ref=\"blueprintBundleContext\" />\n"
"        <property name=\"jettyWebXmlLocation\" value=\"/WEB-INF/jetty-web.xml\" />\n"
"        <property name=\"constraintMappings\">\n"
"            <list>\n"
"                <ref component-id=\"cxfConstraintMapping\" />\n"
"            </list>\n"
"        </property>\n"
"    </bean>\n"
"\n"
"    <bean id=\"defaultCxfReregistration\" class=\"org.keycloak.adapters.osgi.ServletReregistrationService\" depends-on=\"cxfKeycloakPaxWebIntegration\"\n"
"          init-method=\"start\" destroy-method=\"stop\">\n"
"        <property name=\"bundleContext\" ref=\"blueprintBundleContext\" />\n"
"        <property name=\"managedServiceReference\">\n"
"            <reference interface=\"org.osgi.service.cm.ManagedService\" filter=\"(service.pid=org.apache.cxf.osgi)\" timeout=\"5000\"  />\n"
"        </property>\n"
"    </bean>\n"
"\n"
"</blueprint>"
msgstr ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n"
"           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"           xmlns:jaxrs=\"http://cxf.apache.org/blueprint/jaxrs\"\n"
"           xsi:schemaLocation=\"\n"
"\t\thttp://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n"
"\t\thttp://cxf.apache.org/blueprint/jaxrs http://cxf.apache.org/schemas/blueprint/jaxrs.xsd\">\n"
"\n"
"    <!-- JAXRS Application -->\n"
"\n"
"    <bean id=\"customerBean\" class=\"org.keycloak.example.rs.CxfCustomerService\" />\n"
"\n"
"    <jaxrs:server id=\"cxfJaxrsServer\" address=\"/customerservice\">\n"
"        <jaxrs:providers>\n"
"            <bean class=\"com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider\" />\n"
"        </jaxrs:providers>\n"
"        <jaxrs:serviceBeans>\n"
"            <ref component-id=\"customerBean\" />\n"
"        </jaxrs:serviceBeans>\n"
"    </jaxrs:server>\n"
"\n"
"\n"
"    <!-- Securing of whole /cxf context by unregister default cxf servlet from paxweb and re-register with applied security constraints -->\n"
"\n"
"    <bean id=\"cxfConstraintMapping\" class=\"org.eclipse.jetty.security.ConstraintMapping\">\n"
"        <property name=\"constraint\">\n"
"            <bean class=\"org.eclipse.jetty.util.security.Constraint\">\n"
"                <property name=\"name\" value=\"cst1\"/>\n"
"                <property name=\"roles\">\n"
"                    <list>\n"
"                        <value>user</value>\n"
"                    </list>\n"
"                </property>\n"
"                <property name=\"authenticate\" value=\"true\"/>\n"
"                <property name=\"dataConstraint\" value=\"0\"/>\n"
"            </bean>\n"
"        </property>\n"
"        <property name=\"pathSpec\" value=\"/cxf/*\"/>\n"
"    </bean>\n"
"\n"
"    <bean id=\"cxfKeycloakPaxWebIntegration\" class=\"org.keycloak.adapters.osgi.PaxWebIntegrationService\"\n"
"          init-method=\"start\" destroy-method=\"stop\">\n"
"        <property name=\"bundleContext\" ref=\"blueprintBundleContext\" />\n"
"        <property name=\"jettyWebXmlLocation\" value=\"/WEB-INF/jetty-web.xml\" />\n"
"        <property name=\"constraintMappings\">\n"
"            <list>\n"
"                <ref component-id=\"cxfConstraintMapping\" />\n"
"            </list>\n"
"        </property>\n"
"    </bean>\n"
"\n"
"    <bean id=\"defaultCxfReregistration\" class=\"org.keycloak.adapters.osgi.ServletReregistrationService\" depends-on=\"cxfKeycloakPaxWebIntegration\"\n"
"          init-method=\"start\" destroy-method=\"stop\">\n"
"        <property name=\"bundleContext\" ref=\"blueprintBundleContext\" />\n"
"        <property name=\"managedServiceReference\">\n"
"            <reference interface=\"org.osgi.service.cm.ManagedService\" filter=\"(service.pid=org.apache.cxf.osgi)\" timeout=\"5000\"  />\n"
"        </property>\n"
"    </bean>\n"
"\n"
"</blueprint>"

msgid ""
"As a result, all other CXF services running on the default CXF HTTP "
"destination are also secured. Similarly, when the application is undeployed,"
" the entire `/cxf` context becomes unsecured as well. For this reason, using"
" your own Jetty engine for your applications as described in "
"<<_fuse_adapter_cxf_separate,Secure CXF Application on separate Jetty "
"Engine>> then gives you more control over security for each individual "
"application."
msgstr ""
"その結果、デフォルトのCXF HTTPの宛先で実行されている他のすべてのCXFサービスも保護されます。同様に、アプリケーションがアンデプロイされると、 "
"`/cxf` "
"コンテキスト全体がセキュリティー保護されなくなります。このため、<<_fuse_adapter_cxf_separate,独立したJettyエンジンでのApache"
" "
"CXFエンドポイントの保護>>で説明されているように、独自のJettyエンジンをアプリケーションに使用すると、個々のアプリケーションのセキュリティーをより詳細に制御できます。"

msgid ""
"The `WEB-INF` directory might need to be inside your project (even if your "
"project is not a web application). You might also need to edit the `/WEB-"
"INF/jetty-web.xml` and `/WEB-INF/keycloak.json` files in a similar way as in"
" <<_fuse_adapter_classic_war,Classic WAR application>>. Note that you do not"
" need the `web.xml` file as the security constraints are declared in the "
"blueprint configuration file."
msgstr ""
"`WEB-INF` ディレクトリーはプロジェクト内にある必要があります（プロジェクトがWebアプリケーションでない場合でも）。 "
"また、<<_fuse_adapter_classic_war,クラシックWARアプリケーション>>と同様に、 `/WEB-INF/jetty-"
"web.xml` および `/WEB-INF/keycloak.json` "
"ファイルを編集する必要があります。セキュリティー制約がblueprint設定ファイルで宣言されているので、 `web.xml` "
"ファイルは必要ないことに注意してください。"

msgid ""
"The `Import-Package` in `META-INF/MANIFEST.MF` must contain these imports:"
msgstr "`META-INF/MANIFEST.MF` の `Import-Package` は以下のインポートを含まなければなりません。"

msgid ""
"META-INF.cxf;version=\"[2.7,3.2)\",\n"
"META-INF.cxf.osgi;version=\"[2.7,3.2)\";resolution:=optional,\n"
"org.apache.cxf.transport.http;version=\"[2.7,3.2)\",\n"
"org.apache.cxf.*;version=\"[2.7,3.2)\",\n"
"com.fasterxml.jackson.jaxrs.json;version=\"[2.5,3)\",\n"
"org.eclipse.jetty.security;version=\"[9,10)\",\n"
"org.eclipse.jetty.util.security;version=\"[9,10)\",\n"
"org.keycloak.*;version=\"{project_versionMvn}\",\n"
"org.keycloak.adapters.jetty;version=\"{project_versionMvn}\",\n"
"*;resolution:=optional"
msgstr ""
"META-INF.cxf;version=\"[2.7,3.2)\",\n"
"META-INF.cxf.osgi;version=\"[2.7,3.2)\";resolution:=optional,\n"
"org.apache.cxf.transport.http;version=\"[2.7,3.2)\",\n"
"org.apache.cxf.*;version=\"[2.7,3.2)\",\n"
"com.fasterxml.jackson.jaxrs.json;version=\"[2.5,3)\",\n"
"org.eclipse.jetty.security;version=\"[9,10)\",\n"
"org.eclipse.jetty.util.security;version=\"[9,10)\",\n"
"org.keycloak.*;version=\"{project_versionMvn}\",\n"
"org.keycloak.adapters.jetty;version=\"{project_versionMvn}\",\n"
"*;resolution:=optional"

msgid "Securing Fuse Administration Services"
msgstr "Fuse管理サービスのセキュリティー保護"

msgid "Using SSH Authentication to Fuse Terminal"
msgstr "FuseターミナルへのSSH認証の使用"

msgid ""
"{project_name} mainly addresses use cases for authentication of web "
"applications; however, if your other web services and applications are "
"protected with {project_name}, protecting non-web administration services "
"such as SSH with {project_name} credentials is a best pracrice. You can do "
"this using the JAAS login module, which allows remote connection to "
"{project_name} and verifies credentials based on "
"<<_resource_owner_password_credentials_flow,Resource Owner Password "
"Credentials>>."
msgstr ""
"{project_name}は、主にWebアプリケーションの認証のユースケースを扱います。ただし、他のWebサービスやアプリケーションが{project_name}で保護されている場合は、{project_name}のクレデンシャルでSSHなどのWeb以外の管理サービスを保護するのが最善の方法です。これは、{project_name}へのリモート接続を許可し、<<_resource_owner_password_credentials_flow,リソース・オーナー・パスワード・クレデンシャル>>に基づいてクレデンシャルを検証するJAASログイン・モジュールを使用して実行できます。"

msgid "To enable SSH authentication, perform the following procedure."
msgstr "SSH認証を有効にするには、次の手順を実行します。"

msgid ""
"In  {project_name} create a client (for example, `ssh-jmx-admin-client`), "
"which will be used for SSH authentication. This client needs to have `Direct"
" Access Grants Enabled` selected to `On`."
msgstr ""
"{project_name}では、SSH認証に使用されるクライアント（たとえば、 `ssh-jmx-admin-client` "
"）を作成します。このクライアントでは、 `Direct Access Grants Enabled` が `On` に選択されている必要があります。"

msgid ""
"In the `$FUSE_HOME/etc/org.apache.karaf.shell.cfg` file, update or specify "
"this property:"
msgstr ""
"`$FUSE_HOME/etc/org.apache.karaf.shell.cfg` ファイルで、次のとおりにこのプロパティーを更新または指定します。"

msgid "sshRealm=keycloak"
msgstr "sshRealm=keycloak"

msgid ""
"Add the `$FUSE_HOME/etc/keycloak-direct-access.json` file with content "
"similar to the following (based on your environment and {project_name} "
"client settings):"
msgstr ""
"（環境と{project_name}のクライアント設定に基づいて）次のような内容で `$FUSE_HOME/etc/keycloak-direct-"
"access.json` ファイルを追加してください。"

msgid ""
"{\n"
"    \"realm\": \"demo\",\n"
"    \"resource\": \"ssh-jmx-admin-client\",\n"
"    \"ssl-required\" : \"external\",\n"
"    \"auth-server-url\" : \"http://localhost:8080{kc_base_path}\",\n"
"    \"credentials\": {\n"
"        \"secret\": \"password\"\n"
"    }\n"
"}"
msgstr ""
"{\n"
"    \"realm\": \"demo\",\n"
"    \"resource\": \"ssh-jmx-admin-client\",\n"
"    \"ssl-required\" : \"external\",\n"
"    \"auth-server-url\" : \"http://localhost:8080{kc_base_path}\",\n"
"    \"credentials\": {\n"
"        \"secret\": \"password\"\n"
"    }\n"
"}"

msgid ""
"This file specifies the client application configuration, which is used by "
"JAAS DirectAccessGrantsLoginModule from the `keycloak` JAAS realm for SSH "
"authentication."
msgstr ""
"このファイルでは、JAASの `DirectAccessGrantsLoginModule` がSSH認証のために `keycloak` "
"JAASレルムから使用するクライアント・アプリケーションの設定を指定します。"

msgid ""
"Start Fuse and install the `keycloak` JAAS realm. The easiest way is to "
"install the `keycloak-jaas` feature, which has the JAAS realm predefined. "
"You can override the feature's predefined realm by using your own `keycloak`"
" JAAS realm with higher ranking. For details see the "
"https://access.redhat.com/documentation/en-us/red_hat_jboss_fuse/6.3/html-"
"single/security_guide/#ESBSecureContainer[JBoss Fuse documentation]."
msgstr ""
"Fuseを起動し、 `keycloak` JAASレルムをインストールしてください。最も簡単な方法は、JAASレルムがあらかじめ定義された "
"`keycloak-jaas` フィーチャーをインストールすることです。より高いランクの独自 `keycloak` "
"JAASレルムを使用して、フィーチャーに定義済みのレルムをオーバーライドすることができます。詳細については、 "
"https://access.redhat.com/documentation/en-us/red_hat_jboss_fuse/6.3/html-"
"single/security_guide/#ESBSecureContainer[JBoss Fuse "
"documentation]を参照してください。"

msgid "Use these commands in the Fuse terminal:"
msgstr "Fuseターミナルで次のコマンドを使用します。"

msgid ""
"features:addurl mvn:org.keycloak/keycloak-osgi-features/{project_versionMvn}/xml/features\n"
"features:install keycloak-jaas"
msgstr ""
"features:addurl mvn:org.keycloak/keycloak-osgi-features/{project_versionMvn}/xml/features\n"
"features:install keycloak-jaas"

msgid ""
"Log in using SSH as `admin` user by typing the following in the terminal:"
msgstr "SSHで `admin` ユーザーとしてログインするには、ターミナルで次のように入力します。"

msgid "ssh -o PubkeyAuthentication=no -p 8101 admin@localhost"
msgstr "ssh -o PubkeyAuthentication=no -p 8101 admin@localhost"

msgid "Log in with password `password`."
msgstr "パスワードは `password` でログインしてください。"

msgid ""
"On some later operating systems, you might also need to use the SSH "
"command's -o option `-o HostKeyAlgorithms=+ssh-dss` because later SSH "
"clients do not allow use of the `ssh-dss` algorithm, by default. However, by"
" default, it is currently used in {fuseVersion}."
msgstr ""
"最近のオペレーティング・システムでは、SSHコマンドの-oオプションを `-o HostKeyAlgorithms=+ssh-dss` "
"として使用する必要があるかもしれません。これは、最近のSSHクライアントではデフォルトで `ssh-dss` "
"アルゴリズムを使用できないためです。しかし、現在{fuseVersion}ではデフォルトで使用されています。"

msgid ""
"Note that the user needs to have realm role `admin` to perform all "
"operations or another role to perform a subset of operations (for example, "
"the *viewer* role that restricts the user to run only read-only Karaf "
"commands). The available roles are configured in "
"`$FUSE_HOME/etc/org.apache.karaf.shell.cfg` or "
"`$FUSE_HOME/etc/system.properties`."
msgstr ""
"ユーザーはすべての操作を実行するために、レルムロール `admin` "
"を持つ必要があることに注意してください。また、操作のサブセットを実行するためには別のロールが必要となります（たとえば、読み取り専用のKarafコマンドのみを実行するようにユーザーを制限する"
" *viewer* ロール）。利用可能なロールは、 `$FUSE_HOME/etc/org.apache.karaf.shell.cfg` または "
"`$FUSE_HOME/etc/system.properties` で設定されます。"

msgid "Using JMX authentication"
msgstr "JMX認証の使用"

msgid ""
"JMX authentication might be necessary if you want to use jconsole or another"
" external tool to remotely connect to JMX through RMI. Otherwise it might be"
" better to use hawt.io/jolokia, since the jolokia agent is installed in "
"hawt.io by default. For more details see <<_hawtio,Hawtio Admin Console>>."
msgstr ""
"jconsoleまたは別の外部ツールを使用してRMI経由でJMXにリモート接続する場合は、JMX認証が必要になることがあります。それ以外の場合は、デフォルトでhaolt.ioにjolokiaエージェントがインストールされているので、hawt.io/jolokiaを使用する方がよいでしょう。詳細については、<<_hawtio,Hawtio"
" Admin Console>>を参照してください。"

msgid ""
"In the `$FUSE_HOME/etc/org.apache.karaf.management.cfg` file, change the "
"jmxRealm property to:"
msgstr ""
"`$FUSE_HOME/etc/org.apache.karaf.management.cfg` ファイルで、 `jmxRealm` "
"プロパティーを次のように変更します。"

msgid "jmxRealm=keycloak"
msgstr "jmxRealm=keycloak"

msgid ""
"Install the `keycloak-jaas` feature and configure the "
"`$FUSE_HOME/etc/keycloak-direct-access.json` file as described in the SSH "
"section above."
msgstr ""
"上記のSSHのセクションで説明したように、 `keycloak-jaas` フィーチャーをインストールし、 "
"`$FUSE_HOME/etc/keycloak-direct-access.json` ファイルを設定してください。"

msgid "In jconsole you can use a URL such as:"
msgstr "jconsoleでは、次のようなURLを使用できます。"

msgid "service:jmx:rmi://localhost:44444/jndi/rmi://localhost:1099/karaf-root"
msgstr ""
"service:jmx:rmi://localhost:44444/jndi/rmi://localhost:1099/karaf-root"

msgid ""
"and credentials: admin/password (based on the user with admin privileges "
"according to your environment)."
msgstr "クレデンシャルはadmin/password（利用環境の管理者権限を持つユーザー次第）です。"

msgid "Securing the Hawtio Administration Console"
msgstr "Hawtio管理コンソールのセキュリティー保護"

msgid ""
"To secure the Hawtio Administration Console with {project_name}, perform the"
" following procedure."
msgstr ""
"Hawtio Administration Consoleを{project_name}でセキュリティー保護するには、次の手順を実行します。"

msgid "Add these properties to the `$FUSE_HOME/etc/system.properties` file:"
msgstr "これらのプロパティーを `$FUSE_HOME/etc/system.properties` ファイルに追加します。"

msgid ""
"hawtio.keycloakEnabled=true\n"
"hawtio.realm=keycloak\n"
"hawtio.keycloakClientConfig=file://${karaf.base}/etc/keycloak-hawtio-client.json\n"
"hawtio.rolePrincipalClasses=org.keycloak.adapters.jaas.RolePrincipal,org.apache.karaf.jaas.boot.principal.RolePrincipal"
msgstr ""
"hawtio.keycloakEnabled=true\n"
"hawtio.realm=keycloak\n"
"hawtio.keycloakClientConfig=file://${karaf.base}/etc/keycloak-hawtio-client.json\n"
"hawtio.rolePrincipalClasses=org.keycloak.adapters.jaas.RolePrincipal,org.apache.karaf.jaas.boot.principal.RolePrincipal"

msgid ""
"Create a client in the {project_name} Admin Console in your realm. For "
"example, in the {project_name} `demo` realm, create a client `hawtio-"
"client`, specify `public` as the Access Type, and specify a redirect URI "
"pointing to Hawtio: \\http://localhost:8181/hawtio/*. You must also have a "
"corresponding Web Origin configured (in this case, \\http://localhost:8181)."
msgstr ""
"利用レルムの{project_name}管理コンソールにクライアントを作成します。たとえば、{project_name}の `demo` "
"レルムでクライアント `hawtio-client` を作成し、アクセス・タイプとして `public` を指定し、Hawtio: "
"\\http://localhost:8181/hawtio/* を指すリダイレクトURIを指定します。また、対応するWeb Origin（この場合は、"
" \\http://localhost:8181）も設定する必要があります。"

msgid ""
"Create the `keycloak-hawtio-client.json` file in the `$FUSE_HOME/etc` "
"directory using content similar to that shown in the example below. Change "
"the `realm`, `resource`, and `auth-server-url` properties according to your "
"{project_name} environment. The `resource` property must point to the client"
" created in the previous step. This file is used by the client (Hawtio "
"JavaScript application) side."
msgstr ""
"`$FUSE_HOME/etc` ディレクトリーに `keycloak-hawtio-client.json` "
"ファイルを作成します。このファイルは、以下の例のような内容で作成します。{project_name}環境に応じて、 `realm` 、 "
"`resource` 、 `auth-server-url` の各プロパティーを変更してください。 `resource` "
"プロパティーは前のステップで作成されたクライアントを指し示さなければなりません。このファイルは、クライアント（Hawtio "
"JavaScriptアプリケーション）側で使用されます。"

msgid ""
"{\n"
"  \"realm\" : \"demo\",\n"
"  \"resource\" : \"hawtio-client\",\n"
"  \"auth-server-url\" : \"http://localhost:8080{kc_base_path}\",\n"
"  \"ssl-required\" : \"external\",\n"
"  \"public-client\" : true\n"
"}"
msgstr ""
"{\n"
"  \"realm\" : \"demo\",\n"
"  \"resource\" : \"hawtio-client\",\n"
"  \"auth-server-url\" : \"http://localhost:8080{kc_base_path}\",\n"
"  \"ssl-required\" : \"external\",\n"
"  \"public-client\" : true\n"
"}"

msgid ""
"Create the `keycloak-hawtio.json` file in the `$FUSE_HOME/etc` dicrectory "
"using content similar to that shown in the example below. Change the `realm`"
" and `auth-server-url` properties according to your {project_name} "
"environment. This file is used by the adapters on the server (JAAS Login "
"module) side."
msgstr ""
"`$FUSE_HOME/etc` ディレクトリーに `keycloak-hawtio.json` "
"ファイルを作成します。このファイルは、以下の例のような内容です。{project_name}の環境に応じて `realm` と `auth-"
"server-url` プロパティーを変更してください。このファイルは、サーバー（JAASログイン・モジュール）側のアダプターによって使用されます。"

msgid ""
"{\n"
"  \"realm\" : \"demo\",\n"
"  \"resource\" : \"jaas\",\n"
"  \"bearer-only\" : true,\n"
"  \"auth-server-url\" : \"http://localhost:8080{kc_base_path}\",\n"
"  \"ssl-required\" : \"external\",\n"
"  \"use-resource-role-mappings\": false,\n"
"  \"principal-attribute\": \"preferred_username\"\n"
"}"
msgstr ""
"{\n"
"  \"realm\" : \"demo\",\n"
"  \"resource\" : \"jaas\",\n"
"  \"bearer-only\" : true,\n"
"  \"auth-server-url\" : \"http://localhost:8080{kc_base_path}\",\n"
"  \"ssl-required\" : \"external\",\n"
"  \"use-resource-role-mappings\": false,\n"
"  \"principal-attribute\": \"preferred_username\"\n"
"}"

msgid ""
"Start {fuseVersion} and install the keycloak feature if you have not already"
" done so. The commands in Karaf terminal are similar to this example:"
msgstr ""
"Keycloakフィーチャーをまだインストールしていない場合は、{fuseVersion}を起動し、インストールしてください。Karafターミナルのコマンドはこの例に似ています。"

msgid ""
"Go to http://localhost:8181/hawtio and log in as a user from your "
"{project_name} realm."
msgstr "http://localhost:8181/hawtio に移動し、{project_name}のレルムからユーザーとしてログインします。"

msgid ""
"Note that the user needs to have the proper realm role to successfully "
"authenticate to Hawtio. The available roles are configured in the "
"`$FUSE_HOME/etc/system.properties` file in `hawtio.roles`."
msgstr ""
"Hawtioに対して正常に認証するには、ユーザーが適切なレルムロールを持っている必要があることに注意してください。利用可能なロールは、 "
"`hawtio.roles` の `$FUSE_HOME/etc/system.properties` ファイルで設定されます。"

msgid "Securing Hawtio on {fuseHawtioEAPVersion}"
msgstr "{fuseHawtioEAPVersion}上のHawtioのセキュリティー保護"

msgid ""
"Set up {project_name} as described in <<_hawtio,Securing the Hawtio "
"Administration Console>>. It is assumed that:"
msgstr ""
"<<_hawtio,Securing the Hawtio Administration Console>> "
"にあるように、{project_name}をセットアップします。以下を想定しています。"

msgid "you have a {project_name} realm `demo` and client `hawtio-client`"
msgstr "{project_name}のレルムのデモとクライアント `hawtio-client` を持っている"

msgid "your {project_name} is running on `localhost:8080`"
msgstr "{project_name}が `localhost:8080` で動作している"

msgid ""
"the {fuseHawtioEAPVersion} server with deployed Hawtio will be running on "
"`localhost:8181`. The directory with this server is referred in next steps "
"as `$EAP_HOME`."
msgstr ""
"展開されたHawtioがある{fuseHawtioEAPVersion}サーバーは `localhost:8181` "
"で動作します。このサーバーのディレクトリーは、次のステップでは、 `$EAP_HOME` と呼ばれます。"

msgid ""
"Copy the `{fuseHawtioWARVersion}` archive to the "
"`$EAP_HOME/standalone/configuration` directory. For more details about "
"deploying Hawtio see the https://access.redhat.com/documentation/en-"
"us/red_hat_jboss_fuse/6.3/html-single/deploying_into_a_web_server/[Fuse "
"Hawtio documentation]."
msgstr ""
"`{fuseHawtioWARVersion}` アーカイブを `$EAP_HOME/standalone/configuration` "
"ディレクトリーにコピーします。Hawtioの導入の詳細については、 "
"https://access.redhat.com/documentation/en-us/red_hat_jboss_fuse/6.3/html-"
"single/deploying_into_a_web_server/[Fuse Hawtio documentation]を参照してください。"

msgid ""
"Copy the `keycloak-hawtio.json` and `keycloak-hawtio-client.json` files with"
" the above content to the `$EAP_HOME/standalone/configuration` directory."
msgstr ""
"上記内容の `keycloak-hawtio.json` ファイルと `keycloak-hawtio-client.json` ファイルを "
"`$EAP_HOME/standalone/configuration` ディレクトリーにコピーします。"

msgid ""
"Install the {project_name} adapter subsystem to your {fuseHawtioEAPVersion} "
"server as described in the <<_jboss_adapter,JBoss adapter documentation>>."
msgstr ""
"<<_jboss_adapter,JBossアダプターのドキュメント>>の説明に従って、{project_name}アダプター・サブシステムを{fuseHawtioEAPVersion}サーバーにインストールします。"

msgid ""
"In the `$EAP_HOME/standalone/configuration/standalone.xml` file configure "
"the system properties as in this example:"
msgstr ""
"`$EAP_HOME/standalone/configuration/standalone.xml` "
"ファイルで、次の例のようにシステムのプロパティーを設定します。"

msgid ""
"<extensions>\n"
"...\n"
"</extensions>\n"
"\n"
"<system-properties>\n"
"    <property name=\"hawtio.authenticationEnabled\" value=\"true\" />\n"
"    <property name=\"hawtio.realm\" value=\"hawtio\" />\n"
"    <property name=\"hawtio.roles\" value=\"admin,viewer\" />\n"
"    <property name=\"hawtio.rolePrincipalClasses\" value=\"org.keycloak.adapters.jaas.RolePrincipal\" />\n"
"    <property name=\"hawtio.keycloakEnabled\" value=\"true\" />\n"
"    <property name=\"hawtio.keycloakClientConfig\" value=\"${jboss.server.config.dir}/keycloak-hawtio-client.json\" />\n"
"    <property name=\"hawtio.keycloakServerConfig\" value=\"${jboss.server.config.dir}/keycloak-hawtio.json\" />\n"
"</system-properties>"
msgstr ""
"<extensions>\n"
"...\n"
"</extensions>\n"
"\n"
"<system-properties>\n"
"    <property name=\"hawtio.authenticationEnabled\" value=\"true\" />\n"
"    <property name=\"hawtio.realm\" value=\"hawtio\" />\n"
"    <property name=\"hawtio.roles\" value=\"admin,viewer\" />\n"
"    <property name=\"hawtio.rolePrincipalClasses\" value=\"org.keycloak.adapters.jaas.RolePrincipal\" />\n"
"    <property name=\"hawtio.keycloakEnabled\" value=\"true\" />\n"
"    <property name=\"hawtio.keycloakClientConfig\" value=\"${jboss.server.config.dir}/keycloak-hawtio-client.json\" />\n"
"    <property name=\"hawtio.keycloakServerConfig\" value=\"${jboss.server.config.dir}/keycloak-hawtio.json\" />\n"
"</system-properties>"

msgid ""
"Add the Hawtio realm to the same file in the `security-domains` section:"
msgstr "Hawtioレルムを同じファイルの `security-domains` セクションに追加します。"

msgid ""
"<security-domain name=\"hawtio\" cache-type=\"default\">\n"
"    <authentication>\n"
"        <login-module code=\"org.keycloak.adapters.jaas.BearerTokenLoginModule\" flag=\"required\">\n"
"            <module-option name=\"keycloak-config-file\" value=\"${hawtio.keycloakServerConfig}\"/>\n"
"        </login-module>\n"
"    </authentication>\n"
"</security-domain>"
msgstr ""
"<security-domain name=\"hawtio\" cache-type=\"default\">\n"
"    <authentication>\n"
"        <login-module code=\"org.keycloak.adapters.jaas.BearerTokenLoginModule\" flag=\"required\">\n"
"            <module-option name=\"keycloak-config-file\" value=\"${hawtio.keycloakServerConfig}\"/>\n"
"        </login-module>\n"
"    </authentication>\n"
"</security-domain>"

msgid ""
"Add the `secure-deployment` section `hawtio` to the adapter subsystem. This "
"ensures that the Hawtio WAR is able to find the JAAS login module classes."
msgstr ""
"`hawtio` の `secure-deployment` セクションをアダプター・サブシステムに追加してください。これにより、Hawtio "
"WARがJAASログイン・モジュール・クラスを見つけることができます。"

msgid ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak:1.1\">\n"
"    <secure-deployment name=\"{fuseHawtioWARVersion}\" />\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak:1.1\">\n"
"    <secure-deployment name=\"{fuseHawtioWARVersion}\" />\n"
"</subsystem>"

msgid "Restart the {fuseHawtioEAPVersion} server with Hawtio:"
msgstr "Hawtioと{fuseHawtioEAPVersion}サーバーを再起動します。"

msgid ""
"cd $EAP_HOME/bin\n"
"./standalone.sh -Djboss.socket.binding.port-offset=101"
msgstr ""
"cd $EAP_HOME/bin\n"
"./standalone.sh -Djboss.socket.binding.port-offset=101"

msgid ""
"Access Hawtio at http://localhost:8181/hawtio. It is secured by "
"{project_name}."
msgstr ""
"Hawtio（ http://localhost:8181/hawtio "
"）へアクセスしてください。{project_name}によってセキュリティー保護されています。"

msgid "JBoss Fuse 7 Adapter"
msgstr "JBoss Fuse 7アダプター"

msgid ""
"{project_name} supports securing your web applications running inside "
"https://developers.redhat.com/products/fuse/overview[JBoss Fuse 7]."
msgstr ""
"{project_name}は https://developers.redhat.com/products/fuse/overview[JBoss "
"Fuse 7] 内で実行されているWebアプリケーションのセキュリティー保護をサポートしています。"

msgid ""
"JBoss Fuse 7 leverages Undertow adapter which is essentially the same as "
"<<_jboss_adapter,EAP 7 / WildFly Adapter>> as {fuse7Version} is bundled with"
" the Undertow HTTP engine under the covers and Undertow is used for running "
"various kinds of web applications."
msgstr ""
"JBoss Fuse 7は、基本的に同等である<<_jboss_adapter,EAP 7 / "
"WildFlyアダプター>>を利用しています。{fuse7Version}はUndertow HTTP Engineを "
"{fuse7Version}しており、Undertowはさまざまな種類のWebアプリケーションの実行に使用されています。"

msgid ""
"The only supported version of Fuse 7 is the latest release. If you use "
"earlier versions of Fuse 7, it is possible that some functions will not work"
" correctly. In particular, integration will not work at all for versions of "
"Fuse 7 lower than 7.0.1."
msgstr ""
"サポートされているFuse 7のバージョンは最新リリースのみです。以前のバージョンのFuse "
"7を使用している場合、一部の機能が正しく動作しない可能性があります。特に、7.0.1より前のバージョンのFuse 7では、統合はまったく機能しません。"

msgid ""
"Servlets deployed on Fuse as OSGI services with Pax Web Whiteboard Extender "
"and additionally servlets registered through "
"org.osgi.service.http.HttpService#registerServlet() which is standard OSGi "
"Enterprise HTTP Service"
msgstr ""
"Pax Web Whiteboard Extenderを使用してFuseにOSGIサービスとしてデプロイされたサーブレットと、さらに標準のOSGi "
"Enterprise HTTP "
"Serviceであるorg.osgi.service.http.HttpService#registerServlet()によって登録されたサーブレット"

msgid ""
"https://camel.apache.org/[Apache Camel] Undertow endpoints running with the "
"https://camel.apache.org/components/next/undertow-component.html[Camel "
"Undertow] component"
msgstr ""
"https://camel.apache.org/components/next/undertow-component.html[Camel "
"Undertow] コンポーネントで動作する https://camel.apache.org/[Apache Camel] "
"Undertowエンドポイント"

msgid ""
"https://cxf.apache.org/[Apache CXF] endpoints running on their own separate "
"Undertow engine"
msgstr "独自の分離されたUndertowエンジンで動作する https://cxf.apache.org/[Apache CXF] エンドポイント"

msgid "Securing your web applications inside Fuse 7"
msgstr "Fuse 7内でWebアプリケーションをセキュリティー保護する"

msgid ""
"You must first install the {project_name} Karaf feature. Next you will need "
"to perform the steps according to the type of application you want to "
"secure. All referenced web applications require injecting the {project_name}"
" Undertow authentication mechanism into the underlying web server. The steps"
" to achieve this depend on the application type. The details are described "
"below."
msgstr ""
"最初に{project_name} "
"Karafのフィーチャーをインストールする必要があります。次に、セキュリティー保護するアプリケーションの種類に応じた手順を実行する必要があります。参照されているすべてのWebアプリケーションで、{project_name}"
" "
"Undertow認証メカニズムを、基盤となるWebサーバーに注入する必要があります。これを達成するための手順は、アプリケーションの種類によって異なります。詳細は以下のとおりです。"

msgid ""
"The best place to start is look at Fuse demo bundled as part of "
"{project_name} examples in directory `fuse` . Most of the steps should be "
"understandable from testing and understanding the demo."
msgstr ""
"始めるのに最適なのは、 `fuse` "
"ディレクトリー内の{project_name}のサンプルの一部としてバンドルされているFuseのデモを見ることです。ほとんどの手順はテストとデモから理解できるはずです。"

msgid ""
"You must first install the `keycloak-pax-http-undertow` and `keycloak-jaas` "
"features in the JBoss Fuse environment. The `keycloak-pax-http-undertow` "
"feature includes the Fuse adapter and all third-party dependencies. The "
"`keycloak-jaas` contains JAAS module used in realm for SSH and JMX "
"authentication. You can install it either from the Maven repository or from "
"an archive."
msgstr ""
"最初に `keycloak-pax-http-undertow` と `keycloak-jaas` のフィーチャーをJBoss "
"Fuse環境にインストールする必要があります。 `keycloak-pax-http-undertow` "
"フィーチャーには、Fuseアダプターとサードパーティーのすべての依存関係が含まれます。 `keycloak-jaas` "
"には、SSHとJMX認証のためにレルムで使用されるJAASモジュールが含まれています。Mavenリポジトリーまたはアーカイブからインストールすることができます。"

msgid "Start {fuse7Version}"
msgstr "{fuseVersion}を起動します。"

msgid "In the Karaf terminal, type:"
msgstr "Karaf端末で以下をタイプします。"

msgid ""
"feature:repo-add mvn:org.keycloak/keycloak-osgi-features/{project_versionMvn}/xml/features\n"
"feature:install keycloak-pax-http-undertow keycloak-jaas"
msgstr ""
"feature:repo-add mvn:org.keycloak/keycloak-osgi-features/{project_versionMvn}/xml/features\n"
"feature:install keycloak-pax-http-undertow keycloak-jaas"

msgid "You might also need to install the Undertow feature:"
msgstr "以下のようにUndertowフィーチャーをインストールする必要もあるかもしれません。"

msgid "feature:install pax-http-undertow"
msgstr "feature:install pax-http-undertow"

msgid "feature:list | grep keycloak"
msgstr "feature:list | grep keycloak"

msgid ""
"This is useful if you are offline or do not want to use Maven to obtain the "
"JAR files and other artifacts."
msgstr "これは、オフラインになっている場合や、Mavenを使用してJARファイルやその他のアーティファクトを取得したくない場合に便利です。"

msgid "Use this for {fuse7Version}:"
msgstr "{Fuse7Version}には、これを使用します。"

msgid ""
"cd /path-to-fuse/fuse-karaf-7.z\n"
"unzip -q /path-to-adapter-zip/keycloak-fuse-adapter-{project_versionMvn}.zip"
msgstr ""
"cd /path-to-fuse/fuse-karaf-7.z\n"
"unzip -q /path-to-adapter-zip/keycloak-fuse-adapter-{project_versionMvn}.zip"

msgid ""
"Install the corresponding Undertow adapter. Since the artifacts are "
"available directly in the JBoss Fuse `system` directory, you do not need to "
"use the Maven repository."
msgstr ""
"対応するUndertowアダプターをインストールします。アーティファクトはJBoss Fuseの `system` "
"ディレクトリーから直接利用できるので、Mavenリポジトリーを使う必要はありません。"

msgid ""
"login configuration in the <login-config> element. Make sure that the "
"`<auth-method>` is `KEYCLOAK`."
msgstr ""
"<login-config> 要素内のログイン設定。 `<auth-method>` が `KEYCLOAK` であることを確認してください。"

msgid "security roles in the <security-role> element"
msgstr "<security-role> 要素のセキュリティー・ロール。"

msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"         version=\"3.0\">\n"
"\n"
"    <module-name>customer-portal</module-name>\n"
"\n"
"    <welcome-file-list>\n"
"        <welcome-file>index.html</welcome-file>\n"
"    </welcome-file-list>\n"
"\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Customers</web-resource-name>\n"
"            <url-pattern>/customers/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>user</role-name>\n"
"        </auth-constraint>\n"
"    </security-constraint>\n"
"\n"
"    <login-config>\n"
"        <auth-method>KEYCLOAK</auth-method>\n"
"        <realm-name>does-not-matter</realm-name>\n"
"    </login-config>\n"
"\n"
"    <security-role>\n"
"        <role-name>admin</role-name>\n"
"    </security-role>\n"
"    <security-role>\n"
"        <role-name>user</role-name>\n"
"    </security-role>\n"
"</web-app>"
msgstr ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"         version=\"3.0\">\n"
"\n"
"    <module-name>customer-portal</module-name>\n"
"\n"
"    <welcome-file-list>\n"
"        <welcome-file>index.html</welcome-file>\n"
"    </welcome-file-list>\n"
"\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Customers</web-resource-name>\n"
"            <url-pattern>/customers/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>user</role-name>\n"
"        </auth-constraint>\n"
"    </security-constraint>\n"
"\n"
"    <login-config>\n"
"        <auth-method>KEYCLOAK</auth-method>\n"
"        <realm-name>does-not-matter</realm-name>\n"
"    </login-config>\n"
"\n"
"    <security-role>\n"
"        <role-name>admin</role-name>\n"
"    </security-role>\n"
"    <security-role>\n"
"        <role-name>user</role-name>\n"
"    </security-role>\n"
"</web-app>"

msgid ""
"{\n"
"    \"realm\": \"demo\",\n"
"    \"resource\": \"customer-portal\",\n"
"    \"auth-server-url\": \"http://localhost:8080{kc_base_path}\",\n"
"    \"ssl-required\" : \"external\",\n"
"    \"credentials\": {\n"
"        \"secret\": \"password\"\n"
"    }\n"
"}"
msgstr ""
"{\n"
"    \"realm\": \"demo\",\n"
"    \"resource\": \"customer-portal\",\n"
"    \"auth-server-url\": \"http://localhost:8080{kc_base_path}\",\n"
"    \"ssl-required\" : \"external\",\n"
"    \"credentials\": {\n"
"        \"secret\": \"password\"\n"
"    }\n"
"}"

msgid ""
"Contrary to the Fuse 6 adapter, there are no special OSGi imports needed in "
"MANIFEST.MF."
msgstr "Fuse 6アダプターとは異なり、MANIFEST.MFには特別なOSGiのインポートは必要ありません。"

msgid "Configuration resolvers"
msgstr "設定リゾルバー"

msgid ""
"The `keycloak.json` adapter configuration file can be stored inside a "
"bundle, which is default behaviour, or in a directory on a filesystem. To "
"specify the actual source of the configuration file, set the "
"`keycloak.config.resolver` deployment parameter to the desired configuration"
" resolver class. For example, in a classic WAR application, set the "
"`keycloak.config.resolver` context parameter in `web.xml` file like this:"
msgstr ""
"`keycloak.json` "
"アダプター設定ファイルはバンドル内か（デフォルトの動作）、ファイルシステム上のディレクトリーに保存することができます。設定ファイルの実際のソースを指定するには、"
" `keycloak.config.resolver` "
"配備パラメーターを目的の設定リゾルバークラスに設定します。たとえば、古典的なWARアプリケーションでは、 `web.xml` ファイルに "
"`keycloak.config.resolver` コンテキスト・パラメーターを以下のように設定します。"

msgid "The following resolvers are available for `keycloak.config.resolver`:"
msgstr "`keycloak.config.resolver` には、次のリゾルバーがあります。"

msgid "org.keycloak.adapters.osgi.BundleBasedKeycloakConfigResolver"
msgstr "org.keycloak.adapters.osgi.BundleBasedKeycloakConfigResolver"

msgid ""
"This is the default resolver. The configuration file is expected inside the "
"OSGi bundle that is being secured. By default, it loads file named `WEB-"
"INF/keycloak.json` but this file name can be configured via `configLocation`"
" property."
msgstr ""
"これがデフォルトのリゾルバーです。設定ファイルは、セキュリティー保護されているOSGiバンドル内にあります。デフォルトでは、 `WEB-"
"INF/keycloak.json` という名前のファイルをロードしますが、このファイル名は `configLocation` "
"プロパティーで設定できます。"

msgid "org.keycloak.adapters.osgi.PathBasedKeycloakConfigResolver"
msgstr "org.keycloak.adapters.osgi.PathBasedKeycloakConfigResolver"

msgid ""
"This resolver searches for a file called `<your_web_context>-keycloak.json` "
"inside a folder that is specified by `keycloak.config` system property. If "
"`keycloak.config` is not set, `karaf.etc` system property is used instead."
msgstr ""
"このリゾルバーは、 `keycloak.config` システム・プロパティーで指定されたフォルダーの中で "
"`<your_web_context>-keycloak.json` というファイルを探します。 `keycloak.config` "
"が設定されていなければ、代わりに `karaf.etc` システム・プロパティーが使われます。"

msgid ""
"For example, if your web application is deployed into context `my-portal`, "
"then   your adapter configuration would be loaded either from the   "
"`${keycloak.config}/my-portal-keycloak.json` file, or from `${karaf.etc}/my-"
"portal-keycloak.json`."
msgstr ""
"たとえば、Webアプリケーションがコンテキスト `my-portal` にデプロイされている場合、アダプターの設定は "
"`${keycloak.config}/my-portal-keycloak.json` ファイルか `${karaf.etc}/my-portal-"
"keycloak.json` のいずれかからロードされます。"

msgid "org.keycloak.adapters.osgi.HierarchicalPathBasedKeycloakConfigResolver"
msgstr ""
"org.keycloak.adapters.osgi.HierarchicalPathBasedKeycloakConfigResolver"

msgid ""
"This resolver is similar to `PathBasedKeycloakConfigResolver` above, where "
"for given URI path, configuration locations are checked from most to least "
"specific."
msgstr ""
"このリゾルバーは、上記の `PathBasedKeycloakConfigResolver` "
"に似ています。与えられたURIパスに対して、設定の場所が手当たり次第にチェックされます。"

msgid ""
"For example, for `/my/web-app/context` URI, the following configuration "
"locations are searched for existence until the first one exists:"
msgstr "たとえば、URIが `/my/web-app/context` の場合、設定場所が存在するまで、次のものが存在するかどうかが検索されます。"

msgid "`${karaf.etc}/my-web-app-context-keycloak.json`"
msgstr "`${karaf.etc}/my-web-app-context-keycloak.json`"

msgid "`${karaf.etc}/my-web-app-keycloak.json`"
msgstr "`${karaf.etc}/my-web-app-keycloak.json`"

msgid "`${karaf.etc}/my-keycloak.json`"
msgstr "`${karaf.etc}/my-keycloak.json`"

msgid "`${karaf.etc}/keycloak.json`"
msgstr "`${karaf.etc}/keycloak.json`"

msgid ""
"{project_name} provides "
"`org.keycloak.adapters.osgi.undertow.PaxWebIntegrationService`, which allows"
" configuring authentication method and security constraints for your "
"application. You need to declare such services in the `OSGI-"
"INF/blueprint/blueprint.xml` file inside your application. Note that your "
"servlet needs to depend on it. An example configuration:"
msgstr ""
"{project_name}は "
"`org.keycloak.adapters.osgi.undertow.PaxWebIntegrationService` "
"を提供します。これにより、アプリケーションに認証方法とセキュリティー制約の設定を設定できます。アプリケーション内の `OSGI-"
"INF/blueprint/blueprint.xml` "
"ファイルでそのようなサービスを宣言する必要があります。サーブレットはそれに依存する必要があることに注意してください。設定例は次のとおりです。"

msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n"
"           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"           xsi:schemaLocation=\"http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\">\n"
"\n"
"    <bean id=\"servletConstraintMapping\" class=\"org.keycloak.adapters.osgi.PaxWebSecurityConstraintMapping\">\n"
"        <property name=\"roles\">\n"
"            <list>\n"
"                <value>user</value>\n"
"            </list>\n"
"        </property>\n"
"        <property name=\"authentication\" value=\"true\"/>\n"
"        <property name=\"url\" value=\"/product-portal/*\"/>\n"
"    </bean>\n"
"\n"
"    <!-- This handles the integration and setting the login-config and security-constraints parameters -->\n"
"    <bean id=\"keycloakPaxWebIntegration\" class=\"org.keycloak.adapters.osgi.undertow.PaxWebIntegrationService\"\n"
"          init-method=\"start\" destroy-method=\"stop\">\n"
"        <property name=\"bundleContext\" ref=\"blueprintBundleContext\" />\n"
"        <property name=\"constraintMappings\">\n"
"            <list>\n"
"                <ref component-id=\"servletConstraintMapping\" />\n"
"            </list>\n"
"        </property>\n"
"    </bean>\n"
"\n"
"    <bean id=\"productServlet\" class=\"org.keycloak.example.ProductPortalServlet\" depends-on=\"keycloakPaxWebIntegration\" />\n"
"\n"
"    <service ref=\"productServlet\" interface=\"javax.servlet.Servlet\">\n"
"        <service-properties>\n"
"            <entry key=\"alias\" value=\"/product-portal\" />\n"
"            <entry key=\"servlet-name\" value=\"ProductServlet\" />\n"
"            <entry key=\"keycloak.config.file\" value=\"/keycloak.json\" />\n"
"        </service-properties>\n"
"    </service>\n"
"</blueprint>"
msgstr ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n"
"           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"           xsi:schemaLocation=\"http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\">\n"
"\n"
"    <bean id=\"servletConstraintMapping\" class=\"org.keycloak.adapters.osgi.PaxWebSecurityConstraintMapping\">\n"
"        <property name=\"roles\">\n"
"            <list>\n"
"                <value>user</value>\n"
"            </list>\n"
"        </property>\n"
"        <property name=\"authentication\" value=\"true\"/>\n"
"        <property name=\"url\" value=\"/product-portal/*\"/>\n"
"    </bean>\n"
"\n"
"    <!-- This handles the integration and setting the login-config and security-constraints parameters -->\n"
"    <bean id=\"keycloakPaxWebIntegration\" class=\"org.keycloak.adapters.osgi.undertow.PaxWebIntegrationService\"\n"
"          init-method=\"start\" destroy-method=\"stop\">\n"
"        <property name=\"bundleContext\" ref=\"blueprintBundleContext\" />\n"
"        <property name=\"constraintMappings\">\n"
"            <list>\n"
"                <ref component-id=\"servletConstraintMapping\" />\n"
"            </list>\n"
"        </property>\n"
"    </bean>\n"
"\n"
"    <bean id=\"productServlet\" class=\"org.keycloak.example.ProductPortalServlet\" depends-on=\"keycloakPaxWebIntegration\" />\n"
"\n"
"    <service ref=\"productServlet\" interface=\"javax.servlet.Servlet\">\n"
"        <service-properties>\n"
"            <entry key=\"alias\" value=\"/product-portal\" />\n"
"            <entry key=\"servlet-name\" value=\"ProductServlet\" />\n"
"            <entry key=\"keycloak.config.file\" value=\"/keycloak.json\" />\n"
"        </service-properties>\n"
"    </service>\n"
"</blueprint>"

msgid ""
"You might need to have the `WEB-INF` directory inside your project (even if "
"your project is not a web application) and create the `/WEB-"
"INF/keycloak.json` file as  described in the "
"<<_fuse7_adapter_classic_war,Classic WAR application>> section. Note you "
"don't need the `web.xml` file as the security-constraints are declared in "
"the blueprint configuration file."
msgstr ""
"プロジェクト内に `WEB-INF` "
"ディレクトリー（プロジェクトがWebアプリケーションでない場合でも）を用意し、<<_fuse7_adapter_classic_war, "
"クラシックWARアプリケーション>>のセクションのような `/WEB-INF/keycloak.json` "
"ファイルを作成する必要があります。security-constraintsがblueprint設定ファイルで宣言されているので、 `web.xml` "
"ファイルは必要ありません。"

msgid ""
"You can secure Apache Camel endpoints implemented with the "
"https://camel.apache.org/components/next/undertow-component.html[camel-"
"undertow] component by injecting the proper security constraints via "
"blueprint and updating the used component to `undertow-keycloak`. You have "
"to add the `OSGI-INF/blueprint/blueprint.xml` file to your Camel application"
" with a similar configuration as below. The roles, security constraint "
"mappings, and adapter configuration might differ slightly depending on your "
"environment and needs."
msgstr ""
"https://camel.apache.org/components/next/undertow-component.html[camel-"
"undertow]コンポーネントで実装されたApache "
"Camelエンドポイントをセキュリティー保護するには、適切なセキュリティー制約をBlueprintを介して注入し、使用されるコンポーネントを "
"`undertow-keycloak` に更新します。以下のような設定で、 `OSGI-INF/blueprint/blueprint.xml` "
"ファイルをCamelアプリケーションに追加する必要があります。ロール、セキュリティー制約のマッピング、およびアダプターの設定は、使用する環境と必要性により若干異なる場合があります。"

msgid ""
"Compared to the standard `undertow` component, `undertow-keycloak` component"
" adds two new properties:"
msgstr ""
"標準の `undertow` コンポーネントと比較して、 `undertow-keycloak` "
"コンポーネントは次の2つの新しいプロパティーを追加します。"

msgid ""
"`configResolver` is a resolver bean that supplies {project_name} adapter "
"configuration. Available resolvers are listed in "
"<<_fuse7_config_external_adapter,Configuration Resolvers>> section."
msgstr ""
"`configResolver` "
"は、{project_name}アダプター設定を提供するリゾルバービーンです。利用可能なリゾルバーは、<<_fuse7_config_external_adapter,設定リゾルバー>>セクションにリストされています。"

msgid ""
"`allowedRoles` is a comma-separated list of roles. User accessing the "
"service has to have at least one role to be permitted the access."
msgstr ""
"`allowedRoles` "
"はカンマで区切られたロールのリストです。サービスにアクセスするユーザーは、アクセスを許可されるロールを少なくとも1つは持っていなければなりません。"

msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n"
"           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"           xmlns:camel=\"http://camel.apache.org/schema/blueprint\"\n"
"           xsi:schemaLocation=\"\n"
"       http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n"
"       http://camel.apache.org/schema/blueprint http://camel.apache.org/schema/blueprint/camel-blueprint-2.17.1.xsd\">\n"
"\n"
"    <bean id=\"keycloakConfigResolver\" class=\"org.keycloak.adapters.osgi.BundleBasedKeycloakConfigResolver\" >\n"
"        <property name=\"bundleContext\" ref=\"blueprintBundleContext\" />\n"
"    </bean>\n"
"\n"
"    <bean id=\"helloProcessor\" class=\"org.keycloak.example.CamelHelloProcessor\" />\n"
"\n"
"    <camelContext id=\"blueprintContext\"\n"
"                  trace=\"false\"\n"
"                  xmlns=\"http://camel.apache.org/schema/blueprint\">\n"
"\n"
"        <route id=\"httpBridge\">\n"
"            <from uri=\"undertow-keycloak:http://0.0.0.0:8383/admin-camel-endpoint?matchOnUriPrefix=true&amp;configResolver=#keycloakConfigResolver&amp;allowedRoles=admin\" />\n"
"            <process ref=\"helloProcessor\" />\n"
"            <log message=\"The message from camel endpoint contains ${body}\"/>\n"
"        </route>\n"
"\n"
"    </camelContext>\n"
"\n"
"</blueprint>"
msgstr ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n"
"           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"           xmlns:camel=\"http://camel.apache.org/schema/blueprint\"\n"
"           xsi:schemaLocation=\"\n"
"       http://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n"
"       http://camel.apache.org/schema/blueprint http://camel.apache.org/schema/blueprint/camel-blueprint-2.17.1.xsd\">\n"
"\n"
"    <bean id=\"keycloakConfigResolver\" class=\"org.keycloak.adapters.osgi.BundleBasedKeycloakConfigResolver\" >\n"
"        <property name=\"bundleContext\" ref=\"blueprintBundleContext\" />\n"
"    </bean>\n"
"\n"
"    <bean id=\"helloProcessor\" class=\"org.keycloak.example.CamelHelloProcessor\" />\n"
"\n"
"    <camelContext id=\"blueprintContext\"\n"
"                  trace=\"false\"\n"
"                  xmlns=\"http://camel.apache.org/schema/blueprint\">\n"
"\n"
"        <route id=\"httpBridge\">\n"
"            <from uri=\"undertow-keycloak:http://0.0.0.0:8383/admin-camel-endpoint?matchOnUriPrefix=true&amp;configResolver=#keycloakConfigResolver&amp;allowedRoles=admin\" />\n"
"            <process ref=\"helloProcessor\" />\n"
"            <log message=\"The message from camel endpoint contains ${body}\"/>\n"
"        </route>\n"
"\n"
"    </camelContext>\n"
"\n"
"</blueprint>"

msgid ""
"javax.servlet;version=\"[3,4)\",\n"
"javax.servlet.http;version=\"[3,4)\",\n"
"javax.net.ssl,\n"
"org.apache.camel.*,\n"
"org.apache.camel;version=\"[2.13,3)\",\n"
"io.undertow.*,\n"
"org.keycloak.*;version=\"{project_versionMvn}\",\n"
"org.osgi.service.blueprint,\n"
"org.osgi.service.blueprint.container"
msgstr ""
"javax.servlet;version=\"[3,4)\",\n"
"javax.servlet.http;version=\"[3,4)\",\n"
"javax.net.ssl,\n"
"org.apache.camel.*,\n"
"org.apache.camel;version=\"[2.13,3)\",\n"
"io.undertow.*,\n"
"org.keycloak.*;version=\"{project_versionMvn}\",\n"
"org.osgi.service.blueprint,\n"
"org.osgi.service.blueprint.container"

msgid ""
"The following example shows how to configure integration using the "
"`undertow-keycloak` component, with references to some of the beans defined "
"in previous Blueprint example."
msgstr ""
"次の例は、 `undertow-keycloak` "
"コンポーネントを使用して統合を設定する方法を示しています。前回のBlueprintの例で定義されたBeanのいくつかを参照しています。"

msgid ""
"<camelContext id=\"blueprintContext\"\n"
"              trace=\"false\"\n"
"              xmlns=\"http://camel.apache.org/schema/blueprint\">\n"
"\n"
"    <!--the link with Keycloak security handlers happens by using undertow-keycloak component -->\n"
"    <restConfiguration apiComponent=\"undertow-keycloak\" contextPath=\"/restdsl\" port=\"8484\">\n"
"        <endpointProperty key=\"configResolver\" value=\"#keycloakConfigResolver\" />\n"
"        <endpointProperty key=\"allowedRoles\" value=\"admin,superadmin\" />\n"
"    </restConfiguration>\n"
"\n"
"    <rest path=\"/hello\" >\n"
"        <description>Hello rest service</description>\n"
"        <get uri=\"/{id}\" outType=\"java.lang.String\">\n"
"            <description>Just a hello</description>\n"
"            <to uri=\"direct:justDirect\" />\n"
"        </get>\n"
"\n"
"    </rest>\n"
"\n"
"    <route id=\"justDirect\">\n"
"        <from uri=\"direct:justDirect\"/>\n"
"        <process ref=\"helloProcessor\" />\n"
"        <log message=\"RestDSL correctly invoked ${body}\"/>\n"
"        <setBody>\n"
"            <constant>(__This second sentence is returned from a Camel RestDSL endpoint__)</constant>\n"
"        </setBody>\n"
"    </route>\n"
"\n"
"</camelContext>\n"
msgstr ""
"<camelContext id=\"blueprintContext\"\n"
"              trace=\"false\"\n"
"              xmlns=\"http://camel.apache.org/schema/blueprint\">\n"
"\n"
"    <!--the link with Keycloak security handlers happens by using undertow-keycloak component -->\n"
"    <restConfiguration apiComponent=\"undertow-keycloak\" contextPath=\"/restdsl\" port=\"8484\">\n"
"        <endpointProperty key=\"configResolver\" value=\"#keycloakConfigResolver\" />\n"
"        <endpointProperty key=\"allowedRoles\" value=\"admin,superadmin\" />\n"
"    </restConfiguration>\n"
"\n"
"    <rest path=\"/hello\" >\n"
"        <description>Hello rest service</description>\n"
"        <get uri=\"/{id}\" outType=\"java.lang.String\">\n"
"            <description>Just a hello</description>\n"
"            <to uri=\"direct:justDirect\" />\n"
"        </get>\n"
"\n"
"    </rest>\n"
"\n"
"    <route id=\"justDirect\">\n"
"        <from uri=\"direct:justDirect\"/>\n"
"        <process ref=\"helloProcessor\" />\n"
"        <log message=\"RestDSL correctly invoked ${body}\"/>\n"
"        <setBody>\n"
"            <constant>(__This second sentence is returned from a Camel RestDSL endpoint__)</constant>\n"
"        </setBody>\n"
"    </route>\n"
"\n"
"</camelContext>\n"

msgid "Securing an Apache CXF endpoint on a separate Undertow Engine"
msgstr "分離されたUndertowエンジンでのApache CXFエンドポイントのセキュリティー保護"

msgid ""
"To run your CXF endpoints secured by {project_name} on a separate Undertow "
"engine, perform the following procedure."
msgstr ""
"別々のUndertowエンジンで{project_name}でセキュリティー保護されたCXFエンドポイントを実行するには、次の手順を実行します。"

msgid ""
"Add `OSGI-INF/blueprint/blueprint.xml` to your application, and in it, add "
"the proper configuration resolver bean similarly to "
"<<_fuse7_adapter_camel,Camel configuration>>. In the `httpu:engine-factory` "
"declare `org.keycloak.adapters.osgi.undertow.CxfKeycloakAuthHandler` handler"
" using that camel configuration. The configuration for a CFX JAX-WS "
"application might resemble this one:"
msgstr ""
"アプリケーションに `OSGI-INF/blueprint/blueprint.xml` "
"を追加し、その中に<<_fuse7_adapter_camel, Camelの設定>>と同様の適切な設定リゾルバービーンを追加します。 "
"`httpu:engine-factory` の中で、そのCamelの設定を使って "
"`org.keycloak.adapters.osgi.undertow.CxfKeycloakAuthHandler` ハンドラーを宣言します。CFX"
" JAX-WSアプリケーションの設定は、次のようになります。"

msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n"
"           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"           xmlns:jaxws=\"http://cxf.apache.org/blueprint/jaxws\"\n"
"           xmlns:cxf=\"http://cxf.apache.org/blueprint/core\"\n"
"           xmlns:httpu=\"http://cxf.apache.org/transports/http-undertow/configuration\".\n"
"           xsi:schemaLocation=\"\n"
"      http://cxf.apache.org/transports/http-undertow/configuration http://cxf.apache.org/schemas/configuration/http-undertow.xsd\n"
"      http://cxf.apache.org/blueprint/core http://cxf.apache.org/schemas/blueprint/core.xsd\n"
"      http://cxf.apache.org/blueprint/jaxws http://cxf.apache.org/schemas/blueprint/jaxws.xsd\">\n"
"\n"
"    <bean id=\"keycloakConfigResolver\" class=\"org.keycloak.adapters.osgi.BundleBasedKeycloakConfigResolver\" >\n"
"        <property name=\"bundleContext\" ref=\"blueprintBundleContext\" />\n"
"    </bean>\n"
"\n"
"    <httpu:engine-factory bus=\"cxf\" id=\"kc-cxf-endpoint\">\n"
"        <httpu:engine port=\"8282\">\n"
"            <httpu:handlers>\n"
"                <bean class=\"org.keycloak.adapters.osgi.undertow.CxfKeycloakAuthHandler\">\n"
"                    <property name=\"configResolver\" ref=\"keycloakConfigResolver\" />\n"
"                </bean>\n"
"            </httpu:handlers>\n"
"        </httpu:engine>\n"
"    </httpu:engine-factory>\n"
"\n"
"    <jaxws:endpoint implementor=\"org.keycloak.example.ws.ProductImpl\"\n"
"                    address=\"http://localhost:8282/ProductServiceCF\" depends-on=\"kc-cxf-endpoint\"/>\n"
"\n"
"</blueprint>"
msgstr ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n"
"           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"           xmlns:jaxws=\"http://cxf.apache.org/blueprint/jaxws\"\n"
"           xmlns:cxf=\"http://cxf.apache.org/blueprint/core\"\n"
"           xmlns:httpu=\"http://cxf.apache.org/transports/http-undertow/configuration\".\n"
"           xsi:schemaLocation=\"\n"
"      http://cxf.apache.org/transports/http-undertow/configuration http://cxf.apache.org/schemas/configuration/http-undertow.xsd\n"
"      http://cxf.apache.org/blueprint/core http://cxf.apache.org/schemas/blueprint/core.xsd\n"
"      http://cxf.apache.org/blueprint/jaxws http://cxf.apache.org/schemas/blueprint/jaxws.xsd\">\n"
"\n"
"    <bean id=\"keycloakConfigResolver\" class=\"org.keycloak.adapters.osgi.BundleBasedKeycloakConfigResolver\" >\n"
"        <property name=\"bundleContext\" ref=\"blueprintBundleContext\" />\n"
"    </bean>\n"
"\n"
"    <httpu:engine-factory bus=\"cxf\" id=\"kc-cxf-endpoint\">\n"
"        <httpu:engine port=\"8282\">\n"
"            <httpu:handlers>\n"
"                <bean class=\"org.keycloak.adapters.osgi.undertow.CxfKeycloakAuthHandler\">\n"
"                    <property name=\"configResolver\" ref=\"keycloakConfigResolver\" />\n"
"                </bean>\n"
"            </httpu:handlers>\n"
"        </httpu:engine>\n"
"    </httpu:engine-factory>\n"
"\n"
"    <jaxws:endpoint implementor=\"org.keycloak.example.ws.ProductImpl\"\n"
"                    address=\"http://localhost:8282/ProductServiceCF\" depends-on=\"kc-cxf-endpoint\"/>\n"
"\n"
"</blueprint>"

msgid ""
"META-INF.cxf;version=\"[2.7,3.3)\",\n"
"META-INF.cxf.osgi;version=\"[2.7,3.3)\";resolution:=optional,\n"
"org.apache.cxf.bus;version=\"[2.7,3.3)\",\n"
"org.apache.cxf.bus.spring;version=\"[2.7,3.3)\",\n"
"org.apache.cxf.bus.resource;version=\"[2.7,3.3)\",\n"
"org.apache.cxf.transport.http;version=\"[2.7,3.3)\",\n"
"org.apache.cxf.*;version=\"[2.7,3.3)\",\n"
"org.springframework.beans.factory.config,\n"
"org.keycloak.*;version=\"{project_versionMvn}\""
msgstr ""
"META-INF.cxf;version=\"[2.7,3.3)\",\n"
"META-INF.cxf.osgi;version=\"[2.7,3.3)\";resolution:=optional,\n"
"org.apache.cxf.bus;version=\"[2.7,3.3)\",\n"
"org.apache.cxf.bus.spring;version=\"[2.7,3.3)\",\n"
"org.apache.cxf.bus.resource;version=\"[2.7,3.3)\",\n"
"org.apache.cxf.transport.http;version=\"[2.7,3.3)\",\n"
"org.apache.cxf.*;version=\"[2.7,3.3)\",\n"
"org.springframework.beans.factory.config,\n"
"org.keycloak.*;version=\"{project_versionMvn}\""

msgid "Securing an Apache CXF endpoint on the default Undertow Engine"
msgstr "デフォルトのUndertowエンジンでのApache CXFエンドポイントの保護"

msgid ""
"Some services automatically come with deployed servlets on startup. One such"
" service is the CXF servlet running in the $$http://localhost:8181/cxf$$ "
"context. Fuse's Pax Web supports altering existing contexts via "
"configuration admin. This can be used to secure endpoints by {project_name}."
msgstr ""
"いくつかのサービスは、起動時にデプロイされたサーブレットを自動的に提供します。そのようなサービスの1つは、 "
"$$http://localhost:8181/cxf$$ コンテキストで実行されているCXFサーブレットです。FuseのPax "
"Webは、設定管理を介して既存のコンテキストを変更することをサポートしています。これは、{project_name}でエンドポイントを保護するために使用できます。"

msgid ""
"The configuration file `OSGI-INF/blueprint/blueprint.xml` inside your "
"application might resemble the one below. Note that it adds the JAX-RS "
"`customerservice` endpoint, which is endpoint-specific to your application."
msgstr ""
"アプリケーション内の設定ファイル `OSGI-INF/blueprint/blueprint.xml` "
"は、以下のようになります。アプリケーションにJAX-RSの `customerservice` "
"エンドポイント（アプリケーション固有のエンドポイント）を追加することに注意してください。"

msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n"
"           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"           xmlns:jaxrs=\"http://cxf.apache.org/blueprint/jaxrs\"\n"
"           xsi:schemaLocation=\"\n"
"\t\thttp://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n"
"\t\thttp://cxf.apache.org/blueprint/jaxrs http://cxf.apache.org/schemas/blueprint/jaxrs.xsd\">\n"
"\n"
"    <!-- JAXRS Application -->\n"
"    <bean id=\"customerBean\" class=\"org.keycloak.example.rs.CxfCustomerService\" />\n"
"\n"
"    <jaxrs:server id=\"cxfJaxrsServer\" address=\"/customerservice\">\n"
"        <jaxrs:providers>\n"
"            <bean class=\"com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider\" />\n"
"        </jaxrs:providers>\n"
"        <jaxrs:serviceBeans>\n"
"            <ref component-id=\"customerBean\" />\n"
"        </jaxrs:serviceBeans>\n"
"    </jaxrs:server>\n"
"</blueprint>"
msgstr ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<blueprint xmlns=\"http://www.osgi.org/xmlns/blueprint/v1.0.0\"\n"
"           xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"           xmlns:jaxrs=\"http://cxf.apache.org/blueprint/jaxrs\"\n"
"           xsi:schemaLocation=\"\n"
"\t\thttp://www.osgi.org/xmlns/blueprint/v1.0.0 http://www.osgi.org/xmlns/blueprint/v1.0.0/blueprint.xsd\n"
"\t\thttp://cxf.apache.org/blueprint/jaxrs http://cxf.apache.org/schemas/blueprint/jaxrs.xsd\">\n"
"\n"
"    <!-- JAXRS Application -->\n"
"    <bean id=\"customerBean\" class=\"org.keycloak.example.rs.CxfCustomerService\" />\n"
"\n"
"    <jaxrs:server id=\"cxfJaxrsServer\" address=\"/customerservice\">\n"
"        <jaxrs:providers>\n"
"            <bean class=\"com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider\" />\n"
"        </jaxrs:providers>\n"
"        <jaxrs:serviceBeans>\n"
"            <ref component-id=\"customerBean\" />\n"
"        </jaxrs:serviceBeans>\n"
"    </jaxrs:server>\n"
"</blueprint>"

msgid ""
"Furthermore, you have to create `${karaf.etc}/org.ops4j.pax.web.context-"
"_anyName_.cfg file`. It will be treated as factory PID configuration that is"
" tracked by `pax-web-runtime` bundle. Such configuration may contain the "
"following properties that correspond to some of the properties of standard "
"`web.xml`:"
msgstr ""
"さらに `${karaf.etc}/org.ops4j.pax.web.context-_anyName_.cfg file` "
"を作成する必要があります。これは、 `pax-web-runtime` "
"バンドルによって追跡されるファクトリーPID設定として扱われます。このような設定には、標準の `web.xml` "
"のいくつかのプロパティーに対応する以下のプロパティーを含めることができます。"

msgid ""
"bundle.symbolicName = org.apache.cxf.cxf-rt-transports-http\n"
"context.id = default\n"
"\n"
"context.param.keycloak.config.resolver = org.keycloak.adapters.osgi.HierarchicalPathBasedKeycloakConfigResolver\n"
"\n"
"login.config.authMethod = KEYCLOAK\n"
"\n"
"security.cxf.url = /cxf/customerservice/*\n"
"security.cxf.roles = admin, user"
msgstr ""
"bundle.symbolicName = org.apache.cxf.cxf-rt-transports-http\n"
"context.id = default\n"
"\n"
"context.param.keycloak.config.resolver = org.keycloak.adapters.osgi.HierarchicalPathBasedKeycloakConfigResolver\n"
"\n"
"login.config.authMethod = KEYCLOAK\n"
"\n"
"security.cxf.url = /cxf/customerservice/*\n"
"security.cxf.roles = admin, user"

msgid ""
"For full description of available properties in configuration admin file, "
"please refer to Fuse documentation. The properties above have the following "
"meaning:"
msgstr ""
"設定管理ファイルで利用可能なプロパティーの詳細については、Fuseのドキュメントを参照してください。上記のプロパティーの意味は次のとおりです。"

msgid "`bundle.symbolicName` and `context.id`"
msgstr "`bundle.symbolicName` と `context.id`"

msgid ""
"Identification of the bundle and its deployment context within "
"`org.ops4j.pax.web.service.WebContainer`."
msgstr "`org.ops4j.pax.web.service.WebContainer` 内のバンドルとその配備コンテキストの識別。"

msgid "`context.param.keycloak.config.resolver`"
msgstr "`context.param.keycloak.config.resolver`"

msgid ""
"Provides value of `keycloak.config.resolver` context parameter to the bundle"
" just the same as in `web.xml` for classic WARs. Available resolvers are "
"described in <<_fuse7_config_external_adapter,Configuration Resolvers>> "
"section."
msgstr ""
"古典的なWARの `web.xml` とまったく同じバンドルへの `keycloak.config.resolver` "
"コンテキスト・パラメーターの値を提供します。使用可能なリゾルバーについては、<<_fuse7_config_external_adapter,設定リゾルバー>>のセクションで説明しています。"

msgid "`login.config.authMethod`"
msgstr "`login.config.authMethod`"

msgid "Authentication method. Must be `KEYCLOAK`."
msgstr "認証方法。 `KEYCLOAK` でなければなりません。"

msgid "`security._anyName_.url` and `security._anyName_.roles`"
msgstr "`security._anyName_.url` と `security._anyName_.roles`"

msgid ""
"Values of properties of individual security constraints just as they would "
"be set in `security-constraint/web-resource-collection/url-pattern` and "
"`security-constraint/auth-constraint/role-name` in `web.xml`, respectively. "
"Roles are separated by comma and whitespace around it. The `_anyName_` "
"identifier can be arbitrary but must match for individual properties of the "
"same security constraint."
msgstr ""
"`web.xml` の `security-constraint/web-resource-collection/url-pattern` と "
"`security-constraint/auth-constraint/role-name` "
"に設定されているように、それぞれ、ロールはカンマとその周囲の空白で区切られます。 `_anyName_` "
"識別子は任意ですが、同じセキュリティー制約の個々のプロパティーに一致する必要があります。"

msgid ""
"Some Fuse versions contain a bug that requires roles to be separated by `\","
" \"` (comma and single space). Make sure you use precisely this notation for"
" separating the roles."
msgstr ""
"一部のFuseのバージョンには、ロールを `\", \"` "
"（カンマと単一のスペース）で区切らなければならないバグがあります。ロールを区切るためにこの表記法を正確に使用してください。"

msgid ""
"javax.ws.rs;version=\"[2,3)\",\n"
"META-INF.cxf;version=\"[2.7,3.3)\",\n"
"META-INF.cxf.osgi;version=\"[2.7,3.3)\";resolution:=optional,\n"
"org.apache.cxf.transport.http;version=\"[2.7,3.3)\",\n"
"org.apache.cxf.*;version=\"[2.7,3.3)\",\n"
"com.fasterxml.jackson.jaxrs.json;version=\"${jackson.version}\""
msgstr ""
"javax.ws.rs;version=\"[2,3)\",\n"
"META-INF.cxf;version=\"[2.7,3.3)\",\n"
"META-INF.cxf.osgi;version=\"[2.7,3.3)\";resolution:=optional,\n"
"org.apache.cxf.transport.http;version=\"[2.7,3.3)\",\n"
"org.apache.cxf.*;version=\"[2.7,3.3)\",\n"
"com.fasterxml.jackson.jaxrs.json;version=\"${jackson.version}\""

msgid ""
"Start Fuse and install the `keycloak` JAAS realm. The easiest way is to "
"install the `keycloak-jaas` feature, which has the JAAS realm predefined. "
"You can override the feature's predefined realm by using your own `keycloak`"
" JAAS realm with higher ranking. For details see the "
"https://access.redhat.com/documentation/en-us/red_hat_fuse/7.2/html-"
"single/apache_karaf_security_guide/index#ESBSecureContainer[JBoss Fuse "
"documentation]."
msgstr ""
"Fuseを起動し、 `keycloak` のJAASレルムをインストールしてください。最も簡単な方法は、JAASレルムがあらかじめ定義された "
"`keycloak-jaas` 機能をインストールすることです。独自の `keycloak` "
"JAASレルムを使用して、より高いランクでその機能の定義済みレルムを上書きすることができます。詳細については、 "
"https://access.redhat.com/documentation/en-us/red_hat_fuse/7.2/html-"
"single/apache_karaf_security_guide/index#ESBSecureContainer[JBoss Fuse "
"documentation] を参照してください。"

msgid ""
"On some later operating systems, you might also need to use the SSH "
"command's -o option `-o HostKeyAlgorithms=+ssh-dss` because later SSH "
"clients do not allow use of the `ssh-dss` algorithm, by default. However, by"
" default, it is currently used in {fuse7Version}."
msgstr ""
"最近のオペレーティング・システムでは、SSHコマンドの-oオプション `-o HostKeyAlgorithms=+ssh-dss` "
"を使用する必要があります。これは、最近のSSHクライアントではデフォルトで `ssh-dss` "
"アルゴリズムの使用は許可されていないためです。しかし、{fuse7Version}では現在デフォルトで使用されています。"

msgid ""
"JMX authentication might be necessary if you want to use jconsole or another"
" external tool to remotely connect to JMX through RMI. Otherwise it might be"
" better to use hawt.io/jolokia, since the jolokia agent is installed in "
"hawt.io by default. For more details see <<_fuse7_hawtio,Hawtio Admin "
"Console>>."
msgstr ""
"jconsoleまたは別の外部ツールを使用してRMI経由でJMXにリモート接続する場合は、JMX認証が必要になることがあります。そうでなければ、jolokiaエージェントがデフォルトでhawt.ioにインストールされているので、hawt.io/jolokiaを使用する方が良いかもしれません。詳細については、<<_fuse7_hawtio,Hawtio"
" Admin Console>>を参照してください。"

msgid "To use JMX authentication, perform the following procedure."
msgstr "JMX認証を使用するには、次の手順を実行します。"

msgid ""
"Create a client in the {project_name} Admin Console in your realm. For "
"example, in the {project_name} `demo` realm, create a client `hawtio-"
"client`, specify `public` as the Access Type, and specify a redirect URI "
"pointing to Hawtio: \\http://localhost:8181/hawtio/*. Configure "
"corresponding Web Origin (in this case, \\http://localhost:8181). Setup "
"client scope mapping to include _view-profile_ client role of _account_ "
"client in _Scope_ tab in `hawtio-client` client detail."
msgstr ""
"利用レルムの{project_name}管理コンソールにクライアントを作成します。たとえば、{project_name}の `demo` "
"レルムでクライアント `hawtio-client` を作成し、アクセスタイプとして `public` を指定し、Hawtio: "
"\\http://localhost:8181/hawtio/* を指すリダイレクトURIを指定します。対応するWeb Origin（この場合は、 "
"\\http://localhost:8181）を設定します。 `hawtio-client` クライアント詳細の _Scope_ タブにある "
"_account_ クライアントの _view-profile_ クライアントロールを含むようにクライアント・スコープ・マッピングを設定します。"

msgid ""
"{\n"
"  \"realm\" : \"demo\",\n"
"  \"clientId\" : \"hawtio-client\",\n"
"  \"url\" : \"http://localhost:8080{kc_base_path}\",\n"
"  \"ssl-required\" : \"external\",\n"
"  \"public-client\" : true\n"
"}"
msgstr ""
"{\n"
"  \"realm\" : \"demo\",\n"
"  \"clientId\" : \"hawtio-client\",\n"
"  \"url\" : \"http://localhost:8080{kc_base_path}\",\n"
"  \"ssl-required\" : \"external\",\n"
"  \"public-client\" : true\n"
"}"

msgid ""
"Create the `keycloak-direct-access.json` file in the `$FUSE_HOME/etc` "
"directory using content similar to that shown in the example below. Change "
"the `realm` and `url` properties according to your {project_name} "
"environment. This file is used by JavaScript client."
msgstr ""
"`$FUSE_HOME/etc` ディレクトリーに `keycloak-direct-access.json` "
"ファイルを作成します。このファイルは、以下の例のような内容です。{project_name}の環境に応じて `realm` と `url` "
"プロパティーを変更してください。このファイルは、JavaScriptクライアントによって使用されます。"

msgid ""
"{\n"
"  \"realm\" : \"demo\",\n"
"  \"resource\" : \"ssh-jmx-admin-client\",\n"
"  \"auth-server-url\" : \"http://localhost:8080{kc_base_path}\",\n"
"  \"ssl-required\" : \"external\",\n"
"  \"credentials\": {\n"
"    \"secret\": \"password\"\n"
"  }\n"
"}"
msgstr ""
"{\n"
"  \"realm\" : \"demo\",\n"
"  \"resource\" : \"ssh-jmx-admin-client\",\n"
"  \"auth-server-url\" : \"http://localhost:8080{kc_base_path}\",\n"
"  \"ssl-required\" : \"external\",\n"
"  \"credentials\": {\n"
"    \"secret\": \"password\"\n"
"  }\n"
"}"

msgid ""
"Start {fuse7Version}, <<_fuse7_install_feature,install the Keycloak "
"feature>>. Then type in the Karaf terminal:"
msgstr ""
"{fuse7Version}を開始し、<<_fuse7_install_feature, Keycloak "
"featureをインストールします>>。次に以下をKarafターミナルに入力してください。"

msgid ""
"system:property -p hawtio.keycloakEnabled true\n"
"system:property -p hawtio.realm keycloak\n"
"system:property -p hawtio.keycloakClientConfig file://\\${karaf.base}/etc/keycloak-hawtio-client.json\n"
"system:property -p hawtio.rolePrincipalClasses org.keycloak.adapters.jaas.RolePrincipal,org.apache.karaf.jaas.boot.principal.RolePrincipal\n"
"restart io.hawt.hawtio-war"
msgstr ""
"system:property -p hawtio.keycloakEnabled true\n"
"system:property -p hawtio.realm keycloak\n"
"system:property -p hawtio.keycloakClientConfig file://\\${karaf.base}/etc/keycloak-hawtio-client.json\n"
"system:property -p hawtio.rolePrincipalClasses org.keycloak.adapters.jaas.RolePrincipal,org.apache.karaf.jaas.boot.principal.RolePrincipal\n"
"restart io.hawt.hawtio-war"

msgid "Spring Boot adapter"
msgstr "Spring Bootアダプター"

msgid "Installing the Spring Boot adapter"
msgstr "Spring Bootアダプターのインストール"

msgid ""
"To be able to secure Spring Boot apps you must add the Keycloak Spring Boot "
"adapter JAR to your app. You then have to provide some extra configuration "
"via normal Spring Boot configuration (`application.properties`)."
msgstr ""
"Spring Bootアプリケーションをセキュリティー保護するには、Keycloak Spring "
"BootアダプターJARをアプリケーションに追加する必要があります。通常のSpring Bootの設定（ "
"`application.properties` ）でいくつかの設定を追加する必要があります。"

msgid ""
"The Keycloak Spring Boot adapter takes advantage of Spring Boot's "
"autoconfiguration so all you need to do is add this adapter Keycloak Spring "
"Boot starter to your project."
msgstr ""
"Keycloak Spring Bootアダプターは、Spring Bootの自動設定を利用するので、Keycloak Spring Boot "
"Starterをプロジェクトに追加するだけです。"

msgid ""
"To add the starter to your project using Maven, add the following to your "
"dependencies:"
msgstr "Mavenを使用してプロジェクトにstarterを追加するには、以下を依存関係に追加してください。"

msgid ""
"<dependency>\n"
"    <groupId>org.keycloak</groupId>\n"
"    <artifactId>keycloak-spring-boot-starter</artifactId>\n"
"</dependency>"
msgstr ""
"<dependency>\n"
"    <groupId>org.keycloak</groupId>\n"
"    <artifactId>keycloak-spring-boot-starter</artifactId>\n"
"</dependency>"

msgid "Add the Adapter BOM dependency:"
msgstr "アダプターのBOM依存関係も追加して下さい。"

msgid ""
"<dependencyManagement>\n"
"  <dependencies>\n"
"    <dependency>\n"
"      <groupId>org.keycloak.bom</groupId>\n"
"      <artifactId>keycloak-adapter-bom</artifactId>\n"
"      <version>{project_versionMvn}</version>\n"
"      <type>pom</type>\n"
"      <scope>import</scope>\n"
"    </dependency>\n"
"  </dependencies>\n"
"</dependencyManagement>"
msgstr ""
"<dependencyManagement>\n"
"  <dependencies>\n"
"    <dependency>\n"
"      <groupId>org.keycloak.bom</groupId>\n"
"      <artifactId>keycloak-adapter-bom</artifactId>\n"
"      <version>{project_versionMvn}</version>\n"
"      <type>pom</type>\n"
"      <scope>import</scope>\n"
"    </dependency>\n"
"  </dependencies>\n"
"</dependencyManagement>"

msgid ""
"Currently the following embedded containers are supported and do not require"
" any extra dependencies if using the Starter:"
msgstr "現在、次の組み込みコンテナーがサポートされており、Starterを使用する場合は特別な依存関係は必要ありません。"

msgid "Tomcat"
msgstr "Tomcat"

msgid "Undertow"
msgstr "Undertow"

msgid "Jetty"
msgstr "Jetty"

msgid "Configuring the Spring Boot Adapter"
msgstr "Spring Bootアダプターの設定"

msgid ""
"Use the procedure to configure your Spring Boot app to use {project_name}."
msgstr "この手順で、Spring Bootアプリが{project_name}を使用するように設定します。"

msgid ""
"Instead of a `keycloak.json` file, you configure the realm for the Spring "
"Boot  adapter via the normal Spring Boot configuration. For example:"
msgstr ""
"`keycloak.json` ファイルの代わりに、通常のSpring Bootの設定を使って、Spring "
"Bootアダプターに対するレルムを設定します。例を以下に示します。"

msgid ""
"keycloak.realm = demorealm\n"
"keycloak.auth-server-url = http://127.0.0.1:8080{kc_base_path}\n"
"keycloak.ssl-required = external\n"
"keycloak.resource = demoapp\n"
"keycloak.credentials.secret = 11111111-1111-1111-1111-111111111111\n"
"keycloak.use-resource-role-mappings = true"
msgstr ""
"keycloak.realm = demorealm\n"
"keycloak.auth-server-url = http://127.0.0.1:8080{kc_base_path}\n"
"keycloak.ssl-required = external\n"
"keycloak.resource = demoapp\n"
"keycloak.credentials.secret = 11111111-1111-1111-1111-111111111111\n"
"keycloak.use-resource-role-mappings = true"

msgid ""
"You can disable the Keycloak Spring Boot Adapter (for example in tests) by "
"setting `keycloak.enabled = false`."
msgstr ""
"`keycloak.enabled = false` を設定することで、Keycloak Spring "
"Bootアダプターを無効にすることができます（テストなどで）。"

msgid ""
"To configure a Policy Enforcer, unlike keycloak.json, use `policy-enforcer-"
"config` instead of just `policy-enforcer`."
msgstr ""
"ポリシー・エンフォーサーを設定するには、keycloak.jsonとは異なり、 `policy-enforcer` の代わりに `policy-"
"enforcer-config` を使用します。"

msgid ""
"Specify the Jakarta EE security config that would normally go in the "
"`web.xml`."
msgstr "通常 `web.xml` に記述するJakarta EEセキュリティー設定を指定します。"

msgid ""
"The Spring Boot Adapter will set the `login-method` to `KEYCLOAK` and "
"configure the `security-constraints` at startup time. Here's an example "
"configuration:"
msgstr ""
"Spring Boot アダプターは起動時に `login-method` を `KEYCLOAK` に設定し、`security-"
"constraints` を設定します。以下は設定例です。"

msgid ""
"keycloak.securityConstraints[0].authRoles[0] = admin\n"
"keycloak.securityConstraints[0].authRoles[1] = user\n"
"keycloak.securityConstraints[0].securityCollections[0].name = insecure stuff\n"
"keycloak.securityConstraints[0].securityCollections[0].patterns[0] = /insecure\n"
"\n"
"keycloak.securityConstraints[1].authRoles[0] = admin\n"
"keycloak.securityConstraints[1].securityCollections[0].name = admin stuff\n"
"keycloak.securityConstraints[1].securityCollections[0].patterns[0] = /admin"
msgstr ""
"keycloak.securityConstraints[0].authRoles[0] = admin\n"
"keycloak.securityConstraints[0].authRoles[1] = user\n"
"keycloak.securityConstraints[0].securityCollections[0].name = insecure stuff\n"
"keycloak.securityConstraints[0].securityCollections[0].patterns[0] = /insecure\n"
"\n"
"keycloak.securityConstraints[1].authRoles[0] = admin\n"
"keycloak.securityConstraints[1].securityCollections[0].name = admin stuff\n"
"keycloak.securityConstraints[1].securityCollections[0].patterns[0] = /admin"

msgid ""
"If you plan to deploy your Spring Application as a WAR then you should not "
"use the Spring Boot Adapter and use the dedicated adapter for the "
"application server or servlet container you are using. Your Spring Boot "
"should also contain a `web.xml` file."
msgstr ""
"SpringアプリケーションをWARとしてデプロイする予定の場合は、Spring "
"Bootアダプターを使用せず、使用しているアプリケーション・サーバーまたはサーブレット・コンテナーの専用アダプターを使用してください。Spring "
"Bootには `web.xml` ファイルも含まれていなければなりません。"

msgid "Tomcat 7, 8, and 9 adapters"
msgstr "Tomcat 7、8、9アダプター"

msgid ""
"To be able to secure WAR apps deployed on Tomcat 7, 8, and 9, you install "
"the Keycloak Tomcat 7 adapter or Keycloak Tomcat adapter into your Tomcat "
"installation. You then perform extra configuration to secure each WAR you "
"deploy to Tomcat."
msgstr ""
"Tomcat 7、8、9上に配備されたWARアプリをセキュリティー保護するためには、TomcatのインストールにKeycloak Tomcat "
"7アダプターまたはKeycloak "
"Tomcatアダプターをインストールします。その後、Tomcatにデプロイする各WARをセキュリティー保護するための追加設定を行います。"

msgid "Installing the adapter"
msgstr "アダプターのインストール"

msgid ""
"Adapters are no longer included with the appliance or war distribution. Each"
" adapter is a separate download on the Keycloak Downloads site. They are "
"also available as a maven artifact."
msgstr ""
"アダプターはアプライアンスやwarには含まれていません。各アダプターは、Keycloakのダウンロード・サイトで個別にダウンロードできます。これらは、mavenのアーティファクトとしても利用できます。"

msgid ""
"Download the adapter for the Tomcat version on your system from the "
"link:https://www.keycloak.org/downloads[Keycloak Downloads] site."
msgstr ""
"link:https://www.keycloak.org/downloads[Keycloakダウンロード] "
"サイトから、お使いのシステムのTomcatバージョンに対応したアダプターをダウンロードします。"

msgid "Install on Tomcat 7:"
msgstr "Tomcat 7へのインストールは次のとおりです。"

msgid ""
"$ cd $TOMCAT_HOME/lib\n"
"$ unzip keycloak-tomcat7-adapter-dist.zip"
msgstr ""
"$ cd $TOMCAT_HOME/lib\n"
"$ unzip keycloak-tomcat7-adapter-dist.zip"

msgid "Install on Tomcat 8 or 9:"
msgstr "Tomcat 8、9へのインストールは次のとおりです。"

msgid ""
"\n"
"$ cd $TOMCAT_HOME/lib\n"
"$ unzip keycloak-tomcat-adapter-dist.zip"
msgstr ""
"\n"
"$ cd $TOMCAT_HOME/lib\n"
"$ unzip keycloak-tomcat-adapter-dist.zip"

msgid ""
"Including the adapter's jars within your WEB-INF/lib directory will not "
"work. The Keycloak adapter is implemented as a Valve and valve code must "
"reside in Tomcat's main lib/ directory."
msgstr ""
"アダプターのjarをWEB-"
"INF/libディレクトリーに含めてもうまくいきません。KeycloakアダプターはValveとして実装されており、ValveのコードはTomcatのメインlib/ディレクトリーに存在する必要があります。"

msgid ""
"This section describes how to secure a WAR directly by adding config and "
"editing files within your WAR package."
msgstr "このセクションでは、直接WARパッケージ内に設定を追加し、ファイルを編集することで、WARをセキュリティー保護する方法について説明します。"

msgid "Create a `META-INF/context.xml` file in your WAR package."
msgstr "WARパッケージ内に `META-INF/context.xml` ファイルを作成します。"

msgid ""
"This is a Tomcat specific config file and you must define a Keycloak "
"specific Valve."
msgstr "これはTomcat固有の設定ファイルであり、Keycloak固有のValveを定義する必要があります。"

msgid ""
"<Context path=\"/your-context-path\">\n"
"    <Valve className=\"org.keycloak.adapters.tomcat.KeycloakAuthenticatorValve\"/>\n"
"</Context>"
msgstr ""
"<Context path=\"/your-context-path\">\n"
"    <Valve className=\"org.keycloak.adapters.tomcat.KeycloakAuthenticatorValve\"/>\n"
"</Context>"

msgid ""
"Create a `keycloak.json` adapter config file within the `WEB-INF` directory "
"of your WAR."
msgstr "WAR の `WEB-INF` ディレクトリーに `keycloak.json` アダプター設定ファイルを作成します。"

msgid ""
"The format of this config file is described in the "
"<<_java_adapter_config,Java adapter configuration>>"
msgstr "この設定ファイルの形式は<<_java_adapter_config,Javaアダプターの設定>>で説明しています。"

msgid ""
"Specify both a `login-config` and use standard servlet security to specify "
"role-base constraints on your URLs. Here's an example:"
msgstr ""
"URLに対してロールベース制約を指定するために、 `login-config` "
"と標準のサーブレット・セキュリティーの両方を指定します。例を次に示します。"

msgid ""
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"      version=\"3.0\">\n"
"\n"
"\t<module-name>customer-portal</module-name>\n"
"\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Customers</web-resource-name>\n"
"            <url-pattern>/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>user</role-name>\n"
"        </auth-constraint>\n"
"    </security-constraint>\n"
"\n"
"    <login-config>\n"
"        <auth-method>BASIC</auth-method>\n"
"        <realm-name>this is ignored currently</realm-name>\n"
"    </login-config>\n"
"\n"
"    <security-role>\n"
"        <role-name>admin</role-name>\n"
"    </security-role>\n"
"    <security-role>\n"
"        <role-name>user</role-name>\n"
"    </security-role>\n"
"</web-app>"
msgstr ""
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"      version=\"3.0\">\n"
"\n"
"\t<module-name>customer-portal</module-name>\n"
"\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Customers</web-resource-name>\n"
"            <url-pattern>/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>user</role-name>\n"
"        </auth-constraint>\n"
"    </security-constraint>\n"
"\n"
"    <login-config>\n"
"        <auth-method>BASIC</auth-method>\n"
"        <realm-name>this is ignored currently</realm-name>\n"
"    </login-config>\n"
"\n"
"    <security-role>\n"
"        <role-name>admin</role-name>\n"
"    </security-role>\n"
"    <security-role>\n"
"        <role-name>user</role-name>\n"
"    </security-role>\n"
"</web-app>"

msgid "Jetty 9.x adapters"
msgstr "Jetty 9.xアダプター"

msgid ""
"Keycloak has a separate adapter for Jetty 9.2.x, Jetty 9.3.x and Jetty 9.4.x"
" that you will have to install into your Jetty installation. You then have "
"to provide some extra configuration in each WAR you deploy to Jetty."
msgstr ""
"Keycloakには、Jetty 9.2.x、Jetty 9.3.x、Jetty "
"9.4.x用の個別のアダプターがあります。これらをJettyにインストールする必要があります。Jettyにデプロイする各WARには、さらにいくつかの設定を行う必要があります。"

msgid ""
"Adapters are no longer included with the appliance or war distribution. Each"
" adapter is a separate download on the Keycloak downloads site. They are "
"also available as a maven artifact."
msgstr ""
"アダプターはアプライアンスやwarには含まれていません。各アダプターは、Keycloakのダウンロード・サイトで個別にダウンロードできます。これらは、mavenのアーティファクトとしても利用できます。"

msgid ""
"Download the {project_name} Jetty 9.x adapter ZIP archive from the "
"link:https://www.keycloak.org/downloads[Keycloak Downloads] site."
msgstr ""
"link:https://www.keycloak.org/downloads[Keycloakダウンロード] サイトから、{project_name}"
" Jetty 9.xアダプターのZIPアーカイブをダウンロードします。"

msgid ""
"Unzip the Jetty 9.x distro into Jetty 9.x's "
"link:https://www.eclipse.org/jetty/documentation/jetty-9/index.html[base "
"directory]. In the example below, the Jetty base is named `your-base`:"
msgstr ""
"Jetty 9.x用の配布物をJetty 9.xの "
"link:https://www.eclipse.org/jetty/documentation/jetty-9/index.html[baseディレクトリー]"
" に解凍してください。以下の例では、Jettyのベースは `your-base` という名前になっています。"

msgid ""
"$ cd your-base\n"
"$ unzip keycloak-jetty93-adapter-dist-2.5.0.Final.zip"
msgstr ""
"$ cd your-base\n"
"$ unzip keycloak-jetty93-adapter-dist-2.5.0.Final.zip"

msgid "Enable the `keycloak` module for your Jetty base:"
msgstr "Jettyベースの `keycloak` モジュールを有効にします。"

msgid "$ java -jar $JETTY_HOME/start.jar --add-to-startd=keycloak"
msgstr "$ java -jar $JETTY_HOME/start.jar --add-to-startd=keycloak"

msgid ""
"Including the adapter's jars within your WEB-INF/lib directory will not "
"work."
msgstr "WEB-INF/libディレクトリー内にアダプターのjarを含めても動作しません。"

msgid "Jetty 9 Securing a WAR"
msgstr "Jetty のWARのセキュリティー保護"

msgid ""
"Use this procedure to secure a WAR directly by adding config and editing "
"files within your WAR package."
msgstr "この手順を使用し、WARパッケージ内に設定ファイルを追加して編集することで、直接WARをセキュリティー保護します。"

msgid ""
"Create a `WEB-INF/jetty-web.xml` file in your WAR package. This is a Jetty "
"specific config fil. You define a Keycloak specific authenticator within it."
msgstr ""
"WARパッケージの中に `WEB-INF/jetty-web.xml` "
"ファイルを作成します。これはJetty固有の設定ファイルです。その中で、Keycloak固有のオーセンティケーター機能を定義します。"

msgid ""
"<?xml version=\"1.0\"?>\n"
"<!DOCTYPE Configure PUBLIC \"-//Mort Bay Consulting//DTD Configure//EN\" \"http://www.eclipse.org/jetty/configure_9_0.dtd\">\n"
"<Configure class=\"org.eclipse.jetty.webapp.WebAppContext\">\n"
"    <Get name=\"securityHandler\">\n"
"        <Set name=\"authenticator\">\n"
"            <New class=\"org.keycloak.adapters.jetty.KeycloakJettyAuthenticator\">\n"
"            </New>\n"
"        </Set>\n"
"    </Get>\n"
"</Configure>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<!DOCTYPE Configure PUBLIC \"-//Mort Bay Consulting//DTD Configure//EN\" \"http://www.eclipse.org/jetty/configure_9_0.dtd\">\n"
"<Configure class=\"org.eclipse.jetty.webapp.WebAppContext\">\n"
"    <Get name=\"securityHandler\">\n"
"        <Set name=\"authenticator\">\n"
"            <New class=\"org.keycloak.adapters.jetty.KeycloakJettyAuthenticator\">\n"
"            </New>\n"
"        </Set>\n"
"    </Get>\n"
"</Configure>"

msgid ""
"The format of this config file is described in the "
"<<_java_adapter_config,Java adapter configuration>>            section."
msgstr "この設定ファイルの形式は、<<_java_adapter_config,Javaアダプターの設定>>のセクションで説明しています。"

msgid ""
"The Jetty 9.x adapter will not be able to find the `keycloak.json` file. You"
" will have to define all adapter settings within the `jetty-web.xml` file as"
" described below. Instead of using keycloak.json, you can define everything "
"within the `jetty-web.xml`. You'll just have to figure out how the json "
"settings match to the "
"`org.keycloak.representations.adapters.config.AdapterConfig` class."
msgstr ""
"Jetty 9.xアダプターは `keycloak.json` ファイルを見つけることができません。そのため、すべてのアダプターの設定を、後述の "
"`jetty-web.xml` ファイルで定義する必要があります。 `keycloak.json` を使用する代わりに、 `jetty-web.xml`"
" の中ですべてを定義することができます。jsonの設定が "
"`org.keycloak.representations.adapters.config.AdapterConfig` "
"クラスにどのようにマッチするかを考える必要があるだけです。"

msgid ""
"<?xml version=\"1.0\"?>\n"
"<!DOCTYPE Configure PUBLIC \"-//Mort Bay Consulting//DTD Configure//EN\" \"http://www.eclipse.org/jetty/configure_9_0.dtd\">\n"
"<Configure class=\"org.eclipse.jetty.webapp.WebAppContext\">\n"
"  <Get name=\"securityHandler\">\n"
"    <Set name=\"authenticator\">\n"
"        <New class=\"org.keycloak.adapters.jetty.KeycloakJettyAuthenticator\">\n"
"            <Set name=\"adapterConfig\">\n"
"                <New class=\"org.keycloak.representations.adapters.config.AdapterConfig\">\n"
"                    <Set name=\"realm\">tomcat</Set>\n"
"                    <Set name=\"resource\">customer-portal</Set>\n"
"                    <Set name=\"authServerUrl\">http://localhost:8081{kc_base_path}</Set>\n"
"                    <Set name=\"sslRequired\">external</Set>\n"
"                    <Set name=\"credentials\">\n"
"                        <Map>\n"
"                            <Entry>\n"
"                                <Item>secret</Item>\n"
"                                <Item>password</Item>\n"
"                            </Entry>\n"
"                        </Map>\n"
"                    </Set>\n"
"                </New>\n"
"            </Set>\n"
"        </New>\n"
"    </Set>\n"
"  </Get>\n"
"</Configure>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<!DOCTYPE Configure PUBLIC \"-//Mort Bay Consulting//DTD Configure//EN\" \"http://www.eclipse.org/jetty/configure_9_0.dtd\">\n"
"<Configure class=\"org.eclipse.jetty.webapp.WebAppContext\">\n"
"  <Get name=\"securityHandler\">\n"
"    <Set name=\"authenticator\">\n"
"        <New class=\"org.keycloak.adapters.jetty.KeycloakJettyAuthenticator\">\n"
"            <Set name=\"adapterConfig\">\n"
"                <New class=\"org.keycloak.representations.adapters.config.AdapterConfig\">\n"
"                    <Set name=\"realm\">tomcat</Set>\n"
"                    <Set name=\"resource\">customer-portal</Set>\n"
"                    <Set name=\"authServerUrl\">http://localhost:8081{kc_base_path}</Set>\n"
"                    <Set name=\"sslRequired\">external</Set>\n"
"                    <Set name=\"credentials\">\n"
"                        <Map>\n"
"                            <Entry>\n"
"                                <Item>secret</Item>\n"
"                                <Item>password</Item>\n"
"                            </Entry>\n"
"                        </Map>\n"
"                    </Set>\n"
"                </New>\n"
"            </Set>\n"
"        </New>\n"
"    </Set>\n"
"  </Get>\n"
"</Configure>"

msgid ""
"Create the jetty-web.xml file in your webapps directory with the name of "
"yourwar.xml. Jetty should pick it up. You do not need to open your WAR to "
"secure it with {project_name}. In this mode, you declare keycloak.json "
"configuration directly within the xml file."
msgstr ""
"webappsディレクトリーにjetty-"
"web.xmlファイルをyourwar.xmlという名前で作成します。Jettyがそれを拾ってくれるはずです。WARを開いて{project_name}でセキュリティー保護する必要はありません。このモードでは、xmlファイル内で直接keycloak.jsonの設定を宣言します。"

msgid ""
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"      version=\"3.0\">\n"
"\n"
"\t<module-name>customer-portal</module-name>\n"
"\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Customers</web-resource-name>\n"
"            <url-pattern>/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>user</role-name>\n"
"        </auth-constraint>\n"
"        <user-data-constraint>\n"
"            <transport-guarantee>CONFIDENTIAL</transport-guarantee>\n"
"        </user-data-constraint>\n"
"    </security-constraint>\n"
"\n"
"    <login-config>\n"
"        <auth-method>BASIC</auth-method>\n"
"        <realm-name>this is ignored currently</realm-name>\n"
"    </login-config>\n"
"\n"
"    <security-role>\n"
"        <role-name>admin</role-name>\n"
"    </security-role>\n"
"    <security-role>\n"
"        <role-name>user</role-name>\n"
"    </security-role>\n"
"</web-app>"
msgstr ""
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"      version=\"3.0\">\n"
"\n"
"\t<module-name>customer-portal</module-name>\n"
"\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Customers</web-resource-name>\n"
"            <url-pattern>/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>user</role-name>\n"
"        </auth-constraint>\n"
"        <user-data-constraint>\n"
"            <transport-guarantee>CONFIDENTIAL</transport-guarantee>\n"
"        </user-data-constraint>\n"
"    </security-constraint>\n"
"\n"
"    <login-config>\n"
"        <auth-method>BASIC</auth-method>\n"
"        <realm-name>this is ignored currently</realm-name>\n"
"    </login-config>\n"
"\n"
"    <security-role>\n"
"        <role-name>admin</role-name>\n"
"    </security-role>\n"
"    <security-role>\n"
"        <role-name>user</role-name>\n"
"    </security-role>\n"
"</web-app>"

msgid "Spring Security adapter"
msgstr "Spring Securityアダプター"

msgid ""
"To secure an application with Spring Security and Keycloak, add this adapter"
" as a dependency to your project. You then have to provide some extra beans "
"in your Spring Security configuration file and add the Keycloak security "
"filter to your pipeline."
msgstr ""
"Spring "
"SecurityとKeycloakでアプリケーションを保護するには、このアダプターをプロジェクトのdependencyに追加します。Spring "
"Securityの設定ファイルにいくつか追加のBeanを用意し、パイプラインにKeycloakセキュリティー・フィルターを追加する必要があります。"

msgid ""
"Unlike the other Keycloak Adapters, you should not configure your security "
"in web.xml. However, keycloak.json is still required. In order for Single "
"Sign Out to work properly you have to define a session listener."
msgstr ""
"他のKeycloakアダプターとは異なり、web.xmlにセキュリティーを設定しないでください。ただし、 `keycloak.json` "
"は依然として必要です。シングル・サインアウトが適切に機能するためには、セッション・リスナーを定義する必要があります。"

msgid "The session listener can be defined:"
msgstr "次のようにセッション・リスナーを定義できます。"

msgid "in web.xml (for pure Spring Security environments):"
msgstr "web.xml内（純粋なSpring Security環境用）"

msgid ""
"<listener>\n"
"     <listener-class>org.springframework.security.web.session.HttpSessionEventPublisher</listener-class>\n"
"</listener>"
msgstr ""
"<listener>\n"
"     <listener-class>org.springframework.security.web.session.HttpSessionEventPublisher</listener-class>\n"
"</listener>"

msgid ""
"as a Spring bean (in Spring Boot environments using Spring Security adapter)"
msgstr "Spring Beanとして（Spring Securityアダプターを使用するSpring Boot環境で）"

msgid ""
"@Bean\n"
"public ServletListenerRegistrationBean<HttpSessionEventPublisher> httpSessionEventPublisher() {\n"
"    return new ServletListenerRegistrationBean<HttpSessionEventPublisher>(new HttpSessionEventPublisher());\n"
"}"
msgstr ""
"@Bean\n"
"public ServletListenerRegistrationBean<HttpSessionEventPublisher> httpSessionEventPublisher() {\n"
"    return new ServletListenerRegistrationBean<HttpSessionEventPublisher>(new HttpSessionEventPublisher());\n"
"}"

msgid ""
"Add Keycloak Spring Security adapter as a dependency to your Maven POM or "
"Gradle build."
msgstr "MavenのPOMまたはGradleのbuildに、依存するKeycloak Spring Securityアダプターを追加してください。"

msgid ""
"<dependency>\n"
"    <groupId>org.keycloak</groupId>\n"
"    <artifactId>keycloak-spring-security-adapter</artifactId>\n"
"    <version>{project_versionMvn}</version>\n"
"</dependency>"
msgstr ""
"<dependency>\n"
"    <groupId>org.keycloak</groupId>\n"
"    <artifactId>keycloak-spring-security-adapter</artifactId>\n"
"    <version>{project_versionMvn}</version>\n"
"</dependency>"

msgid "Configuring the Spring Security Adapter"
msgstr "セキュリティーSpring Securityアダプターの設定"

msgid ""
"The Keycloak Spring Security adapter takes advantage of Spring Security's "
"flexible security configuration syntax."
msgstr "Keycloak Spring Securityアダプターは、Spring Securityの柔軟なセキュリティー設定構文を利用します。"

msgid "Java configuration"
msgstr "Java設定"

msgid ""
"Keycloak provides a KeycloakWebSecurityConfigurerAdapter as a convenient "
"base class for creating a https://docs.spring.io/spring-"
"security/site/docs/4.0.x/apidocs/org/springframework/security/config/annotation/web/WebSecurityConfigurer.html[WebSecurityConfigurer]"
"                instance. The implementation allows customization by "
"overriding methods. While its use is not required, it greatly simplifies "
"your security context configuration."
msgstr ""
"Keycloakは、 https://docs.spring.io/spring-"
"security/site/docs/4.0.x/apidocs/org/springframework/security/config/annotation/web/WebSecurityConfigurer.html[WebSecurityConfigurer]"
" を作成するための便利な基本クラスとして、 `KeycloakWebSecurityConfigurerAdapter` "
"を提供します。この実装では、メソッドのオーバーライドによるカスタマイズが可能です。その使用は必須ではありませんが、セキュリティー・コンテキストの設定が大幅に簡素化されます。"

msgid ""
"\n"
"\n"
"@KeycloakConfiguration\n"
"public class SecurityConfig extends KeycloakWebSecurityConfigurerAdapter\n"
"{\n"
"    /**\n"
"     * Registers the KeycloakAuthenticationProvider with the authentication manager.\n"
"     */\n"
"    @Autowired\n"
"    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n"
"        auth.authenticationProvider(keycloakAuthenticationProvider());\n"
"    }\n"
"\n"
"    /**\n"
"     * Defines the session authentication strategy.\n"
"     */\n"
"    @Bean\n"
"    @Override\n"
"    protected SessionAuthenticationStrategy sessionAuthenticationStrategy() {\n"
"        return new RegisterSessionAuthenticationStrategy(buildSessionRegistry());\n"
"    }\n"
"\n"
"    @Bean\n"
"    protected SessionRegistry buildSessionRegistry() {\n"
"        return new SessionRegistryImpl();\n"
"    }\n"
"\n"
"    @Override\n"
"    protected void configure(HttpSecurity http) throws Exception\n"
"    {\n"
"        super.configure(http);\n"
"        http\n"
"                .authorizeRequests()\n"
"                .antMatchers(\"/customers*\").hasRole(\"USER\")\n"
"                .antMatchers(\"/admin*\").hasRole(\"ADMIN\")\n"
"                .anyRequest().permitAll();\n"
"    }\n"
"}"
msgstr ""
"\n"
"\n"
"@KeycloakConfiguration\n"
"public class SecurityConfig extends KeycloakWebSecurityConfigurerAdapter\n"
"{\n"
"    /**\n"
"     * Registers the KeycloakAuthenticationProvider with the authentication manager.\n"
"     */\n"
"    @Autowired\n"
"    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n"
"        auth.authenticationProvider(keycloakAuthenticationProvider());\n"
"    }\n"
"\n"
"    /**\n"
"     * Defines the session authentication strategy.\n"
"     */\n"
"    @Bean\n"
"    @Override\n"
"    protected SessionAuthenticationStrategy sessionAuthenticationStrategy() {\n"
"        return new RegisterSessionAuthenticationStrategy(buildSessionRegistry());\n"
"    }\n"
"\n"
"    @Bean\n"
"    protected SessionRegistry buildSessionRegistry() {\n"
"        return new SessionRegistryImpl();\n"
"    }\n"
"\n"
"    @Override\n"
"    protected void configure(HttpSecurity http) throws Exception\n"
"    {\n"
"        super.configure(http);\n"
"        http\n"
"                .authorizeRequests()\n"
"                .antMatchers(\"/customers*\").hasRole(\"USER\")\n"
"                .antMatchers(\"/admin*\").hasRole(\"ADMIN\")\n"
"                .anyRequest().permitAll();\n"
"    }\n"
"}"

msgid ""
"You must provide a session authentication strategy bean which should be of "
"type `RegisterSessionAuthenticationStrategy` for public or confidential "
"applications and `NullAuthenticatedSessionStrategy` for bearer-only "
"applications."
msgstr ""
"パブリックまたはコンフィデンシャルなアプリケーションの場合は `RegisterSessionAuthenticationStrategy` "
"の、bearer-onlyアプリケーションの場合は `NullAuthenticatedSessionStrategy` "
"のタイプのセッション認証ストラテジーBeanを提供する必要があります。"

msgid ""
"Spring Security's `SessionFixationProtectionStrategy` is currently not "
"supported because it changes the session identifier after login via "
"Keycloak. If the session identifier changes, universal log out will not work"
" because Keycloak is unaware of the new session identifier."
msgstr ""
"Keycloak経由でログインした後にセッション識別子を変更するため、Spring Securityの "
"`SessionFixationProtectionStrategy` "
"は現在サポートされていません。セッション識別子が変更された場合、Keycloakは新しいセッション識別子を認識しないため、ユニバーサル・ログアウトは機能しません。"

msgid ""
"The `@KeycloakConfiguration` annotation is a metadata annotation that "
"defines all annotations that are needed to integrate {project_name} in "
"Spring Security. If you have a complex Spring Security setup you can simply "
"have a look at the annotations of the `@KeycloakConfiguration` annotation "
"and create your own custom meta annotation or just use specific Spring "
"annotations for the {project_name} adapter."
msgstr ""
"`@KeycloakConfiguration` アノテーションは、Spring "
"Securityで{project_name}を統合するために必要なすべてのアノテーションを定義するメタ・データ・アノテーションです。複雑なSpring"
" Securityの設定をする場合は、 `@KeycloakConfiguration` "
"アノテーションを参照して、独自のカスタム・メタ・アノテーションを作成してください。もしくは、{project_name}アダプター用の特定のSpringアノテーションを使用してください。"

msgid "XML configuration"
msgstr "XML設定"

msgid ""
"While Spring Security's XML namespace simplifies configuration, customizing "
"the configuration can be a bit verbose."
msgstr "Spring SecurityのXML名前空間は設定を簡素化しますが、設定のカスタマイズは少し冗長になる可能性があります。"

msgid ""
"\n"
"\n"
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<beans xmlns=\"http://www.springframework.org/schema/beans\"\n"
"       xmlns:context=\"http://www.springframework.org/schema/context\"\n"
"       xmlns:security=\"http://www.springframework.org/schema/security\"\n"
"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"       xsi:schemaLocation=\"\n"
"       http://www.springframework.org/schema/beans\n"
"       http://www.springframework.org/schema/beans/spring-beans.xsd\n"
"       http://www.springframework.org/schema/context\n"
"       http://www.springframework.org/schema/context/spring-context.xsd\n"
"       http://www.springframework.org/schema/security\n"
"       http://www.springframework.org/schema/security/spring-security.xsd\">\n"
"\n"
"    <context:component-scan base-package=\"org.keycloak.adapters.springsecurity\" />\n"
"\n"
"    <security:authentication-manager alias=\"authenticationManager\">\n"
"        <security:authentication-provider ref=\"keycloakAuthenticationProvider\" />\n"
"    </security:authentication-manager>\n"
"\n"
"    <bean id=\"adapterDeploymentContext\" class=\"org.keycloak.adapters.springsecurity.AdapterDeploymentContextFactoryBean\">\n"
"        <constructor-arg value=\"/WEB-INF/keycloak.json\" />\n"
"    </bean>\n"
"\n"
"    <bean id=\"keycloakAuthenticationEntryPoint\" class=\"org.keycloak.adapters.springsecurity.authentication.KeycloakAuthenticationEntryPoint\">\n"
"        <constructor-arg ref=\"adapterDeploymentContext\" />\n"
"    </bean>\n"
"    <bean id=\"keycloakAuthenticationProvider\" class=\"org.keycloak.adapters.springsecurity.authentication.KeycloakAuthenticationProvider\" />\n"
"    <bean id=\"keycloakPreAuthActionsFilter\" class=\"org.keycloak.adapters.springsecurity.filter.KeycloakPreAuthActionsFilter\" />\n"
"    <bean id=\"keycloakAuthenticationProcessingFilter\" class=\"org.keycloak.adapters.springsecurity.filter.KeycloakAuthenticationProcessingFilter\">\n"
"        <constructor-arg name=\"authenticationManager\" ref=\"authenticationManager\" />\n"
"    </bean>\n"
"    <bean id=\"keycloakSecurityContextRequestFilter\"\n"
"          class=\"org.keycloak.adapters.springsecurity.filter.KeycloakSecurityContextRequestFilter\" />\n"
"\n"
"<bean id=\"keycloakSecurityContextRequestFilter\"\n"
"     class=\"org.keycloak.adapters.springsecurity.filter.KeycloakSecurityContextRequestFilter\" />\n"
"\n"
"    <bean id=\"keycloakLogoutHandler\" class=\"org.keycloak.adapters.springsecurity.authentication.KeycloakLogoutHandler\">\n"
"        <constructor-arg ref=\"adapterDeploymentContext\" />\n"
"    </bean>\n"
"\n"
"    <bean id=\"logoutFilter\" class=\"org.springframework.security.web.authentication.logout.LogoutFilter\">\n"
"        <constructor-arg name=\"logoutSuccessUrl\" value=\"/\" />\n"
"        <constructor-arg name=\"handlers\">\n"
"            <list>\n"
"                <ref bean=\"keycloakLogoutHandler\" />\n"
"                <bean class=\"org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler\" />\n"
"            </list>\n"
"        </constructor-arg>\n"
"        <property name=\"logoutRequestMatcher\">\n"
"            <bean class=\"org.springframework.security.web.util.matcher.AntPathRequestMatcher\">\n"
"                <constructor-arg name=\"pattern\" value=\"/sso/logout**\" />\n"
"                <constructor-arg name=\"httpMethod\" value=\"GET\" />\n"
"            </bean>\n"
"        </property>\n"
"    </bean>\n"
"\n"
"    <security:http auto-config=\"false\" entry-point-ref=\"keycloakAuthenticationEntryPoint\">\n"
"        <security:custom-filter ref=\"keycloakPreAuthActionsFilter\" before=\"LOGOUT_FILTER\" />\n"
"        <security:custom-filter ref=\"keycloakAuthenticationProcessingFilter\" before=\"FORM_LOGIN_FILTER\" />\n"
"        <security:custom-filter ref=\"keycloakSecurityContextRequestFilter\" after=\"FORM_LOGIN_FILTER\" />\n"
"        <security:intercept-url pattern=\"/customers**\" access=\"ROLE_USER\" />\n"
"        <security:intercept-url pattern=\"/admin**\" access=\"ROLE_ADMIN\" />\n"
"        <security:custom-filter ref=\"logoutFilter\" position=\"LOGOUT_FILTER\" />\n"
"    </security:http>\n"
"\n"
"</beans>"
msgstr ""
"\n"
"\n"
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<beans xmlns=\"http://www.springframework.org/schema/beans\"\n"
"       xmlns:context=\"http://www.springframework.org/schema/context\"\n"
"       xmlns:security=\"http://www.springframework.org/schema/security\"\n"
"       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"       xsi:schemaLocation=\"\n"
"       http://www.springframework.org/schema/beans\n"
"       http://www.springframework.org/schema/beans/spring-beans.xsd\n"
"       http://www.springframework.org/schema/context\n"
"       http://www.springframework.org/schema/context/spring-context.xsd\n"
"       http://www.springframework.org/schema/security\n"
"       http://www.springframework.org/schema/security/spring-security.xsd\">\n"
"\n"
"    <context:component-scan base-package=\"org.keycloak.adapters.springsecurity\" />\n"
"\n"
"    <security:authentication-manager alias=\"authenticationManager\">\n"
"        <security:authentication-provider ref=\"keycloakAuthenticationProvider\" />\n"
"    </security:authentication-manager>\n"
"\n"
"    <bean id=\"adapterDeploymentContext\" class=\"org.keycloak.adapters.springsecurity.AdapterDeploymentContextFactoryBean\">\n"
"        <constructor-arg value=\"/WEB-INF/keycloak.json\" />\n"
"    </bean>\n"
"\n"
"    <bean id=\"keycloakAuthenticationEntryPoint\" class=\"org.keycloak.adapters.springsecurity.authentication.KeycloakAuthenticationEntryPoint\">\n"
"        <constructor-arg ref=\"adapterDeploymentContext\" />\n"
"    </bean>\n"
"    <bean id=\"keycloakAuthenticationProvider\" class=\"org.keycloak.adapters.springsecurity.authentication.KeycloakAuthenticationProvider\" />\n"
"    <bean id=\"keycloakPreAuthActionsFilter\" class=\"org.keycloak.adapters.springsecurity.filter.KeycloakPreAuthActionsFilter\" />\n"
"    <bean id=\"keycloakAuthenticationProcessingFilter\" class=\"org.keycloak.adapters.springsecurity.filter.KeycloakAuthenticationProcessingFilter\">\n"
"        <constructor-arg name=\"authenticationManager\" ref=\"authenticationManager\" />\n"
"    </bean>\n"
"    <bean id=\"keycloakSecurityContextRequestFilter\"\n"
"          class=\"org.keycloak.adapters.springsecurity.filter.KeycloakSecurityContextRequestFilter\" />\n"
"\n"
"<bean id=\"keycloakSecurityContextRequestFilter\"\n"
"     class=\"org.keycloak.adapters.springsecurity.filter.KeycloakSecurityContextRequestFilter\" />\n"
"\n"
"    <bean id=\"keycloakLogoutHandler\" class=\"org.keycloak.adapters.springsecurity.authentication.KeycloakLogoutHandler\">\n"
"        <constructor-arg ref=\"adapterDeploymentContext\" />\n"
"    </bean>\n"
"\n"
"    <bean id=\"logoutFilter\" class=\"org.springframework.security.web.authentication.logout.LogoutFilter\">\n"
"        <constructor-arg name=\"logoutSuccessUrl\" value=\"/\" />\n"
"        <constructor-arg name=\"handlers\">\n"
"            <list>\n"
"                <ref bean=\"keycloakLogoutHandler\" />\n"
"                <bean class=\"org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler\" />\n"
"            </list>\n"
"        </constructor-arg>\n"
"        <property name=\"logoutRequestMatcher\">\n"
"            <bean class=\"org.springframework.security.web.util.matcher.AntPathRequestMatcher\">\n"
"                <constructor-arg name=\"pattern\" value=\"/sso/logout**\" />\n"
"                <constructor-arg name=\"httpMethod\" value=\"GET\" />\n"
"            </bean>\n"
"        </property>\n"
"    </bean>\n"
"\n"
"    <security:http auto-config=\"false\" entry-point-ref=\"keycloakAuthenticationEntryPoint\">\n"
"        <security:custom-filter ref=\"keycloakPreAuthActionsFilter\" before=\"LOGOUT_FILTER\" />\n"
"        <security:custom-filter ref=\"keycloakAuthenticationProcessingFilter\" before=\"FORM_LOGIN_FILTER\" />\n"
"        <security:custom-filter ref=\"keycloakSecurityContextRequestFilter\" after=\"FORM_LOGIN_FILTER\" />\n"
"        <security:intercept-url pattern=\"/customers**\" access=\"ROLE_USER\" />\n"
"        <security:intercept-url pattern=\"/admin**\" access=\"ROLE_ADMIN\" />\n"
"        <security:custom-filter ref=\"logoutFilter\" position=\"LOGOUT_FILTER\" />\n"
"    </security:http>\n"
"\n"
"</beans>"

msgid "Multi Tenancy"
msgstr "マルチテナンシー"

msgid ""
"The Keycloak Spring Security adapter also supports Multi Tenancy. Instead of"
" injecting `AdapterDeploymentContextFactoryBean` with the path to "
"`keycloak.json` you can inject an implementation of the "
"`KeycloakConfigResolver` interface. More details on how to implement the "
"`KeycloakConfigResolver` can be found in <<_multi_tenancy,Multi Tenancy>>."
msgstr ""
"Keycloak Spring Securityアダプターはマルチテナンシーをサポートしています。 "
"`AdapterDeploymentContextFactoryBean` に `keycloak.json` "
"へのパスを注入する代わりに、`KeycloakConfigResolver` インターフェイスの実装を注入することができます。 "
"`KeycloakConfigResolver` の実装方法の詳細は<<_multi_tenancy,マルチテナンシー>>にあります。"

msgid "Naming security roles"
msgstr "セキュリティー・ロールの命名"

msgid ""
"Spring Security, when using role-based authentication, requires that role "
"names start with `ROLE_`. For example, an administrator role must be "
"declared in Keycloak as `ROLE_ADMIN` or similar, not simply `ADMIN`."
msgstr ""
"Spring Securityで、ロールベースの認証を使用する場合、ロール名は `ROLE_` で始まる必要があります。たとえば、管理者のロールは単に "
"`ADMIN` ではなく、 `ROLE_ADMIN` または同様のものとして、Keycloakで宣言されなければなりません。"

msgid ""
"The class "
"`org.keycloak.adapters.springsecurity.authentication.KeycloakAuthenticationProvider`"
"            supports an optional "
"`org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper`"
"            which can be used to map roles coming from Keycloak to roles "
"recognized by Spring Security. Use, for example, "
"`org.springframework.security.core.authority.mapping.SimpleAuthorityMapper` "
"to insert the `ROLE_` prefix and convert the role name to upper case. The "
"class is part of Spring Security Core module."
msgstr ""
"`org.keycloak.adapters.springsecurity.authentication.KeycloakAuthenticationProvider` クラスはオプションで `org.springframework.security.core.authority.mapping.GrantedAuthoritiesMapper` をサポートしており、Spring Securityによって認識されるロールにKeycloakから来るロールをマップするために使用することができます。\n"
"たとえば、 `org.springframework.security.core.authority.mapping.SimpleAuthorityMapper` を使用して、接頭辞 `ROLE_` を挿入し、ロール名を大文字に変換します。\n"
"クラスはSpring Security Coreモジュールの一部です。"

msgid "Client to Client Support"
msgstr "クライアント・トゥ・クライアント・サポート"

msgid ""
"To simplify communication between clients, Keycloak provides an extension of"
" Spring's `RestTemplate` that handles bearer token authentication for you. "
"To enable this feature your security configuration must add the "
"`KeycloakRestTemplate` bean. Note that it must be scoped as a prototype to "
"function correctly."
msgstr ""
"クライアント間の通信を簡素化するために、Keycloakはベアラー・トークン認証を処理するSpringの `RestTemplate` "
"の拡張を提供します。この機能を有効にするには、セキュリティー設定で `KeycloakRestTemplate` "
"を追加する必要があります。正しく機能するには、プロトタイプとしてスコープを設定する必要があることに注意してください。"

msgid "For Java configuration:"
msgstr "Javaによる設定："

msgid ""
"\n"
"\n"
"@Configuration\n"
"@EnableWebSecurity\n"
"@ComponentScan(basePackageClasses = KeycloakSecurityComponents.class)\n"
"public class SecurityConfig extends KeycloakWebSecurityConfigurerAdapter {\n"
"\n"
"    ...\n"
"\n"
"    @Autowired\n"
"    public KeycloakClientRequestFactory keycloakClientRequestFactory;\n"
"\n"
"    @Bean\n"
"    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n"
"    public KeycloakRestTemplate keycloakRestTemplate() {\n"
"        return new KeycloakRestTemplate(keycloakClientRequestFactory);\n"
"    }\n"
"\n"
"    ...\n"
"}"
msgstr ""
"\n"
"\n"
"@Configuration\n"
"@EnableWebSecurity\n"
"@ComponentScan(basePackageClasses = KeycloakSecurityComponents.class)\n"
"public class SecurityConfig extends KeycloakWebSecurityConfigurerAdapter {\n"
"\n"
"    ...\n"
"\n"
"    @Autowired\n"
"    public KeycloakClientRequestFactory keycloakClientRequestFactory;\n"
"\n"
"    @Bean\n"
"    @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n"
"    public KeycloakRestTemplate keycloakRestTemplate() {\n"
"        return new KeycloakRestTemplate(keycloakClientRequestFactory);\n"
"    }\n"
"\n"
"    ...\n"
"}"

msgid "For XML configuration:"
msgstr "XMLによる設定："

msgid ""
"\n"
"\n"
"<bean id=\"keycloakRestTemplate\" class=\"org.keycloak.adapters.springsecurity.client.KeycloakRestTemplate\" scope=\"prototype\">\n"
"    <constructor-arg name=\"factory\" ref=\"keycloakClientRequestFactory\" />\n"
"</bean>"
msgstr ""
"\n"
"\n"
"<bean id=\"keycloakRestTemplate\" class=\"org.keycloak.adapters.springsecurity.client.KeycloakRestTemplate\" scope=\"prototype\">\n"
"    <constructor-arg name=\"factory\" ref=\"keycloakClientRequestFactory\" />\n"
"</bean>"

msgid ""
"Your application code can then use `KeycloakRestTemplate` any time it needs "
"to make a call to another client. For example:"
msgstr ""
"アプリケーション・コードは、別のクライアントを呼び出す必要があるときはいつでも、 `KeycloakRestTemplate` を使うことができます。 "
"次に例を示します。"

msgid ""
"\n"
"\n"
"\n"
"@Service\n"
"public class RemoteProductService implements ProductService {\n"
"\n"
"    @Autowired\n"
"    private KeycloakRestTemplate template;\n"
"\n"
"    private String endpoint;\n"
"\n"
"    @Override\n"
"    public List<String> getProducts() {\n"
"        ResponseEntity<String[]> response = template.getForEntity(endpoint, String[].class);\n"
"        return Arrays.asList(response.getBody());\n"
"    }\n"
"}"
msgstr ""
"\n"
"\n"
"\n"
"@Service\n"
"public class RemoteProductService implements ProductService {\n"
"\n"
"    @Autowired\n"
"    private KeycloakRestTemplate template;\n"
"\n"
"    private String endpoint;\n"
"\n"
"    @Override\n"
"    public List<String> getProducts() {\n"
"        ResponseEntity<String[]> response = template.getForEntity(endpoint, String[].class);\n"
"        return Arrays.asList(response.getBody());\n"
"    }\n"
"}"

msgid "Spring Boot Integration"
msgstr "Spring Boot統合"

msgid "The Spring Boot and the Spring Security adapters can be combined."
msgstr "Spring BootアダプターとSpring Securityアダプターを組み合わせることができます。"

msgid ""
"If you are using the Keycloak Spring Boot Starter to make use of the Spring "
"Security adapter you just need to add the Spring Security starter :"
msgstr ""
"Spring Securityアダプターを使用するために、Keycloak Spring Boot Starterを使用している場合は、Spring "
"Security Starterを追加するだけです。"

msgid ""
"\n"
"<dependency>\n"
"  <groupId>org.springframework.boot</groupId>\n"
"  <artifactId>spring-boot-starter-security</artifactId>\n"
"</dependency>\n"
msgstr ""
"\n"
"<dependency>\n"
"  <groupId>org.springframework.boot</groupId>\n"
"  <artifactId>spring-boot-starter-security</artifactId>\n"
"</dependency>\n"

msgid "Using Spring Boot Configuration"
msgstr "Spring Boot設定の使用"

msgid ""
"By Default, the Spring Security Adapter looks for a `keycloak.json` "
"configuration file. You can make sure it looks at the configuration provided"
" by the Spring Boot Adapter by adding this bean :"
msgstr ""
"デフォルトでは、Spring Securityアダプターは `keycloak.json` "
"設定ファイルを探します。このBeanを追加することで、Spring Bootアダプターが提供する設定を確認できます。"

msgid ""
"\n"
"@Bean\n"
"public KeycloakConfigResolver keycloakConfigResolver() {\n"
"    return new KeycloakSpringBootConfigResolver();\n"
"}\n"
msgstr ""
"\n"
"@Bean\n"
"public KeycloakConfigResolver keycloakConfigResolver() {\n"
"    return new KeycloakSpringBootConfigResolver();\n"
"}\n"

msgid "Avoid double bean registration"
msgstr "Beanの二重登録を避ける"

msgid ""
"Spring Boot attempts to eagerly register filter beans with the web "
"application context. Therefore, when running the Keycloak Spring Security "
"adapter in a Spring Boot environment, it may be necessary to add "
"``FilterRegistrationBean``s to your security configuration to prevent the "
"Keycloak filters from being registered twice."
msgstr ""
"Spring Bootは、フィルターBeanをWebアプリケーション・コンテキストに登録しようとします。そのため、Spring "
"Boot環境でKeycloak Spring "
"Securityアダプターを実行する場合は、Keycloakフィルターが2回登録されないように、セキュリティー設定に "
"`FilterRegistrationBean` を追加する必要があります。"

msgid ""
"Spring Boot 2.1 also disables `spring.main.allow-bean-definition-overriding`"
" by default. This can mean that an `BeanDefinitionOverrideException` will be"
" encountered if a `Configuration` class extending "
"`KeycloakWebSecurityConfigurerAdapter` registers a bean that is already "
"detected by a `@ComponentScan`. This can be avoided by overriding the "
"registration to use the Boot-specific `@ConditionalOnMissingBean` "
"annotation, as with `HttpSessionManager` below."
msgstr ""
"また、Spring Boot 2.1はデフォルトで `spring.main.allow-bean-definition-overriding` "
"を無効にしています。これは、もし `KeycloakWebSecurityConfigurerAdapter` を拡張した "
"`Configuration` クラスが `@ComponentScan` によってすでに検出されているBeanを登録しようとすると、 "
"`BeanDefinitionOverrideException` が発生することを意味します。これについては以下の "
"`HttpSessionManager` のように、 `@ConditionalOnMissingBean` "
"アノテーションを使用して登録を上書きすることで避けることができます。"

msgid ""
"\n"
"\n"
"@Configuration\n"
"@EnableWebSecurity\n"
"public class SecurityConfig extends KeycloakWebSecurityConfigurerAdapter\n"
"{\n"
"    ...\n"
"\n"
"    @Bean\n"
"    public FilterRegistrationBean keycloakAuthenticationProcessingFilterRegistrationBean(\n"
"            KeycloakAuthenticationProcessingFilter filter) {\n"
"        FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter);\n"
"        registrationBean.setEnabled(false);\n"
"        return registrationBean;\n"
"    }\n"
"\n"
"    @Bean\n"
"    public FilterRegistrationBean keycloakPreAuthActionsFilterRegistrationBean(\n"
"            KeycloakPreAuthActionsFilter filter) {\n"
"        FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter);\n"
"        registrationBean.setEnabled(false);\n"
"        return registrationBean;\n"
"    }\n"
"\n"
"    @Bean\n"
"    public FilterRegistrationBean keycloakAuthenticatedActionsFilterBean(\n"
"            KeycloakAuthenticatedActionsFilter filter) {\n"
"        FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter);\n"
"        registrationBean.setEnabled(false);\n"
"        return registrationBean;\n"
"    }\n"
"\n"
"    @Bean\n"
"    public FilterRegistrationBean keycloakSecurityContextRequestFilterBean(\n"
"        KeycloakSecurityContextRequestFilter filter) {\n"
"        FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter);\n"
"        registrationBean.setEnabled(false);\n"
"        return registrationBean;\n"
"    }\n"
"\n"
"    @Bean\n"
"    @Override\n"
"    @ConditionalOnMissingBean(HttpSessionManager.class)\n"
"    protected HttpSessionManager httpSessionManager() {\n"
"        return new HttpSessionManager();\n"
"    }\n"
"    ...\n"
"}"
msgstr ""
"\n"
"\n"
"@Configuration\n"
"@EnableWebSecurity\n"
"public class SecurityConfig extends KeycloakWebSecurityConfigurerAdapter\n"
"{\n"
"    ...\n"
"\n"
"    @Bean\n"
"    public FilterRegistrationBean keycloakAuthenticationProcessingFilterRegistrationBean(\n"
"            KeycloakAuthenticationProcessingFilter filter) {\n"
"        FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter);\n"
"        registrationBean.setEnabled(false);\n"
"        return registrationBean;\n"
"    }\n"
"\n"
"    @Bean\n"
"    public FilterRegistrationBean keycloakPreAuthActionsFilterRegistrationBean(\n"
"            KeycloakPreAuthActionsFilter filter) {\n"
"        FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter);\n"
"        registrationBean.setEnabled(false);\n"
"        return registrationBean;\n"
"    }\n"
"\n"
"    @Bean\n"
"    public FilterRegistrationBean keycloakAuthenticatedActionsFilterBean(\n"
"            KeycloakAuthenticatedActionsFilter filter) {\n"
"        FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter);\n"
"        registrationBean.setEnabled(false);\n"
"        return registrationBean;\n"
"    }\n"
"\n"
"    @Bean\n"
"    public FilterRegistrationBean keycloakSecurityContextRequestFilterBean(\n"
"        KeycloakSecurityContextRequestFilter filter) {\n"
"        FilterRegistrationBean registrationBean = new FilterRegistrationBean(filter);\n"
"        registrationBean.setEnabled(false);\n"
"        return registrationBean;\n"
"    }\n"
"\n"
"    @Bean\n"
"    @Override\n"
"    @ConditionalOnMissingBean(HttpSessionManager.class)\n"
"    protected HttpSessionManager httpSessionManager() {\n"
"        return new HttpSessionManager();\n"
"    }\n"
"    ...\n"
"}"

msgid "Java servlet filter adapter"
msgstr "Javaサーブレット・フィルター・アダプター"

msgid ""
"If you are deploying your Java Servlet application on a platform where there"
" is no {project_name} adapter you opt to use the servlet filter adapter. "
"This adapter works a bit differently than the other adapters. You do not "
"define security constraints in web.xml. Instead you define a filter mapping "
"using the {project_name} servlet filter adapter to secure the url patterns "
"you want to secure."
msgstr ""
"{project_name}アダプターがないプラットフォームにJavaサーブレット・アプリケーションをデプロイする場合は、サーブレット・フィルター・アダプターを使用することを選択します。このアダプターは、他のアダプターとは多少動作が異なります。web.xmlにはセキュリティー制約を定義しません。代わりに{project_name}サーブレット・フィルター・アダプターを使用してフィルター・マッピングを定義して、URLパターンでセキュリティー保護します。"

msgid ""
"Backchannel logout works a bit differently than the standard adapters. "
"Instead of invalidating the HTTP session it marks the session id as logged "
"out. There's no standard way to invalidate an HTTP session based on a "
"session id."
msgstr ""
"バックチャネル・ログアウトは、標準のアダプターとは少し異なります。HTTPセッションを無効にする代わりに、セッションIDをログアウトしたものとしてマークします。セッションIDに基づいてHTTPセッションを無効にする標準的な方法はありません。"

msgid ""
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"      version=\"3.0\">\n"
"\n"
"\t<module-name>application</module-name>\n"
"\n"
"    <filter>\n"
"        <filter-name>Keycloak Filter</filter-name>\n"
"        <filter-class>org.keycloak.adapters.servlet.KeycloakOIDCFilter</filter-class>\n"
"    </filter>\n"
"    <filter-mapping>\n"
"        <filter-name>Keycloak Filter</filter-name>\n"
"        <url-pattern>/keycloak/*</url-pattern>\n"
"        <url-pattern>/protected/*</url-pattern>\n"
"    </filter-mapping>\n"
"</web-app>"
msgstr ""
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"      version=\"3.0\">\n"
"\n"
"\t<module-name>application</module-name>\n"
"\n"
"    <filter>\n"
"        <filter-name>Keycloak Filter</filter-name>\n"
"        <filter-class>org.keycloak.adapters.servlet.KeycloakOIDCFilter</filter-class>\n"
"    </filter>\n"
"    <filter-mapping>\n"
"        <filter-name>Keycloak Filter</filter-name>\n"
"        <url-pattern>/keycloak/*</url-pattern>\n"
"        <url-pattern>/protected/*</url-pattern>\n"
"    </filter-mapping>\n"
"</web-app>"

msgid ""
"In the snippet above there are two url-patterns.  _/protected/*_ are the "
"files we want protected, while the _/keycloak/*_ url-pattern handles "
"callbacks from the {project_name} server."
msgstr ""
"上記のスニペットには2つのURLパターンがあります。 _/protected/*_ は保護したいファイルで、_/keycloak/*_ のurl-"
"patternは{project_name}サーバーからのコールバックを処理します。"

msgid ""
"If you need to exclude some paths beneath the configured `url-patterns` you "
"can use the Filter init-param `keycloak.config.skipPattern` to configure a "
"regular expression that describes a path-pattern for which the keycloak "
"filter should immediately delegate to the filter-chain. By default no "
"skipPattern is configured."
msgstr ""
"設定された `url-patterns` "
"の下にあるいくつかのパスを除外する必要がある場合は、keycloakフィルターが直ちにフィルター・チェーンに委譲すべきパス・パターンを記述する正規表現を設定するために、フィルターのinit-"
"param `keycloak.config.skipPattern` を使用できます。デフォルトでは、skipPatternは設定されていません。"

msgid ""
"Patterns are matched against the `requestURI` without the `context-path`. "
"Given the context-path `/myapp` a request for `/myapp/index.html` will be "
"matched with `/index.html` against the skip pattern."
msgstr ""
"パターンは `コンテキスト・パス` なしで `requestURI` と照合されます。コンテキスト・パス `/myapp` が与えられると、 "
"`/myapp/index.html` のリクエストは、スキップ・パターンと `/index.html` で照合されます。"

msgid ""
"<init-param>\n"
"    <param-name>keycloak.config.skipPattern</param-name>\n"
"    <param-value>^/(path1|path2|path3).*</param-value>\n"
"</init-param>"
msgstr ""
"<init-param>\n"
"    <param-name>keycloak.config.skipPattern</param-name>\n"
"    <param-value>^/(path1|path2|path3).*</param-value>\n"
"</init-param>"

msgid ""
"Note that you should configure your client in the {project_name} Admin "
"Console with an Admin URL that points to a secured section covered by the "
"filter's url-pattern."
msgstr ""
"{project_name}管理コンソールでクライアントのURLを設定する必要があります。Admin URLは、フィルターのurl-"
"patternで保護されたセクションを指します。"

msgid ""
"The Admin URL will make callbacks to the Admin URL to do things like "
"backchannel logout. So, the Admin URL in this example should be "
"`http[s]://hostname/{context-root}/keycloak`."
msgstr ""
"Admin URLは、バックチャネル・ログアウトなどの操作を行うために、管Admin URLへのコールバックを行います。したがって、この例のAdmin "
"URLは `http[s]://hostname/{context-root}/keycloak` でなければなりません。"

msgid ""
"If you need to customize the session ID mapper, you can configure the fully "
"qualified name of the class in the Filter init-param "
"keycloak.config.idMapper. Session ID mapper is a mapper that is used to map "
"user IDs and session IDs. By default "
"org.keycloak.adapters.spi.InMemorySessionIdMapper is configured."
msgstr ""
"セッションIDマッパーをカスタマイズする必要がある場合は、Filter init-param "
"keycloak.config.idMapperでクラスの完全修飾名を設定することができます。セッションIDマッパーは、ユーザIDとセッションIDをマッピングするために使用されるマッパーです。デフォルトではorg.keycloak.adapters.spi.InMemorySessionIdMapperが設定されています。"

msgid ""
"<init-param>\n"
"    <param-name>keycloak.config.idMapper</param-name>\n"
"    <param-value>org.keycloak.adapters.spi.InMemorySessionIdMapper</param-value>\n"
"</init-param>"
msgstr ""
"<init-param>\n"
"    <param-name>keycloak.config.idMapper</param-name>\n"
"    <param-value>org.keycloak.adapters.spi.InMemorySessionIdMapper</param-value>\n"
"</init-param>"

msgid ""
"The {project_name} filter has the same configuration parameters as the other"
" adapters except you must define them as filter init params instead of "
"context params."
msgstr ""
"{project_name}フィルターは、コンテキスト・パラメーターの代わりにフィルター初期化パラメーターとして定義する必要がある以外は、他のアダプターと同じ設定パラメーターを持ちます。"

msgid "To use this filter, include this maven artifact in your WAR poms:"
msgstr "このフィルターを使用するには、WARのpomに次のmavenアーティファクトを含めます。"

msgid ""
"<dependency>\n"
"    <groupId>org.keycloak</groupId>\n"
"    <artifactId>keycloak-servlet-filter-adapter</artifactId>\n"
"    <version>{project_versionMvn}</version>\n"
"</dependency>"
msgstr ""
"<dependency>\n"
"    <groupId>org.keycloak</groupId>\n"
"    <artifactId>keycloak-servlet-filter-adapter</artifactId>\n"
"    <version>{project_versionMvn}</version>\n"
"</dependency>"

msgid "Using on OSGi"
msgstr "OSGiでの使用"

msgid ""
"The servlet filter adapter is packaged as an OSGi bundle, and thus is usable"
" in a generic OSGi environment (R6 and above) with HTTP Service and HTTP "
"Whiteboard."
msgstr ""
"サーブレット・フィルター・アダプターは、OSGiバンドルとしてパッケージされているため、HTTP ServiceとHTTP "
"Whiteboardを使用する汎用OSGi環境（R6以上）で使用できます。"

msgid "Installation"
msgstr "インストール"

msgid ""
"The adapter and its dependencies are distributed as Maven artifacts, so "
"you'll need either working Internet connection to access Maven Central, or "
"have the artifacts cached in your local Maven repo."
msgstr ""
"アダプターとその依存関係はMavenのアーティファクトとして配布されるため、Maven "
"Centralにアクセスするためにインターネット接続を使用するか、ローカルのMavenリポジトリーにアーティファクトをキャッシュする必要があります。"

msgid ""
"If you are using Apache Karaf, you can simply install a feature from the "
"Keycloak feature repo:"
msgstr "Apache Karafを使用している場合は、Keycloakフィーチャー・リポジトリーからフィーチャーをインストールするだけです。"

msgid ""
"karaf@root()> feature:repo-add mvn:org.keycloak/keycloak-osgi-features/{project_versionMvn}/xml/features\n"
"karaf@root()> feature:install keycloak-servlet-filter-adapter"
msgstr ""
"karaf@root()> feature:repo-add mvn:org.keycloak/keycloak-osgi-features/{project_versionMvn}/xml/features\n"
"karaf@root()> feature:install keycloak-servlet-filter-adapter"

msgid ""
"For other OSGi runtimes, please refer to the runtime documentation on how to"
" install the adapter bundle and its dependencies."
msgstr ""
"その他のOSGiランタイムについては、ランタイム・ドキュメントでアダプター・バンドルとその依存関係をインストールする方法を参照してください。"

msgid ""
"If your OSGi platform is Apache Karaf with Pax Web, you should consider "
"using <<_fuse_adapter,JBoss Fuse 6>> or <<_fuse7_adapter,JBoss Fuse 7>> "
"adapters instead."
msgstr ""
"OSGiプラットフォームがPax WebとApache Karafである場合は、代わりに<<_fuse_adapter,JBoss Fuse 6 "
">>アダプターまたは<<_fuse7_adapter,JBoss Fuse 7 >>アダプターを使用することを検討してください。"

msgid "Configuration"
msgstr "設定"

msgid ""
"First, the adapter needs to be registered as a servlet filter with the OSGi "
"HTTP Service. The most common ways to do this are programmatic (for example "
"via bundle activator) and declarative (using OSGi annotations). We recommend"
" using the latter since it simplifies the process of dynamically registering"
" and un-registering the filter:"
msgstr ""
"まず、アダプターをOSGi HTTP "
"Serviceでサーブレット・フィルターとして登録する必要があります。これを行う最も一般的な方法は、プログラム的な方法（たとえば、バンドル・アクティベーターを介して）と宣言的な方法（OSGiアノテーションを使用して）です。フィルターを動的に登録および登録解除するプロセスが簡素化されるため、後者を使用することをお勧めします。"

msgid ""
"package mypackage;\n"
"\n"
"import javax.servlet.Filter;\n"
"import org.keycloak.adapters.servlet.KeycloakOIDCFilter;\n"
"import org.osgi.service.component.annotations.Component;\n"
"import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n"
"\n"
"@Component(\n"
"    immediate = true,\n"
"    service = Filter.class,\n"
"    property = {\n"
"        KeycloakOIDCFilter.CONFIG_FILE_PARAM + \"=\" + \"keycloak.json\",\n"
"        HttpWhiteboardConstants.HTTP_WHITEBOARD_FILTER_PATTERN + \"=\" +\"/*\",\n"
"        HttpWhiteboardConstants.HTTP_WHITEBOARD_CONTEXT_SELECT + \"=\" + \"(osgi.http.whiteboard.context.name=mycontext)\"\n"
"    }\n"
")\n"
"public class KeycloakFilter extends KeycloakOIDCFilter {\n"
"  //\n"
"}"
msgstr ""
"package mypackage;\n"
"\n"
"import javax.servlet.Filter;\n"
"import org.keycloak.adapters.servlet.KeycloakOIDCFilter;\n"
"import org.osgi.service.component.annotations.Component;\n"
"import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n"
"\n"
"@Component(\n"
"    immediate = true,\n"
"    service = Filter.class,\n"
"    property = {\n"
"        KeycloakOIDCFilter.CONFIG_FILE_PARAM + \"=\" + \"keycloak.json\",\n"
"        HttpWhiteboardConstants.HTTP_WHITEBOARD_FILTER_PATTERN + \"=\" +\"/*\",\n"
"        HttpWhiteboardConstants.HTTP_WHITEBOARD_CONTEXT_SELECT + \"=\" + \"(osgi.http.whiteboard.context.name=mycontext)\"\n"
"    }\n"
")\n"
"public class KeycloakFilter extends KeycloakOIDCFilter {\n"
"  //\n"
"}"

msgid ""
"The above snippet uses OSGi declarative service specification to expose the "
"filter as an OSGI service under `javax.servlet.Filter` class. Once the class"
" is published in the OSGi service registry, it is going to be picked up by "
"OSGi HTTP Service implementation and used for filtering requests for the "
"specified servlet context. This will trigger Keycloak adapter for every "
"request that matches servlet context path + filter path."
msgstr ""
"上記のスニペットは、OSGi宣言型サービスの仕様を使用して、 `javax.servlet.Filter` "
"クラスの下でOSGIサービスとしてフィルターを公開します。クラスがOSGiサービス・レジストリーにパブリッシュされると、OSGi HTTP "
"Serviceの実装によってピックアップされ、指定されたサーブレット・コンテキストへのリクエストをフィルタリングするために使用されます。これにより、サーブレットのコンテキストパス+フィルターパスに一致するすべてのリクエストに対して、Keycloakアダプターがトリガーされます。"

msgid ""
"Since the component is put under the control of OSGi Configuration Admin "
"Service, it's properties can be configured dynamically. To do that, either "
"create a `mypackage.KeycloakFilter.cfg` file under the standard config "
"location for your OSGi runtime:"
msgstr ""
"コンポーネントはOSGi Configuration Admin "
"Serviceの制御下に置かれるため、そのプロパティーは動的に設定できます。これを行うには、OSGiランタイムの標準の設定場所に "
"`mypackage.KeycloakFilter.cfg` ファイルを作成するか、"

msgid ""
"keycloak.config.file = /path/to/keycloak.json\n"
"osgi.http.whiteboard.filter.pattern = /secure/*"
msgstr ""
"keycloak.config.file = /path/to/keycloak.json\n"
"osgi.http.whiteboard.filter.pattern = /secure/*"

msgid "or use interactive console, if your runtime allows for that:"
msgstr "または、ランタイムが可能な場合は、対話型コンソールを使用してください。"

msgid ""
"karaf@root()> config:edit mypackage.KeycloakFilter\n"
"karaf@root()> config:property-set keycloak.config.file '${karaf.etc}/keycloak.json'\n"
"karaf@root()> config:update"
msgstr ""
"karaf@root()> config:edit mypackage.KeycloakFilter\n"
"karaf@root()> config:property-set keycloak.config.file '${karaf.etc}/keycloak.json'\n"
"karaf@root()> config:update"

msgid ""
"If you need more control, for example, providing custom "
"`KeycloakConfigResolver` to implement <<_multi_tenancy,multi tenancy>>, you "
"can register the filter programmatically:"
msgstr ""
"より多くの制御が必要な場合、たとえば<<_multi_tenancy,マルチテナンシー >>を実装するカスタム "
"`KeycloakConfigResolver` を提供する場合は、次のようにフィルターをプログラムで登録することができます。"

msgid ""
"public class Activator implements BundleActivator {\n"
"\n"
"  private ServiceRegistration registration;\n"
"\n"
"  public void start(BundleContext context) throws Exception {\n"
"    Hashtable props = new Hashtable();\n"
"    props.put(HttpWhiteboardConstants.HTTP_WHITEBOARD_FILTER_PATTERN, \"/secure/*\");\n"
"    props.put(KeycloakOIDCFilter.CONFIG_RESOLVER_PARAM, new MyConfigResolver());\n"
"\n"
"    this.registration = context.registerService(Filter.class.getName(), new KeycloakOIDCFilter(), props);\n"
"  }\n"
"\n"
"  public void stop(BundleContext context) throws Exception {\n"
"    this.registration.unregister();\n"
"  }\n"
"}"
msgstr ""
"public class Activator implements BundleActivator {\n"
"\n"
"  private ServiceRegistration registration;\n"
"\n"
"  public void start(BundleContext context) throws Exception {\n"
"    Hashtable props = new Hashtable();\n"
"    props.put(HttpWhiteboardConstants.HTTP_WHITEBOARD_FILTER_PATTERN, \"/secure/*\");\n"
"    props.put(KeycloakOIDCFilter.CONFIG_RESOLVER_PARAM, new MyConfigResolver());\n"
"\n"
"    this.registration = context.registerService(Filter.class.getName(), new KeycloakOIDCFilter(), props);\n"
"  }\n"
"\n"
"  public void stop(BundleContext context) throws Exception {\n"
"    this.registration.unregister();\n"
"  }\n"
"}"

msgid ""
"Please refer to https://github.com/apache/felix-dev/tree/master/http#using-"
"the-osgi-http-whiteboard[Apache Felix HTTP Service] for more info on "
"programmatic registration."
msgstr ""
"プログラムによる登録の詳細については、 https://github.com/apache/felix-"
"dev/tree/master/http#using-the-osgi-http-whiteboard[Apache Felix HTTP "
"Service] を参照してください。"

msgid "JAAS plugin"
msgstr "JAASプラグイン"

msgid ""
"It's generally not needed to use JAAS for most of the applications, "
"especially if they are HTTP based, and you should most likely choose one of "
"our other adapters. However, some applications and systems may still rely on"
" pure legacy JAAS solution. {project_name} provides two login modules to "
"help in these situations."
msgstr ""
"ほとんどのアプリケーションでJAASを使用する必要はありません。特にHTTPベースのアプリケーションの場合は、JAASを使用する必要はありません。 "
"しかし、一部のアプリケーションやシステムは、依然として純粋なレガシーJAASソリューションに依存している場合があります。{project_name}は、このような状況に役立つ2つのログイン・モジュールを提供します。"

msgid "The provided login modules are:"
msgstr "提供されるログイン・モジュールは次のとおりです。"

msgid "org.keycloak.adapters.jaas.DirectAccessGrantsLoginModule"
msgstr "org.keycloak.adapters.jaas.DirectAccessGrantsLoginModule"

msgid ""
"This login module allows to authenticate with username/password from "
"{project_name}. It's using "
"<<_resource_owner_password_credentials_flow,Resource Owner Password "
"Credentials>> flow to validate if the provided username/password is valid. "
"It's useful for non-web based systems, which need to rely on JAAS and want "
"to use {project_name}, but can't use the standard browser based flows due to"
" their non-web nature. Example of such application could be messaging or "
"SSH."
msgstr ""
"このログイン・モジュールは、{project_name}のユーザー名/パスワードで認証することができます。<<_resource_owner_password_credentials_flow,リソース・オーナー・パスワード・クレデンシャル>>のフローを使用して、提供されたユーザー名/パスワードが有効かどうかを検証します。JAASに依存する必要があり、{project_name}を使用したい非Webベースのシステムにとっては有益ですが、Web以外の性質のため、標準のブラウザー・ベースのフローを使用することはできません。このようなアプリケーションとして挙げられるのは、メッセージングやSSHです。"

msgid "org.keycloak.adapters.jaas.BearerTokenLoginModule"
msgstr "org.keycloak.adapters.jaas.BearerTokenLoginModule"

msgid ""
"This login module allows to authenticate with {project_name} access token "
"passed to it through CallbackHandler as password. It may be useful for "
"example in case, when you have {project_name} access token from standard "
"based authentication flow and your web application then needs to talk to "
"external non-web based system, which rely on JAAS. For example a messaging "
"system."
msgstr ""
"このログイン・モジュールでは、パスワードとして `CallbackHandler` "
"を介して渡された{project_name}のアクセストークンで認証できます。たとえば、標準ベースの認証フローから{project_name}のアクセストークンを取得し、WebアプリケーションがJAASに依存する外部の非Webベースのシステムと対話する必要がある場合などに便利です。たとえば、メッセージング・システムです。"

msgid "Both modules use the following configuration properties:"
msgstr "どちらのモジュールも次の設定プロパティーを使用します。"

msgid "keycloak-config-file"
msgstr "keycloak-config-file"

msgid ""
"The location of the `keycloak.json` configuration file. The configuration "
"file can either be located on the filesystem or on the classpath. If it's "
"located on the classpath you need to prefix the location with `classpath:` "
"(for example `classpath:/path/keycloak.json`). This is _REQUIRED._"
msgstr ""
"`keycloak.json` "
"設定ファイルの場所。設定ファイルは、ファイルシステム上またはクラスパス上に置くことができます。クラスパス上にある場合は、その場所の前に "
"`classpath:` を付ける必要があります（たとえば `classpath:/path/keycloak.json` ）。これは _必須_ です。"

msgid "`role-principal-class`"
msgstr "`role-principal-class`"

msgid ""
"Configure alternative class for Role principals attached to JAAS Subject. "
"Default value is `org.keycloak.adapters.jaas.RolePrincipal`. Note: The class"
" is required to have a constructor with a single `String` argument."
msgstr ""
"JAAS Subjectに添付されているロール・プリンシパルの代替クラスを設定します。デフォルト値は "
"`org.keycloak.adapters.jaas.RolePrincipal` です。注意：クラスには、単一の `String` "
"引数を持つコンストラクタが必要です。"

msgid "`scope`"
msgstr "`scope`"

msgid ""
"This option is only applicable to the `DirectAccessGrantsLoginModule`. The "
"specified value will be used as the OAuth2 `scope` parameter in the Resource"
" Owner Password Credentials Grant request."
msgstr ""
"このオプションは `DirectAccessGrantsLoginModule` "
"にのみ適用されます。指定された値は、リソース・オーナー・パスワード・クレデンシャル・グラント・リクエストのOAuth2 `scope` "
"パラメーターとして使用されます。"

msgid "CLI / Desktop Applications"
msgstr "CLI / デスクトップ・アプリケーション"

msgid ""
"{project_name} supports securing desktop (for example Swing, JavaFX) or CLI "
"applications via the `KeycloakInstalled` adapter by performing the "
"authentication step via the system browser."
msgstr ""
"{project_name}は、システム・ブラウザーを介して認証ステップを実行することによって、 `KeycloakInstalled` "
"アダプターを介したデスクトップ（たとえば、Swing、JavaFX）またはCLIアプリケーションのセキュリティー保護をサポートします。"

msgid ""
"The `KeycloakInstalled` adapter supports a `desktop` and a `manual` variant."
" The desktop variant uses the system browser to gather the user credentials."
" The manual variant reads the user credentials from `STDIN`."
msgstr ""
"`KeycloakInstalled` アダプターは、 `desktop` と `manual` "
"のバリアントをサポートしています。デスクトップ・バリアントは、システム・クレデンシャルを収集するためにシステム・ブラウザーを使用します。手動バリアントは、ユーザー・クレデンシャルを"
" `STDIN` から読み込みます。"

msgid "How it works"
msgstr "どのように動くか"

msgid ""
"To authenticate a user with the `desktop` variant the `KeycloakInstalled` "
"adapter opens a desktop browser window where a user uses the regular "
"{project_name} login pages to login when the `loginDesktop()` method is "
"called on the `KeycloakInstalled` object."
msgstr ""
"`desktop` バリアントを使用してユーザーを認証するために、 `KeycloakInstalled` "
"アダプターはデスクトップ・ブラウザーのウィンドウを開きます。ここで `KeycloakInstalled` オブジェクトに対して "
"`loginDesktop()` メソッドが呼び出されると、ユーザーは通常の{project_name}ログインページを使用してログインします。"

msgid ""
"The login page URL is opened with redirect parameter that points to a local "
"`ServerSocket` listening on a free ephemeral port on `localhost` which is "
"started by the adapter."
msgstr ""
"ログイン・ページのURLは、アダプターによって起動される `localhost` の空きエフェメラル・ポートをリッスンするローカル "
"`ServerSocket` を指すリダイレクト・パラメーターでオープンされます。"

msgid ""
"After a succesful login the `KeycloakInstalled` receives the authorization "
"code from the incoming HTTP request and performs the authorization code "
"flow. Once the code to token exchange is completed the `ServerSocket` is "
"shutdown."
msgstr ""
"ログイン成功後、 `KeycloakInstalled` "
"は受信したHTTPリクエストから認可コードを受け取り、認可コード・フローを実行します。トークンからコードへの交換が完了すると、 "
"`ServerSocket` はシャットダウンされます。"

msgid ""
"If the user already has an active {project_name} session then the login form"
" is not shown but the code to token exchange is continued, which enables a "
"smooth Web based SSO experience."
msgstr ""
"ユーザーがすでに{project_name}のアクティブなセッションを持っている場合、ログイン・フォームは表示されませんが、コードからトークンへの交換は継続され、スムーズなWebベースのSSO体験が可能になります。"

msgid ""
"The client eventually receives the tokens (access_token, refresh_token, "
"id_token) which can then be used to call backend services."
msgstr ""
"クライアントは、最終的にバックエンド・サービスを呼び出すために使用できるトークン（access_token、refresh_token、id_token）を受け取ります。"

msgid ""
"The `KeycloakInstalled` adapter provides support for renewal of stale "
"tokens."
msgstr "`KeycloakInstalled` アダプターは失効したトークンの更新をサポートします。"

msgid ""
"\n"
"\n"
"<dependency>\n"
"\t<groupId>org.keycloak</groupId>\n"
"\t<artifactId>keycloak-installed-adapter</artifactId>\n"
"\t<version>{project_versionMvn}</version>\n"
"</dependency>\n"
msgstr ""
"\n"
"\n"
"<dependency>\n"
"\t<groupId>org.keycloak</groupId>\n"
"\t<artifactId>keycloak-installed-adapter</artifactId>\n"
"\t<version>{project_versionMvn}</version>\n"
"</dependency>\n"

msgid "Client configuration"
msgstr "クライアントの設定"

msgid ""
"The application needs to be configured as a `public` OpenID Connect client "
"with `Standard Flow Enabled` and pass:[http://localhost] as an allowed "
"`Valid Redirect URI`."
msgstr ""
"アプリケーションは、 `Standard Flow Enabled` で `public` なOpenID Connectクライアントであり、許可される"
" `Valid Redirect URI` として pass:[http://localhost] が設定される必要があります。"

msgid ""
"The `KeycloakInstalled` adapter supports the `PKCE` [RFC 7636] mechanism to "
"provide additional protection during code to token exchanges in the `OIDC` "
"protocol. PKCE can be enabled with the `\"enable-pkce\": true` setting in "
"the adapter configuration. Enabling PKCE is highly recommended, to avoid "
"code injection and code replay attacks."
msgstr ""
"`KeycloakInstalled` アダプターは、 `OIDC` プロトコルでのコードからトークンへの交換中に追加の保護を提供する `PKCE` "
"[RFC 7636] メカニズムをサポートします。PKCEは、アダプター設定の `\"enable-pkce\": true` "
"の設定で有効にできます。コード・インジェクションおよびコードリプレイ攻撃を回避するために、PKCEを有効にすることを強くお勧めします。"

msgid "Usage"
msgstr "使い方"

msgid ""
"The `KeycloakInstalled` adapter reads it's configuration from `META-"
"INF/keycloak.json` on the classpath. Custom configurations can be supplied "
"with an `InputStream` or a `KeycloakDeployment` through the "
"`KeycloakInstalled` constructor."
msgstr ""
"`KeycloakInstalled` アダプターはクラスパス上の `META-INF/keycloak.json` "
"から設定を読み込みます。カスタム設定は、 `KeycloakInstalled` コンストラクタを介して、 `InputStream` または "
"`KeycloakDeployment` で提供することができます。"

msgid ""
"In the example below, the client configuration for `desktop-app` uses the "
"following `keycloak.json`:"
msgstr "以下の例では、 `desktop-app` のクライアント設定は `keycloak.json` を使います。"

msgid ""
"\n"
"{\n"
"  \"realm\": \"desktop-app-auth\",\n"
"  \"auth-server-url\": \"http://localhost:8081{kc_base_path}\",\n"
"  \"ssl-required\": \"external\",\n"
"  \"resource\": \"desktop-app\",\n"
"  \"public-client\": true,\n"
"  \"use-resource-role-mappings\": true,\n"
"  \"enable-pkce\": true\n"
"}\n"
msgstr ""
"\n"
"{\n"
"  \"realm\": \"desktop-app-auth\",\n"
"  \"auth-server-url\": \"http://localhost:8081{kc_base_path}\",\n"
"  \"ssl-required\": \"external\",\n"
"  \"resource\": \"desktop-app\",\n"
"  \"public-client\": true,\n"
"  \"use-resource-role-mappings\": true,\n"
"  \"enable-pkce\": true\n"
"}\n"

msgid ""
"the following sketch demonstrates working with the `KeycloakInstalled` "
"adapter:"
msgstr "次のスケッチは、 `KeycloakInstalled` アダプターとの動作を示しています。"

msgid ""
"\n"
"// reads the configuration from classpath: META-INF/keycloak.json\n"
"KeycloakInstalled keycloak = new KeycloakInstalled();\n"
"\n"
"// opens desktop browser\n"
"keycloak.loginDesktop();\n"
"\n"
"AccessToken token = keycloak.getToken();\n"
"// use token to send backend request\n"
"\n"
"// ensure token is valid for at least 30 seconds\n"
"long minValidity = 30L;\n"
"String tokenString = keycloak.getTokenString(minValidity, TimeUnit.SECONDS);\n"
"\n"
"\n"
" // when you want to logout the user.\n"
"keycloak.logout();\n"
msgstr ""
"\n"
"// reads the configuration from classpath: META-INF/keycloak.json\n"
"KeycloakInstalled keycloak = new KeycloakInstalled();\n"
"\n"
"// opens desktop browser\n"
"keycloak.loginDesktop();\n"
"\n"
"AccessToken token = keycloak.getToken();\n"
"// use token to send backend request\n"
"\n"
"// ensure token is valid for at least 30 seconds\n"
"long minValidity = 30L;\n"
"String tokenString = keycloak.getTokenString(minValidity, TimeUnit.SECONDS);\n"
"\n"
"\n"
" // when you want to logout the user.\n"
"keycloak.logout();\n"

msgid ""
"The `KeycloakInstalled` class supports customization of the http responses "
"returned by login / logout requests via the `loginResponseWriter` and "
"`logoutResponseWriter` attributes."
msgstr ""
"`KeycloakInstalled` クラスは `loginResponseWriter` 属性と `logoutResponseWriter` "
"属性を介したログイン/ログアウト・リクエストによって、返されたHTTPレスポンスのカスタマイズをサポートしています。"

msgid "Example"
msgstr "例"

msgid ""
"The following provides an example for the configuration mentioned above."
msgstr "以下に、上記の設定例を示します。"

msgid ""
"import java.util.Locale;\n"
"import java.util.concurrent.Executors;\n"
"import java.util.concurrent.TimeUnit;\n"
"\n"
"import org.keycloak.adapters.installed.KeycloakInstalled;\n"
"import org.keycloak.representations.AccessToken;\n"
"\n"
"public class DesktopApp {\n"
"\n"
"\tpublic static void main(String[] args) throws Exception {\n"
"\n"
"\t\tKeycloakInstalled keycloak = new KeycloakInstalled();\n"
"\t\tkeycloak.setLocale(Locale.ENGLISH);\n"
"\t\tkeycloak.loginDesktop();\n"
"\n"
"\t\tAccessToken token = keycloak.getToken();\n"
"\t\tExecutors.newSingleThreadExecutor().submit(() -> {\n"
"\n"
"\t\t\tSystem.out.println(\"Logged in...\");\n"
"\t\t\tSystem.out.println(\"Token: \" + token.getSubject());\n"
"\t\t\tSystem.out.println(\"Username: \" + token.getPreferredUsername());\n"
"\t\t\ttry {\n"
"\t\t\t\tSystem.out.println(\"AccessToken: \" + keycloak.getTokenString());\n"
"\t\t\t} catch (Exception ex) {\n"
"\t\t\t\tex.printStackTrace();\n"
"\t\t\t}\n"
"\n"
"\t\t\tint timeoutSeconds = 20;\n"
"\t\t\tSystem.out.printf(\"Logging out in...%d Seconds%n\", timeoutSeconds);\n"
"\t\t\ttry {\n"
"\t\t\t\tTimeUnit.SECONDS.sleep(timeoutSeconds);\n"
"\t\t\t} catch (Exception e) {\n"
"\t\t\t\te.printStackTrace();\n"
"\t\t\t}\n"
"\n"
"\t\t\ttry {\n"
"\t\t\t\tkeycloak.logout();\n"
"\t\t\t} catch (Exception e) {\n"
"\t\t\t\te.printStackTrace();\n"
"\t\t\t}\n"
"\n"
"\t\t\tSystem.out.println(\"Exiting...\");\n"
"\t\t\tSystem.exit(0);\n"
"\t\t});\n"
"\t}\n"
"}"
msgstr ""
"import java.util.Locale;\n"
"import java.util.concurrent.Executors;\n"
"import java.util.concurrent.TimeUnit;\n"
"\n"
"import org.keycloak.adapters.installed.KeycloakInstalled;\n"
"import org.keycloak.representations.AccessToken;\n"
"\n"
"public class DesktopApp {\n"
"\n"
"\tpublic static void main(String[] args) throws Exception {\n"
"\n"
"\t\tKeycloakInstalled keycloak = new KeycloakInstalled();\n"
"\t\tkeycloak.setLocale(Locale.ENGLISH);\n"
"\t\tkeycloak.loginDesktop();\n"
"\n"
"\t\tAccessToken token = keycloak.getToken();\n"
"\t\tExecutors.newSingleThreadExecutor().submit(() -> {\n"
"\n"
"\t\t\tSystem.out.println(\"Logged in...\");\n"
"\t\t\tSystem.out.println(\"Token: \" + token.getSubject());\n"
"\t\t\tSystem.out.println(\"Username: \" + token.getPreferredUsername());\n"
"\t\t\ttry {\n"
"\t\t\t\tSystem.out.println(\"AccessToken: \" + keycloak.getTokenString());\n"
"\t\t\t} catch (Exception ex) {\n"
"\t\t\t\tex.printStackTrace();\n"
"\t\t\t}\n"
"\n"
"\t\t\tint timeoutSeconds = 20;\n"
"\t\t\tSystem.out.printf(\"Logging out in...%d Seconds%n\", timeoutSeconds);\n"
"\t\t\ttry {\n"
"\t\t\t\tTimeUnit.SECONDS.sleep(timeoutSeconds);\n"
"\t\t\t} catch (Exception e) {\n"
"\t\t\t\te.printStackTrace();\n"
"\t\t\t}\n"
"\n"
"\t\t\ttry {\n"
"\t\t\t\tkeycloak.logout();\n"
"\t\t\t} catch (Exception e) {\n"
"\t\t\t\te.printStackTrace();\n"
"\t\t\t}\n"
"\n"
"\t\t\tSystem.out.println(\"Exiting...\");\n"
"\t\t\tSystem.exit(0);\n"
"\t\t});\n"
"\t}\n"
"}"

msgid "Security Context"
msgstr "セキュリティー・コンテキスト"

msgid ""
"The `KeycloakSecurityContext` interface is available if you need to access "
"to the tokens directly. This could be useful if you want to retrieve "
"additional details from the token (such as user profile information) or you "
"want to invoke a RESTful service that is protected by {project_name}."
msgstr ""
"`KeycloakSecurityContext` "
"インターフェイスはトークンに直接アクセスする必要がある場合に利用できます。これは、トークンから追加の詳細情報（ユーザー・プロファイル情報など）を取得する場合や、{project_name}によって保護されているRESTfulサービスを呼び出す場合に便利です。"

msgid ""
"In servlet environments it is available in secured invocations as an "
"attribute in HttpServletRequest:"
msgstr ""
"サーブレット環境では、セキュアな呼び出しで `HttpServletRequest` "
"の属性として以下のようにセキュリティー・コンテキストを利用できます。"

msgid ""
"httpServletRequest\n"
"    .getAttribute(KeycloakSecurityContext.class.getName());"
msgstr ""
"httpServletRequest\n"
"    .getAttribute(KeycloakSecurityContext.class.getName());"

msgid "Or, it is available in insecured requests in the HttpSession:"
msgstr "または、セキュアでないリクエストでは以下のように `HttpSession` からセキュリティー・コンテキストを利用できます。"

msgid ""
"httpServletRequest.getSession()\n"
"    .getAttribute(KeycloakSecurityContext.class.getName());"
msgstr ""
"httpServletRequest.getSession()\n"
"    .getAttribute(KeycloakSecurityContext.class.getName());"

msgid "Error handling"
msgstr "エラー処理"

msgid ""
"{project_name} has some error handling facilities for servlet based client "
"adapters. When an error is encountered in authentication, {project_name} "
"will call `HttpServletResponse.sendError()`. You can set up an error-page "
"within your `web.xml` file to handle the error however you want. "
"{project_name} can throw 400, 401, 403, and 500 errors."
msgstr ""
"{project_name}には、サーブレットベースのクライアント・アダプター用のエラー処理機能があります。認証でエラーが発生すると、{project_name}は"
" `HttpServletResponse.sendError()` を呼び出します。 `web.xml` ファイル内にerror-"
"pageを設定してエラーを処理することができます。{project_name}は400、401、403、500のエラーをスローできます。"

msgid ""
"<error-page>\n"
"    <error-code>403</error-code>\n"
"    <location>/ErrorHandler</location>\n"
"</error-page>"
msgstr ""
"<error-page>\n"
"    <error-code>403</error-code>\n"
"    <location>/ErrorHandler</location>\n"
"</error-page>"

msgid ""
"{project_name} also sets a `HttpServletRequest` attribute that you can "
"retrieve. The attribute name is "
"`org.keycloak.adapters.spi.AuthenticationError`, which should be casted to "
"`org.keycloak.adapters.OIDCAuthenticationError`."
msgstr ""
"{project_name}はまた、取得可能な  `HttpServletRequest` 属性を設定します。属性名は、 "
"`org.keycloak.adapters.spi.AuthenticationError` です。これは "
"`org.keycloak.adapters.OIDCAuthenticationError` にキャストする必要があります。"

msgid ""
"import org.keycloak.adapters.OIDCAuthenticationError;\n"
"import org.keycloak.adapters.OIDCAuthenticationError.Reason;\n"
"...\n"
"\n"
"OIDCAuthenticationError error = (OIDCAuthenticationError) httpServletRequest\n"
"    .getAttribute('org.keycloak.adapters.spi.AuthenticationError');\n"
"\n"
"Reason reason = error.getReason();\n"
"System.out.println(reason.name());"
msgstr ""
"import org.keycloak.adapters.OIDCAuthenticationError;\n"
"import org.keycloak.adapters.OIDCAuthenticationError.Reason;\n"
"...\n"
"\n"
"OIDCAuthenticationError error = (OIDCAuthenticationError) httpServletRequest\n"
"    .getAttribute('org.keycloak.adapters.spi.AuthenticationError');\n"
"\n"
"Reason reason = error.getReason();\n"
"System.out.println(reason.name());"

msgid "Logout"
msgstr "ログアウト"

msgid ""
"You can log out of a web application in multiple ways. For Jakarta EE "
"servlet containers, you can call `HttpServletRequest.logout()`. For other "
"browser applications, you can redirect the browser to `\\http://auth-"
"server{kc_realms_path}/{realm-name}/protocol/openid-"
"connect/logout?redirect_uri=encodedRedirectUri`, which logs you out if you "
"have an SSO session with your browser."
msgstr ""
"Webアプリケーションからログアウトする方法は複数あります。Jakarta EEサーブレット・コンテナーの場合、 "
"`HttpServletRequest.logout()` "
"を呼び出すことができます。他のブラウザー・アプリケーションの場合、ブラウザーにSSOセッションがあれば、 `http://auth-"
"server/{kc_realms_path}/{realm-name}/protocol/openid-"
"connect/logout?redirect_uri=encodedRedirectUri` にリダイレクトすることでログアウトできます。"

msgid ""
"When using the `HttpServletRequest.logout()` option the adapter executes a "
"back-channel POST call against the {project_name} server passing the refresh"
" token. If the method is executed from an unprotected page (a page that does"
" not check for a valid token) the refresh token can be unavailable and, in "
"that case, the adapter skips the call. For this reason, using a protected "
"page to execute `HttpServletRequest.logout()` is recommended so that current"
" tokens are always taken into account and an interaction with the "
"{project_name} server is performed if needed."
msgstr ""
"`HttpServletRequest.logout()` "
"を使用すると、アダプターは{project_name}サーバーに対して、バックチャネルでリフレッシュトークンを渡すPOSTリクエストを送信します。保護されていないページ（有効なトークンをチェックしていないページ）からメソッドが実行された場合、リフレッシュトークンは使用できない可能性があり、その場合はアダプターがPOSTリクエストの送信をスキップします。このため、現在のトークンが常に考慮され、必要に応じて{project_name}サーバーとの対話が実行されるように、保護されたページを使用して"
" `HttpServletRequest.logout()` を実行することを推奨します。"

msgid ""
"If you want to avoid logging out of an external identity provider as part of"
" the logout process, you can supply the parameter `$$initiating_idp$$`, with"
" the value being the identity (alias) of the identity provider in question. "
"This is useful when the logout endpoint is invoked as part of single logout "
"initiated by the external identity provider."
msgstr ""
"ログアウト・プロセスの一部として外部アイデンティティー･プロバイダーからログアウトしないようにするには、パラメーター "
"`$$initiating_idp$$` "
"を指定します。値は当該のアイデンティティー･プロバイダーのアイデンティティー（エイリアス）です。これは、外部アイデンティティー･プロバイダーによって開始されたシングルログアウトの一部として、ログアウト・エンドポイントが呼び出された場合に便利です。"

msgid "Parameters forwarding"
msgstr "パラメーター・フォワーディング"

msgid ""
"The {project_name}  initial authorization endpoint request has support for "
"various parameters. Most of the parameters are described in "
"https://openid.net/specs/openid-connect-"
"core-1_0.html#AuthorizationEndpoint[OIDC specification]. Some parameters are"
" added automatically by the adapter based on the adapter configuration. "
"However, there are also a few parameters that can be added on a per-"
"invocation basis. When you open the secured application URI, the particular "
"parameter will be forwarded to the {project_name} authorization endpoint."
msgstr ""
"{project_name}の初期認可エンドポイント・リクエストは、さまざまなパラメーターをサポートしています。ほとんどのパラメータは "
"https://openid.net/specs/openid-connect-"
"core-1_0.html#AuthorizationEndpoint[OIDC仕様] "
"に記述されています。一部のパラメーターは、アダプターの設定に基づいて、アダプターにより自動的に追加されます。ただし、呼び出しごとに追加できるパラメーターもいくつかあります。保護されたアプリケーションURIにアクセスすると、特定のパラメーターは{project_name}認可エンドポイントにフォワードされます。"

msgid ""
"For example, if you request an offline token, then you can open the secured "
"application URI with the `scope` parameter like:"
msgstr ""
"たとえば、オフライントークンを要求する場合、以下のように `scope` パラメーターを使用して保護されたアプリケーションのURIにアクセスできます。"

msgid "http://myappserver/mysecuredapp?scope=offline_access"
msgstr "http://myappserver/mysecuredapp?scope=offline_access"

msgid ""
"and the parameter `scope=offline_access` will be automatically forwarded to "
"the {project_name} authorization endpoint."
msgstr "パラメーター `scope=offline_access` が自動的に{project_name}認可エンドポイントにフォワードされます。"

msgid "The supported parameters are:"
msgstr "サポートされるパラメーターは次のとおりです。"

msgid ""
"scope - Use a space-delimited list of scopes. A space-delimited list "
"typically references link:{adminguide_link}#_client_scopes[Client scopes] "
"defined on particular client. Note that the scope `openid` will be always be"
" added to the list of scopes by the adapter. For example, if you enter the "
"scope options `address phone`, then the request to {project_name} will "
"contain the scope parameter `scope=openid address phone`."
msgstr ""
"scope - "
"スペース区切りのスコープリストを使用します。スペースで区切られたリストは通常、特定のクライアントで定義されたlink:{adminguide_link}#_client_scopes[クライアントスコープ]を参照します。スコープ"
" `openid` は、アダプターによって常にスコープのリストに追加されることに注意してください。たとえば、スコープ・オプション `address "
"phone` を入力すると、{project_name}へのリクエストにスコープ・パラメーター `scope=openid address phone`"
" が含まれます。"

msgid "prompt - {project_name} supports these settings:"
msgstr "prompt - {project_name}は以下の設定をサポートしています。"

msgid ""
"`login` - SSO will be ignored and the {project_name} login page will be "
"always shown, even if the user is already authenticated"
msgstr "`login` - SSOは無視され、ユーザーがすでに認証されていても{project_name}ログインページが常に表示されます"

msgid ""
"`consent` - Applicable only for the clients with `Consent Required`. If it "
"is used, the Consent page will always be displayed, even if the user "
"previously granted consent to this client."
msgstr ""
"`consent` - Consent Required "
"のクライアントにのみ適用されます。これを使用すると、ユーザーが以前にこのクライアントに同意したとしても、常に同意ページが表示されます。"

msgid ""
"`none` - The login page will never be shown; instead the user will be "
"redirected to the application, with an error if the user is not yet "
"authenticated. This setting allows you to create a filter/interceptor on the"
" application side and show a custom error page to the user. See more details"
" in the specification."
msgstr ""
"`none` - "
"ログインページは表示されません。代わりにユーザーはアプリケーションにリダイレクトされ、ユーザーがまだ認証されていない場合はエラーが発生します。この設定により、アプリケーション側でフィルター/インターセプターを作成し、ユーザーにカスタム・エラーページを表示することができます。詳細については、仕様を参照してください。"

msgid ""
"max_age - Used only if a user is already authenticated. Specifies maximum "
"permitted time for the authentication to persist, measured from when the "
"user authenticated. If user is authenticated longer than `maxAge`, the SSO "
"is ignored and he must re-authenticate."
msgstr ""
"max_age - "
"ユーザーがすでに認証されている場合にのみ使用されます。ユーザーが認証されたときから測定された、認証が維持される最大許容時間を指定します。ユーザーが認証されてから"
" `maxAge` が経過すると、SSOは無視され、再認証が必要になります。"

msgid ""
"login_hint - Used to pre-fill the username/email field on the login form."
msgstr "login_hint - ログイン・フォームのユーザー名/電子メール・フィールドを事前入力するために使用されます。"

msgid ""
"kc_idp_hint - Used to tell {project_name} to skip showing login page and "
"automatically redirect to specified identity provider instead. More info in "
"the link:{adminguide_link}#_client_suggested_idp[Identity Provider "
"documentation]."
msgstr ""
"kc_idp_hint - "
"{project_name}にログインページの表示をスキップし、代わりに指定されたアイデンティティー・プロバイダーに自動的にリダイレクトするように指示するために使用されます。詳細は、link:{adminguide_link}#_client_suggested_idp[アイデンティティー・プロバイダーのドキュメント]を参照してください。"

msgid ""
"Most of the parameters are described in the https://openid.net/specs/openid-"
"connect-core-1_0.html#AuthorizationEndpoint[OIDC specification]. The only "
"exception is parameter `kc_idp_hint`, which is specific to {project_name} "
"and contains the name of the identity provider to automatically use. For "
"more information see the `Identity Brokering` section in the "
"link:{adminguide_link}[{adminguide_name}]."
msgstr ""
"ほとんどのパラメーターは https://openid.net/specs/openid-connect-"
"core-1_0.html#AuthorizationEndpoint[OIDC仕様] に記載されています。唯一の例外はパラメーター "
"`kc_idp_hint` です。これは{project_name}固有で、自動的に使用するアイデンティティー・プロバイダーの名前を含んでいます。詳細は"
" link:{adminguide_link}[{adminguide_name}] の `アイデンティティー・ブローカリング` "
"のセクションを参照してください。"

msgid ""
"If you open the URL using the attached parameters, the adapter will not "
"redirect you to {project_name} if you are already authenticated in the "
"application. For example, opening "
"$$http://myappserver/mysecuredapp?prompt=login$$ will not automatically "
"redirect you to the {project_name} login page if you are already "
"authenticated to the application `mysecuredapp` . This behavior may be "
"changed in the future."
msgstr ""
"アプリケーションで既に認証されている場合、添付されたパラメーターを使用してURLを開いても、アダプターは{project_name}にリダイレクトしません。たとえば、アプリケーション"
" `mysecuredapp` にすでに認証されている場合、 "
"$$http://myappserver/mysecuredapp?prompt=login$$ "
"を開いても、自動的に{project_name}ログインページにリダイレクトされません。この挙動は将来変更される可能性があります。"

msgid "Client authentication"
msgstr "クライアント認証"

msgid ""
"When a confidential OIDC client needs to send a backchannel request (for "
"example, to exchange code for the token, or to refresh the token) it needs "
"to authenticate against the {project_name} server. By default, there are "
"three ways to authenticate the client: client ID and client secret, client "
"authentication with signed JWT, or client authentication with signed JWT "
"using client secret."
msgstr ""
"コンフィデンシャルOIDCクライアントがバックチャネル・リクエストを送信する必要がある場合（たとえば、トークンのコードを交換したり、トークンをリフレッシュするような場合）、{project_name}サーバーに対して認証する必要があります。デフォルトでは、クライアントIDとクライアント・シークレット、署名付きJWTによるクライアント認証、またはクライアント・シークレットを使用した署名付きJWTによるクライアント認証の3つの方法でクライアントを認証します。"

msgid "Client ID and Client Secret"
msgstr "クライアントIDとクライアント・シークレット"

msgid ""
"This is the traditional method described in the OAuth2 specification. The "
"client has a secret, which needs to be known to both the adapter "
"(application) and the {project_name} server. You can generate the secret for"
" a particular client in the {project_name} Admin Console, and then paste "
"this secret into the `keycloak.json` file on the application side:"
msgstr ""
"これは、OAuth2の仕様で説明されている伝統的な方法です。クライアントにはシークレットがあり、アダプター（アプリケーション）と{project_name}サーバーの両方に知られている必要があります。{project_name}管理コンソールで特定のクライアントのシークレットを生成し、このシークレットをアプリケーション側の"
" `keycloak.json` ファイルに以下のように貼り付けます。"

msgid ""
"\"credentials\": {\n"
"    \"secret\": \"19666a4f-32dd-4049-b082-684c74115f28\"\n"
"}"
msgstr ""
"\"credentials\": {\n"
"    \"secret\": \"19666a4f-32dd-4049-b082-684c74115f28\"\n"
"}"

msgid "Client authentication with Signed JWT"
msgstr "署名付きJWTによるクライアント認証"

msgid ""
"This is based on the https://datatracker.ietf.org/doc/html/rfc7523[RFC7523] "
"specification. It works this way:"
msgstr ""
"これは https://datatracker.ietf.org/doc/html/rfc7523[RFC7523] "
"の仕様に基づいています。以下の方法で動作します。"

msgid ""
"The client must have the private key and certificate. For  {project_name} "
"this is available through the traditional `keystore` file, which is either "
"available on the client application's classpath or somewhere on the file "
"system."
msgstr ""
"クライアントには秘密鍵と証明書が必要です。{project_name}の場合、これは伝統的な  `keystore` "
"ファイルから利用できます。これはクライアント・アプリケーションのクラスパスかファイルシステムのどこかで利用できます。"

msgid ""
"Once the client application is started, it allows to download its public key"
" in https://self-issued.info/docs/draft-ietf-jose-json-web-key.html[JWKS] "
"format using a URL such as \\http://myhost.com/myapp/k_jwks, assuming that "
"\\http://myhost.com/myapp is the base URL of your client application. This "
"URL can be used by {project_name} (see below)."
msgstr ""
"クライアント・アプリケーションが開始されると、 \\http://myhost.com/myapp/k_jwks のようなURLを使った "
"https://self-issued.info/docs/draft-ietf-jose-json-web-key.html[JWKS] "
"形式の公開鍵のダウンロードが許可されます。 \\http://myhost.com/myapp "
"はクライアント・アプリケーションのベースURLであることを前提としています。このURLは{project_name}により使用されます（下記参照）。"

msgid ""
"During authentication, the client generates a JWT token and signs it with "
"its private key and sends it to {project_name} in the particular backchannel"
" request (for example, code-to-token request) in the `client_assertion` "
"parameter."
msgstr ""
"認証中に、クライアントはJWTトークンを生成し、その秘密鍵で署名し、 `client_assertion` "
"パラメーターとともに特定のバックチャネル・リクエスト（たとえば、コードからトークンへの交換リクエスト）を{project_name}に送信します。"

msgid ""
"{project_name} must have the public key or certificate of the client so that"
" it can verify the signature on JWT. In {project_name} you need to configure"
" client credentials for your client. First you need to choose `Signed JWT` "
"as the method of authenticating your client in the tab `Credentials` in the "
"Admin Console. Then you can choose to either in the tab `Keys`:"
msgstr ""
"{project_name}は、JWTの署名を検証できるように、クライアントの公開鍵または証明書を持っていなければなりません。{project_name}では、クライアントのクライアント・クレデンシャルを設定する必要があります。まず、管理コンソールの"
" `Credentials` タブでクライアントを認証する方法として、 `Signed JWT` を選択する必要があります。そして、次のどちらかを "
"`Keys` タブで選択することができます。"

msgid ""
"Configure the JWKS URL where {project_name} can download the client's public"
" keys. This can be a URL such as  \\http://myhost.com/myapp/k_jwks (see "
"details above). This option is the most flexible, since the client can "
"rotate its keys anytime and {project_name} then always downloads new keys "
"when needed without needing to change the configuration. More accurately,  "
"{project_name} downloads new keys when it sees the token signed by an "
"unknown `kid` (Key ID)."
msgstr ""
"{project_name}がクライアントの公開鍵をダウンロードできるJWKS URLを設定します。これは "
"\\http://myhost.com/myapp/k_jwks "
"のようなURLです（詳細は上記を参照）。クライアントはいつでもキーをローテーションさせることができるので、このオプションは最も柔軟です。{project_name}は、設定を変更することなく、必要なときに常に新しいキーをダウンロードします。より正確には、{project_name}は、未知の"
" `kid` （Key ID）で署名されたトークンを見ると、新しい鍵をダウンロードします。"

msgid ""
"Upload the client's public key or certificate, either in PEM format, in JWK "
"format, or from the keystore. With this option, the public key is hardcoded "
"and must be changed when the client generates a new key pair. You can even "
"generate your own keystore from the {project_name} Admin Console if you "
"don't have your own available. For more details on how to set up the "
"{project_name} Admin Console, see the {adminguide_link}[{adminguide_name}]."
msgstr ""
"クライアントの公開鍵または証明書を、PEM形式、JWK形式、またはキーストアからアップロードします。このオプションを使用すると、公開鍵はハードコードされるので、クライアントが新しい鍵ペアを生成するときに変更する必要があります。独自のキーストアがない場合は、{project_name}管理コンソールから独自のキーストアを生成することもできます。{project_name}管理コンソールの設定方法の詳細については、{adminguide_link}[{adminguide_name}]を参照してください。"

msgid ""
"For set up on the adapter side you need to have something like this in your "
"`keycloak.json` file:"
msgstr "アダプター側でセットアップするには、 `keycloak.json` ファイルに次のようなものが必要です。"

msgid ""
"\"credentials\": {\n"
"  \"jwt\": {\n"
"    \"client-keystore-file\": \"classpath:keystore-client.jks\",\n"
"    \"client-keystore-type\": \"JKS\",\n"
"    \"client-keystore-password\": \"storepass\",\n"
"    \"client-key-password\": \"keypass\",\n"
"    \"client-key-alias\": \"clientkey\",\n"
"    \"token-expiration\": 10\n"
"  }\n"
"}"
msgstr ""
"\"credentials\": {\n"
"  \"jwt\": {\n"
"    \"client-keystore-file\": \"classpath:keystore-client.jks\",\n"
"    \"client-keystore-type\": \"JKS\",\n"
"    \"client-keystore-password\": \"storepass\",\n"
"    \"client-key-password\": \"keypass\",\n"
"    \"client-key-alias\": \"clientkey\",\n"
"    \"token-expiration\": 10\n"
"  }\n"
"}"

msgid ""
"With this configuration, the keystore file `keystore-client.jks` must be "
"available on classpath in your WAR. If you do not use the prefix "
"`classpath:` you can point to any file on the file system where the client "
"application is running."
msgstr ""
"この設定では、キーストア・ファイル `keystore-client.jks` がWARのクラスパス上で利用可能でなければなりません。 "
"`classpath:` "
"というプレフィックスを使用しない場合は、クライアント・アプリケーションが実行されているファイルシステム上のファイルを指すことができます。"

msgid ""
"For inspiration, you can take a look at the examples distribution into the "
"main demo example into the `product-portal` application."
msgstr "インスピレーションのために、 `product-portal` アプリケーションのデモのサンプル配布物を見てみることができます。"

msgid "Client authentication with Signed JWT using client secret"
msgstr "クライアント・シークレットを使用した署名付きJWTによるクライアント認証"

msgid ""
"This is the same as Client Authentication with Signed JWT except for using "
"the client secret instead of the private key and certificate."
msgstr "これは、署名付きJWTによるクライアント認証と同じですが、秘密鍵と証明書の代わりにクライアント・シークレットを使用する点が異なります。"

msgid ""
"The client has a secret, which needs to be known to both the adapter "
"(application) and the {project_name} server. You need to choose `Signed JWT "
"with Client Secret` as the method of authenticating your client in the tab "
"`Credentials` in the Admin Console, and then paste this secret into the "
"`keycloak.json` file on the application side:"
msgstr ""
"クライアントにはシークレットがあり、アダプター（アプリケーション）と{project_name}サーバーの両方に知られている必要があります。管理コンソールの"
" `Credentials` タブでクライアントを認証する方法として `Signed JWT with Client Secret` "
"を選択し、このシークレットをアプリケーション側の `keycloak.json` ファイルに以下のように貼り付けます。"

msgid ""
"\"credentials\": {\n"
"  \"secret-jwt\": {\n"
"    \"secret\": \"19666a4f-32dd-4049-b082-684c74115f28\",\n"
"    \"algorithm\": \"HS512\"\n"
"  }\n"
"}"
msgstr ""
"\"credentials\": {\n"
"  \"secret-jwt\": {\n"
"    \"secret\": \"19666a4f-32dd-4049-b082-684c74115f28\",\n"
"    \"algorithm\": \"HS512\"\n"
"  }\n"
"}"

msgid ""
"The \"algorithm\" field specifies the algorithm for Signed JWT using Client "
"Secret. It needs to be one of the following values : HS256, HS384, and "
"HS512. For details, please refer to "
"https://datatracker.ietf.org/doc/html/rfc7518#section-3.2[JSON Web "
"Algorithms (JWA)]."
msgstr ""
"\"algorithm\"フィールドには、クライアント・シークレットを使用した署名付きJWTのアルゴリズムを指定します。HS256、HS384、HS512のいずれかの値である必要があります。詳細については、"
" https://datatracker.ietf.org/doc/html/rfc7518#section-3.2[JSON Web "
"Algorithms（JWA）] を参照してください。"

msgid ""
"This \"algorithm\" field is optional so that HS256 is applied automatically "
"if the \"algorithm\" field does not exist on the `keycloak.json` file."
msgstr ""
"この\"algorithm\"フィールドはオプションであり、\"algorithm\"フィールドが `keycloak.json` "
"ファイルに存在しない場合はHS256が自動的に適用されます。"

msgid "Add your own client authentication method"
msgstr "独自のクライアント認証方式の追加"

msgid ""
"You can add your own client authentication method as well. You will need to "
"implement both client-side and server-side providers. For more details see "
"the `Authentication SPI` section in "
"link:{developerguide_link}[{developerguide_name}]."
msgstr ""
"独自のクライアント認証方式を追加することもできます。クライアントサイドとサーバーサイドの両方のプロバイダーを実装する必要があります。詳細は "
"{developerguide_link}[{developerguide_name}] の `Authentication SPI` "
"のセクションを参照してください。"

msgid ""
"Multi Tenancy, in our context, means that a single target application (WAR) "
"can be secured with multiple {project_name} realms. The realms can be "
"located on the same {project_name} instance or on different instances."
msgstr ""
"マルチテナンシーとは、単一のターゲット・アプリケーション（WAR）が複数の{project_name}のレルムで保護されることを意味します。レルムは、同じ{project_name}インスタンスまたは異なるインスタンスに配置できます。"

msgid ""
"In practice, this means that the application needs to have multiple "
"`keycloak.json` adapter configuration files."
msgstr "実際には、これはアプリケーションが複数の `keycloak.json` アダプター設定ファイルを持つ必要があることを意味します。"

msgid ""
"You could have multiple instances of your WAR with different adapter "
"configuration files deployed to different context-paths. However, this may "
"be inconvenient and you may also want to select the realm based on something"
" else than context-path."
msgstr ""
"さまざまなコンテキストパスに異なるアダプター設定ファイルをデプロイして、WARの複数のインスタンスを作成することができます。しかし、これは不便かもしれませんし、コンテキストパス以外のものに基づいてレルムを選択するようにできます。"

msgid ""
"{project_name} makes it possible to have a custom config resolver so you can"
" choose what adapter config is used for each request."
msgstr ""
"{project_name}はカスタムの設定リゾルバーを持つことができるので、各リクエストにどのアダプター設定が使われるかを選ぶことができます。"

msgid ""
"To achieve this first you need to create an implementation of "
"`org.keycloak.adapters.KeycloakConfigResolver`. For example:"
msgstr ""
"まずこれを達成するためには、 `org.keycloak.adapters.KeycloakConfigResolver` "
"の実装を作成する必要があります。たとえば、以下のようになります。"

msgid ""
"package example;\n"
"\n"
"import org.keycloak.adapters.KeycloakConfigResolver;\n"
"import org.keycloak.adapters.KeycloakDeployment;\n"
"import org.keycloak.adapters.KeycloakDeploymentBuilder;\n"
"\n"
"public class PathBasedKeycloakConfigResolver implements KeycloakConfigResolver {\n"
"\n"
"    @Override\n"
"    public KeycloakDeployment resolve(OIDCHttpFacade.Request request) {\n"
"        if (path.startsWith(\"alternative\")) {\n"
"            KeycloakDeployment deployment = cache.get(realm);\n"
"            if (null == deployment) {\n"
"                InputStream is = getClass().getResourceAsStream(\"/tenant1-keycloak.json\");\n"
"                return KeycloakDeploymentBuilder.build(is);\n"
"            }\n"
"        } else {\n"
"            InputStream is = getClass().getResourceAsStream(\"/default-keycloak.json\");\n"
"            return KeycloakDeploymentBuilder.build(is);\n"
"        }\n"
"    }\n"
"\n"
"}"
msgstr ""
"package example;\n"
"\n"
"import org.keycloak.adapters.KeycloakConfigResolver;\n"
"import org.keycloak.adapters.KeycloakDeployment;\n"
"import org.keycloak.adapters.KeycloakDeploymentBuilder;\n"
"\n"
"public class PathBasedKeycloakConfigResolver implements KeycloakConfigResolver {\n"
"\n"
"    @Override\n"
"    public KeycloakDeployment resolve(OIDCHttpFacade.Request request) {\n"
"        if (path.startsWith(\"alternative\")) {\n"
"            KeycloakDeployment deployment = cache.get(realm);\n"
"            if (null == deployment) {\n"
"                InputStream is = getClass().getResourceAsStream(\"/tenant1-keycloak.json\");\n"
"                return KeycloakDeploymentBuilder.build(is);\n"
"            }\n"
"        } else {\n"
"            InputStream is = getClass().getResourceAsStream(\"/default-keycloak.json\");\n"
"            return KeycloakDeploymentBuilder.build(is);\n"
"        }\n"
"    }\n"
"\n"
"}"

msgid ""
"You also need to configure which `KeycloakConfigResolver` implementation to "
"use with the `keycloak.config.resolver` context-param in your `web.xml`:"
msgstr ""
"また、以下のように `web.xml` の `keycloak.config.resolver` のcontext-paramでどの "
"`KeycloakConfigResolver` 実装を使うかを設定する必要もあります。"

msgid ""
"<web-app>\n"
"    ...\n"
"    <context-param>\n"
"        <param-name>keycloak.config.resolver</param-name>\n"
"        <param-value>example.PathBasedKeycloakConfigResolver</param-value>\n"
"    </context-param>\n"
"</web-app>"
msgstr ""
"<web-app>\n"
"    ...\n"
"    <context-param>\n"
"        <param-name>keycloak.config.resolver</param-name>\n"
"        <param-value>example.PathBasedKeycloakConfigResolver</param-value>\n"
"    </context-param>\n"
"</web-app>"

msgid "Application clustering"
msgstr "アプリケーション・クラスタリング"

msgid ""
"This chapter is related to supporting clustered applications deployed to "
"JBoss EAP, WildFly and JBoss AS."
msgstr ""
"この章では、JBoss EAP、WildFly、またはJBoss ASにデプロイされてクラスター化されたアプリケーションのサポートについて解説します。"

msgid ""
"There are a few options available depending on whether your application is:"
msgstr "アプリケーションが次のような場合には、いくつかのオプションがあります。"

msgid "Stateless or stateful"
msgstr "ステートレスまたはステートフル"

msgid "Distributable (replicated http session) or non-distributable"
msgstr "分散可能（HTTPセッション・レプリケーション）または分散不可能"

msgid "Relying on sticky sessions provided by load balancer"
msgstr "ロードバランサーによって提供されるスティッキー・セッションに依存する"

msgid "Hosted on same domain as {project_name}"
msgstr "{project_name}と同じドメインでホストされている"

msgid ""
"Dealing with clustering is not quite as simple as for a regular application."
" Mainly due to the fact that both the browser and the server-side "
"application sends requests to {project_name}, so it's not as simple as "
"enabling sticky sessions on your load balancer."
msgstr ""
"クラスタリングを扱うことは、通常のアプリケーションほど簡単ではありません。ブラウザーとサーバーサイド・アプリケーションの両方が{project_name}にリクエストを送信することになるため、ロードバランサーでスティッキー・セッションを有効にするほど簡単ではありません。"

msgid "Stateless token store"
msgstr "ステートレス・トークン・ストア"

msgid ""
"By default, the web application secured by {project_name} uses the HTTP "
"session to store security context. This means that you either have to enable"
" sticky sessions or replicate the HTTP session."
msgstr ""
"デフォルトでは、{project_name}によって保護されたWebアプリケーションは、HTTPセッションを使用してセキュリティー・コンテキストを保存します。つまり、スティッキー・セッションを有効にするか、HTTPセッションをレプリケーションする必要があります。"

msgid ""
"As an alternative to storing the security context in the HTTP session the "
"adapter can be configured to store this in a cookie instead. This is useful "
"if you want to make your application stateless or if you don't want to store"
" the security context in the HTTP session."
msgstr ""
"HTTPセッションにセキュリティー・コンテキストを保存する代わりに、これをCookieに保存するようにアダプターを設定することもできます。これは、アプリケーションをステートレスにする場合や、セキュリティー・コンテキストをHTTPセッションに保存したくない場合に便利です。"

msgid ""
"To use the cookie store for saving the security context, edit your "
"applications `WEB-INF/keycloak.json` and add:"
msgstr ""
"セキュリティー・コンテキストを保存するためにCookieストアを使用するには、アプリケーションの `WEB-INF/keycloak.json` "
"を編集して次の行を追加します。"

msgid "\"token-store\": \"cookie\""
msgstr "\"token-store\": \"cookie\""

msgid ""
"The default value for `token-store` is `session`, which stores the security "
"context in the HTTP session."
msgstr ""
"`token-store` のデフォルト値は `session` です。これにより、セキュリティー・コンテキストがHTTPセッションに保存されます。"

msgid ""
"One limitation of using the cookie store is that the whole security context "
"is passed in the cookie for every HTTP request. This may impact performance."
msgstr ""
"Cookieストアを使用する際の制限の1つは、すべてのHTTPリクエストに対して、セキュリティー・コンテキスト全体がCookieに渡されることです。これはパフォーマンスに影響する可能性があります。"

msgid ""
"Another small limitation is limited support for Single-Sign Out. It works "
"without issues if you init servlet logout (HttpServletRequest.logout) from "
"the application itself as the adapter will delete the KEYCLOAK_ADAPTER_STATE"
" cookie. However, back-channel logout initialized from a different "
"application isn't propagated by {project_name} to applications using cookie "
"store. Hence it's recommended to use a short value for the access token "
"timeout (for example 1 minute)."
msgstr ""
"もう一つの小さな制限は、シングルサイン・アウトのサポートが限られていることです。アダプターが `KEYCLOAK_ADAPTER_STATE` "
"クッキーを削除するので、アプリケーション自体からサーブレット・ログアウト（ `HttpServletRequest.logout` "
"）を開始すると、問題なく動作します。 "
"ただし、別のアプリケーションからの初期化されたバックチャネル・ログアウトは、{project_name}によってCookieストアを使用するアプリケーションに伝播されません。したがって、アクセストークンのタイムアウトに短い値（たとえば1分）を使用することをお勧めします。"

msgid ""
"Some load balancers do not allow any configuration of the sticky session "
"cookie name or contents, such as Amazon ALB. For these, it is recommended to"
" set the `shouldAttachRoute` option to `false`."
msgstr ""
"一部のロードバランサーは、スティッキー・セッションCookieの名前や内容の設定を許可しません（Amazon ALBなど）。これらのために、 "
"`shouldAttachRoute` オプションを `false` に設定することが推奨されます。"

msgid "Relative URI optimization"
msgstr "相対URIの最適化"

msgid ""
"In deployment scenarios where {project_name} and the application is hosted "
"on the same domain (through a reverse proxy or load balancer) it can be "
"convenient to use relative URI options in your client configuration."
msgstr ""
"{project_name}とアプリケーションが同じドメイン（リバース・プロキシーまたはロードバランサーを介して）でホストされているデプロイメントのシナリオでは、クライアント設定で相対URIオプションを使用すると便利です。"

msgid ""
"With relative URIs the URI is resolved as relative to the URL used to access"
" {project_name}."
msgstr "相対URIの場合、URIは{project_name}にアクセスするために使用されるURLに関連して解決されます。"

msgid ""
"For example if the URL to your application is `$$https://acme.org/myapp$$` "
"and the URL to {project_name} is `\\https://acme.org{kc_base_path}`, then "
"you can use the redirect-uri `/myapp` instead of "
"`$$https://acme.org/myapp$$`."
msgstr ""
"たとえば、アプリケーションへのURLが `$$https://acme.org/myapp$$` で、{project_name}へのURLが "
"`\\https://acme.org{kc_base_path}` である場合、 `$$https://acme.org/myapp$$` "
"の代わりにリダイレクトURIの `/myapp` を使うことができます。"

msgid "Admin URL configuration"
msgstr "管理URLの設定"

msgid ""
"Admin URL for a particular client can be configured in the {project_name} "
"Admin Console. It's used by the {project_name} server to send backend "
"requests to the application for various tasks, like logout users or push "
"revocation policies."
msgstr ""
"特定のクライアント用の管理URLは、{project_name}管理コンソールで設定できます。これは、{project_name}サーバーによって、ユーザーのログアウトや取消しポリシーのプッシュなどのさまざまなタスクのバックエンド・リクエストをアプリケーションに送信するために使用されます。"

msgid "For example the way backchannel logout works is:"
msgstr "たとえば、バックチャネル・ログアウトの仕組みは次のとおりです。"

msgid "User sends logout request from one application"
msgstr "ユーザーが1つのアプリケーションからログアウト・リクエストを送信します"

msgid "The application sends logout request to {project_name}"
msgstr "アプリケーションは{project_name}にログアウト・リクエストを送信します"

msgid "The {project_name} server invalidates the user session"
msgstr "{project_name}サーバーはユーザー・セッションを無効にします"

msgid ""
"The {project_name} server then sends a backchannel request to application "
"with an admin url that are associated with the session"
msgstr "{project_name}サーバーは、セッションに関連付けられた管理URLでバックチャネル・リクエストをアプリケーションに送信します"

msgid ""
"When an application receives the logout request it invalidates the "
"corresponding HTTP session"
msgstr "アプリケーションがログアウト・リクエストを受信すると、対応するHTTPセッションが無効になります"

msgid ""
"If admin URL contains `${application.session.host}` it will be replaced with"
" the URL to the node associated with the HTTP session."
msgstr ""
"管理URLに `${application.session.host}` "
"が含まれていると、HTTPセッションに関連付けられたノードのURLに置き換えられます。"

msgid "Registration of application nodes"
msgstr "アプリケーション・ノードの登録"

msgid ""
"The previous section describes how {project_name} can send logout request to"
" node associated with a specific HTTP session. However, in some cases admin "
"may want to propagate admin tasks to all registered cluster nodes, not just "
"one of them. For example to push a new not before policy to the application "
"or to logout all users from the application."
msgstr ""
"前のセクションでは、{project_name}が特定のHTTPセッションに関連付けられたノードにログアウト・リクエストを送信する方法について説明しました。しかし、管理者が管理タスクを登録されている全てのクラスターノードに伝播させたい場合があります。たとえば、新しいnot"
" beforeポリシーをアプリケーションにプッシュする、またはアプリケーションからすべてのユーザーをログアウトする場合などです。"

msgid ""
"In this case {project_name} needs to be aware of all application cluster "
"nodes, so it can send the event to all of them. To achieve this, we support "
"auto-discovery mechanism:"
msgstr ""
"この場合、{project_name}はすべてのアプリケーション・クラスター・ノードを認識する必要があります。これにより、全てのノードにイベントを送信できます。これを達成するために、オート・ディスカバリーのメカニズムをサポートしています。"

msgid ""
"When a new application node joins the cluster, it sends a registration "
"request to the {project_name} server"
msgstr "新しいアプリケーション・ノードがクラスターに参加すると、{project_name}サーバーに登録リクエストを送信します。"

msgid ""
"The request may be re-sent to {project_name} in configured periodic "
"intervals"
msgstr "定期的に設定された間隔で、設定が{project_name}に送信されます"

msgid ""
"If the {project_name} server doesn't receive a re-registration request "
"within a specified timeout then it automatically unregisters the specific "
"node"
msgstr ""
"{project_name}サーバーが指定されたタイムアウト時間内に再登録リクエストを受信しなかった場合、{project_name}サーバーは自動的に特定のノードの登録を解除します"

msgid ""
"The node is also unregistered in {project_name} when it sends an "
"unregistration request, which is usually during node shutdown or application"
" undeployment. This may not work properly for forced shutdown when "
"undeployment listeners are not invoked, which results in the need for "
"automatic unregistration"
msgstr ""
"また、登録解除リクエストを送信するときに、ノードは{project_name}で登録抹消されます。これは、通常、ノードのシャットダウンまたはアプリケーションのアンデプロイメント中です。アンデプロイメント・リスナーが呼び出されない場合、強制シャットダウンで正しく動作しないことがあります。その結果、自動登録解除が必要になります"

msgid ""
"Sending startup registrations and periodic re-registration is disabled by "
"default as it's only required for some clustered applications."
msgstr "スタートアップ登録の送信と定期的な再登録は、クラスター化された一部のアプリケーションでのみ必要なので、デフォルトでは無効になっています。"

msgid ""
"To enable the feature edit the `WEB-INF/keycloak.json` file for your "
"application and add:"
msgstr "この機能を有効にするには、アプリケーションの `WEB-INF/keycloak.json` ファイルを編集し、次の行を追加します。"

msgid ""
"\"register-node-at-startup\": true,\n"
"\"register-node-period\": 600,"
msgstr ""
"\"register-node-at-startup\": true,\n"
"\"register-node-period\": 600,"

msgid ""
"This means the adapter will send the registration request on startup and re-"
"register every 10 minutes."
msgstr "これは、アダプターが起動時に登録リクエストを送信し、10分ごとに再登録することを意味します。"

msgid ""
"In the {project_name} Admin Console you can specify the maximum node re-"
"registration timeout (should be larger than _register-node-period_ from the "
"adapter configuration). You can also manually add and remove cluster nodes "
"in through the Admin Console, which is useful if you don't want to rely on "
"the automatic registration feature or if you want to remove stale "
"application nodes in the event your not using the automatic unregistration "
"feature."
msgstr ""
"{project_name}管理コンソールでは、最大ノード再登録タイムアウトを指定できます（アダプター設定から _register-node-"
"period_ "
"より大きい値にする必要があります）。管理コンソールから、クラスター・ノードを手動で追加したり、削除することもできます。自動登録機能を使用したくない場合や、自動登録解除機能を使用しない場合、失効したアプリケーション・ノードを削除する場合に便利です"
" 。"

msgid "Refresh token in each request"
msgstr "各リクエストのトークンのリフレッシュ"

msgid ""
"By default the application adapter will only refresh the access token when "
"it's expired. However, you can also configure the adapter to refresh the "
"token on every request. This may have a performance impact as your "
"application will send more requests to the {project_name} server."
msgstr ""
"デフォルトでは、アプリケーション・アダプターは期限切れになったときにのみ、アクセストークンを更新します。ただし、リクエストごとにトークンをリフレッシュするようにアダプターを設定することもできます。これは、アプリケーションが{project_name}サーバーにさらに多くのリクエストを送信するため、パフォーマンスに影響を与える可能性があります。"

msgid "\"always-refresh-token\": true"
msgstr "\"always-refresh-token\": true"

msgid ""
"This may have a significant impact on performance. Only enable this feature "
"if you can't rely on backchannel messages to propagate logout and not before"
"     policies. Another thing to consider is that by default access tokens "
"has a short expiration so even if logout is not propagated the token will "
"expire within     minutes of the logout."
msgstr ""
"これはパフォーマンスに重大な影響を与える可能性があります。ログアウトとnot "
"beforeポリシーを伝播するために、バックチャネル・メッセージに頼ることができない場合にのみ、この機能を有効にしてください。考慮すべきことは、デフォルトではアクセストークンの有効期限が短いので、ログアウトが伝播されなくてもログアウトから数分以内にトークンが期限切れになることです。"

msgid "JavaScript adapter"
msgstr "JavaScriptアダプター"

msgid ""
"{project_name} comes with a client-side JavaScript library that can be used "
"to secure HTML5/JavaScript applications. The JavaScript adapter has built-in"
" support for Cordova applications."
msgstr ""
"{project_name}には、HTML5/JavaScriptアプリケーションをセキュリティー保護するために使用可能なクライアント・サイドのJavaScriptライブラリーが付属しています。JavaScriptアダプターには、Cordovaアプリケーションのサポートが組み込まれています。"

msgid ""
"The library can be retrieved directly from the {project_name} server at "
"`{kc_js_path}/keycloak.js` and is also distributed as a ZIP archive."
msgstr ""
"ライブラリーは{project_name}サーバーの `{kc_js_path}/keycloak.js` "
"から直接取得することができ、ZIPアーカイブとしても配布されています。"

msgid ""
"A best practice is to load the JavaScript adapter directly from "
"{project_name} Server as it will automatically be updated when you upgrade "
"the server. If you copy the adapter to your web application instead, make "
"sure you upgrade the adapter only after you have upgraded the server."
msgstr ""
"{project_name}サーバーをアップグレードする際に自動的にJavaScriptアダプターが更新されるため、ベスト・プラクティスは{project_name}サーバーからJavaScriptアダプターを直接ロードすることです。そうではなくアダプターをWebアプリケーションにコピーする場合は、サーバーをアップグレードした後に、アダプターもアップグレードするようにしてください。"

msgid ""
"You can also download package from npm: "
"https://www.npmjs.com/package/keycloak-js"
msgstr ""
"npm（https://www.npmjs.com/package/keycloak-js）からパッケージをダウンロードすることもできます。"

msgid ""
"One important thing to note about using client-side applications is that the"
" client has to be a public client as there is no secure way to store client "
"credentials in a client-side application. This makes it very important to "
"make sure the redirect URIs you have configured for the client are correct "
"and as specific as possible."
msgstr ""
"クライアント・サイドのアプリケーションを使用する際に注意すべき重要な点の1つは、クライアント・サイドのアプリケーションにクライアント・クレデンシャルを安全に保存する方法がないため、クライアントをパブリック・クライアントにする必要があることです。これにより、クライアント用に設定したリダイレクトURIが正しいか、できるだけ具体的であるかを確認することが非常に重要になります。"

msgid ""
"To use the JavaScript adapter you must first create a client for your "
"application in the {project_name} Admin Console. Make sure `public` is "
"selected for `Access Type`."
msgstr ""
"JavaScriptアダプターを使用するには、まず{project_name}管理コンソールでアプリケーション用のクライアントを作成する必要があります。"
" `Access Type` に `public` が選択されていることを確認してください。"

msgid ""
"You also need to configure `Valid Redirect URIs` and `Web Origins`. Be as "
"specific as possible as failing to do so may result in a security "
"vulnerability."
msgstr ""
"また、 `Valid Redirect URIs` と `Web Origins` "
"を設定する必要があります。できるだけ具体的にする理由は、そうしなければセキュリティー上の脆弱性が生じる可能性があるためです。"

msgid ""
"Once the client is created click on the `Installation` tab select `Keycloak "
"OIDC JSON` for `Format Option` then click `Download`. The downloaded "
"`keycloak.json` file should be hosted on your web server at the same "
"location as your HTML pages."
msgstr ""
"クライアントが作成されたら `Installation` タブをクリックし、 `Format Option` の中から `Keycloak OIDC "
"JSON` を選択して、 `Download` をクリックします。ダウンロードした `keycloak.json` "
"ファイルは、HTMLページと同じ場所にあるWebサーバー上にホストされるべきです。"

msgid ""
"Alternatively, you can skip the configuration file and manually configure "
"the adapter."
msgstr "または、設定ファイルではなく、アダプターを手動で設定することもできます。"

msgid "The following example shows how to initialize the JavaScript adapter:"
msgstr "次の例は、JavaScriptアダプターを初期化する方法を示しています。"

msgid ""
"<html>\n"
"<head>\n"
"    <script src=\"keycloak.js\"></script>\n"
"    <script>\n"
"        function initKeycloak() {\n"
"            var keycloak = new Keycloak();\n"
"            keycloak.init().then(function(authenticated) {\n"
"                alert(authenticated ? 'authenticated' : 'not authenticated');\n"
"            }).catch(function() {\n"
"                alert('failed to initialize');\n"
"            });\n"
"        }\n"
"    </script>\n"
"</head>\n"
"<body onload=\"initKeycloak()\">\n"
"    <!-- your page content goes here -->\n"
"</body>\n"
"</html>"
msgstr ""
"<html>\n"
"<head>\n"
"    <script src=\"keycloak.js\"></script>\n"
"    <script>\n"
"        function initKeycloak() {\n"
"            var keycloak = new Keycloak();\n"
"            keycloak.init().then(function(authenticated) {\n"
"                alert(authenticated ? 'authenticated' : 'not authenticated');\n"
"            }).catch(function() {\n"
"                alert('failed to initialize');\n"
"            });\n"
"        }\n"
"    </script>\n"
"</head>\n"
"<body onload=\"initKeycloak()\">\n"
"    <!-- your page content goes here -->\n"
"</body>\n"
"</html>"

msgid ""
"If the `keycloak.json` file is in a different location you can specify it:"
msgstr "`keycloak.json` ファイルが別の場所にある場合、以下のように指定することができます。"

msgid ""
"var keycloak = new Keycloak('http://localhost:8080/myapp/keycloak.json');"
msgstr ""
"var keycloak = new Keycloak('http://localhost:8080/myapp/keycloak.json');"

msgid ""
"Alternatively, you can pass in a JavaScript object with the required "
"configuration instead:"
msgstr "または、以下のように必要な設定でJavaScriptオブジェクトを渡すこともできます。"

msgid ""
"var keycloak = new Keycloak({\n"
"    url: 'http://keycloak-server${kc_base_path}',\n"
"    realm: 'myrealm',\n"
"    clientId: 'myapp'\n"
"});"
msgstr ""
"var keycloak = new Keycloak({\n"
"    url: 'http://keycloak-server${kc_base_path}',\n"
"    realm: 'myrealm',\n"
"    clientId: 'myapp'\n"
"});"

msgid ""
"By default to authenticate you need to call the `login` function. However, "
"there are two options available to make the adapter automatically "
"authenticate. You can pass `login-required` or `check-sso` to the init "
"function. `login-required` will authenticate the client if the user is "
"logged-in to {project_name} or display the login page if not. `check-sso` "
"will only authenticate the client if the user is already logged-in, if the "
"user is not logged-in the browser will be redirected back to the application"
" and remain unauthenticated."
msgstr ""
"デフォルトでは `login` 関数を呼び出す必要があります。ただし、アダプターを自動的に認証させるための2つのオプションがあります。 `init` "
"関数に `login-required` または `check-sso` を渡すことができます。 `login-required` "
"は、ユーザーが{project_name}にログインしていない場合にクライアントを認証し、そうでない場合にログインページを表示します。 `check-"
"sso` "
"は、ユーザーがすでにログインしている場合にのみクライアントを認証します。ユーザーがログインしていない場合、ブラウザーはアプリケーションにリダイレクトされ、未認証のままになります。"

msgid ""
"You can configure a _silent_ `check-sso` option. With this feature enabled, "
"your browser won't do a full redirect to the {project_name} server and back "
"to your application, but this action will be performed in a hidden iframe, "
"so your application resources only need to be loaded and parsed once by the "
"browser when the app is initialized and not again after the redirect back "
"from {project_name} to your app. This is particularly useful in case of SPAs"
" (Single Page Applications)."
msgstr ""
"_silent_ `check-sso` "
"オプションを設定できます。この機能を有効にすると、ブラウザーは{project_name}サーバーへの完全なリダイレクトを行わず、アプリケーションに戻ります。このアクションは非表示のiframeで実行されるため、アプリケーションのリソースはアプリの初期化時にブラウザーによって1回だけロードと解析がされ、{project_name}からアプリへのリダイレクト・バック後に再度行われはしません。これは、SPA（シングル・ページ・アプリケーション）の場合に特に便利です。"

msgid ""
"To enable the _silent_ `check-sso`, you have to provide a "
"`silentCheckSsoRedirectUri` attribute in the init method. This URI needs to "
"be a valid endpoint in the application (and of course it must be configured "
"as a valid redirect for the client in the {project_name} Admin Console):"
msgstr ""
"_silent_ `check-sso` を有効にするには、initメソッドで `silentCheckSsoRedirectUri` "
"属性を提供する必要があります。このURIは、アプリケーションの有効なエンドポイントである必要があります（もちろん、{project_name}管理コンソールでクライアントの有効なリダイレクトとして設定する必要があります）。"

msgid ""
"keycloak.init({\n"
"    onLoad: 'check-sso',\n"
"    silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html'\n"
"})"
msgstr ""
"keycloak.init({\n"
"    onLoad: 'check-sso',\n"
"    silentCheckSsoRedirectUri: window.location.origin + '/silent-check-sso.html'\n"
"})"

msgid ""
"The page at the silent check-sso redirect uri is loaded in the iframe after "
"successfully checking your authentication state and retrieving the tokens "
"from the {project_name} server. It has no other task than sending the "
"received tokens to the main application and should only look like this:"
msgstr ""
"サイレント・チェックSSOリダイレクトURIのページは、認証状態を正常にチェックし、{project_name}サーバーからトークンを取得した後、iframeにロードされます。受信したトークンをメイン・アプリケーションに送信する以外のタスクはなく、次のように見えるはずです。"

msgid ""
"<html>\n"
"<body>\n"
"    <script>\n"
"        parent.postMessage(location.href, location.origin)\n"
"    </script>\n"
"</body>\n"
"</html>"
msgstr ""
"<html>\n"
"<body>\n"
"    <script>\n"
"        parent.postMessage(location.href, location.origin)\n"
"    </script>\n"
"</body>\n"
"</html>"

msgid ""
"Please keep in mind that this page at the specified location must be "
"provided by the application itself and is _not_ part of the JavaScript "
"adapter!"
msgstr ""
"指定されたlocationにあるこのページは、アプリケーション自体によって提供される必要があり、JavaScriptアダプターの一部ではないことに注意してください。"

msgid ""
"_Silent_ `check-sso` functionality is limited in some modern browsers. "
"Please see the <<_modern_browsers,Modern Browsers with Tracking Protection "
"Section>>."
msgstr ""
"_Silent_ `check-sso` "
"機能は、一部の最新ブラウザーで制限されています。<<_modern_browsers,トラッキング防止機能を備えた最新のブラウザーのセクション>>を参照してください。"

msgid ""
"To enable `login-required` set `onLoad` to `login-required` and pass to the "
"init method:"
msgstr ""
"`login-required` を有効にするには、以下のように `onLoad` に `login-required` を設定し、 `init` "
"メソッドに渡します。"

msgid ""
"keycloak.init({\n"
"    onLoad: 'login-required'\n"
"})"
msgstr ""
"keycloak.init({\n"
"    onLoad: 'login-required'\n"
"})"

msgid ""
"After the user is authenticated the application can make requests to RESTful"
" services secured by {project_name} by including the bearer token in the "
"`Authorization` header. For example:"
msgstr ""
"ユーザーが認証された後、アプリケーションは `Authorization` "
"ヘッダーにベアラー・トークンを含めることによって、{project_name}によって保護されたRESTfulサービスへのリクエストを行うことができます。以下に例を示します。"

msgid ""
"var loadData = function () {\n"
"    document.getElementById('username').innerText = keycloak.subject;\n"
"\n"
"    var url = 'http://localhost:8080/restful-service';\n"
"\n"
"    var req = new XMLHttpRequest();\n"
"    req.open('GET', url, true);\n"
"    req.setRequestHeader('Accept', 'application/json');\n"
"    req.setRequestHeader('Authorization', 'Bearer ' + keycloak.token);\n"
"\n"
"    req.onreadystatechange = function () {\n"
"        if (req.readyState == 4) {\n"
"            if (req.status == 200) {\n"
"                alert('Success');\n"
"            } else if (req.status == 403) {\n"
"                alert('Forbidden');\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    req.send();\n"
"};"
msgstr ""
"var loadData = function () {\n"
"    document.getElementById('username').innerText = keycloak.subject;\n"
"\n"
"    var url = 'http://localhost:8080/restful-service';\n"
"\n"
"    var req = new XMLHttpRequest();\n"
"    req.open('GET', url, true);\n"
"    req.setRequestHeader('Accept', 'application/json');\n"
"    req.setRequestHeader('Authorization', 'Bearer ' + keycloak.token);\n"
"\n"
"    req.onreadystatechange = function () {\n"
"        if (req.readyState == 4) {\n"
"            if (req.status == 200) {\n"
"                alert('Success');\n"
"            } else if (req.status == 403) {\n"
"                alert('Forbidden');\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    req.send();\n"
"};"

msgid ""
"One thing to keep in mind is that the access token by default has a short "
"life expiration so you may need to refresh the access token prior to sending"
" the request. You can do this by the `updateToken` method. The `updateToken`"
" method returns a promise which makes it easy to invoke the service only if "
"the token was successfully refreshed and display an error to the user if it "
"wasn't. For example:"
msgstr ""
"注意すべきことは、デフォルトではアクセス・トークンの有効期限が短いため、リクエストを送信する前にアクセス・トークンを更新する必要があることです。これは "
"`updateToken` メソッドで行うことができます。 `updateToken` "
"メソッドは、トークンが正常にリフレッシュされた場合にのみ、サービスの呼び出しを容易にするPromiseを返し、そうでない場合は、ユーザーにエラーを表示します。以下に例を示します。"

msgid ""
"keycloak.updateToken(30).then(function() {\n"
"    loadData();\n"
"}).catch(function() {\n"
"    alert('Failed to refresh token');\n"
"});"
msgstr ""
"keycloak.updateToken(30).then(function() {\n"
"    loadData();\n"
"}).catch(function() {\n"
"    alert('Failed to refresh token');\n"
"});"

msgid "Session Status iframe"
msgstr "セッション・ステータスiframe"

msgid ""
"By default, the JavaScript adapter creates a hidden iframe that is used to "
"detect if a Single-Sign Out has occurred. This does not require any network "
"traffic, instead the status is retrieved by looking at a special status "
"cookie. This feature can be disabled by setting `checkLoginIframe: false` in"
" the options passed to the `init` method."
msgstr ""
"デフォルトでは、JavaScriptアダプターは、シングル・サイン・アウトが発生したかどうかを検出するために使用される非表示のiframeを作成します。これはネットワーク・トラフィックを必要とせず、代わりに特殊なステータス・クッキーを調べることによってステータスを取得します。この機能は、"
" `init` メソッドに渡されるオプションに `checkLoginIframe: false` を設定することで無効にできます。"

msgid ""
"You should not rely on looking at this cookie directly. Its format can "
"change and it's also associated with the URL of the {project_name} server, "
"not your application."
msgstr ""
"このクッキーを直接参照することに頼るべきではありません。フォーマットは変更可能で、アプリケーションではなく{project_name}サーバーのURLに関連付けられています。"

msgid ""
"Session Status iframe functionality is limited in some modern browsers. "
"Please see <<_modern_browsers,Modern Browsers with Tracking Protection "
"Section>>."
msgstr ""
"Session Status "
"iframe機能は、一部の最新ブラウザーで制限されています。<<_modern_browsers,トラッキング防止機能を備えた最新のブラウザーのセクション>>を参照してください。"

msgid "Implicit and hybrid flow"
msgstr "インプリシット・フローとハイブリッド・フロー"

msgid ""
"By default, the JavaScript adapter uses the https://openid.net/specs/openid-"
"connect-core-1_0.html#CodeFlowAuth[Authorization Code] flow."
msgstr ""
"デフォルトで、JavaScriptアダプターは https://openid.net/specs/openid-connect-"
"core-1_0.html#CodeFlowAuth[認可コード] フローを使用します。"

msgid ""
"With this flow the {project_name} server returns an authorization code, not "
"an authentication token, to the application. The JavaScript adapter "
"exchanges the `code` for an access token and a refresh token after the "
"browser is redirected back to the application."
msgstr ""
"このフローにより、{project_name}サーバーは認証トークンではなく、認可コードをアプリケーションに返します。ブラウザーがアプリケーションにリダイレクトされた後、JavaScriptアダプターは"
"  `code`  をアクセス・トークンとリフレッシュ・トークンに交換します。"

msgid ""
"{project_name} also supports the https://openid.net/specs/openid-connect-"
"core-1_0.html#ImplicitFlowAuth[Implicit] flow where an access token is sent "
"immediately after successful authentication with {project_name}. This may "
"have better performance than standard flow, as there is no additional "
"request to exchange the code for tokens, but it has implications when the "
"access token expires."
msgstr ""
"{project_name}は、{project_name}での認証が成功した直後にアクセス・トークンが送信される "
"https://openid.net/specs/openid-connect-"
"core-1_0.html#ImplicitFlowAuth[インプリシット・フロー] "
"もサポートしています。これは、トークンに対してコードを交換する追加のリクエストが無いので、標準フローよりもパフォーマンスに優れる可能性がありますが、アクセス・トークンの有効期限が切れたときに影響があります。"

msgid ""
"However, sending the access token in the URL fragment can be a security "
"vulnerability. For example the token could be leaked through web server logs"
" and or browser history."
msgstr ""
"ただし、URLフラグメントにアクセス・トークンを送信することはセキュリティー上の脆弱性となります。たとえば、Webサーバーのログやブラウザーの履歴からトークンが漏洩する可能性があります。"

msgid ""
"To enable implicit flow, you need to enable the `Implicit Flow Enabled` flag"
" for the client in the {project_name} Admin Console. You also need to pass "
"the parameter `flow` with value `implicit` to `init` method:"
msgstr ""
"インプリシット・フローを有効にするには、{project_name}管理コンソールでクライアントの `Implicit Flow Enabled` "
"フラグを有効にする必要があります。 `init` メソッドに `implicit` という値を持つ `flow` パラメータを渡す必要もあります："

msgid ""
"keycloak.init({\n"
"    flow: 'implicit'\n"
"})"
msgstr ""
"keycloak.init({\n"
"    flow: 'implicit'\n"
"})"

msgid ""
"One thing to note is that only an access token is provided and there is no "
"refresh token. This means that once the access token has expired the "
"application has to do the redirect to the {project_name} again to obtain a "
"new access token."
msgstr ""
"注意すべき点の1つは、アクセス・トークンのみが提供され、リフレッシュ・トークンがないことです。つまり、アクセス・トークンが期限切れになると、アプリケーションは{project_name}へのリダイレクトを再度実行して、新しいアクセス・トークンを取得する必要があります。"

msgid ""
"{project_name} also supports the https://openid.net/specs/openid-connect-"
"core-1_0.html#HybridFlowAuth[Hybrid] flow."
msgstr ""
"{project_name}は https://openid.net/specs/openid-connect-"
"core-1_0.html#HybridFlowAuth[ハイブリッド・フロー] もサポートしています。"

msgid ""
"This requires the client to have both the `Standard Flow Enabled` and "
"`Implicit Flow Enabled` flags enabled in the admin console. The "
"{project_name} server will then send both the code and tokens to your "
"application. The access token can be used immediately while the code can be "
"exchanged for access and refresh tokens. Similar to the implicit flow, the "
"hybrid flow is good for performance because the access token is available "
"immediately. But, the token is still sent in the URL, and the security "
"vulnerability mentioned earlier may still apply."
msgstr ""
"これは、管理コンソールでクライアントの `Standard Flow Enabled` と `Implicit Flow Enabled` "
"フラグを有効にすることを要求します。{project_name}サーバーはコードとトークンの両方をアプリケーションに送信します。アクセス・トークンとリフレッシュ・トークンの交換ができる間、アクセス・トークンは即時使用できます。インプリシット・フローと同様に、アクセス・トークンがすぐに利用できるため、ハイブリッド・フローはパフォーマンスに優れています。しかし、トークンは引き続きURLに送信され、前述のセキュリティーの脆弱性が当てはまる可能性があります。"

msgid ""
"One advantage in the Hybrid flow is that the refresh token is made available"
" to the application."
msgstr "ハイブリッド・フローの1つの利点は、アプリケーションでリフレッシュ・トークンが利用可能になることです。"

msgid ""
"For the Hybrid flow, you need to pass the parameter `flow` with value "
"`hybrid` to the `init` method:"
msgstr ""
"ハイブリッド・フローの場合、以下のようにパラメーター `flow` を値 `hybrid` で `init` メソッドに渡す必要があります。"

msgid ""
"keycloak.init({\n"
"    flow: 'hybrid'\n"
"})"
msgstr ""
"keycloak.init({\n"
"    flow: 'hybrid'\n"
"})"

msgid "Hybrid Apps with Cordova"
msgstr "ハイブリッド・アプリとCordova"

msgid ""
"Keycloak support hybrid mobile apps developed with "
"https://cordova.apache.org/[Apache Cordova]. The JavaScript adapter has two "
"modes for this: `cordova` and `cordova-native`:"
msgstr ""
"Keycloakは https://cordova.apache.org/[Apache Cordova] "
"で開発されたハイブリッド・モバイルアプリをサポートしています。JavaScriptアダプターには、 `cordova` と `cordova-"
"native` の2つのモードがあります。"

msgid ""
"The default is cordova, which the adapter will automatically select if no "
"adapter type has been configured and window.cordova is present. When logging"
" in, it will open an "
"https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-"
"inappbrowser/[InApp Browser] that lets the user interact with {project_name}"
" and afterwards returns to the app by redirecting to `http://localhost`. "
"Because of this, you must whitelist this URL as a valid redirect-uri in the "
"client configuration section of the Admin Console."
msgstr ""
"デフォルトはcordovaで、アダプタータイプが設定されておらず、window.cordovaが存在する場合、アダプターは自動的に選択します。ログインすると、"
" https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-"
"inappbrowser/[InApp Browser] が開き、ユーザーは{project_name}とやり取りした後、アプリを "
"`http://localhost` "
"にリダイレクトします。そのため、管理コンソールのクライアント設定のセクションで、このURLを有効なリダイレクトURIとしてホワイトリストに登録する必要があります。"

msgid "While this mode is easy to setup, it also has some disadvantages:"
msgstr "このモードはセットアップが簡単ですが、いくつかの欠点もあります。"

msgid ""
"The InApp-Browser is a browser embedded in the app and is not the phone's "
"default browser. Therefore it will have different settings and stored "
"credentials will not be available."
msgstr ""
"InApp-"
"Browserは、アプリに組み込まれたブラウザーであり、携帯電話のデフォルト・ブラウザーではありません。したがって、設定が異なり、保存されたクレデンシャルは利用できません。"

msgid ""
"The InApp-Browser might also be slower, especially when rendering more "
"complex themes."
msgstr "特に複雑なテーマをレンダリングする場合、InApp-Browserの方が処理速度が遅くなる可能性があります。"

msgid ""
"There are security concerns to consider, before using this mode, such as "
"that it is possible for the app to gain access to the credentials of the "
"user, as it has full control of the browser rendering the login page, so do "
"not allow its use in apps you do not trust."
msgstr ""
"このモードを使用する前に、アプリがログインページをレンダリングするブラウザーを完全に制御しているため、ユーザーのクレデンシャルにアクセスする可能性があるなど、セキュリティーを考慮する必要があります。そのため、信頼できないアプリでは使用を許可しないでください。"

msgid ""
"Use this example app to help you get started: "
"https://github.com/keycloak/keycloak/tree/master/examples/cordova"
msgstr ""
"このサンプル・アプリケーションを使用して、開始します： "
"https://github.com/keycloak/keycloak/tree/master/examples/cordova"

msgid ""
"The alternative mode `cordova-native` takes a different approach. It opens "
"the login page using the system's browser. After the user has authenticated,"
" the browser redirects back into the app using a special URL. From there, "
"the {project_name} adapter can finish the login by reading the code or token"
" from the URL."
msgstr ""
"代替モード `cordova-native` "
"は異なるアプローチをとっています。システムのブラウザーを使用してログインページを開きます。ユーザーが認証されると、特別なURLを使用して、ブラウザーがアプリにリダイレクトされます。そこから、{project_name}アダプターは、URLからコードまたはトークンを読み取ってログインを完了できます。"

msgid ""
"You can activate the native mode by passing the adapter type `cordova-"
"native` to the `init` method:"
msgstr ""
"ネイティブモードをアクティブにするには、次のようにアダプタータイプ `cordova-native` を `init` メソッドに渡します。"

msgid ""
"keycloak.init({\n"
"    adapter: 'cordova-native'\n"
"})"
msgstr ""
"keycloak.init({\n"
"    adapter: 'cordova-native'\n"
"})"

msgid "This adapter required two additional plugins:"
msgstr "このアダプターには、次の2つの追加プラグインが必要でした。"

msgid ""
"https://github.com/google/cordova-plugin-browsertab[cordova-plugin-"
"browsertab]: allows the app to open webpages in the system's browser"
msgstr ""
"https://github.com/google/cordova-plugin-browsertab[cordova-plugin-"
"browsertab]：アプリがシステムのブラウザーでウェブページを開くことができます"

msgid ""
"https://github.com/e-imaxina/cordova-plugin-deeplinks[cordova-plugin-"
"deeplinks]: allow the browser to redirect back to your app by special URLs"
msgstr ""
"https://github.com/e-imaxina/cordova-plugin-deeplinks[cordova-plugin-"
"deeplinks]：ブラウザーが特別なURLでアプリにリダイレクトできるようにします"

msgid ""
"The technical details for linking to an app differ on each platform and "
"special setup is needed. Please refer to the Android and iOS sections of the"
" https://github.com/e-imaxina/cordova-plugin-"
"deeplinks/blob/master/README.md[deeplinks plugin documentation] for further "
"instructions."
msgstr ""
"アプリにリンクするための技術的詳細は、各プラットフォームで異なり、特別な設定が必要です。詳しい手順については、 "
"https://github.com/e-imaxina/cordova-plugin-"
"deeplinks/blob/master/README.md[ディープリンク・プラグインのドキュメント] "
"のAndroidおよびiOSのセクションを参照してください。"

msgid ""
"There are different kinds of links for opening apps: custom schemes (i.e. "
"`myapp://login` or `android-"
"app://com.example.myapp/https/example.com/login`) and "
"https://developer.apple.com/ios/universal-links/[Universal Links (iOS)]) / "
"https://developer.android.com/training/app-links/deep-linking[Deep Links "
"(Android)]. While the former are easier to setup and tend to work more "
"reliably, the later offer extra security as they are unique and only the "
"owner of a domain can register them. Custom-URLs are deprecated on iOS. We "
"recommend that you use universal links, combined with a fallback site with a"
" custom-url link on it for best reliability."
msgstr ""
"アプリを開くためのリンクには、カスタムスキーマ（つまり、 `myapp://login` または `android-"
"app://com.example.myapp/https/example.com/login` ）と "
"https://developer.apple.com/ios/universal-links/[ユニバーサル・リンク（iOS）]）/ "
"https://developer.android.com/training/app-links/deep-"
"linking[ディープリンク（Android）]をクリックします。前者は設定が容易で、より確実に動作する傾向がありますが、後者はセキュリティーが強化され、ドメインの所有者のみが登録できます。カスタムURLはiOSでは推奨されていません。最良の信頼性を得るために、ユニバーサル・リンクとそれにcustom-"
"urlリンクを持つ代替サイトを組み合わせて使用することをお勧めします。"

msgid ""
"Furthermore, we recommend the following steps to improve compatibility with "
"the Keycloak Adapter:"
msgstr "さらに、Keycloakアダプターとの互換性を向上させるには、以下の手順を実行することをお勧めします。"

msgid ""
"Universal Links on iOS seem to work more reliably with `response-mode` set "
"to `query`"
msgstr "iOS上のユニバーサル・リンクは、 `query-mode` に設定された `response-mode` でより確実に動作するようです。"

msgid ""
"To prevent Android from opening a new instance of your app on redirect add "
"the following snippet to `config.xml`:"
msgstr ""
"Androidがリダイレクト時にアプリケーションの新しいインスタンスをオープンすることを防ぐには、次のスニペットを `config.xml` "
"に追加します。"

msgid "<preference name=\"AndroidLaunchMode\" value=\"singleTask\" />"
msgstr "<preference name=\"AndroidLaunchMode\" value=\"singleTask\" />"

msgid ""
"There is an example app that shows how to use the native-mode: "
"https://github.com/keycloak/keycloak/tree/master/examples/cordova-native"
msgstr ""
"ネイティブモードを使用する方法を示すサンプル・アプリケーションがあります: "
"https://github.com/keycloak/keycloak/tree/master/examples/cordova-native"

msgid "Custom Adapters"
msgstr "カスタム・アダプター"

msgid ""
"Sometimes it's necessary to run the JavaScript client in environments that "
"are not supported by default (such as Capacitor). To make it possible to use"
" the JavasScript client in these kind of unknown environments is possible to"
" pass a custom adapter. For example a 3rd party library could provide such "
"an adapter to make it possible to run the JavaScript client without issues:"
msgstr ""
"デフォルトでサポートされていない環境（Capacitorなど）でJavaScriptクライアントを実行する必要がある場合があります。このような未知の環境でJavasScriptクライアントを使用できるようにするために、カスタム・アダプターを渡すことができます。たとえば、サードパーティーのライブラリーがそのようなアダプターを提供して、JavaScriptクライアントを問題なく実行できるようにすることができます。"

msgid ""
"import Keycloak from 'keycloak-js';\n"
"import KeycloakCapacitorAdapter from 'keycloak-capacitor-adapter';\n"
"\n"
"const keycloak = new Keycloak();\n"
"\n"
"keycloak.init({\n"
"    adapter: KeycloakCapacitorAdapter,\n"
"});"
msgstr ""
"import Keycloak from 'keycloak-js';\n"
"import KeycloakCapacitorAdapter from 'keycloak-capacitor-adapter';\n"
"\n"
"const keycloak = new Keycloak();\n"
"\n"
"keycloak.init({\n"
"    adapter: KeycloakCapacitorAdapter,\n"
"});"

msgid ""
"This specific package does not exist, but it gives a pretty good example of "
"how such an adapter could be passed into the client."
msgstr "この特定のパッケージは存在しませんが、そのようなアダプターをクライアントに渡す方法の良い例を示しています。"

msgid ""
"It's also possible to make your own adapter, to do so you will have to "
"implement the methods described in the `KeycloakAdapter` interface. For "
"example the following TypeScript code ensures that all of the methods are "
"properly implemented:"
msgstr ""
"独自のアダプターを作成することもできます。そのためには、 `KeycloakAdapter` "
"インターフェイスで説明されているメソッドを実装する必要があります。たとえば、次のTypeScriptコードにより、すべてのメソッドが適切に実装されます。"

msgid ""
"import Keycloak, { KeycloakAdapter } from 'keycloak-js';\n"
"\n"
"// Implement the 'KeycloakAdapter' interface so that all required methods are guaranteed to be present.\n"
"const MyCustomAdapter: KeycloakAdapter = {\n"
"    login(options) {\n"
"        // Write your own implementation here.\n"
"    }\n"
"\n"
"    // The other methods go here...\n"
"};\n"
"\n"
"const keycloak = new Keycloak();\n"
"\n"
"keycloak.init({\n"
"    adapter: MyCustomAdapter,\n"
"});"
msgstr ""
"import Keycloak, { KeycloakAdapter } from 'keycloak-js';\n"
"\n"
"// Implement the 'KeycloakAdapter' interface so that all required methods are guaranteed to be present.\n"
"const MyCustomAdapter: KeycloakAdapter = {\n"
"    login(options) {\n"
"        // Write your own implementation here.\n"
"    }\n"
"\n"
"    // The other methods go here...\n"
"};\n"
"\n"
"const keycloak = new Keycloak();\n"
"\n"
"keycloak.init({\n"
"    adapter: MyCustomAdapter,\n"
"});"

msgid ""
"Naturally you can also do this without TypeScript by omitting the type "
"information, but ensuring implementing the interface properly will then be "
"left entirely up to you."
msgstr ""
"もちろん、タイプ情報を省略してTypeScriptを使用せずにこれを行うこともできますが、インターフェイスを適切に実装することは、完全にあなた次第です。"

msgid "Earlier Browsers"
msgstr "以前のブラウザー"

msgid ""
"The JavaScript adapter depends on Base64 (window.btoa and window.atob), "
"HTML5 History API and optionally the Promise API. If you need to support "
"browsers that do not have these available (for example, IE9) you need to add"
" polyfillers."
msgstr ""
"JavaScriptアダプターは、Base64（window.btoaとwindow.atob）、HTML5 History "
"API、およびオプションでPromise "
"APIに依存しています。これらが利用できないブラウザー（IE9など）をサポートする必要がある場合は、Polyfillを追加する必要があります。"

msgid "Example polyfill libraries:"
msgstr "Polyfillライブラリーの例："

msgid "Base64 - https://github.com/davidchambers/Base64.js"
msgstr "Base64 - https://github.com/davidchambers/Base64.js"

msgid "HTML5 History - https://github.com/devote/HTML5-History-API"
msgstr "HTML5 History - https://github.com/devote/HTML5-History-API"

msgid "Promise - https://github.com/stefanpenner/es6-promise"
msgstr "Promise - https://github.com/stefanpenner/es6-promise"

msgid "Modern Browsers with Tracking Protection"
msgstr "トラッキング防止を備えた最新のブラウザー"

msgid ""
"In the latest versions of some browsers various cookies policies are applied"
" to prevent tracking of the users by third-parties, like SameSite in Chrome "
"or completely blocked third-party cookies. It is expected that those "
"policies will become even more restrictive and adopted by other browsers "
"over time, eventually leading to cookies in third-party contexts to be "
"completely unsupported and blocked by the browsers. The adapter features "
"affected by this might get deprecated in the future."
msgstr ""
"一部のブラウザーの最新バージョンでは、さまざまなCookieポリシーが適用され、ChromeのSameSiteやサードパーティーのCookieを完全にブロックするなど、サードパーティによるユーザーのトラッキングを防止しています。これらのポリシーは今後さらに制限が厳しくなり、他のブラウザによって採用され、最終的にサードパーティーのコンテキストのCookieが完全にサポートされなくなり、ブラウザーによってブロックされることが予想されます。これにより影響を受けるアダプター機能は、将来廃止される可能性があります。"

msgid ""
"Javascript adapter relies on third-party cookies for Session Status iframe, "
"_silent_ `check-sso` and partially also for regular (non-silent) `check-"
"sso`. Those features have limited functionality or are completely disabled "
"based on how the browser is restrictive regarding cookies. The adapter tries"
" to detect this setting and reacts accordingly."
msgstr ""
"JavaScriptアダプターは、Session Status iframe、 _silent_ `check-sso`、および通常の（非サイレント） "
"`check-sso` "
"のサードパーティーCookieに依存しています。これらの機能は、機能が制限されているか、Cookieに関するブラウザーの制限に基づいて完全に無効になっています。アダプターはこの設定を検出しようとし、それに応じて反応します。"

msgid "Browsers with \"SameSite=Lax by Default\" Policy"
msgstr "\"SameSite=Lax by Default\" ポリシーのブラウザー"

msgid ""
"All features are supported if SSL / TLS connection is configured on the "
"{project_name} side as well as on the application side. See "
"link:{installguide_link}#_setting_up_ssl[configuring the SSL / TLS]. "
"Affected is for example Chrome starting with version 84."
msgstr ""
"SSL / TLS接続が{project_name}側とアプリケーション側で設定されている場合、すべての機能がサポートされます。 "
"link:{installguide_link}#_setting_up_ssl[SSL / TLSの構成] を参照してください。影響を受けるのは "
"バージョン84以降のChromeです。"

msgid "Browsers with Blocked Third-Party Cookies"
msgstr "サードパーティーのCookieがブロックされているブラウザー"

msgid ""
"Session Status iframe is not supported and is automatically disabled if such"
" browser behavior is detected by the JS adapter. This means the adapter "
"cannot use session cookie for Single Sign-Out detection and have to rely "
"purely on tokens. This implies that when user logs out in another window, "
"the application using JavaScript adapter won't be logged out until it tries "
"to refresh the Access Token. Therefore, it is recommended to set Access "
"Token Lifespan to relatively short time, so that the logout is detected "
"rather sooner than later. Please see "
"link:{adminguide_link}#_timeouts[Session and Token Timeouts]."
msgstr ""
"セッション・ステータスiframeはサポートされておらず、そのようなブラウザーの動作がJSアダプターによって検出された場合は自動的に無効になります。つまり、アダプターはシングル・サインアウトの検出にセッションCookieを使用できず、純粋にトークンに依存する必要があります。これは、ユーザーが別のウィンドウでログアウトすると、JavaScriptアダプターを使用するアプリケーションは、アクセストークンをリフレッシュしようとするまでログアウトされないことを意味します。そのため、アクセストークンのライフスパンを比較的短い時間に設定して、ログアウトが検出されるのが遅くなるのを防ぐことを推奨します。"
" link:{adminguide_link}#_timeouts[セッションとトークンのタイムアウト] を参照してください。"

msgid ""
"_Silent_ `check-sso` is not supported and falls back to regular (non-silent)"
" `check-sso` by default. This behaviour can be changed by setting "
"`silentCheckSsoFallback: false` in the options passed to the `init` method. "
"In this case, `check-sso` will be completely disabled if restrictive browser"
" behavior is detected."
msgstr ""
"_Silent_ `check-sso` はサポートされておらず、デフォルトでは通常の（非サイレント） `check-sso` "
"にフォールバックします。この動作は、 `init` メソッドに渡されるオプションで `silentCheckSsoFallback: false` "
"を設定することで変更できます。この場合、ブラウザーの制限的な動作が検出されると、 `check-sso` は完全に無効になります。"

msgid ""
"Regular `check-sso` is affected as well. Since Session Status iframe is "
"unsupported, an additional redirect to {project_name} has to be made when "
"the adapter is initialized to check user's login status. This is different "
"from standard behavior when the iframe is used to tell whether the user is "
"logged in, and the redirect is performed only when logged out."
msgstr ""
"通常の `check-sso` も影響を受けます。Session Status "
"iframeはサポートされていないため、ユーザーのログイン・ステータスを確認するためにアダプターを初期化するときに、{project_name}への追加のリダイレクトを行う必要があります。これは、iframeを使用してユーザーがログインしているかどうかを通知する標準の動作とは異なり、リダイレクトはログアウトした場合にのみ実行されます。"

msgid "An affected browser is for example Safari starting with version 13.1."
msgstr "影響を受けるブラウザーは、バージョン13.1以降のSafariです。"

msgid "JavaScript Adapter Reference"
msgstr "JavaScriptアダプター・リファレンス"

msgid "Constructor"
msgstr "コンストラクター"

msgid ""
"new Keycloak();\n"
"new Keycloak('http://localhost/keycloak.json');\n"
"new Keycloak({ url: 'http://localhost{kc_base_path}', realm: 'myrealm', clientId: 'myApp' });"
msgstr ""
"new Keycloak();\n"
"new Keycloak('http://localhost/keycloak.json');\n"
"new Keycloak({ url: 'http://localhost{kc_base_path}', realm: 'myrealm', clientId: 'myApp' });"

msgid "Properties"
msgstr "プロパティー"

msgid "authenticated"
msgstr "authenticated"

msgid "Is `true` if the user is authenticated, `false` otherwise."
msgstr "ユーザーが認証されている場合は `true` 、それ以外の場合は `false` です。"

msgid "token"
msgstr "token"

msgid ""
"The base64 encoded token that can be sent in the `Authorization` header in "
"requests to services."
msgstr "サービスへのリクエストの `Authorization` ヘッダーで送信できるBase64でエンコードされたトークンです。"

msgid "tokenParsed"
msgstr "tokenParsed"

msgid "The parsed token as a JavaScript object."
msgstr "JavaScriptオブジェクトとして解析されたトークン。"

msgid "subject"
msgstr "subject"

msgid "The user id."
msgstr "ユーザーID。"

msgid "idToken"
msgstr "idToken"

msgid "The base64 encoded ID token."
msgstr "Base64でエンコードされたIDトークン。"

msgid "idTokenParsed"
msgstr "idTokenParsed"

msgid "The parsed id token as a JavaScript object."
msgstr "JavaScriptオブジェクトとして解析されたIDトークン。"

msgid "realmAccess"
msgstr "realmAccess"

msgid "The realm roles associated with the token."
msgstr "トークンに関連付けられているレルムのロール。"

msgid "resourceAccess"
msgstr "resourceAccess"

msgid "The resource roles associated with the token."
msgstr "トークンに関連付けられているリソースのロール。"

msgid "refreshToken"
msgstr "refreshToken"

msgid ""
"The base64 encoded refresh token that can be used to retrieve a new token."
msgstr "新しいトークンの取得に使用できるBase64でエンコードされたリフレッシュ・トークン。"

msgid "refreshTokenParsed"
msgstr "refreshTokenParsed"

msgid "The parsed refresh token as a JavaScript object."
msgstr "JavaScriptオブジェクトとして解析されたリフレッシュ・トークン。"

msgid "timeSkew"
msgstr "timeSkew"

msgid ""
"The estimated time difference between the browser time and the "
"{project_name} server in seconds. This value is just an estimation, but is "
"accurate enough when determining if a token is expired or not."
msgstr ""
"ブラウザーと{project_name}サーバーの推定される時間差（秒単位）。この値は単なる見積もりですが、トークンが期限切れになっているかどうかを判断するには十分正確です。"

msgid "responseMode"
msgstr "responseMode"

msgid "Response mode passed in init (default value is fragment)."
msgstr "initに渡されるレスポンス・モード（デフォルト値はfragment）。"

msgid "flow"
msgstr "flow"

msgid "Flow passed in init."
msgstr "initに渡されるフロー。"

msgid "adapter"
msgstr "アダプター"

msgid ""
"Allows you to override the way that redirects and other browser-related "
"functions will be handled by the library. Available options:"
msgstr ""
"リダイレクトの方法やライブラリーにより処理されるその他のブラウザー関連の関数をオーバーライドすることができます。利用可能なオプションは以下のとおりです。"

msgid ""
"\"default\" - the library uses the browser api for redirects (this is the "
"default)"
msgstr "\"default\" - ライブラリーはリダイレクトにブラウザーのAPIを使用します（これはデフォルトです）"

msgid ""
"\"cordova\" - the library will try to use the InAppBrowser cordova plugin to"
" load keycloak login/registration pages (this is used automatically when the"
" library is working in a cordova ecosystem)"
msgstr ""
"\"cordova\" - ライブラリーは、InAppBrowser "
"cordovaプラグインを使用して、Keycloakのログイン/登録ページを読み込もうとします（これは、ライブラリーがcordovaエコシステムで動作しているときに自動的に使用されます）"

msgid ""
"\"cordova-native\" - the library tries to open the login and registration "
"page using the phone's system browser using the BrowserTabs cordova plugin. "
"This requires extra setup for redirecting back to the app (see <<hybrid-"
"apps-with-cordova>>)."
msgstr ""
"\"cordova-native\" - ライブラリーはBrowserTabs "
"cordovaプラグインを使用して、電話のシステム・ブラウザーを使用してログインページと登録ページを開こうとします。これには、アプリケーションにリダイレクトするための特別な設定が必要です（<<hybrid-"
"apps-with-cordova>>を参照してください）。"

msgid ""
"custom - allows you to implement a custom adapter (only for advanced use "
"cases)"
msgstr "custom - カスタム・アダプターを実装することができます（高度なユースケースのみ）"

msgid "responseType"
msgstr "responseType"

msgid ""
"Response type sent to {project_name} with login requests. This is determined"
" based on the flow value used during initialization, but can be overridden "
"by setting this value."
msgstr ""
"{project_name}にログイン・リクエストとともに送信されたレスポンスタイプ。これは、初期化中に使用されたフロー値に基づいて決定されますが、この値を設定することで上書きできます。"

msgid "Methods"
msgstr "メソッド"

msgid "init(options)"
msgstr "init(options)"

msgid "Called to initialize the adapter."
msgstr "アダプターを初期化するために呼び出されます。"

msgid "Options is an Object, where:"
msgstr "optionsはオブジェクトで、以下のプロパティーがあります。"

msgid ""
"useNonce - Adds a cryptographic nonce to verify that the authentication "
"response matches the request (default is `true`)."
msgstr "useNonce - 暗号化ノンスを追加して、認証レスポンスがリクエストと一致することを確認します（デフォルトは `true` です）。"

msgid ""
"onLoad - Specifies an action to do on load. Supported values are `login-"
"required` or `check-sso`."
msgstr ""
"onLoad - ロード時に実行するアクションを指定します。サポートされている値は `login-required` または `check-sso` "
"です。"

msgid ""
"silentCheckSsoRedirectUri - Set the redirect uri for silent authentication "
"check if onLoad is set to 'check-sso'."
msgstr ""
"silentCheckSsoRedirectUri - onLoadが'check-"
"sso'に設定されている場合、サイレント認証チェックのリダイレクトURIを設定します。"

msgid ""
"silentCheckSsoFallback - Enables fall back to regular `check-sso` when "
"_silent_ `check-sso` is not supported by the browser (default is `true`)."
msgstr ""
"silentCheckSsoFallback - _silent_ `check-sso` がブラウザーでサポートされていない場合、通常の "
"`check-sso` へのフォールバックを有効にします（デフォルトは `true` です）。"

msgid "token - Set an initial value for the token."
msgstr "token - トークンの初期値を設定します。"

msgid "refreshToken - Set an initial value for the refresh token."
msgstr "refreshToken - リフレッシュ・トークンの初期値を設定します。"

msgid ""
"idToken - Set an initial value for the id token (only together with token or"
" refreshToken)."
msgstr "idToken - IDトークンの初期値を設定します（tokenまたはrefreshTokenとともにする場合のみ）。"

msgid ""
"timeSkew - Set an initial value for skew between local time and "
"{project_name} server in seconds (only together with token or refreshToken)."
msgstr ""
"timeSkew - "
"ローカルの時間と{project_name}サーバーとの間のスキューの初期値を秒単位で設定します（tokenまたはrefreshTokenとともにする場合のみ）。"

msgid ""
"checkLoginIframe - Set to enable/disable monitoring login state (default is "
"`true`)."
msgstr "checkLoginIframe - ログイン状態の監視を有効/無効に設定します（デフォルトは `true` ）。"

msgid ""
"checkLoginIframeInterval - Set the interval to check login state (default is"
" 5 seconds)."
msgstr "checkLoginIframeInterval - ログイン状態を確認する間隔を設定します（デフォルトは5秒）。"

msgid ""
"responseMode - Set the OpenID Connect response mode send to {project_name} "
"server at login request. Valid values are `query` or `fragment`. Default "
"value is `fragment`, which means that after successful authentication will "
"{project_name} redirect to JavaScript application with OpenID Connect "
"parameters added in URL fragment. This is generally safer and recommended "
"over `query`."
msgstr ""
"responseMode - ログイン・リクエストの時に{project_name}サーバーに送信するOpenID "
"Connectレスポンス・モードを設定します。有効な値は、 `query` または `fragment` です。デフォルト値は `fragment` "
"です。つまり、認証が成功した後、{project_name}はURLフラグメントに追加されたOpenID "
"Connectパラメーターとともに、JavaScriptアプリケーションにリダイレクトされます。これは一般的に `query` "
"よりも安全で推奨されます。"

msgid ""
"flow - Set the OpenID Connect flow. Valid values are `standard`, `implicit` "
"or `hybrid`."
msgstr ""
"flow - OpenID Connectのフローを設定します。有効な値は、 `standard` 、 `implicit` 、 `hybrid` "
"のいずれかです。"

msgid ""
"enableLogging - Enables logging messages from Keycloak to the console "
"(default is `false`)."
msgstr "enableLogging - Keycloakからコンソールへのメッセージのロギングを有効にします（デフォルトは `false` ）。"

msgid ""
"pkceMethod - The method for Proof Key Code Exchange "
"(https://datatracker.ietf.org/doc/html/rfc7636[PKCE]) to use. Configuring "
"this value enables the PKCE mechanism. Available options:"
msgstr ""
"pkceMethod - Proof Key Code Exchange（ "
"https://datatracker.ietf.org/doc/html/rfc7636[PKCE] "
"）が使用するメソッド。この値を設定すると、PKCEメカニズムが有効になります。利用可能なオプションは、以下の通りです。"

msgid "\"S256\" - The SHA256 based PKCE method"
msgstr "\"S256\" - SHA256ベースのPKCEメソッド"

msgid ""
"messageReceiveTimeout - Set a timeout in milliseconds for waiting for "
"message responses from the Keycloak server. This is used, for example, when "
"waiting for a message during 3rd party cookies check. The default value is "
"10000."
msgstr ""
"messageReceiveTimeout - "
"Keycloakサーバーからのメッセージ応答を待つためのタイムアウトをミリ秒単位で設定します。これは、たとえば、サードパーティーのCookieチェック中にメッセージを待つときに使用されます。デフォルト値は10000です。"

msgid "Returns a promise that resolves when initialization completes."
msgstr "初期化が完了すると解決するPromiseを返します。"

msgid "login(options)"
msgstr "login(options)"

msgid "Redirects to login form."
msgstr "ログイン画面にリダイレクトします。"

msgid "Options is an optional Object, where:"
msgstr "Optionsは、以下のオプションのObjectです。"

msgid "redirectUri - Specifies the uri to redirect to after login."
msgstr "redirectUri - ログイン後にリダイレクトするURIを指定します。"

msgid ""
"prompt - This parameter allows to slightly customize the login flow on the "
"{project_name} server side. For example enforce displaying the login screen "
"in case of value `login`. See "
"link:{adapterguide_link}#_params_forwarding[Parameters Forwarding Section] "
"for the details and all the possible values of the `prompt` parameter."
msgstr ""
"prompt - このパラメーターを使用すると、{project_name}サーバー側のログインフローを少しだけカスタマイズできます。たとえば、値が "
"`login` の場合は、ログイン画面を表示するようにします。 `prompt` パラメーターの詳細とすべての値については、 "
"link:{adapterguide_link}#_params_forwarding[パラメーター転送のセクション] を参照してください。"

msgid ""
"maxAge - Used just if user is already authenticated. Specifies maximum time "
"since the authentication of user happened. If user is already authenticated "
"for longer time than `maxAge`, the SSO is ignored and he will need to re-"
"authenticate again."
msgstr ""
"maxAge - ユーザーがすでに認証されている場合にのみ使用されます。ユーザーの認証が行われてからの最大時間を指定します。ユーザーがすでに "
"`maxAge` よりも長い時間認証済みの場合、SSOは無視され、再度認証する必要があります。"

msgid ""
"loginHint - Used to pre-fill the username/email field on the login form."
msgstr "loginHint - ログイン・フォームのユーザー名/電子メール・フィールドを事前入力するために使用されます。"

msgid ""
"scope - Used to forward the scope parameter to the {project_name} login "
"endpoint. Use a space-delimited list of scopes. Those typically reference "
"link:{adminguide_link}#_client_scopes[Client scopes] defined on particular "
"client. Note that the scope `openid` will be always be added to the list of "
"scopes by the adapter. For example, if you enter the scope options `address "
"phone`, then the request to {project_name} will contain the scope parameter "
"`scope=openid address phone`."
msgstr ""
"scope - "
"{project_name}ログイン・エンドポイントに、scopeパラメーターを転送するために使用します。スペース区切りのスコープのリストを使用します。それらは通常、特定のクライアントで定義されたlink:{adminguide_link}#_client_scopes[Client"
" scopes]を参照します。スコープ `openid` "
"は、アダプターによって常にスコープのリストに追加されることに注意してください。たとえば、スコープ・オプション `address phone` "
"を入力すると、{project_name}へのリクエストにスコープ・パラメーター `scope=openid address phone` "
"が含まれます。"

msgid ""
"idpHint - Used to tell {project_name} to skip showing the login page and "
"automatically redirect to the specified identity provider instead. More info"
" in the link:{adminguide_link}#_client_suggested_idp[Identity Provider "
"documentation]."
msgstr ""
"idpHint - "
"ログインページの表示をスキップし、代わりに指定されたアイデンティティー・プロバイダーに自動的にリダイレクトするように、{project_name}に指示するために使用されます。詳細は、link:{adminguide_link}#_client_suggested_idp[Identity"
" Provider documentation]を参照してください。"

msgid ""
"action - If value is `register` then user is redirected to registration "
"page, if the value is `UPDATE_PASSWORD` then the user will redirected to the"
" reset password page (if not authenticated will send user to login page "
"first and redirect after authenticated), otherwise to login page."
msgstr ""
"action - 値が `register` の場合、ユーザーは登録ページにリダイレクトされ、値が `UPDATE_PASSWORD` "
"の場合、ユーザーはパスワード・リセット・ページにリダイレクトされます（認証されていない場合は、まずログイン画面に送られ、認証された後にリダイレクトされます）。それ以外の場合はログイン画面にリダイレクトされます。"

msgid ""
"locale - Sets the 'ui_locales' query param in compliance with "
"https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest[section "
"3.1.2.1 of the OIDC 1.0 specification]."
msgstr ""
"locale - https://openid.net/specs/openid-connect-"
"core-1_0.html#AuthRequest[OIDC 1.0仕様のセクション3.1.2.1] に準拠した 'ui_locales' "
"クエリー・パラメーターを設定します。"

msgid ""
"cordovaOptions - Specifies the arguments that are passed to the Cordova in-"
"app-browser (if applicable). Options `hidden` and `location` are not "
"affected by these arguments. All available options are defined at "
"https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-"
"inappbrowser/. Example of use: `{ zoom: \"no\", hardwareback: \"yes\" }`;"
msgstr ""
"cordovaOptions - Cordovaのアプリケーション内ブラウザーに渡される引数を指定します（該当する場合）。オプション `hidden` "
"と `location` はこれらの引数の影響を受けません。利用可能なすべてのオプションは "
"https://cordova.apache.org/docs/en/latest/reference/cordova-plugin-"
"inappbrowser/ で定義されています。使用例： `{ zoom: \"no\", hardwareback: \"yes\" }`"

msgid "createLoginUrl(options)"
msgstr "createLoginUrl(options)"

msgid "Returns the URL to login form."
msgstr "ログイン画面のURLを返します。"

msgid ""
"Options is an optional Object, which supports same options as the function "
"`login` ."
msgstr "Options はオプションのオブジェクトで、関数 `login` と同じオプションをサポートします。"

msgid "logout(options)"
msgstr "logout(options)"

msgid "Redirects to logout."
msgstr "ログアウトにリダイレクトします。"

msgid "redirectUri - Specifies the uri to redirect to after logout."
msgstr "redirectUri - ログアウト後にリダイレクトするURIを指定します。"

msgid "createLogoutUrl(options)"
msgstr "createLogoutUrl(options)"

msgid "Returns the URL to logout the user."
msgstr "ユーザーをログアウトするURLを返します。"

msgid "register(options)"
msgstr "register(options)"

msgid ""
"Redirects to registration form. Shortcut for login with option action = "
"'register'"
msgstr "登録フォームにリダイレクトします。オプション action = 'register' でのloginメソッドのショートカットです。"

msgid ""
"Options are same as for the login method but 'action' is set to 'register'"
msgstr "optionsはloginメソッドと同じですが、 'action' は 'register' に設定されています。"

msgid "createRegisterUrl(options)"
msgstr "createRegisterUrl(options)"

msgid ""
"Returns the url to registration page. Shortcut for createLoginUrl with "
"option action = 'register'"
msgstr ""
"登録ページのURLを返します。オプション action = 'register' でのcreateLoginUrlメソッドのショートカットです。"

msgid ""
"Options are same as for the createLoginUrl method but 'action' is set to "
"'register'"
msgstr "optionsは createLoginUrlメソッドと同じですが、 'action' は 'register' に設定されています。"

msgid "accountManagement()"
msgstr "accountManagement()"

msgid "Redirects to the Account Management Console."
msgstr "アカウント管理コンソールにリダイレクトします。"

msgid "createAccountUrl(options)"
msgstr "createAccountUrl(options)"

msgid "Returns the URL to the Account Management Console."
msgstr "アカウント管理コンソールのURLを返します。"

msgid ""
"redirectUri - Specifies the uri to redirect to when redirecting back to the "
"application."
msgstr "redirectUri - アプリケーションにリダイレクトで戻るときに、リダイレクトするURIを指定します。"

msgid "hasRealmRole(role)"
msgstr "hasRealmRole(role)"

msgid "Returns true if the token has the given realm role."
msgstr "トークンに指定されたレルム・ロールがある場合は、trueを返します。"

msgid "hasResourceRole(role, resource)"
msgstr "hasResourceRole(role, resource)"

msgid ""
"Returns true if the token has the given role for the resource (resource is "
"optional, if not specified clientId is used)."
msgstr ""
"トークンに指定されたresourceのロールがある場合は、trueを返します（resourceはオプションであり、指定されていない場合はclientIdが使用されます）。"

msgid "loadUserProfile()"
msgstr "loadUserProfile()"

msgid "Loads the users profile."
msgstr "ユーザーのプロファイルを読み込みます。"

msgid "Returns a promise that resolves with the profile."
msgstr "プロファイルで解決されるPromiseを返します。"

msgid ""
"keycloak.loadUserProfile()\n"
"    .then(function(profile) {\n"
"        alert(JSON.stringify(profile, null, \"  \"))\n"
"    }).catch(function() {\n"
"        alert('Failed to load user profile');\n"
"    });"
msgstr ""
"keycloak.loadUserProfile()\n"
"    .then(function(profile) {\n"
"        alert(JSON.stringify(profile, null, \"  \"))\n"
"    }).catch(function() {\n"
"        alert('Failed to load user profile');\n"
"    });"

msgid "isTokenExpired(minValidity)"
msgstr "isTokenExpired(minValidity)"

msgid ""
"Returns true if the token has less than minValidity seconds left before it "
"expires (minValidity is optional, if not specified 0 is used)."
msgstr ""
"トークンが期限切れになる前にminValidity秒を下回っている場合はtrueを返します（指定されていない場合はminValidityはオプションです。0が使用されます）。"

msgid "updateToken(minValidity)"
msgstr "updateToken(minValidity)"

msgid ""
"If the token expires within minValidity seconds (minValidity is optional, if"
" not specified 5 is used) the token is refreshed. If the session status "
"iframe is enabled, the session status is also checked."
msgstr ""
"トークンがminValidity秒以内に期限切れになると（minValidityは省略可能です。指定されていない場合は5が使用されます）、トークンがリフレッシュされます。セッション・ステータスiframeが有効な場合、セッション・ステータスもチェックされます。"

msgid ""
"Returns a promise that resolves with a boolean indicating whether or not the"
" token has been refreshed."
msgstr "トークンがリフレッシュされたかどうかを示すブール値で解決されるPromiseを返します。"

msgid ""
"keycloak.updateToken(5)\n"
"    .then(function(refreshed) {\n"
"        if (refreshed) {\n"
"            alert('Token was successfully refreshed');\n"
"        } else {\n"
"            alert('Token is still valid');\n"
"        }\n"
"    }).catch(function() {\n"
"        alert('Failed to refresh the token, or the session has expired');\n"
"    });"
msgstr ""
"keycloak.updateToken(5)\n"
"    .then(function(refreshed) {\n"
"        if (refreshed) {\n"
"            alert('Token was successfully refreshed');\n"
"        } else {\n"
"            alert('Token is still valid');\n"
"        }\n"
"    }).catch(function() {\n"
"        alert('Failed to refresh the token, or the session has expired');\n"
"    });"

msgid "clearToken()"
msgstr "clearToken()"

msgid ""
"Clear authentication state, including tokens. This can be useful if "
"application has detected the session was expired, for example if updating "
"token fails."
msgstr ""
"認証状態（トークンを含む）をクリアします。これは、トークンの更新が失敗した場合など、セッションが終了したことをアプリケーションが検出した場合に役立ちます。"

msgid "Invoking this results in onAuthLogout callback listener being invoked."
msgstr "これを呼び出すと、onAuthLogoutコールバック・リスナーが呼び出されます。"

msgid "Callback Events"
msgstr "コールバック・イベント"

msgid "The adapter supports setting callback listeners for certain events."
msgstr "アダプターは、特定のイベントのコールバック・リスナーの設定をサポートします。"

msgid "keycloak.onAuthSuccess = function() { alert('authenticated'); }"
msgstr "keycloak.onAuthSuccess = function() { alert('authenticated'); }"

msgid "The available events are:"
msgstr "使用できるイベントは次のとおりです。"

msgid "onReady(authenticated) - Called when the adapter is initialized."
msgstr "onReady(authenticated) - アダプターが初期化されたときに呼び出されます。"

msgid "onAuthSuccess - Called when a user is successfully authenticated."
msgstr "onAuthSuccess - ユーザーが正常に認証されたときに呼び出されます。"

msgid "onAuthError - Called if there was an error during authentication."
msgstr "onAuthError - 認証時にエラーが発生した場合に呼び出されます。"

msgid "onAuthRefreshSuccess - Called when the token is refreshed."
msgstr "onAuthRefreshSuccess - トークンがリフレッシュされたときに呼び出されます。"

msgid ""
"onAuthRefreshError - Called if there was an error while trying to refresh "
"the token."
msgstr "onAuthRefreshError - トークンをリフレッシュする際にエラーが発生した場合に呼び出されます。"

msgid ""
"onAuthLogout - Called if the user is logged out (will only be called if the "
"session status iframe is enabled, or in Cordova mode)."
msgstr ""
"onAuthLogout - "
"ユーザーがログアウトしたときに呼び出されます（セッション・ステータスiframeが有効な場合、またはCordovaモードの場合にのみ、呼び出されます）。"

msgid ""
"onTokenExpired - Called when the access token is expired. If a refresh token"
" is available the token can be refreshed with updateToken, or in cases where"
" it is not (that is, with implicit flow) you can redirect to login screen to"
" obtain a new access token."
msgstr ""
"onTokenExpired - "
"アクセス・トークンが期限切れになったときに呼び出されます。リフレッシュ・トークンが利用可能な場合、トークンはupdateTokenでリフレッシュすることができます。リフレッシュ・トークンが利用できない場合（つまり、インプリシット・フローの場合）、ログイン画面にリダイレクトして新しいアクセス・トークンを取得できます。"

msgid "Node.js adapter"
msgstr "Node.jsアダプター"

msgid ""
"{project_name} provides a Node.js adapter built on top of "
"https://github.com/senchalabs/connect[Connect] to protect server-side "
"JavaScript apps - the goal was to be flexible enough to integrate with "
"frameworks like https://expressjs.com/[Express.js]."
msgstr ""
"{project_name}は、サーバーサイドのJavaScriptアプリケーションを保護するために、 "
"https://github.com/senchalabs/connect[Connect] "
"の上に構築されたNode.jsアダプターを提供します。目標は、 https://expressjs.com/[Express.js] "
"などのフレームワークと統合するのに十分な柔軟性を得ることです。"

msgid ""
"The library can be downloaded directly from "
"https://www.npmjs.com/package/keycloak-connect[ {project_name} organization]"
" and the source is available at https://github.com/keycloak/keycloak-nodejs-"
"connect[GitHub]."
msgstr ""
"ライブラリーは https://www.npmjs.com/package/keycloak-connect[{project_name} "
"organization] から直接ダウンロードすることができ、ソースは https://github.com/keycloak/keycloak-"
"nodejs-connect[GitHub] で利用可能です。"

msgid ""
"To use the Node.js adapter, first you must create a client for your "
"application in the {project_name} Admin Console. The adapter supports "
"public, confidential, and bearer-only access type. Which one to choose "
"depends on the use-case scenario."
msgstr ""
"Node.jsアダプターを使用するには、まず、{project_name}管理コンソールでアプリケーションのクライアントを作成する必要があります。アダプターは、public、confidential、bearer-"
"onlyのアクセス・タイプをサポートします。どれを選択するかは、ユースケースのシナリオに依存します。"

msgid ""
"Once the client is created click the `Installation` tab, select "
"`{project_name} OIDC JSON` for `Format Option`, and then click `Download`. "
"The downloaded `keycloak.json` file should be at the root folder of your "
"project."
msgstr ""
"クライアントが作成されたら、 `Installation` タブをクリックし、 `Format Option` で `{project_name} "
"OIDC JSON` を選択し、 `Download` をクリックします。ダウンロードした `keycloak.json` "
"ファイルはプロジェクトのルート・フォルダーに配置します。"

msgid ""
"Assuming you've already installed https://nodejs.org[Node.js], create a "
"folder for your application:"
msgstr ""
"すでに https://nodejs.org[Node.js] がインストールされていると仮定して、アプリケーション用のフォルダーを作成します。"

msgid "mkdir myapp && cd myapp"
msgstr "mkdir myapp && cd myapp"

msgid ""
"Use `npm init` command to create a `package.json` for your application. Now "
"add the {project_name} connect adapter in the dependencies list:"
msgstr ""
"`npm init` コマンドを使ってアプリケーション用の `package.json` "
"を作成してください。依存関係リストに{project_name}接続アダプターを追加します。"

msgid ""
"    \"dependencies\": {\n"
"        \"keycloak-connect\": \"{project_versionNpm}\"\n"
"    }"
msgstr ""
"    \"dependencies\": {\n"
"        \"keycloak-connect\": \"{project_versionNpm}\"\n"
"    }"

msgid "Instantiate a Keycloak class"
msgstr "Keycloakクラスのインスタンスの作成"

msgid ""
"The `Keycloak` class provides a central point for configuration and "
"integration with your application.  The simplest creation involves no "
"arguments."
msgstr "`Keycloak` クラスは、アプリケーションの設定と統合のための中心的なポイントを提供します。最も簡単な作成では引数はありません。"

msgid ""
"    var session = require('express-session');\n"
"    var Keycloak = require('keycloak-connect');\n"
"\n"
"    var memoryStore = new session.MemoryStore();\n"
"    var keycloak = new Keycloak({ store: memoryStore });"
msgstr ""
"    var session = require('express-session');\n"
"    var Keycloak = require('keycloak-connect');\n"
"\n"
"    var memoryStore = new session.MemoryStore();\n"
"    var keycloak = new Keycloak({ store: memoryStore });"

msgid ""
"By default, this will locate a file named `keycloak.json` alongside the main"
" executable of your application to initialize keycloak-specific settings "
"(public key, realm name, various URLs).  The `keycloak.json` file is "
"obtained from the {project_name} Admin Console."
msgstr ""
"デフォルトでは、keycloak固有の設定（公開鍵、レルム名、さまざまなURL）を初期化するために、アプリケーションのメイン実行可能ファイルの横に "
"`keycloak.json` という名前のファイルがあります。 `keycloak.json` "
"ファイルは、{project_name}管理者コンソールから取得できます。"

msgid ""
"Instantiation with this method results in all of the reasonable defaults "
"being used. As alternative, it's also possible to provide a configuration "
"object, rather than the `keycloak.json` file:"
msgstr ""
"このメソッドでインスタンス化すると、合理的なデフォルトが使用されます。代替として、 `keycloak.json` "
"ファイルではなく、次のように設定オブジェクトを提供することも可能です。"

msgid ""
"    let kcConfig = {\n"
"        clientId: 'myclient',\n"
"        bearerOnly: true,\n"
"        serverUrl: 'http://localhost:8080{kc_base_path}',\n"
"        realm: 'myrealm',\n"
"        realmPublicKey: 'MIIBIjANB...'\n"
"    };\n"
"\n"
"    let keycloak = new Keycloak({ store: memoryStore }, kcConfig);"
msgstr ""
"    let kcConfig = {\n"
"        clientId: 'myclient',\n"
"        bearerOnly: true,\n"
"        serverUrl: 'http://localhost:8080{kc_base_path}',\n"
"        realm: 'myrealm',\n"
"        realmPublicKey: 'MIIBIjANB...'\n"
"    };\n"
"\n"
"    let keycloak = new Keycloak({ store: memoryStore }, kcConfig);"

msgid ""
"Applications can also redirect users to their preferred identity provider by"
" using:"
msgstr "アプリケーションは、次の方法を使用して、ユーザーを優先度の高いアイデンティティー・プロバイダーにリダイレクトすることもできます。"

msgid ""
"    let keycloak = new Keycloak({ store: memoryStore, idpHint: myIdP }, "
"kcConfig);"
msgstr ""
"    let keycloak = new Keycloak({ store: memoryStore, idpHint: myIdP }, "
"kcConfig);"

msgid "Configuring a web session store"
msgstr "Webセッションストアの設定"

msgid ""
"If you want to use web sessions to manage server-side state for "
"authentication, you need to initialize the `Keycloak(...)` with at least a "
"`store` parameter, passing in the actual session store that `express-"
"session` is using."
msgstr ""
"認証のために、Webセッションを使用してサーバーサイドの状態を管理する場合は、少なくとも `store` パラメータで `Keycloak(...)` "
"を初期化し、実際のセッションストアで `express-session` 使用する必要があります。"

msgid ""
"    var session = require('express-session');\n"
"    var memoryStore = new session.MemoryStore();\n"
"\n"
"    var keycloak = new Keycloak({ store: memoryStore });"
msgstr ""
"    var session = require('express-session');\n"
"    var memoryStore = new session.MemoryStore();\n"
"\n"
"    var keycloak = new Keycloak({ store: memoryStore });"

msgid "Passing a custom scope value"
msgstr "カスタムスコープ値を渡す"

msgid ""
"By default, the scope value `openid` is passed as a query parameter to "
"{project_name}'s login URL, but you can add an additional custom value:"
msgstr ""
"デフォルトでは、スコープ値 `openid` "
"はクエリー・パラメーターとして{project_name}のログインURLに渡されますが、次のようにカスタム値を新たに追加することもできます。"

msgid "    var keycloak = new Keycloak({ scope: 'offline_access' });"
msgstr "    var keycloak = new Keycloak({ scope: 'offline_access' });"

msgid "Installing middleware"
msgstr "ミドルウェアのインストール"

msgid ""
"Once instantiated, install the middleware into your connect-capable app:"
msgstr "インスタンス化が完了したら、Middlewareをconnectに対応したアプリケーションにインストールします。"

msgid ""
"    var app = express();\n"
"\n"
"    app.use( keycloak.middleware() );"
msgstr ""
"    var app = express();\n"
"\n"
"    app.use( keycloak.middleware() );"

msgid "Configuration for proxies"
msgstr "プロキシーの設定"

msgid ""
"If the application is running behind a proxy that terminates an SSL "
"connection Express must be configured per the "
"link:https://expressjs.com/en/guide/behind-proxies.html[express behind "
"proxies] guide. Using an incorrect proxy configuration can result in invalid"
" redirect URIs being generated."
msgstr ""
"SSL接続を終了するプロキシーの背後でアプリケーションが実行されている場合は、 "
"link:https://expressjs.com/en/guide/behind-proxies.html[express behind "
"proxies] "
"ガイドに従ってExpressを設定する必要があります。不適切なプロキシー設定を使用すると、無効なリダイレクトURIが生成される可能性があります。"

msgid "Example configuration:"
msgstr "設定例："

msgid ""
"    var app = express();\n"
"\n"
"    app.set( 'trust proxy', true );\n"
"\n"
"    app.use( keycloak.middleware() );"
msgstr ""
"    var app = express();\n"
"\n"
"    app.set( 'trust proxy', true );\n"
"\n"
"    app.use( keycloak.middleware() );"

msgid "Checking authentication"
msgstr "認証のチェック"

msgid ""
"To check that a user is authenticated before accessing a resource, simply "
"use `keycloak.checkSso()`. It will only authenticate if the user is already "
"logged-in. If the user is not logged-in, the browser will be redirected back"
" to the originally-requested URL and remain unauthenticated:"
msgstr ""
"リソースにアクセスする前にユーザーが認証されていることを確認するには、単に `keycloak.checkSso()` "
"を使います。ユーザーがすでにログインしている場合にのみ認証されます。ユーザーがログインしていない場合、ブラウザーは最初に要求されたURLにリダイレクトされ、ユーザーは未認証のままになります。"

msgid "    app.get( '/check-sso', keycloak.checkSso(), checkSsoHandler );"
msgstr "    app.get( '/check-sso', keycloak.checkSso(), checkSsoHandler );"

msgid "Protecting resources"
msgstr "リソースの保護"

msgid "Simple authentication"
msgstr "単純な認証"

msgid ""
"To enforce that a user must be authenticated before accessing a resource, "
"simply use a no-argument version of `keycloak.protect()`:"
msgstr "リソースにアクセスする前にユーザーの認証を強制するには、引数のないバージョンの `keycloak.protect()` を使うだけです。"

msgid "    app.get( '/complain', keycloak.protect(), complaintHandler );"
msgstr "    app.get( '/complain', keycloak.protect(), complaintHandler );"

msgid "Role-based authorization"
msgstr "ロールベースの認可"

msgid "To secure a resource with an application role for the current app:"
msgstr "現在のアプリケーションのアプリケーション・ロールでリソースを保護するには次のようにします。"

msgid ""
"    app.get( '/special', keycloak.protect('special'), specialHandler );"
msgstr ""
"    app.get( '/special', keycloak.protect('special'), specialHandler );"

msgid "To secure a resource with an application role for a *different* app:"
msgstr "*別の* アプリケーションのアプリケーション・ロールでリソースを保護するには次のようにします。"

msgid ""
"    app.get( '/extra-special', keycloak.protect('other-app:special'), "
"extraSpecialHandler );"
msgstr ""
"    app.get( '/extra-special', keycloak.protect('other-app:special'), "
"extraSpecialHandler );"

msgid "To secure a resource with a realm role:"
msgstr "レルムロールを使用してリソースを保護するには次のようにします。"

msgid ""
"    app.get( '/admin', keycloak.protect( 'realm:admin' ), adminHandler );"
msgstr ""
"    app.get( '/admin', keycloak.protect( 'realm:admin' ), adminHandler );"

msgid "Resource-Based Authorization"
msgstr "リソースベースの認可"

msgid ""
"Resource-Based Authorization allows you to protect resources, and their "
"specific methods/actions,**** based on a set of policies defined in "
"Keycloak, thus externalizing authorization from your application. This is "
"achieved by exposing a `keycloak.enforcer` method which you can use to "
"protect resources.*"
msgstr ""
"リソースベースの認可では、Keycloakで定義されている一連のポリシーに基づいてリソースとその特定のメソッド/アクションを保護することができます。したがって、アプリケーションからの認可を外部化できます。これは、リソースを保護するために使用できる"
" `keycloak.enforcer` メソッドを公開することによって達成されます。"

msgid ""
"    app.get('/apis/me', keycloak.enforcer('user:profile'), "
"userProfileHandler);"
msgstr ""
"    app.get('/apis/me', keycloak.enforcer('user:profile'), "
"userProfileHandler);"

msgid ""
"The `keycloak-enforcer` method operates in two modes, depending on the value"
" of the `response_mode` configuration option."
msgstr "`keycloak-enforcer` メソッドは、 `response_mode` 設定オプションの値に応じて2つのモードで動作します。"

msgid ""
"    app.get('/apis/me', keycloak.enforcer('user:profile', {response_mode: "
"'token'}), userProfileHandler);"
msgstr ""
"    app.get('/apis/me', keycloak.enforcer('user:profile', {response_mode: "
"'token'}), userProfileHandler);"

msgid ""
"If `response_mode` is set to `token`, permissions are obtained from the "
"server on behalf of the subject represented by the bearer token that was "
"sent to your application. In this case, a new access token is issued by "
"Keycloak with the permissions granted by the server. If the server did not "
"respond with a token with the expected permissions, the request is denied. "
"When using this mode, you should be able to obtain the token from the "
"request as follows:"
msgstr ""
"`response_mode` が `token` "
"に設定されている場合、パーミッションはアプリケーションに送られたベアラートークンによって表されるサブジェクトに代わりにサーバーから取得されます。この場合、Keycloakによって付与されたパーミッションとともに新しいアクセストークンが発行されます。サーバーが想定したパーミッションを持つトークンで応答しなかった場合、リクエストは拒否されます。このモードを使用するときは、次のようにリクエストからトークンを取得できるはずです。"

msgid ""
"    app.get('/apis/me', keycloak.enforcer('user:profile', {response_mode: 'token'}), function (req, res) {\n"
"        var token = req.kauth.grant.access_token.content;\n"
"        var permissions = token.authorization ? token.authorization.permissions : undefined;\n"
"\n"
"        // show user profile\n"
"    });"
msgstr ""
"    app.get('/apis/me', keycloak.enforcer('user:profile', {response_mode: 'token'}), function (req, res) {\n"
"        var token = req.kauth.grant.access_token.content;\n"
"        var permissions = token.authorization ? token.authorization.permissions : undefined;\n"
"\n"
"        // show user profile\n"
"    });"

msgid ""
"Prefer this mode when your application is using sessions and you want to "
"cache previous decisions from the server, as well automatically handle "
"refresh tokens. This mode is especially useful for applications acting as a "
"client and resource server."
msgstr ""
"アプリケーションがセッションを使用していて、サーバーからの以前の決定をキャッシュしたい場合や、自動的に更新トークンを処理したい場合は、このモードを選択してください。このモードは、クライアントおよびリソースサーバーとして機能するアプリケーションに特に役立ちます。"

msgid ""
"If `response_mode` is set to `permissions` (default mode), the server only "
"returns the list of granted permissions, without issuing a new access token."
" In addition to not issuing a new token, this method exposes the permissions"
" granted by the server through the `request` as follows:"
msgstr ""
"`response_mode` が `permissions` "
"に設定されている場合（デフォルトモード）、サーバーは新しいアクセストークンを発行せずに、許可されたパーミッションのリストのみを返します。新しいトークンを発行しないことに加えて、このメソッドは以下のように"
" `request` を介してサーバーにより与えられたパーミッションを公開します。"

msgid ""
"    app.get('/apis/me', keycloak.enforcer('user:profile', {response_mode: 'permissions'}), function (req, res) {\n"
"        var permissions = req.permissions;\n"
"\n"
"        // show user profile\n"
"    });"
msgstr ""
"    app.get('/apis/me', keycloak.enforcer('user:profile', {response_mode: 'permissions'}), function (req, res) {\n"
"        var permissions = req.permissions;\n"
"\n"
"        // show user profile\n"
"    });"

msgid ""
"Regardless of the `response_mode` in use, the `keycloak.enforcer` method "
"will first try to check the permissions within the bearer token that was "
"sent to your application. If the bearer token already carries the expected "
"permissions, there is no need to interact with the server to obtain a "
"decision. This is specially useful when your clients are capable of "
"obtaining access tokens from the server with the expected permissions before"
" accessing a protected resource, so they can use some capabilities provided "
"by Keycloak Authorization Services such as incremental authorization and "
"avoid additional requests to the server when `keycloak.enforcer` is "
"enforcing access to the resource."
msgstr ""
"`response_mode` が使われているかどうかにかかわらず、 `keycloak.enforcer` "
"メソッドは最初にアプリケーションに送られたベアラートークンの中のパーミッションをチェックしようとします。ベアラートークンがすでに想定されたパーミッションを持っている場合は、決定を得るためにサーバーと対話する必要はありません。これは、保護されたリソースにアクセスする前に、クライアントが期待されるパーミッションでサーバーからアクセストークンを取得できる場合に特に役立ちます。そのため、クライアントは増分認可などのKeycloak認可サービスによって提供される機能を使用できます。"
" `keycloak.enforcer` はリソースへのアクセスを強制します。"

msgid ""
"By default, the policy enforcer will use the `client_id` defined to the "
"application (for instance, via `keycloak.json`) to  reference a client in "
"Keycloak that supports Keycloak Authorization Services. In this case, the "
"client can not be public given  that it is actually a resource server."
msgstr ""
"デフォルトでは、ポリシー・エンフォーサーはアプリケーションに定義された `client_id` を使って（たとえば `keycloak.json` "
"を介して）、Keycloakの認可サービスをサポートするKeycloakのクライアントを参照します。この場合、クライアントは実際にはリソースサーバーであるため、パブリックにすることはできません。"

msgid ""
"If your application is acting as both a public client(frontend) and resource"
" server(backend), you can use the following configuration to reference a "
"different client in Keycloak with the policies that you want to enforce:"
msgstr ""
"アプリケーションがパブリック・クライアント（フロントエンド）とリソースサーバー（バックエンド）の両方として機能している場合は、次の設定を使用して、施行したいポリシーでKeycloak内の別のクライアントを参照できます。"

msgid ""
"      keycloak.enforcer('user:profile', {resource_server_id: 'my-"
"apiserver'})"
msgstr ""
"      keycloak.enforcer('user:profile', {resource_server_id: 'my-"
"apiserver'})"

msgid ""
"It is recommended to use distinct clients in Keycloak to represent your "
"frontend and backend."
msgstr "フロントエンドとバックエンドを表すために、Keycloakで個別のクライアントを使用することをお勧めします。"

msgid ""
"If the application you are protecting is enabled with Keycloak authorization"
" services and you have defined client credentials  in `keycloak.json`, you "
"can push additional claims to the server and make them available to your "
"policies in order to make decisions. For that, you can define a `claims` "
"configuration option which expects a `function` that returns a JSON with the"
" claims you want to push:"
msgstr ""
"保護しているアプリケーションがKeycloak認可サービスで有効になっていて、 `keycloak.json` "
"でクライアントのクレデンシャルを定義している場合は、決定を下すために、追加のクレームをサーバーにプッシュし、それらをポリシーで利用できるようにすることができます。そのために、プッシュしたいクレームを持つJSONを返す"
" `function` を期待する `claim` 設定オプションを定義できます。"

msgid ""
"      app.get('/protected/resource', keycloak.enforcer(['resource:view', 'resource:write'], {\n"
"          claims: function(request) {\n"
"            return {\n"
"              \"http.uri\": [\"/protected/resource\"],\n"
"              \"user.agent\": // get user agent  from request\n"
"            }\n"
"          }\n"
"        }), function (req, res) {\n"
"          // access granted"
msgstr ""
"      app.get('/protected/resource', keycloak.enforcer(['resource:view', 'resource:write'], {\n"
"          claims: function(request) {\n"
"            return {\n"
"              \"http.uri\": [\"/protected/resource\"],\n"
"              \"user.agent\": // get user agent  from request\n"
"            }\n"
"          }\n"
"        }), function (req, res) {\n"
"          // access granted"

msgid ""
"For more details about how to configure Keycloak to protected your "
"application resources, please take a look at the "
"link:{authorizationguide_link}[{authorizationguide_name}]."
msgstr ""
"アプリケーションのリソースを保護するようにKeycloakを設定する方法の詳細については、 "
"link:{authorizationguide_link}[{authorizationguide_name}] をご覧ください。"

msgid "Advanced authorization"
msgstr "高度な認可"

msgid ""
"To secure resources based on parts of the URL itself, assuming a role exists"
" for each section:"
msgstr "URLの一部に基づいてリソースを保護するには次のようにします（各セクションにロールが存在すると仮定します）。"

msgid ""
"    function protectBySection(token, request) {\n"
"      return token.hasRole( request.params.section );\n"
"    }\n"
"\n"
"    app.get( '/:section/:page', keycloak.protect( protectBySection ), sectionHandler );"
msgstr ""
"    function protectBySection(token, request) {\n"
"      return token.hasRole( request.params.section );\n"
"    }\n"
"\n"
"    app.get( '/:section/:page', keycloak.protect( protectBySection ), sectionHandler );"

msgid "Advanced Login Configuration:"
msgstr "高度なログイン設定："

msgid ""
"By default, all unauthorized requests will be redirected to the "
"{project_name} login page unless your client is bearer-only. However, a "
"confidential or public client may host both browsable and API endpoints. To "
"prevent redirects on unauthenticated API requests and instead return an HTTP"
" 401, you can override the redirectToLogin function."
msgstr ""
"デフォルトでは、クライアントがbearer-"
"onlyでない限り、許可されていないすべてのリクエストは{project_name}のログインページにリダイレクトされます。ただし、コンフィデンシャル・クライアントまたはパブリック・クライアントは、閲覧可能なエンドポイントとAPIエンドポイントの両方をホストする場合があります。認証されていないAPIリクエストでのリダイレクトを防ぎ、代わりにHTTP"
" 401を返すようにするために、redirectToLogin関数をオーバーライドできます。"

msgid ""
"For example, this override checks if the URL contains /api/ and disables "
"login redirects:"
msgstr "たとえば、このオーバーライドは、URLに/api/が含まれているかどうかを確認し、ログイン・リダイレクトを無効にします。"

msgid ""
"    Keycloak.prototype.redirectToLogin = function(req) {\n"
"    var apiReqMatcher = /\\/api\\//i;\n"
"    return !apiReqMatcher.test(req.originalUrl || req.url);\n"
"    };"
msgstr ""
"    Keycloak.prototype.redirectToLogin = function(req) {\n"
"    var apiReqMatcher = /\\/api\\//i;\n"
"    return !apiReqMatcher.test(req.originalUrl || req.url);\n"
"    };"

msgid "Additional URLs"
msgstr "追加のURL"

msgid "Explicit user-triggered logout"
msgstr "明示的なユーザー・トリガー・ログアウト"

msgid ""
"By default, the middleware catches calls to `/logout` to send the user "
"through a {project_name}-centric logout workflow. This can be changed by "
"specifying a `logout` configuration parameter to the `middleware()` call:"
msgstr ""
"デフォルトでは、Middlewareは `/logout` "
"の呼び出しをキャッチし、ユーザーに{project_name}中心のログアウト・ワークフローを経由させます。これは、 `logout` "
"設定パラメーターを `middleware()` の呼び出しに指定することで変更できます。"

msgid "    app.use( keycloak.middleware( { logout: '/logoff' } ));"
msgstr "    app.use( keycloak.middleware( { logout: '/logoff' } ));"

msgid ""
"When the user-triggered logout is invoked a query parameter `redirect_url` "
"can be passed:"
msgstr "ユーザートリガーのログアウトが呼び出されると、次のようにクエリー・パラメーター `redirect_url` を渡すことができます。"

msgid ""
"https://example.com/logoff?redirect_url=https%3A%2F%2Fexample.com%3A3000%2Flogged%2Fout"
msgstr ""
"https://example.com/logoff?redirect_url=https%3A%2F%2Fexample.com%3A3000%2Flogged%2Fout"

msgid ""
"This parameter is then used as the redirect url of the OIDC logout endpoint "
"and the user will be redirected to `\\https://example.com/logged/out`."
msgstr ""
"このパラメーターはOIDCログアウト・エンドポイントのリダイレクトURLとして使用され、ユーザーは "
"`\\https://example.com/logged/out` にリダイレクトされます。"

msgid "{project_name} Admin Callbacks"
msgstr "{project_name} Adminコールバック"

msgid ""
"Also, the middleware supports callbacks from the {project_name} console to "
"log out a single session or all sessions.  By default, these type of admin "
"callbacks occur relative to the root URL of `/` but can be changed by "
"providing an `admin` parameter to the `middleware()` call:"
msgstr ""
"また、Middlewareは{project_name}コンソールからのコールバックをサポートしており、単一セッションまたはすべてのセッションをログアウトします。デフォルトでは、これらのタイプのAdminコールバックは"
" `/` のルートURLを基準に発生しますが、 `admin` パラメーターを `middleware()` の呼び出しに与えることで変更できます。"

msgid "    app.use( keycloak.middleware( { admin: '/callbacks' } );"
msgstr "    app.use( keycloak.middleware( { admin: '/callbacks' } );"

msgid "mod_auth_openidc Apache HTTPD Module"
msgstr "mod_auth_openidc Apache HTTPDモジュール"

msgid ""
"The https://github.com/zmartzone/mod_auth_openidc[mod_auth_openidc] is an "
"Apache HTTP plugin for OpenID Connect. If your language/environment supports"
" using Apache HTTPD as a proxy, then you can use _mod_auth_openidc_ to "
"secure your web application with OpenID Connect.  Configuration of this "
"module is beyond the scope of this document.  Please see the "
"_mod_auth_openidc_ GitHub repo for more details on configuration."
msgstr ""
"https://github.com/zmartzone/mod_auth_openidc[mod_auth_openidc]は、OpenID "
"Connect用のApache HTTPプラグインです。現在利用している言語/環境でApache HTTPDをプロキシーとして使用できる場合は、 "
"_mod_auth_openidc_ を使用してOpenID "
"ConnectでWebアプリケーションを保護することができます。このモジュールの設定は、このドキュメントの範囲を超えています。設定の詳細については、 "
"_mod_auth_openidc_ のGitHubリポジトリーを参照ください。"

msgid "To configure _mod_auth_openidc_ you'll need"
msgstr "_mod_auth_openidc_ を設定するには、以下が必要です。"

msgid "The client_id."
msgstr "client_id。"

msgid "The client_secret."
msgstr "client_secret。"

msgid "The redirect_uri to your application."
msgstr "アプリケーションへのredirect_uri。"

msgid "The Keycloak openid-configuration url"
msgstr "Keycloak openid-configuration URL"

msgid "_mod_auth_openidc_ specific Apache HTTPD module config."
msgstr "_mod_auth_openidc_ 固有のApache HTTPDモジュールの設定。"

msgid "An example configuration would look like the following."
msgstr "設定例は次のようになります。"

msgid ""
"LoadModule auth_openidc_module modules/mod_auth_openidc.so\n"
"\n"
"ServerName ${HOSTIP}\n"
"\n"
"<VirtualHost *:80>\n"
"\n"
"    ServerAdmin webmaster@localhost\n"
"    DocumentRoot /var/www/html\n"
"\n"
"    #this is required by mod_auth_openidc\n"
"    OIDCCryptoPassphrase a-random-secret-used-by-apache-oidc-and-balancer\n"
"\n"
"    OIDCProviderMetadataURL ${KC_ADDR}{kc_realms_path}/${KC_REALM}/.well-known/openid-configuration\n"
"\n"
"    OIDCClientID ${CLIENT_ID}\n"
"    OIDCClientSecret ${CLIENT_SECRET}\n"
"    OIDCRedirectURI http://${HOSTIP}/${CLIENT_APP_NAME}/redirect_uri\n"
"\n"
"    # maps the prefered_username claim to the REMOTE_USER environment variable\n"
"    OIDCRemoteUserClaim preferred_username\n"
"\n"
"    <Location /${CLIENT_APP_NAME}/>\n"
"        AuthType openid-connect\n"
"        Require valid-user\n"
"    </Location>\n"
"</VirtualHost>"
msgstr ""
"LoadModule auth_openidc_module modules/mod_auth_openidc.so\n"
"\n"
"ServerName ${HOSTIP}\n"
"\n"
"<VirtualHost *:80>\n"
"\n"
"    ServerAdmin webmaster@localhost\n"
"    DocumentRoot /var/www/html\n"
"\n"
"    #this is required by mod_auth_openidc\n"
"    OIDCCryptoPassphrase a-random-secret-used-by-apache-oidc-and-balancer\n"
"\n"
"    OIDCProviderMetadataURL ${KC_ADDR}{kc_realms_path}/${KC_REALM}/.well-known/openid-configuration\n"
"\n"
"    OIDCClientID ${CLIENT_ID}\n"
"    OIDCClientSecret ${CLIENT_SECRET}\n"
"    OIDCRedirectURI http://${HOSTIP}/${CLIENT_APP_NAME}/redirect_uri\n"
"\n"
"    # maps the prefered_username claim to the REMOTE_USER environment variable\n"
"    OIDCRemoteUserClaim preferred_username\n"
"\n"
"    <Location /${CLIENT_APP_NAME}/>\n"
"        AuthType openid-connect\n"
"        Require valid-user\n"
"    </Location>\n"
"</VirtualHost>"

msgid ""
"Further information on how to configure mod_auth_openidc can be found on the"
" https://github.com/zmartzone/mod_auth_openidc[mod_auth_openidc] project "
"page."
msgstr ""
"mod_auth_openidcの設定方法の詳細については、 "
"https://github.com/zmartzone/mod_auth_openidc[mod_auth_openidc]プロジェクトページを参照してください。"

msgid "Other OpenID Connect libraries"
msgstr "他のOpenID Connectライブラリー"

msgid ""
"{project_name} can be secured by supplied adapters that are usually easier "
"to use and provide better integration with {project_name}. However, if an "
"adapter is not available for your programming language, framework, or "
"platform you might opt to use a generic OpenID Connect Relying Party (RP) "
"library instead. This chapter describes details specific to {project_name} "
"and does not contain specific protocol details. For more information see the"
" https://openid.net/connect/[OpenID Connect specifications] and "
"https://datatracker.ietf.org/doc/html/rfc6749[OAuth2 specification]."
msgstr ""
"{project_name}は、使いやすくて、{project_name}と統合しやすい付属のアダプターにより、セキュリティー保護できます。ただし、使用するプログラミング言語、フレームワーク、プラットフォームでアダプターが使用できない場合は、代わりに一般的なOpenID"
" ConnectのRelying "
"Party（RP）ライブラリーを使用することができます。この章では、{project_name}固有のことについて詳細に説明しますが、特定のプロトコルの詳細については言及しません。詳細については、"
" https://openid.net/connect/[OpenID Connectの仕様] と "
"https://datatracker.ietf.org/doc/html/rfc6749[OAuth2の仕様] を参照してください。"

msgid "Endpoints"
msgstr "エンドポイント"

msgid ""
"The most important endpoint to understand is the `well-known` configuration "
"endpoint. It lists endpoints and other configuration options relevant to the"
" OpenID Connect implementation in {project_name}. The endpoint is:"
msgstr ""
"理解すべき最も重要なエンドポイントは、 `well-known` 設定エンドポイントです。これは、{project_name}のOpenID "
"Connectの実装に関連するエンドポイントとその他の設定オプションを一覧化します。エンドポイントは次のとおりです。"

msgid "/realms/{realm-name}/.well-known/openid-configuration"
msgstr "/realms/{realm-name}/.well-known/openid-configuration"

msgid ""
"To obtain the full URL, add the base URL for {project_name} and replace "
"`{realm-name}` with the name of your realm. For example:"
msgstr ""
"完全なURLを取得するには、{project_name}のベースURLを追加し、 `{realm-name}` "
"をレルム名で置換します。以下に例を示します。"

msgid ""
"\\http://localhost:8080{kc_realms_path}/master/.well-known/openid-"
"configuration"
msgstr ""
"\\http://localhost:8080{kc_realms_path}/master/.well-known/openid-"
"configuration"

msgid ""
"Some RP libraries retrieve all required endpoints from this endpoint, but "
"for others you might need to list the endpoints individually."
msgstr ""
"一部のRPライブラリーは、このエンドポイントから必要なすべてのエンドポイントを取得しますが、他はエンドポイントを個別に記載する必要があります。"

msgid "Authorization endpoint"
msgstr "認可エンドポイント"

msgid "/realms/{realm-name}/protocol/openid-connect/auth"
msgstr "/realms/{realm-name}/protocol/openid-connect/auth"

msgid ""
"The authorization endpoint performs authentication of the end-user. This is "
"done by redirecting the user agent to this endpoint."
msgstr ""
"認可エンドポイントは、エンドユーザーの認証を実行します。これは、ユーザー・エージェントをこのエンドポイントにリダイレクトすることによって行われます。"

msgid ""
"For more details see the https://openid.net/specs/openid-connect-"
"core-1_0.html#AuthorizationEndpoint[Authorization Endpoint] section in the "
"OpenID Connect specification."
msgstr ""
"詳細については、OpenID Connectの仕様の https://openid.net/specs/openid-connect-"
"core-1_0.html#AuthorizationEndpoint[Authorization Endpoint] を参照してください。"

msgid "Token endpoint"
msgstr "トークン・エンドポイント"

msgid "/realms/{realm-name}/protocol/openid-connect/token"
msgstr "/realms/{realm-name}/protocol/openid-connect/token"

msgid ""
"The token endpoint is used to obtain tokens. Tokens can either be obtained "
"by exchanging an authorization code or by supplying credentials directly "
"depending on what flow is used. The token endpoint is also used to obtain "
"new access tokens when they expire."
msgstr ""
"トークン・エンドポイントは、トークンを取得するために使用されます。トークンは、認可コードと交換するか、使用されているフロー次第ではクレデンシャルを直接指定することによって取得できます。トークン・エンドポイントは、有効期限が切れたときに新しいアクセス・トークンを取得するためにも使用されます。"

msgid ""
"For more details see the https://openid.net/specs/openid-connect-"
"core-1_0.html#TokenEndpoint[Token Endpoint] section in the OpenID Connect "
"specification."
msgstr ""
"詳細については、OpenID Connectの仕様の https://openid.net/specs/openid-connect-"
"core-1_0.html#TokenEndpoint[Token Endpoint] を参照してください。"

msgid "Userinfo endpoint"
msgstr "Userinfoエンドポイント"

msgid "/realms/{realm-name}/protocol/openid-connect/userinfo"
msgstr "/realms/{realm-name}/protocol/openid-connect/userinfo"

msgid ""
"The userinfo endpoint returns standard claims about the authenticated user, "
"and is protected by a bearer token."
msgstr "UserInfoエンドポイントは、認証されたユーザーに関する標準クレームを返します。また、ベアラー・トークンによって保護されています。"

msgid ""
"For more details see the https://openid.net/specs/openid-connect-"
"core-1_0.html#UserInfo[Userinfo Endpoint] section in the OpenID Connect "
"specification."
msgstr ""
"詳細については、OpenID Connectの仕様の https://openid.net/specs/openid-connect-"
"core-1_0.html#UserInfo[Userinfo Endpoint]を参照してください。"

msgid "Logout endpoint"
msgstr "ログアウト・エンドポイント"

msgid "/realms/{realm-name}/protocol/openid-connect/logout"
msgstr "/realms/{realm-name}/protocol/openid-connect/logout"

msgid "The logout endpoint logs out the authenticated user."
msgstr "ログアウト・エンドポイントは、認証されたユーザーをログアウトします。"

msgid ""
"The user agent can be redirected to the endpoint, in which case the active "
"user session is logged out. Afterward the user agent is redirected back to "
"the application."
msgstr ""
"ユーザー・エージェントはこのエンドポイントにリダイレクトされた場合、アクティブ・ユーザー・セッションはログアウトされます。その後、ユーザー・エージェントはアプリケーションにリダイレクトされます。"

msgid ""
"The endpoint can also be invoked directly by the application. To invoke this"
" endpoint directly the refresh token needs to be included as well as the "
"credentials required to authenticate the client."
msgstr ""
"エンドポイントは、アプリケーションによって直接呼び出すこともできます。このエンドポイントを直接呼び出すには、リフレッシュ・トークンと、クライアント認証に必要なクレデンシャルを含める必要があります。"

msgid "Certificate endpoint"
msgstr "証明書エンドポイント"

msgid "/realms/{realm-name}/protocol/openid-connect/certs"
msgstr "/realms/{realm-name}/protocol/openid-connect/certs"

msgid ""
"The certificate endpoint returns the public keys enabled by the realm, "
"encoded as a JSON Web Key (JWK). Depending on the realm settings there can "
"be one or more keys enabled for verifying tokens. For more information see "
"the link:{adminguide_link}[{adminguide_name}] and the "
"https://datatracker.ietf.org/doc/html/rfc7517[JSON Web Key specification]."
msgstr ""
"証明書エンドポイントは、JSON Web "
"Key（JWK）としてエンコードされ、レルムで有効化されている公開鍵を返します。レルム設定次第で、トークンを検証するために1つ以上のキーを有効にすることができます。詳細については、link:{adminguide_link}[{adminguide_name}]と"
" https://datatracker.ietf.org/doc/html/rfc7517[JSON Web Keyの仕様] を参照してください。"

msgid "Introspection endpoint"
msgstr "イントロスペクション・エンドポイント"

msgid "/realms/{realm-name}/protocol/openid-connect/token/introspect"
msgstr "/realms/{realm-name}/protocol/openid-connect/token/introspect"

msgid ""
"The introspection endpoint is used to retrieve the active state of a token. "
"In other words, you can use it to validate an access or refresh token. It "
"can only be invoked by confidential clients."
msgstr ""
"イントロスペクション・エンドポイントは、トークンのアクティブ状態を取得するために使用されます。言い換えると、アクセストークンやリフレッシュトークンの検証に使用できます。これはコンフィデンシャル・クライアントによってのみ呼び出すことができます。"

msgid ""
"For more details on how to invoke on this endpoint, see "
"https://datatracker.ietf.org/doc/html/rfc7662[OAuth 2.0 Token Introspection "
"specification]."
msgstr ""
"このエンドポイントで呼び出す方法の詳細については、 "
"https://datatracker.ietf.org/doc/html/rfc7662[OAuth 2.0 Token "
"Introspectionの仕様] を参照してください。"

msgid "Dynamic Client Registration endpoint"
msgstr "動的クライアント登録エンドポイント"

msgid "/realms/{realm-name}/clients-registrations/openid-connect"
msgstr "/realms/{realm-name}/clients-registrations/openid-connect"

msgid ""
"The dynamic client registration endpoint is used to dynamically register "
"clients."
msgstr "動的クライアント登録エンドポイントを使用して、クライアントを動的に登録します。"

msgid ""
"For more details see the <<_client_registration,Client Registration "
"chapter>> and the https://openid.net/specs/openid-connect-"
"registration-1_0.html[OpenID Connect Dynamic Client Registration "
"specification]."
msgstr ""
"詳細については、<<_client_registration,クライアントの登録の章>>と "
"https://openid.net/specs/openid-connect-registration-1_0.html[OpenID Connect"
" Dynamic Client Registrationの仕様] を参照してください。"

msgid "Token Revocation endpoint"
msgstr "トークン無効化エンドポイント"

msgid "/realms/{realm-name}/protocol/openid-connect/revoke"
msgstr "/realms/{realm-name}/protocol/openid-connect/revoke"

msgid ""
"The token revocation endpoint is used to revoke tokens. Both refresh tokens "
"and access tokens are supported by this endpoint."
msgstr ""
"トークン無効化エンドポイントは、トークンを無効化するために使用されます。このエンドポイントでは、リフレッシュトークンとアクセストークンの両方がサポートされています。"

msgid ""
"For more details on how to invoke on this endpoint, see "
"https://datatracker.ietf.org/doc/html/rfc7009[OAuth 2.0 Token Revocation "
"specification]."
msgstr ""
"このエンドポイントで呼び出す方法の詳細については、 "
"https://datatracker.ietf.org/doc/html/rfc7009[OAuth 2.0 Token Revocationの仕様]"
" を参照してください。"

msgid "Device Authorization endpoint"
msgstr "デバイス認可エンドポイント"

msgid "/realms/{realm-name}/protocol/openid-connectauth/device"
msgstr "/realms/{realm-name}/protocol/openid-connectauth/device"

msgid ""
"The device authorization endpoint is used to obtain a device code and a user"
" code. It can be invoked by confidential or public clients."
msgstr ""
"デバイス認可エンドポイントは、デバイスコードとユーザーコードを取得するために使用されます。コンフィデンシャル・クライアントまたはパブリック・クライアントが呼び出すことができます。"

msgid ""
"For more details on how to invoke on this endpoint, see "
"https://datatracker.ietf.org/doc/html/rfc8628[OAuth 2.0 Device Authorization"
" Grant specification]."
msgstr ""
"このエンドポイントで呼び出す方法の詳細については、 "
"https://datatracker.ietf.org/doc/html/rfc8628[OAuth 2.0 Device Authorization"
" Grantの仕様] を参照してください。"

msgid "Backchannel Authentication endpoint"
msgstr "バックチャネル認証エンドポイント"

msgid "/realms/{realm-name}/protocol/openid-connect/ext/ciba/auth"
msgstr "/realms/{realm-name}/protocol/openid-connect/ext/ciba/auth"

msgid ""
"The backchannel authentication endpoint is used to obtain an auth_req_id "
"that identifies the authentication request made by the client. It can only "
"be invoked by confidential clients."
msgstr ""
"バックチャネル認証エンドポイントは、クライアントによって行われた認証リクエストを識別するauth_req_idを取得するために使用されます。コンフィデンシャル・クライアントのみが呼び出すことができます。"

msgid ""
"For more details on how to invoke on this endpoint, see "
"https://openid.net/specs/openid-client-initiated-backchannel-authentication-"
"core-1_0.html[OpenID Connect Client Initiated Backchannel Authentication "
"Flow specification]."
msgstr ""
"このエンドポイントで呼び出す方法の詳細については、 https://openid.net/specs/openid-client-initiated-"
"backchannel-authentication-core-1_0.html[OpenID Connect Client Initiated "
"Backchannel Authentication Flow specification] を参照してください。"

msgid ""
"Also please refer to other places of {project_name} documentation like "
"<<_client_initiated_backchannel_authentication_grant,Client Initiated "
"Backchannel Authentication Grant section of this guide>> and "
"link:{adminguide_link}#_client_initiated_backchannel_authentication_grant[Client"
" Initiated Backchannel Authentication Grant section] of {adminguide_name}."
msgstr ""
"また、<<_client_initiated_backchannel_authentication_grant,このガイドのClient "
"Initiated Backchannel Authentication "
"Grantセクション>>などの{project_name}キュメントの他の場所と{adminguide_name}のlink:{adminguide_link}#_client_initiated_backchannel_authentication_grant[Client"
" Initiated Backchannel Authentication Grantのセクション]を参照してください。"

msgid "Validating access tokens"
msgstr "アクセストークンの検証"

msgid ""
"If you need to manually validate access tokens issued by {project_name} you "
"can invoke the <<_token_introspection_endpoint,Introspection Endpoint>>. The"
" downside to this approach is that you have to make a network invocation to "
"the {project_name} server.  This can be slow and possibly overload the "
"server if you have too many validation requests going on at the same time.  "
"{project_name} issued access tokens are "
"https://datatracker.ietf.org/doc/html/rfc7519[JSON Web Tokens (JWT)] "
"digitally signed and encoded using "
"https://datatracker.ietf.org/doc/html/rfc7515[JSON Web Signature (JWS)]. "
"Because they are encoded in this way, this allows you to locally validate "
"access tokens using the public key of the issuing realm.  You can either "
"hard code the realm's public key in your validation code, or lookup and "
"cache the public key using the <<_certificate_endpoint, certificate "
"endpoint>> with the Key ID (KID) embedded within the JWS.  Depending what "
"language you code in, there are a multitude of third party libraries out "
"there that can help you with JWS validation."
msgstr ""
"{project_name}によって発行されたアクセストークンを手動で検証する必要がある場合は、<<_token_introspection_endpoint,"
" "
"イントロスペクション・エンドポイント>>を呼び出すことができます。このアプローチの欠点は、{project_name}サーバーへのネットワーク呼び出しが必要であることです。これは、同時に実行される検証リクエストが多すぎると、サーバーの速度を低下させ、過剰な負荷をかかる可能性があります。{project_name}が発行したアクセストークンは"
" https://datatracker.ietf.org/doc/html/rfc7519[JSON Web Tokens（JWT）] であり、 "
"https://datatracker.ietf.org/doc/html/rfc7515[JSON Web Signature（JWS）] "
"によりデジタル署名されています。このようにエンコードされているため、発行したレルムの公開鍵を使用してアクセストークンをローカルで検証できます。レルムの公開鍵を検証コードにハードコードするか、<<_certificate_endpoint,"
" 証明書エンドポイント>>を使用してJWSに埋め込まれたKey "
"ID（KID）を使用して公開鍵を検索してキャッシュすることができます。コーディングする言語に応じて、JWS検証の手助けをするサードパーティー・ライブラリーが多数あります。"

msgid "Flows"
msgstr "フロー"

msgid "Authorization code"
msgstr "認可コード"

msgid ""
"The Authorization Code flow redirects the user agent to {project_name}. Once"
" the user has successfully authenticated with {project_name} an "
"Authorization Code is created and the user agent is redirected back to the "
"application. The application then uses the authorization code along with its"
" credentials to obtain an Access Token, Refresh Token and ID Token from "
"{project_name}."
msgstr ""
"認可コード・フローは、ユーザー・エージェントを{project_name}にリダイレクトします。ユーザーが{project_name}で正常に認証されると、認可コードが作成され、ユーザー・エージェントはアプリケーションにリダイレクトされます。次に、アプリケーションは、クレデンシャルとともに認可コードを使用して、{project_name}からアクセス・トークン、リフレッシュ・トークン、IDトークンを取得します。"

msgid ""
"The flow is targeted towards web applications, but is also recommended for "
"native applications, including mobile applications, where it is possible to "
"embed a user agent."
msgstr ""
"このフローはWebアプリケーションを対象としていますが、ユーザー・エージェントを組み込むことができるモバイルアプリケーションなどのネイティブアプリケーションにも推奨されます。"

msgid ""
"For more details refer to the https://openid.net/specs/openid-connect-"
"core-1_0.html#CodeFlowAuth[Authorization Code Flow] in the OpenID Connect "
"specification."
msgstr ""
"詳細については、OpenID Connectの仕様の https://openid.net/specs/openid-connect-"
"core-1_0.html#CodeFlowAuth[Authorization Code Flow] を参照してください。"

msgid "Implicit"
msgstr "インプリシット"

msgid ""
"The Implicit flow redirects works similarly to the Authorization Code flow, "
"but instead of returning an Authorization Code the Access Token and ID Token"
" is returned. This reduces the need for the extra invocation to exchange the"
" Authorization Code for an Access Token. However, it does not include a "
"Refresh Token. This results in the need to either permit Access Tokens with "
"a long expiration, which is problematic as it's very hard to invalidate "
"these. Or requires a new redirect to obtain new Access Token once the "
"initial Access Token has expired. The Implicit flow is useful if the "
"application only wants to authenticate the user and deals with logout "
"itself."
msgstr ""
"インプリシット・フローのリダイレクトは、認可コードフローと同様に機能しますが、認可コードが返される代わりに、アクセストークンとIDトークンが返されます。これにより、アクセストークンのために認可コードを交換するための余分な呼び出しの必要性が減ります。ただし、リフレッシュトークンは含まれません。その結果、長い有効期限を持つアクセストークンを許可する必要があります。これらのトークンを無効にするのは難しいため、問題があります。または、初期アクセストークンが期限切れになった場合は、新しいアクセス・トークンを取得するためにリダイレクトが必要です。インプリシット・フローは、アプリケーションがユーザーの認証のみを行い、自身でログアウトを処理する場合に便利です。"

msgid ""
"There's also a Hybrid flow where both the Access Token and an Authorization "
"Code is returned."
msgstr "アクセス・トークンと認可コードが返されるハイブリッド・フローもあります。"

msgid ""
"One thing to note is that both the Implicit flow and Hybrid flow has "
"potential security risks as the Access Token may be leaked through web "
"server logs and browser history. This is somewhat mitigated by using short "
"expiration for Access Tokens."
msgstr ""
"インプリシット・フローとハイブリッド・フローの両方で、Webサーバーのログとブラウザーの履歴を通じてアクセス・トークンが漏洩する可能性があるため、潜在的なセキュリティー上のリスクがあることに注意してください。これは、アクセス・トークンの有効期限を短くすることで多少緩和されます。"

msgid ""
"For more details refer to the https://openid.net/specs/openid-connect-"
"core-1_0.html#ImplicitFlowAuth[Implicit Flow] in the OpenID Connect "
"specification."
msgstr ""
"詳細については、OpenID Connectの仕様の https://openid.net/specs/openid-connect-"
"core-1_0.html#ImplicitFlowAuth[Implicit Flow] を参照してください。"

msgid "Resource Owner Password Credentials"
msgstr "リソース・オーナー・パスワード・クレデンシャル"

msgid ""
"Resource Owner Password Credentials, referred to as Direct Grant in "
"{project_name}, allows exchanging user credentials for tokens. It's not "
"recommended to use this flow unless you absolutely need to. Examples where "
"this could be useful are legacy applications and command-line interfaces."
msgstr ""
"リソース・オーナー・パスワード・クレデンシャル（{project_name}ではダイレクト・グラントと呼ばれます）は、ユーザー・クレデンシャルとトークンの交換を可能にします。絶対に必要としない限り、このフローを使用することはお勧めしません。これが有用な場合の例は、レガシー・アプリケーションとコマンドライン・インターフェイスです。"

msgid "There are a number of limitations of using this flow, including:"
msgstr "このフローの使用には次のような制限があります。"

msgid "User credentials are exposed to the application"
msgstr "ユーザーのクレデンシャルがアプリケーションに公開されます"

msgid "Applications need login pages"
msgstr "アプリケーションはログイン・ページが必要です"

msgid "Application needs to be aware of the authentication scheme"
msgstr "アプリケーションは認証方式を意識する必要があります"

msgid "Changes to authentication flow requires changes to application"
msgstr "認証フローを変更するには、アプリケーションを変更する必要があります"

msgid "No support for identity brokering or social login"
msgstr "アイデンティティー・ブローカリングまたはソーシャル・ログインはサポートされません"

msgid ""
"Flows are not supported (user self-registration, required actions, etc.)"
msgstr "フローはサポートされていません（ユーザーの自己登録、必須アクションなど）"

msgid ""
"For a client to be permitted to use the Resource Owner Password Credentials "
"grant the client has to have the `Direct Access Grants Enabled` option "
"enabled."
msgstr ""
"リソース・オーナー・パスワード・クレデンシャルの使用が許可されるためには、クライアントは `Direct Access Grants Enabled` "
"オプションを有効にする必要があります。"

msgid ""
"This flow is not included in OpenID Connect, but is a part of the OAuth 2.0 "
"specification."
msgstr "このフローはOpenID Connectには含まれていませんが、OAuth 2.0の仕様の一部です。"

msgid ""
"For more details refer to the "
"https://datatracker.ietf.org/doc/html/rfc6749#section-4.3[Resource Owner "
"Password Credentials Grant] chapter in the OAuth 2.0 specification."
msgstr ""
"詳細については、OAuth 2.0仕様の "
"https://datatracker.ietf.org/doc/html/rfc6749#section-4.3[Resource Owner "
"Password Credentials Grant] のセクションを参照してください。"

msgid "Example using CURL"
msgstr "CURLを使用した例"

msgid ""
"The following example shows how to obtain an access token for a user in the "
"realm `master` with username `user` and password `password`. The example is "
"using the confidential client `myclient`:"
msgstr ""
"次の例は、ユーザー名 `user` とパスワード `password` を使用して、 `master` "
"レルムにあるユーザーのアクセス・トークンを取得する方法を示しています。この例では、コンフィデンシャル・クライアント `myclient` "
"を使用しています。"

msgid ""
"curl \\\n"
"  -d \"client_id=myclient\" \\\n"
"  -d \"client_secret=40cc097b-2a57-4c17-b36a-8fdf3fc2d578\" \\\n"
"  -d \"username=user\" \\\n"
"  -d \"password=password\" \\\n"
"  -d \"grant_type=password\" \\\n"
"  \"http://localhost:8080{kc_realms_path}/master/protocol/openid-connect/token\""
msgstr ""
"curl \\\n"
"  -d \"client_id=myclient\" \\\n"
"  -d \"client_secret=40cc097b-2a57-4c17-b36a-8fdf3fc2d578\" \\\n"
"  -d \"username=user\" \\\n"
"  -d \"password=password\" \\\n"
"  -d \"grant_type=password\" \\\n"
"  \"http://localhost:8080{kc_realms_path}/master/protocol/openid-connect/token\""

msgid "Client credentials"
msgstr "クライアント・クレデンシャル"

msgid ""
"Client Credentials is used when clients (applications and services) wants to"
" obtain access on behalf of themselves rather than on behalf of a user. This"
" can for example be useful for background services that applies changes to "
"the system in general rather than for a specific user."
msgstr ""
"クライアント・クレデンシャルは、クライアント（アプリケーションおよびサービス）がユーザーの代わりにではなく、自分のためにアクセス権を取得したい場合に使用されます。これは、たとえば、特定のユーザーのためにではなく一般的にシステムに変更を適用するバックグラウンド・サービスに役立ちます。"

msgid ""
"{project_name} provides support for clients to authenticate either with a "
"secret or with public/private keys."
msgstr "{project_name}は、クライアントがシークレットまたは公開鍵/秘密鍵のいずれかで認証することをサポートします。"

msgid ""
"For more details refer to the "
"https://datatracker.ietf.org/doc/html/rfc6749#section-4.4[Client Credentials"
" Grant] chapter in the OAuth 2.0 specification."
msgstr ""
"詳細については、OAuth 2.0仕様の "
"https://datatracker.ietf.org/doc/html/rfc6749#section-4.4[Client Credentials"
" Grant] のセクションを参照してください。"

msgid "Device Authorization Grant"
msgstr "デバイス認可グラント"

msgid ""
"Device Authorization Grant is used by clients running on internet-connected "
"devices that have limited input capabilities or lack a suitable browser. The"
" application requests {project_name} a device code and a user code. "
"{project_name} creates a device code and a user code. {project_name} returns"
" a response including the device code and the user code to the application. "
"Then the application provides the user with the user code and the "
"verification URI. The user accesses a verification URI to be authenticated "
"by using another browser. The application repeatedly polls {project_name} "
"until {project_name} completes the user authorization. If user "
"authentication is complete, the application obtains the device code. Then "
"the application uses the device code along with its credentials to obtain an"
" Access Token, Refresh Token and ID Token from {project_name}."
msgstr ""
"デバイス認可グラントは、入力機能が制限されているか、適切なブラウザーがない、インターネットに接続されたデバイスで実行されているクライアントによって使用されます。アプリケーションは{project_name}にデバイスコードとユーザーコードを要求します。{project_name}は、デバイスコードとユーザーコードを作成します。{project_name}は、デバイスコードとユーザーコードを含むレスポンスをアプリケーションに返します。次に、アプリケーションはユーザーにユーザーコードと検証URIを提供します。ユーザーは、別のブラウザーを使用して、認証を受けるための検証URIにアクセスします。アプリケーションは、{project_name}がユーザーの認可を完了するまで、繰り返し{project_name}をポーリングします。ユーザーの認可が完了すると、アプリケーションはデバイスコードを取得します。次に、アプリケーションはデバイスコードとそのクレデンシャルを使用して、{project_name}からアクセストークン、リフレッシュトークン、およびIDトークンを取得します。"

msgid ""
"For more details refer to the "
"https://datatracker.ietf.org/doc/html/rfc8628[OAuth 2.0 Device Authorization"
" Grant specification]."
msgstr ""
"詳細については、 https://datatracker.ietf.org/doc/html/rfc8628[OAuth 2.0 Device "
"Authorization Grantの仕様] を参照してください。"

msgid "Client Initiated Backchannel Authentication Grant"
msgstr "Client Initiated Backchannel Authentication Grant"

msgid ""
"Client Initiated Backchannel Authentication Grant is used by clients who "
"want to initiate the authentication flow by communicating with the OpenID "
"Provider directly without redirect through the user's browser like OAuth "
"2.0's authorization code grant."
msgstr ""
"クライアント起点バックチャネル認証グラントは、OAuth "
"2.0の認証コードグラントのように、ユーザーのブラウザーを介してリダイレクトせずに、OpenIDプロバイダーと直接通信することによって認証フローを開始したいクライアントによって使用されます。"

msgid ""
"The client requests {project_name} an auth_req_id that identifies the "
"authentication request made by the client. {project_name} creates the "
"auth_req_id."
msgstr ""
"クライアントは、クライアントによって行われた認証リクエストを識別するauth_req_idを{project_name}に要求します。{project_name}はauth_req_idを作成します。"

msgid ""
"After receiving this auth_req_id, this client repeatedly needs to poll "
"{project_name} to obtain an Access Token, Refresh Token and ID Token from "
"{project_name} in return for the auth_req_id until the user is "
"authenticated."
msgstr ""
"このauth_req_idを受信した後、このクライアントは{project_name}を繰り返しポーリングして、ユーザーが認証されるまでauth_req_idと引き換えに{project_name}からアクセストークン、リフレッシュトークン、IDトークンを取得する必要があります。"

msgid ""
"In case that client uses `ping` mode, it does not need to repeatedly poll "
"the token endpoint, but it can wait for the notification sent by "
"{project_name} to the specified Client Notification Endpoint. The Client "
"Notification Endpoint can be configured in the {project_name} Admin Console."
" The details of the contract for Client Notification Endpoint are described "
"in the CIBA specification."
msgstr ""
"`ping` "
"モードを使用している場合、クライアントはトークン・エンドポイントを繰り返しポーリングする必要はありませんが、指定されたクライアント通知エンドポイントに{project_name}が通知が送信するのを待つことができます。クライアント通知エンドポイントは、{project_name}の管理コンソールで設定することができます。クライアント通知エンドポイントの決まりごとの詳細については、CIBA仕様書に記載されています。"

msgid ""
"For more details refer to https://openid.net/specs/openid-client-initiated-"
"backchannel-authentication-core-1_0.html[OpenID Connect Client Initiated "
"Backchannel Authentication Flow specification]."
msgstr ""
"詳細については、 https://openid.net/specs/openid-client-initiated-backchannel-"
"authentication-core-1_0.html[OpenID Connect Client Initiated Backchannel "
"Authentication Flow specification] を参照してください。"

msgid ""
"Also please refer to other places of {project_name} documentation like "
"<<_backchannel_authentication_endpoint,Backchannel Authentication Endpoint "
"of this guide>> and "
"link:{adminguide_link}#_client_initiated_backchannel_authentication_grant[Client"
" Initiated Backchannel Authentication Grant section] of {adminguide_name}. "
"For the details about FAPI CIBA compliance, please refer to the <<_fapi-"
"support,FAPI section of this guide>>."
msgstr ""
"また、<<_backchannel_authentication_endpoint,このガイドのBackchannel Authentication "
"Endpoint>>や{adminguide_name}の "
"link:{adminguide_link}#_client_initiated_backchannel_authentication_grant[Client"
" Initiated Backchannel Authentication Grantのセクション] "
"など、{project_name}ドキュメントの他の箇所も参照してください。FAPI CIBA対応については、本ガイドの<<_fapi-"
"support,FAPIセクション>>を参照してください。"

msgid "Redirect URIs"
msgstr "リダイレクトURI"

msgid ""
"When using the redirect based flows it's important to use valid redirect "
"uris for your clients. The redirect uris should be as specific as possible. "
"This especially applies to client-side (public clients) applications. "
"Failing to do so could result in:"
msgstr ""
"リダイレクト・ベースのフローを使用する場合は、クライアントで有効なリダイレクトURLを使用することが重要です。リダイレクトURLはできるだけ具体的にする必要があります。これは、特にクライアント・サイド（パブリック・クライアント）のアプリケーションに適用されます。そうしないと次のことが起こる可能性があります。"

msgid ""
"Open redirects - this can allow attackers to create spoof links that looks "
"like they are coming from your domain"
msgstr "オープン・リダイレクト - これにより、攻撃者はあなたのドメインでできている偽のリンクを作成することができます"

msgid ""
"Unauthorized entry - when users are already authenticated with "
"{project_name} an attacker can use a public client where redirect uris have "
"not be configured correctly to gain access by redirecting the user without "
"the users knowledge"
msgstr ""
"不正侵入 - "
"ユーザーが{project_name}ですでに認証済みの場合、攻撃者はリダイレクトURLが正しく設定されていない公開クライアントを使用し、ユーザーを知らないうちにリダイレクトさせることで、アクセス権を得ます"

msgid ""
"In production for web applications always use `https` for all redirect URIs."
" Do not allow redirects to http."
msgstr ""
"Webアプリケーション用のプロダクション環境では、常にすべてのリダイレクトURIに `https` "
"を使用します。httpへのリダイレクトは許可しないでください。"

msgid "There's also a few special redirect URIs:"
msgstr "また、次のような特別なリダイレクトURIがいくつかあります。"

msgid "`$$http://localhost$$`"
msgstr "`$$http://localhost$$`"

msgid ""
"This redirect URI is useful for native applications and allows the native "
"application to create a web server on a random port that can be used to "
"obtain the authorization code. This redirect uri allows any port."
msgstr ""
"このリダイレクトURIはネイティブ・アプリケーションに役立ちます。ネイティブ・アプリケーションが認可コードを取得するために、ランダムなポート上にWebサーバーを作成することを許可します。このリダイレクトURIは任意のポートを許可します。"

msgid "`urn:ietf:wg:oauth:2.0:oob`"
msgstr "`urn:ietf:wg:oauth:2.0:oob`"

msgid ""
"If its not possible to start a web server in the client (or a browser is not"
" available) it is possible to use the special `urn:ietf:wg:oauth:2.0:oob` "
"redirect uri. When this redirect uri is used {project_name} displays a page "
"with the code in the title and in a box on the page. The application can "
"either detect that the browser title has changed, or the user can copy/paste"
" the code manually to the application. With this redirect uri it is also "
"possible for a user to use a different device to obtain a code to paste back"
" to the application."
msgstr ""
"クライアントでWebサーバーを起動できない（またはブラウザーが利用できない）場合は、特殊な `urn:ietf:wg:oauth:2.0:oob` "
"リダイレクトURIを使用することができます。このリダイレクトURIが使用されると、{project_name}は認可コードをページのタイトルとボックスに含めたページを表示します。アプリケーションがブラウザーのタイトルが変更されたことを検出するか、ユーザーが手動でコードをアプリケーションにコピー/ペーストすることができます。このリダイレクトURIを使用すると、ユーザーが別のデバイスを使用してアプリケーションに貼り付けるコードを取得することもできます。"

msgid "Financial-grade API (FAPI) Support"
msgstr "Financial-grade API（FAPI）のサポート"

msgid ""
"{project_name} makes it easier for administrators to make sure that their "
"clients are compliant with these specifications:"
msgstr "{project_name}を使用することで、管理者はクライアントがこれらの仕様に準拠していることを容易に確認することができます。"

msgid ""
"https://openid.net/specs/openid-financial-api-part-1-1_0.html[Financial-"
"grade API Security Profile 1.0 - Part 1: Baseline]"
msgstr ""
"https://openid.net/specs/openid-financial-api-part-1-1_0.html[Financial-"
"grade API Security Profile 1.0 - Part 1: Baseline]"

msgid ""
"https://openid.net/specs/openid-financial-api-part-2-1_0.html[Financial-"
"grade API Security Profile 1.0 - Part 2: Advanced]"
msgstr ""
"https://openid.net/specs/openid-financial-api-part-2-1_0.html[Financial-"
"grade API Security Profile 1.0 - Part 2: Advanced]"

msgid ""
"https://openid.net/specs/openid-financial-api-ciba-ID1.html[Financial-grade "
"API: Client Initiated Backchannel Authentication Profile] (FAPI CIBA)"
msgstr ""
"https://openid.net/specs/openid-financial-api-ciba-ID1.html[Financial-grade "
"API: Client Initiated Backchannel Authentication Profile] (FAPI CIBA)"

msgid ""
"This compliance means that the {project_name} server will verify the "
"requirements for the authorization server, which are mentioned in the "
"specifications. {project_name} adapters do not have any specific support for"
" the FAPI, hence the required validations on the client (application) side "
"may need to be still done manually or through some other third-party "
"solutions."
msgstr ""
"この準拠は、{project_name}サーバーが仕様書に記載されている認可サーバの要件を検証することを意味します。{project_name}のアダプターはFAPIを特にサポートしていないので、クライアント（アプリケーション）側で必要な検証は、手動または他のサードパーティ・ソリューションを通じて行う必要があるかもしれません。"

msgid "FAPI client profiles"
msgstr "FAPIクライアント・プロファイル"

msgid ""
"To make sure that your clients are FAPI compliant, you can configure Client "
"Policies in your realm as described in the "
"link:{adminguide_link}#_client_policies[{adminguide_name}] and link them to "
"the global client profiles for FAPI support, which are automatically "
"available in each realm. You can use either `fapi-1-baseline` or "
"`fapi-1-advanced` profile based on which FAPI profile you need your clients "
"to conform with."
msgstr ""
"クライアントがFAPIに準拠していることを確認するには、 "
"link:{adminguide_link}#_client_policies[{adminguide_name}] "
"で説明されているように、レルムでクライアント・ポリシーを設定し、それらをFAPIサポートのグローバル・クライアント・プロファイルにリンクします。これは各レルムで自動的に利用可能になります。クライアントが準拠する必要のあるFAPIプロファイルに基づいて、"
" `fapi-1-baseline` または `fapi-1-advanced` プロファイルのいずれかを使用できます。"

msgid ""
"In case you want to use link:{adminguide_link}#_oidc_clients[Pushed "
"Authorization Request (PAR)], it is recommended that your client use both "
"the `fapi-1-baseline` profile and `fapi-1-advanced` for PAR requests. "
"Specifically, the `fapi-1-baseline` profile contains `pkce-enforcer` "
"executor, which makes sure that client use PKCE with secured S256 algorithm."
" This is not required for FAPI Advanced clients unless they use PAR "
"requests."
msgstr ""
"link:{adminguide_link}#_oidc_clients[Pushed Authorization Request（PAR）] "
"を使いたい場合、クライアントはPARリクエストに対して `fapi-1-baseline` プロファイルと `fapi-1-advanced` "
"プロファイルの両方を使用することが推奨されます。特に、`fapi-1-baseline` プロファイルは `pkce-enforcer` "
"Executorを含んでおり、クライアントが安全なS256アルゴリズムのPKCEを使用することを確認します。FAPI "
"Advancedクライアントの場合、PARリクエストを使用しない限り、これは必要ありません。"

msgid ""
"In case you want to use <<_backchannel_authentication_endpoint,CIBA>> in a "
"FAPI compliant way, make sure that your clients use both `fapi-1-advanced` "
"and `fapi-ciba` client profiles. There is a need to use the "
"`fapi-1-advanced` profile, or other client profile containing the requested "
"executors, as the `fapi-ciba` profile contains just CIBA-specific executors."
" When enforcing the requirements of the FAPI CIBA specification, there is a "
"need for more requirements, such as enforcement of confidential clients or "
"certificate-bound access tokens."
msgstr ""
"FAPIに準拠した方法で<<_backchannel_authentication_endpoint,CIBA>>を使用したい場合、クライアントが "
"`fapi-1-advanced` と `fapi-ciba` の両方のクライアント・プロファイルを使用していることを確認してください。 `fapi-"
"ciba` プロファイルはCIBA固有のExecutorだけを含んでいるので、 `fapi-1-advanced` "
"プロファイルか、要求されたExecutorを含む他のクライアント・プロファイルを使用する必要があります。FAPI "
"CIBA仕様の要件を強制する場合、コンフィデンシャル・クライアントの強制や証明書バウンドのアクセストークンなど、より多くの要件が必要です。"

msgid "Open Banking Brasil Financial-grade API Security Profile"
msgstr "Open Banking Brasil Financial-grade API Security Profile"

msgid ""
"{project_name} is compliant with the https://openbanking-"
"brasil.github.io/specs-seguranca/open-banking-brasil-dynamic-client-"
"registration-1_ID2-ptbr.html[Open Banking Brasil Financial-grade API "
"Security Profile 1.0 Implementers Draft 2]. This one is more strict in some "
"requirements than the <<_fapi-support,FAPI 1 Advanced>> specification and "
"hence it may be needed to configure "
"link:{adminguide_link}#_client_policies[Client Policies] in the more strict "
"way to enforce some of the requirements. Especially:"
msgstr ""
"{project_name}は、 https://openbanking-brasil.github.io/specs-seguranca/open-"
"banking-brasil-dynamic-client-registration-1_ID2-ptbr.html[Open Banking "
"Brasil Financial-grade API Security Profile 1.0 Implementers Draft 1] "
"に準拠しています。これは<<_fapi-support,FAPI 1 "
"Advanced>>仕様よりもいくつかの要件が厳しく、したがって、いくつかの要件を強制するために、より厳しい方法で "
"link:{adminguide_link}#_client_policies[クライアント・ポリシー] "
"を構成する必要があるかもしれません。特に、以下の部分です。"

msgid ""
"If your client does not use PAR, make sure that it uses encrypted OIDC "
"request objects. This can be achieved by using a client profile with the "
"`secure-request-object` executor configured with `Encryption Required` "
"enabled."
msgstr ""
"クライアントがPARを使用しない場合、暗号化されたOIDCリクエストオブジェクトを使用することを確認してください。これは `secure-"
"request-object` Executorで `Encryption Required` "
"を有効に設定したクライアント・プロファイルを使用することで実現可能です。"

msgid ""
"Make sure that for JWS, the client uses the `PS256` algorithm. For JWE, the "
"client should use the `RSA-OAEP` with `A256GCM`. This may need to be set in "
"all the link:{adminguide_link}#_oidc_clients[Client Settings] where these "
"algorithms are applicable."
msgstr ""
"JWSの場合、クライアントが `PS256` アルゴリズムを使用していることを確認してください。JWEの場合、クライアントは `RSA-OAEP` と "
"`A256GCM` を使用する必要があります。この設定は、これらのアルゴリズムが適用されるすべての "
"link:{adminguide_link}#_oidc_clients[Client Settings]で行う必要があるかもしれません。"

msgid "TLS considerations"
msgstr "TLSに関する考慮事項"

msgid ""
"As confidential information is being exchanged, all interactions shall be "
"encrypted with TLS (HTTPS). Moreover, there are some requirements in the "
"FAPI specification for the cipher suites and TLS protocol versions used. To "
"match these requirements, you can consider configure allowed ciphers. This "
"configuration can be done in the "
"`KEYCLOAK_HOME/standalone/configuration/standalone-*.xml` file in the "
"Elytron subsystem. For example this element can be added under `tls` -> "
"`server-ssl-contexts`"
msgstr ""
"機密情報が交換されるため、すべてのやり取りはTLS（HTTPS）で暗号化される必要があります。さらに、使用される暗号スイートとTLSプロトコルのバージョンに対してFAPI仕様にはいくつかの要件があります。これらの要件を満たすために、許可された暗号の設定を検討できます。この設定は、Elytronサブシステムの"
" `KEYCLOAK_HOME/standalone/configuration/standalone-*.xml` "
"ファイルで行うことができます。たとえば、この要素は `tls` -> `server-ssl-contexts` の下に追加できます。"

msgid ""
"<server-ssl-context name=\"kcSSLContext\" want-client-auth=\"true\" protocols=\"TLSv1.2\" \\\n"
"key-manager=\"kcKeyManager\" trust-manager=\"kcTrustManager\" \\\n"
"cipher-suite-filter=\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,TLS_DHE_RSA_WITH_AES_256_GCM_SHA384\" protocols=\"TLSv1.2\" />"
msgstr ""
"<server-ssl-context name=\"kcSSLContext\" want-client-auth=\"true\" protocols=\"TLSv1.2\" \\\n"
"key-manager=\"kcKeyManager\" trust-manager=\"kcTrustManager\" \\\n"
"cipher-suite-filter=\"TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_DHE_RSA_WITH_AES_128_GCM_SHA256,TLS_DHE_RSA_WITH_AES_256_GCM_SHA384\" protocols=\"TLSv1.2\" />"

msgid ""
"The references to `kcKeyManager` and `kcTrustManager` refers to the "
"corresponding Keystore and Truststore. See the documentation of Wildfly "
"Elytron subsystem for more details and also other parts of {project_name} "
"documentation such as link:{installguide_link}#_network[Network Setup "
"Section] or link:{adminguide_link}#_x509[X.509 Authentication Section]."
msgstr ""
"`kcKeyManager` と `kcTrustManager` "
"への参照は、対応するキーストアとトラストストアを参照します。詳細については、Wildfly "
"Elytronサブシステムのドキュメントを参照してください。また、 "
"link:{installguide_link}#_network[ネットワークのセットアップのセクション]] や "
"link:{adminguide_link}#_x509[X.509認証のセクション] "
"などの{project_name}ドキュメントの他の部分も参照してください。"

msgid "Using SAML to secure applications and services"
msgstr "SAMLを使用してアプリケーションとサービスをセキュリティー保護する"

msgid ""
"This section describes how you can secure applications and services with "
"SAML using either {project_name} client adapters or generic SAML provider "
"libraries."
msgstr ""
"このセクションでは、{project_name}クライアント・アダプターまたは汎用SAMLプロバイダー・ライブラリーのいずれかを使用して、アプリケーションとサービスをSAMLでセキュリティー保護する方法について説明します。"

msgid "General Adapter Config"
msgstr "共通アダプター設定"

msgid ""
"Each SAML client adapter supported by {project_name} can be configured by a "
"simple XML text file. This is what one might look like:"
msgstr ""
"{project_name}でサポートされているSAMLクライアント・アダプターは、いずれも簡単なXMLテキストファイルで設定できます。これは以下のようなものです。"

msgid ""
"<keycloak-saml-adapter xmlns=\"urn:keycloak:saml:adapter\"\n"
"                       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"                       xsi:schemaLocation=\"urn:keycloak:saml:adapter {saml_adapter_xsd_urn}\">\n"
"    <SP entityID=\"http://localhost:8081/sales-post-sig/\"\n"
"        sslPolicy=\"EXTERNAL\"\n"
"        nameIDPolicyFormat=\"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\"\n"
"        logoutPage=\"/logout.jsp\"\n"
"        forceAuthentication=\"false\"\n"
"        isPassive=\"false\"\n"
"        turnOffChangeSessionIdOnLogin=\"false\"\n"
"        autodetectBearerOnly=\"false\">\n"
"        <Keys>\n"
"            <Key signing=\"true\" >\n"
"                <KeyStore resource=\"/WEB-INF/keystore.jks\" password=\"store123\">\n"
"                    <PrivateKey alias=\"http://localhost:8080/sales-post-sig/\" password=\"test123\"/>\n"
"                    <Certificate alias=\"http://localhost:8080/sales-post-sig/\"/>\n"
"                </KeyStore>\n"
"            </Key>\n"
"        </Keys>\n"
"        <PrincipalNameMapping policy=\"FROM_NAME_ID\"/>\n"
"        <RoleIdentifiers>\n"
"            <Attribute name=\"Role\"/>\n"
"        </RoleIdentifiers>\n"
"        <RoleMappingsProvider id=\"properties-based-role-mapper\">\n"
"            <Property name=\"properties.resource.location\" value=\"/WEB-INF/role-mappings.properties\"/>\n"
"        </RoleMappingsProvider>\n"
"        <IDP entityID=\"idp\"\n"
"             signaturesRequired=\"true\">\n"
"        <SingleSignOnService requestBinding=\"POST\"\n"
"                             bindingUrl=\"http://localhost:8081{kc_realms_path}/demo/protocol/saml\"\n"
"                    />\n"
"\n"
"            <SingleLogoutService\n"
"                    requestBinding=\"POST\"\n"
"                    responseBinding=\"POST\"\n"
"                    postBindingUrl=\"http://localhost:8081{kc_realms_path}/demo/protocol/saml\"\n"
"                    redirectBindingUrl=\"http://localhost:8081{kc_realms_path}/demo/protocol/saml\"\n"
"                    />\n"
"            <Keys>\n"
"                <Key signing=\"true\">\n"
"                    <KeyStore resource=\"/WEB-INF/keystore.jks\" password=\"store123\">\n"
"                        <Certificate alias=\"demo\"/>\n"
"                    </KeyStore>\n"
"                </Key>\n"
"            </Keys>\n"
"        </IDP>\n"
"     </SP>\n"
"</keycloak-saml-adapter>"
msgstr ""
"<keycloak-saml-adapter xmlns=\"urn:keycloak:saml:adapter\"\n"
"                       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"                       xsi:schemaLocation=\"urn:keycloak:saml:adapter {saml_adapter_xsd_urn}\">\n"
"    <SP entityID=\"http://localhost:8081/sales-post-sig/\"\n"
"        sslPolicy=\"EXTERNAL\"\n"
"        nameIDPolicyFormat=\"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\"\n"
"        logoutPage=\"/logout.jsp\"\n"
"        forceAuthentication=\"false\"\n"
"        isPassive=\"false\"\n"
"        turnOffChangeSessionIdOnLogin=\"false\"\n"
"        autodetectBearerOnly=\"false\">\n"
"        <Keys>\n"
"            <Key signing=\"true\" >\n"
"                <KeyStore resource=\"/WEB-INF/keystore.jks\" password=\"store123\">\n"
"                    <PrivateKey alias=\"http://localhost:8080/sales-post-sig/\" password=\"test123\"/>\n"
"                    <Certificate alias=\"http://localhost:8080/sales-post-sig/\"/>\n"
"                </KeyStore>\n"
"            </Key>\n"
"        </Keys>\n"
"        <PrincipalNameMapping policy=\"FROM_NAME_ID\"/>\n"
"        <RoleIdentifiers>\n"
"            <Attribute name=\"Role\"/>\n"
"        </RoleIdentifiers>\n"
"        <RoleMappingsProvider id=\"properties-based-role-mapper\">\n"
"            <Property name=\"properties.resource.location\" value=\"/WEB-INF/role-mappings.properties\"/>\n"
"        </RoleMappingsProvider>\n"
"        <IDP entityID=\"idp\"\n"
"             signaturesRequired=\"true\">\n"
"        <SingleSignOnService requestBinding=\"POST\"\n"
"                             bindingUrl=\"http://localhost:8081{kc_realms_path}/demo/protocol/saml\"\n"
"                    />\n"
"\n"
"            <SingleLogoutService\n"
"                    requestBinding=\"POST\"\n"
"                    responseBinding=\"POST\"\n"
"                    postBindingUrl=\"http://localhost:8081{kc_realms_path}/demo/protocol/saml\"\n"
"                    redirectBindingUrl=\"http://localhost:8081{kc_realms_path}/demo/protocol/saml\"\n"
"                    />\n"
"            <Keys>\n"
"                <Key signing=\"true\">\n"
"                    <KeyStore resource=\"/WEB-INF/keystore.jks\" password=\"store123\">\n"
"                        <Certificate alias=\"demo\"/>\n"
"                    </KeyStore>\n"
"                </Key>\n"
"            </Keys>\n"
"        </IDP>\n"
"     </SP>\n"
"</keycloak-saml-adapter>"

msgid ""
"Some of these configuration switches may be adapter specific and some are "
"common across all adapters. For Java adapters you can use `${...}` enclosure"
" as System property replacement. For example `${jboss.server.config.dir}`."
msgstr ""
"これらの設定の中には、アダプター固有のものもあれば、すべてのアダプターに共通のものもあります。Javaアダプターの場合は、システム・プロパティーの置換に"
" `${...}`  エンクロージャーを使用できます。 たとえば、 `${jboss.server.config.dir}` です。"

msgid "SP element"
msgstr "SP要素"

msgid "Here is the explanation of the SP element attributes:"
msgstr "ここでは、SP要素の属性の説明をします。"

msgid ""
"\n"
"<SP entityID=\"sp\"\n"
"    sslPolicy=\"ssl\"\n"
"    nameIDPolicyFormat=\"format\"\n"
"    forceAuthentication=\"true\"\n"
"    isPassive=\"false\"\n"
"    keepDOMAssertion=\"true\"\n"
"    autodetectBearerOnly=\"false\">\n"
"...\n"
"</SP>"
msgstr ""
"\n"
"<SP entityID=\"sp\"\n"
"    sslPolicy=\"ssl\"\n"
"    nameIDPolicyFormat=\"format\"\n"
"    forceAuthentication=\"true\"\n"
"    isPassive=\"false\"\n"
"    keepDOMAssertion=\"true\"\n"
"    autodetectBearerOnly=\"false\">\n"
"...\n"
"</SP>"

msgid "entityID"
msgstr "entityID"

msgid ""
"This is the identifier for this client. The IdP needs this value to "
"determine who the client is that is communicating with it. This setting is "
"_REQUIRED_."
msgstr ""
"このクライアントの識別子です。IdPは、IdPと通信しているクライアントを特定するため、この値を必要とします。この設定は、_REQUIRED_ です。"

msgid "sslPolicy"
msgstr "sslPolicy"

msgid ""
"This is the SSL policy the adapter will enforce. Valid values are: `ALL`, "
"`EXTERNAL`, and `NONE`. For `ALL`, all requests must come in via HTTPS. For "
"`EXTERNAL`, only non-private IP addresses must come over the wire via HTTPS."
" For `NONE`, no requests are required to come over via HTTPS. This setting "
"is _OPTIONAL_. Default value is `EXTERNAL`."
msgstr ""
"これは、アダプターが実施するSSLポリシーです。有効な値は `ALL` 、 `EXTERNAL` 、 `NONE` です。 `ALL` "
"の場合、すべてのリクエストはHTTPSを経由しなければなりません。 `EXTERNAL` "
"の場合、非プライベートIPアドレスだけがHTTPSを経由しなければなりません。 `NONE` "
"の場合、HTTPS経由であることは要求されません。この設定は _OPTIONAL_ です。デフォルト値は `EXTERNAL` です。"

msgid "nameIDPolicyFormat"
msgstr "nameIDPolicyFormat"

msgid ""
"SAML clients can request a specific NameID Subject format. Fill in this "
"value if you want a specific format. It must be a standard SAML format "
"identifier: `urn:oasis:names:tc:SAML:2.0:nameid-format:transient`. This "
"setting is _OPTIONAL_. By default, no special format is requested."
msgstr ""
"SAMLクライアントは、特定のNameID "
"Subject形式を要求できます。特定の書式が必要な場合は、この値を入力します。これは標準のSAML形式の識別子である "
"`urn:oasis:names:tc:SAML:2.0:nameid-format:transient` でなければなりません。この設定は "
"_OPTIONAL_ です。デフォルトでは、特別な形式は要求されません。"

msgid "forceAuthentication"
msgstr "forceAuthentication"

msgid ""
"SAML clients can request that a user is re-authenticated even if they are "
"already logged in at the IdP. Set this to `true` to enable. This setting is "
"_OPTIONAL_. Default value is `false`."
msgstr ""
"SAMLクライアントは、すでにIdPにログインしていても、ユーザーが再認証されるように要求できます。有効にするには、これを `true` "
"に設定します。この設定は _OPTIONAL_ です。デフォルト値は `false` です。"

msgid "isPassive"
msgstr "isPassive"

msgid ""
"SAML clients can request that a user is never asked to authenticate even if "
"they are not logged in at the IdP. Set this to `true` if you want this. Do "
"not use together with `forceAuthentication` as they are opposite. This "
"setting is _OPTIONAL_. Default value is `false`."
msgstr ""
"SAMLクライアントは、IdPにログインしていなくても、ユーザーに認証を要求しないようにすることができます。その場合は、 `true` "
"に設定してください。 `forceAuthentication` と反対の設定なため一緒に使用しないでください。この設定は _OPTIONAL_ "
"です。デフォルト値は `false` です。"

msgid "turnOffChangeSessionIdOnLogin"
msgstr "turnOffChangeSessionIdOnLogin"

msgid ""
"The session ID is changed by default on a successful login on some platforms"
" to plug a security attack vector. Change this to `true` to disable this.  "
"It is recommended you do not turn it off. Default value is `false`."
msgstr ""
"セッションIDは、セキュリティー攻撃口とならないように、一部のプラットフォームで正常にログインするとデフォルトで変更されます。これを無効にするには、 "
"`true` に変更してください。これは無効にしないことをお勧めします。デフォルト値は `false` です。"

msgid "autodetectBearerOnly"
msgstr "autodetectBearerOnly"

msgid "logoutPage"
msgstr "logoutPage"

msgid ""
"This sets the page to display after logout. If the page is a full URL, such "
"as `http://web.example.com/logout.html`, the user is redirected after logout"
" to that page using the HTTP `302` status code. If a link without scheme "
"part is specified, such as `/logout.jsp`, the page is displayed after "
"logout, _regardless of whether it lies in a protected area according to "
"`security-constraint` declarations in web.xml_, and the page is resolved "
"relative to the deployment context root."
msgstr ""
"これは、ログアウト後に表示するページを設定します。ページが `http://web.example.com/logout.html` "
"のような完全なURLである場合、ログアウトすると、HTTP `302` ステータスコードを使用してそのページにリダイレクトされます。 "
"`/logout.jsp` のようなスキーム部分を持たないリンクが指定された場合、 _web.xmlの `security-constraint` "
"宣言に従って保護されたレルムにあるかどうかに関わらず、_ "
"ログアウト後にそのページが表示されます。このページは、デプロイメント・コンテキスト・ルートに関連して解決されます。"

msgid "keepDOMAssertion"
msgstr "keepDOMAssertion"

msgid ""
"This attribute should be set to __true__ to make the adapter store the DOM "
"representation of the assertion in its original form inside the "
"`SamlPrincipal` associated to the request. The assertion document can be "
"retrieved using the method `getAssertionDocument` inside the principal. This"
" is specially useful when re-playing a signed assertion. The returned "
"document is the one that was generated parsing the SAML response received by"
" the {project_name} server. This setting is _OPTIONAL_ and its default value"
" is __false__ (the document is not saved inside the principal)."
msgstr ""
"アダプターにアサーションのDOM表現を、リクエストに関連付けられた `SamlPrincipal` 内に元の形式で保存させるには、この属性を "
"__true__ に設定する必要があります。アサーション・ドキュメントは、プリンシパル内のメソッド `getAssertionDocument` "
"を使用して取得できます。これは、署名されたアサーションを再生するときに特に便利です。返されるドキュメントは、{project_name}サーバーが受信したSAMLレスポンスを解析して生成されたドキュメントです。この設定は"
" _OPTIONAL_ で、デフォルト値は __false__ です（ドキュメントはプリンシパル内に保存されません）。"

msgid "Service Provider keys and key elements"
msgstr "サービス・プロバイダーのkeysとkey要素"

msgid ""
"If the IdP requires that the client application (or SP) sign all of its "
"requests and/or if the IdP will encrypt assertions, you must define the keys"
" used to do this. For client-signed documents you must define both the "
"private and public key or certificate that is used to sign documents. For "
"encryption, you only have to define the private key that is used to decrypt "
"it."
msgstr ""
"IdPがクライアント・アプリケーション（またはSP）に対してすべてのリクエストに署名することを要求する場合や、IdPがアサーションを暗号化する場合は、それを行うために使用する鍵を定義する必要があります。クライアント署名ドキュメントの場合、署名に使用される秘密鍵と公開鍵、または証明書の両方を定義する必要があります。暗号化の場合、復号化に使用される秘密鍵を定義するだけで済みます。"

msgid ""
"There are two ways to describe your keys. They can be stored within a Java "
"KeyStore or you can copy/paste the keys directly within `keycloak-saml.xml` "
"in the PEM format."
msgstr ""
"鍵を記述する方法は2つあります。Javaキーストア内に格納するか、PEM 形式で `keycloak-saml.xml` "
"内に直接コピー/ペーストできます。"

msgid ""
"\n"
"        <Keys>\n"
"            <Key signing=\"true\" >\n"
"               ...\n"
"            </Key>\n"
"        </Keys>"
msgstr ""
"\n"
"        <Keys>\n"
"            <Key signing=\"true\" >\n"
"               ...\n"
"            </Key>\n"
"        </Keys>"

msgid ""
"The `Key` element has two optional attributes `signing` and `encryption`. "
"When set to true these tell the adapter what the key will be used for. If "
"both attributes are set to true, then the key will be used for both signing "
"documents and decrypting encrypted assertions. You must set at least one of "
"these attributes to true."
msgstr ""
"`Key` 要素には、2つの省略可能な属性 `signing` と `encryption` があります。 "
"これらをtrueに設定すると、アダプターはどの鍵を使用するか決定します。 "
"両方の属性がtrueに設定される場合は、ドキュメントの署名と暗号化されたアサーションの復号化の両方に鍵が使用されます。これらの属性の少なくとも1つはtrueに設定する必要があります。"

msgid "KeyStore element"
msgstr "KeyStore要素"

msgid ""
"Within the `Key` element you can load your keys and certificates from a Java"
" Keystore.  This is declared within a `KeyStore` element."
msgstr "`Key` 要素内でJavaのキーストアから鍵と証明書を読み込むことができます。これは `KeyStore` 要素内で宣言されています。"

msgid ""
"\n"
"        <Keys>\n"
"            <Key signing=\"true\" >\n"
"                <KeyStore resource=\"/WEB-INF/keystore.jks\" password=\"store123\">\n"
"                    <PrivateKey alias=\"myPrivate\" password=\"test123\"/>\n"
"                    <Certificate alias=\"myCertAlias\"/>\n"
"                </KeyStore>\n"
"            </Key>\n"
"        </Keys>"
msgstr ""
"\n"
"        <Keys>\n"
"            <Key signing=\"true\" >\n"
"                <KeyStore resource=\"/WEB-INF/keystore.jks\" password=\"store123\">\n"
"                    <PrivateKey alias=\"myPrivate\" password=\"test123\"/>\n"
"                    <Certificate alias=\"myCertAlias\"/>\n"
"                </KeyStore>\n"
"            </Key>\n"
"        </Keys>"

msgid ""
"Here are the XML config attributes that are defined with the `KeyStore` "
"element."
msgstr "`KeyStore` 要素に定義されているXML設定属性を示します。"

msgid "file"
msgstr "file"

msgid ""
"File path to the key store. This option is _OPTIONAL_.  The file or resource"
" attribute must be set."
msgstr ""
"キーストアのファイルパスです。このオプションは _OPTIONAL_ です。file属性またはresource属性を設定する必要があります。"

msgid ""
"WAR resource path to the KeyStore. This is a path used in method call to "
"ServletContext.getResourceAsStream(). This option is _OPTIONAL_.  The file "
"or resource attribute must be set."
msgstr ""
"キーストアへのWARリソース・パスです。これは、ServletContext.getResourceAsStream()へのメソッド呼び出しで使用されるパスです。このオプションは"
" _OPTIONAL_ です。file属性またはresource属性を設定する必要があります。"

msgid "password"
msgstr "password"

msgid "The password of the KeyStore. This option is _REQUIRED_."
msgstr "キーストアのパスワードです。このオプションは _REQUIRED_ です。"

msgid ""
"If you are defining keys that the SP will use to sign document, you must "
"also specify references to your private keys and certificates within the "
"Java KeyStore. The `PrivateKey` and `Certificate` elements in the above "
"example define an `alias` that points to the key or cert within the "
"keystore.  Keystores require an additional password to access private keys. "
"In the `PrivateKey` element you must define this password within a "
"`password` attribute."
msgstr ""
"SPがドキュメントの署名に使用する鍵を定義している場合、Javaのキーストア内の秘密鍵と証明書への参照も指定する必要があります。上記の例の "
"`PrivateKey` 要素と `Certificate` 要素はキーストア内の鍵または証明書を指す `alias` "
"を定義します。キーストアには、秘密鍵にアクセスするための追加のパスワードが必要です。 `PrivateKey` 要素では、このパスワードを "
"`password` 属性の中で定義する必要があります。"

msgid "Key PEMS"
msgstr "Key PEMS"

msgid ""
"Within the `Key` element you declare your keys and certificates directly "
"using the sub elements `PrivateKeyPem`, `PublicKeyPem`, and "
"`CertificatePem`. The values contained in these elements must conform to the"
" PEM key format. You usually use this option if you are generating keys "
"using `openssl` or similar command line tool."
msgstr ""
"`Key` 要素の中では、 `PrivateKeyPem` 、 `PublicKeyPem` 、 `CertificatePem` "
"というサブ要素を使って、鍵と証明書を直接宣言します。これらの要素に含まれる値は、PEM鍵形式に準拠している必要があります。 `openssl` "
"などのコマンドライン・ツールを使用して鍵を生成する場合は、通常このオプションを使用します。"

msgid ""
"<Keys>\n"
"   <Key signing=\"true\">\n"
"      <PrivateKeyPem>\n"
"         2341251234AB31234==231BB998311222423522334\n"
"      </PrivateKeyPem>\n"
"      <CertificatePem>\n"
"         211111341251234AB31234==231BB998311222423522334\n"
"      </CertificatePem>\n"
"   </Key>\n"
"</Keys>"
msgstr ""
"<Keys>\n"
"   <Key signing=\"true\">\n"
"      <PrivateKeyPem>\n"
"         2341251234AB31234==231BB998311222423522334\n"
"      </PrivateKeyPem>\n"
"      <CertificatePem>\n"
"         211111341251234AB31234==231BB998311222423522334\n"
"      </CertificatePem>\n"
"   </Key>\n"
"</Keys>"

msgid "SP PrincipalNameMapping element"
msgstr "SP PrincipalNameMapping要素"

msgid ""
"This element is optional. When creating a Java Principal object that you "
"obtain from methods such as `HttpServletRequest.getUserPrincipal()`, you can"
" define what name is returned by the `Principal.getName()` method."
msgstr ""
"この要素はオプションです。 `HttpServletRequest.getUserPrincipal()` などのメソッドから取得したJavaの "
"`Principal` オブジェクトを作成するときに、  `Principal.getName()` メソッドが返す名前を定義することができます。"

msgid ""
"<SP ...>\n"
"  <PrincipalNameMapping policy=\"FROM_NAME_ID\"/>\n"
"</SP>\n"
"\n"
"<SP ...>\n"
"  <PrincipalNameMapping policy=\"FROM_ATTRIBUTE\" attribute=\"email\" />\n"
"</SP>\n"
msgstr ""
"<SP ...>\n"
"  <PrincipalNameMapping policy=\"FROM_NAME_ID\"/>\n"
"</SP>\n"
"\n"
"<SP ...>\n"
"  <PrincipalNameMapping policy=\"FROM_ATTRIBUTE\" attribute=\"email\" />\n"
"</SP>\n"

msgid ""
"The `policy` attribute defines the policy used to populate this value. The "
"possible values for this attribute are:"
msgstr "`policy` 属性は、この値を設定するためのポリシーを定義します。 この属性に指定できる値は次のとおりです。"

msgid "FROM_NAME_ID"
msgstr "FROM_NAME_ID"

msgid ""
"This policy just uses whatever the SAML subject value is.  This is the "
"default setting"
msgstr "このポリシーはSAMLサブジェクトの値が何であれ使用します。これはデフォルト設定です。"

msgid "FROM_ATTRIBUTE"
msgstr "FROM_ATTRIBUTE"

msgid ""
"This will pull the value from one of the attributes declared in the SAML "
"assertion received from the server. You'll need to specify the name of the "
"SAML assertion attribute to use within the `attribute` XML attribute."
msgstr ""
"これにより、サーバーから受け取ったSAMLアサーションで宣言された属性の1つから、値が取得されます。 `attribute` "
"XML属性内で使用するSAMLアサーション属性の名前を指定する必要があります。"

msgid "RoleIdentifiers element"
msgstr "RoleIdentifiers要素"

msgid ""
"The `RoleIdentifiers` element defines what SAML attributes within the "
"assertion received from the user should be used as role identifiers within "
"the Jakarta EE Security Context for the user."
msgstr ""
"`RoleIdentifiers` 要素は、ユーザーから受信したアサーション内のどのSAML属性が、Jakarta "
"EEのセキュリティー・コンテキスト内のロール識別子として使用されるか定義します。"

msgid ""
"\n"
"<RoleIdentifiers>\n"
"     <Attribute name=\"Role\"/>\n"
"     <Attribute name=\"member\"/>\n"
"     <Attribute name=\"memberOf\"/>\n"
"</RoleIdentifiers>"
msgstr ""
"\n"
"<RoleIdentifiers>\n"
"     <Attribute name=\"Role\"/>\n"
"     <Attribute name=\"member\"/>\n"
"     <Attribute name=\"memberOf\"/>\n"
"</RoleIdentifiers>"

msgid ""
"By default `Role` attribute values are converted to Jakarta EE roles. Some "
"IdPs send roles using a `member` or `memberOf` attribute assertion. You can "
"define one or more `Attribute` elements to specify which SAML attributes "
"must be converted into roles."
msgstr ""
"デフォルトでは、 `Role` 属性の値はJakarta EEのロールに変換されます。いくつかのIdPは、 `member` または "
"`memberOf` 属性アサーションを使用してロールを送信します。どのSAML属性をロールに変換すべきかを指定するために、1つ以上の "
"`Attribute` 要素を定義できます。"

msgid "RoleMappingsProvider element"
msgstr "RoleMappingsProvider要素"

msgid ""
"The `RoleMappingsProvider` is an optional element that allows for the "
"specification of the id and configuration of the "
"`org.keycloak.adapters.saml.RoleMappingsProvider` SPI implementation that is"
" to be used by the SAML adapter."
msgstr ""
"`RoleMappingsProvider` は、SAMLアダプターによって使用される "
"`org.keycloak.adapters.saml.RoleMappingsProvider` "
"SPIの実装のidと設定を指定できるオプションの要素です。"

msgid ""
"When {project_name} is used as the IDP, it is possible to use the built in "
"role mappers to map any roles before adding them to the SAML assertion. "
"However, the SAML adapters can be used to send SAML requests to third party "
"IDPs and in this case it might be necessary to map the roles extracted from "
"the assertion into a different set of roles as required by the SP. The "
"`RoleMappingsProvider` SPI allows for the configuration of pluggable role "
"mappers that can be used to perform the necessary mappings."
msgstr ""
"{project_name}をIDPとして使用する場合、組み込みのロールマッパーを使用して、ロールをSAMLアサーションに追加する前にマッピングできます。ただし、SAMLアダプターを使用することでSAMLリクエストをサードパーティーのIDPに送信できるため、この場合、SPの要求に応じて、アサーションから抽出されたロールを異なるロールセットにマッピングする必要があります。"
" `RoleMappingsProvider` SPIは、必要なマッピングを実行するために使用できるプラグ可能なロールマッパーの設定を可能にします。"

msgid "The configuration of the provider looks as follows:"
msgstr "プロバイダーの設定は次のようになります。"

msgid ""
"...\n"
"<RoleIdentifiers>\n"
"    ...\n"
"</RoleIdentifiers>\n"
"<RoleMappingsProvider id=\"properties-based-role-mapper\">\n"
"    <Property name=\"properties.resource.location\" value=\"/WEB-INF/role-mappings.properties\"/>\n"
"</RoleMappingsProvider>\n"
"<IDP>\n"
"    ...\n"
"</IDP>\n"
msgstr ""
"...\n"
"<RoleIdentifiers>\n"
"    ...\n"
"</RoleIdentifiers>\n"
"<RoleMappingsProvider id=\"properties-based-role-mapper\">\n"
"    <Property name=\"properties.resource.location\" value=\"/WEB-INF/role-mappings.properties\"/>\n"
"</RoleMappingsProvider>\n"
"<IDP>\n"
"    ...\n"
"</IDP>\n"

msgid ""
"The `id` attribute identifies which of the installed providers is to be "
"used. The `Property` sub-element can be used multiple times to specify "
"configuration properties for the provider."
msgstr ""
"`id` 属性は、インストールされているプロバイダーのどれを使用するかを識別します。 `Property` "
"サブ要素を複数回使用して、プロバイダーの設定プロパティーを指定できます。"

msgid "Properties Based role mappings provider"
msgstr "プロパティー・ベースのロールマッピング・プロバイダー"

msgid ""
"{project_name} includes a `RoleMappingsProvider` implementation that "
"performs the role mappings using a `properties` file. This provider is "
"identified by the id `properties-based-role-mapper` and is implemented by "
"the `org.keycloak.adapters.saml.PropertiesBasedRoleMapper` class."
msgstr ""
"{project_name}には、 `properties` ファイルを使用してロールマッピングを実行する `RoleMappingsProvider`"
" の実装が含まれます。このプロバイダーは、ID `properties-based-role-mapper` によって識別され、 "
"`org.keycloak.adapters.saml.PropertiesBasedRoleMapper` クラスによって実装されます。"

msgid ""
"This provider relies on two configuration properties that can be used to "
"specify the location of the `properties` file that will be used. First, it "
"checks if the `properties.file.location` property has been specified, using "
"the configured value to locate the `properties` file in the filesystem. If "
"the configured file is not located, the provider throws a "
"`RuntimeException`. The following snippet shows an example of provider using"
" the `properties.file.configuration` option to load the `roles.properties` "
"file from the `/opt/mappers/` directory in the filesystem:"
msgstr ""
"このプロバイダーは、使用される `properties` ファイルの場所を指定するために使用できる2つの設定プロパティーに依存しています。まず、 "
"`properties.file.location` プロパティーが指定されているかどうかを確認し、設定された値を使用してファイルシステム内の "
"`properties` ファイルを見つけます。設定されたファイルが見つからない場合、プロバイダーは `RuntimeException` "
"をスローします。次のスニペットは、 `properties.file.configuration` オプションを使用して、ファイルシステムの `/opt"
" /mappers/` ディレクトリーから `roles.properties` ファイルをロードするプロバイダーの例を示しています。"

msgid ""
"    <RoleMappingsProvider id=\"properties-based-role-mapper\">\n"
"        <Property name=\"properties.file.location\" value=\"/opt/mappers/roles.properties\"/>\n"
"    </RoleMappingsProvider>"
msgstr ""
"    <RoleMappingsProvider id=\"properties-based-role-mapper\">\n"
"        <Property name=\"properties.file.location\" value=\"/opt/mappers/roles.properties\"/>\n"
"    </RoleMappingsProvider>"

msgid ""
"If the `properties.file.location` configuration has not been set, the "
"provider checks the `properties.resource.location` property, using the "
"configured value to load the `properties` file from the `WAR` resource. If "
"this configuration property is also not present, the provider attempts to "
"load the file from `/WEB-INF/role-mappings.properties` by default. Failure "
"to load the file from the resource will result in the provider throwing a "
"`RuntimeException`. The following snippet shows an example of provider using"
" the `properties.resource.location` to load the `roles.properties` file from"
" the application's `/WEB-INF/conf/` directory:"
msgstr ""
"`properties.file.location` が設定されていない場合、プロバイダーは "
"`properties.resource.location` プロパティーをチェックし、設定された値を使用して `WAR` リソースから "
"`properties` ファイルをロードします。この設定プロパティーが存在しない場合、プロバイダーはデフォルトで `/WEB-INF/role-"
"mappings.properties` からファイルをロードしようとします。リソースからファイルをロードできないと、プロバイダーは "
"`RuntimeException` をスローします。 次のスニペットは、 `properties.resource.location` "
"を使用してアプリケーションの `/WEB-INF/conf/` ディレクトリーから `roles.properties` "
"ファイルをロードするプロバイダーの例を示しています。"

msgid ""
"    <RoleMappingsProvider id=\"properties-based-role-mapper\">\n"
"        <Property name=\"properties.resource.location\" value=\"/WEB-INF/conf/roles.properties\"/>\n"
"    </RoleMappingsProvider>"
msgstr ""
"    <RoleMappingsProvider id=\"properties-based-role-mapper\">\n"
"        <Property name=\"properties.resource.location\" value=\"/WEB-INF/conf/roles.properties\"/>\n"
"    </RoleMappingsProvider>"

msgid ""
"The `properties` file can contain both roles and principals as keys, and a "
"list of zero or more roles separated by comma as values. When invoked, the "
"implementation iterates through the set of roles that were extracted from "
"the assertion and checks, for each role, if a mapping exists. If the role "
"maps to an empty role, it is discarded. If it maps to a set of one ore more "
"different roles, then these roles are set in the result set. If no mapping "
"is found for the role then it is included as is in the result set."
msgstr ""
"`properties` "
"ファイルには、キーとしてロールとプリンシパルの両方を、値としてカンマで区切られたゼロ以上のロールのリストを含めることができます。呼び出されると、実装はアサーションから抽出された一連のロールを反復処理し、各ロールについてマッピングが存在するかどうかを確認します。ロールが空のロールにマップされている場合は、破棄されます。1つ以上の異なるロールのセットにマップされる場合、これらのロールは結果セットに設定されます。ロールのマッピングが見つからない場合は、結果セットにそのまま含まれます。"

msgid ""
"Once the roles have been processed, the implementation checks if the "
"principal extracted from the assertion contains an entry `properties` file. "
"If a mapping for the principal exists, any roles listed as value are added "
"to the result set. This allows the assignment of extra roles to a principal."
msgstr ""
"ロールが処理されると、実装はアサーションから抽出されたプリンシパルにエントリーの `properties` "
"ファイルが含まれているかどうかを確認します。プリンシパルのマッピングが存在する場合、値としてリストされているロールが結果セットに追加されます。これにより、プリンシパルに追加のロールを割り当てることができます。"

msgid ""
"As an example, let's assume the provider has been configured with the "
"following properties file:"
msgstr "例として、プロバイダーが次のプロパティー・ファイルで設定されていると仮定します。"

msgid ""
"roleA=roleX,roleY\n"
"roleB=\n"
"\n"
"kc_user=roleZ\n"
msgstr ""
"roleA=roleX,roleY\n"
"roleB=\n"
"\n"
"kc_user=roleZ\n"

msgid ""
"If the principal `kc_user` is extracted from the assertion with roles "
"`roleA`, `roleB` and `roleC`, the final set of roles assigned to the "
"principal will be `roleC`, `roleX`, `roleY` and `roleZ` because `roleA` is "
"being mapped into both `roleX` and `roleY`, `roleB` was mapped into an empty"
" role - thus being discarded, `roleC` is used as is and finally an "
"additional role was added to the `kc_user` principal (`roleZ`)."
msgstr ""
"プリンシパル `kc_user` がロール `roleA` 、 `roleB` および `roleC` "
"を持つアサーションから抽出される場合、プリンシパルに割り当てられるロールの最終セットは `roleC` 、 `roleX` 、 `roleY` および "
"`roleZ` になります。 `roleA` は `roleX` と `roleY` の両方にマップされ、 `roleB` "
"は空のロールにマップされているので破棄され、 `roleC` はそのまま使用され、最後に追加のロールが `kc_user` プリンシパル（ "
"`roleZ` ）に追加されるためです。"

msgid ""
"Note: to use spaces in role names for mappings, use unicode replacements for"
" space. For example, incoming 'role A' would appear as:"
msgstr ""
"注意：マッピングのロール名にスペースを使用する場合は、スペースの代わりにUnicodeを使用してください。たとえば、受信した 'role A' "
"は次のように表示されます。"

msgid "role\\u0020A=roleX,roleY"
msgstr "role\\u0020A=roleX,roleY"

msgid "Adding your own role mappings provider"
msgstr "独自のロールマッピング・プロバイダーの追加"

msgid ""
"To add a custom role mappings provider one simply needs to implement the "
"`org.keycloak.adapters.saml.RoleMappingsProvider` SPI. For more details see "
"the `SAML Role Mappings SPI` section in "
"link:{developerguide_link}[{developerguide_name}]."
msgstr ""
"カスタム・ロールマッピング・プロバイダーを追加するには、単に "
"`org.keycloak.adapters.saml.RoleMappingsProvider` SPIを実装する必要があります。詳細については、 "
"link:{developerguide_link}[{developerguide_name}] の `SAML Role Mappings SPI`"
" のセクションを参照してください。"

msgid "IDP Element"
msgstr "IDP要素"

msgid ""
"Everything in the IDP element describes the settings for the identity "
"provider (authentication server) the SP is communicating with."
msgstr "IDP要素内には、SPと通信しているアイデンティティー・プロバイダー（認証サーバー）の設定を記述します。"

msgid ""
"<IDP entityID=\"idp\"\n"
"     signaturesRequired=\"true\"\n"
"     signatureAlgorithm=\"RSA_SHA1\"\n"
"     signatureCanonicalizationMethod=\"http://www.w3.org/2001/10/xml-exc-c14n#\">\n"
"...\n"
"</IDP>"
msgstr ""
"<IDP entityID=\"idp\"\n"
"     signaturesRequired=\"true\"\n"
"     signatureAlgorithm=\"RSA_SHA1\"\n"
"     signatureCanonicalizationMethod=\"http://www.w3.org/2001/10/xml-exc-c14n#\">\n"
"...\n"
"</IDP>"

msgid ""
"Here are the attribute config options you can specify within the `IDP` "
"element declaration."
msgstr "`IDP` 要素宣言内で指定できる属性設定オプションを示します。"

msgid "This is the issuer ID of the IDP. This setting is _REQUIRED_."
msgstr "IDPの発行者IDです。この設定は _REQUIRED_ です。"

msgid "signaturesRequired"
msgstr "signaturesRequired"

msgid ""
"If set to `true`, the client adapter will sign every document it sends to "
"the IDP. Also, the client will expect that the IDP will be signing any "
"documents sent to it. This switch sets the default for all request and "
"response types, but you will see later that you have some fine grain control"
" over this. This setting is _OPTIONAL_ and will default to `false`."
msgstr ""
" `true` に設定すると、クライアント・アダプターはIDPに送信する全ての文書に署名します。 "
"また、クライアントは、送信されたすべてのドキュメントにIDPが署名していることを期待します。このスイッチは、すべてのリクエストとレスポンスの種類に対してデフォルト値を設定しますが、それ以上に細かい制御ができることが後で分かります。この設定は"
" _OPTIONAL_ で、 `false` がデフォルトとなります。"

msgid "signatureAlgorithm"
msgstr "signatureAlgorithm"

msgid ""
"This is the signature algorithm that the IDP expects signed documents to "
"use. Allowed values are: `RSA_SHA1`, `RSA_SHA256`, `RSA_SHA512`, and "
"`DSA_SHA1`. This setting is _OPTIONAL_ and defaults to `RSA_SHA256`."
msgstr ""
"IDPが署名済みドキュメントに使用することを想定している署名アルゴリズムです。許可値は、 `RSA_SHA1` 、 `RSA_SHA256` 、 "
"`RSA_SHA512` 、 `DSA_SHA1` です。 この設定は _OPTIONAL_ で、デフォルトは `RSA_SHA256` です。"

msgid "signatureCanonicalizationMethod"
msgstr "signatureCanonicalizationMethod"

msgid ""
"This is the signature canonicalization method that the IDP expects signed "
"documents to use.  This setting is  _OPTIONAL_. The default value is "
"`\\http://www.w3.org/2001/10/xml-exc-c14n#` and should be good for most "
"IDPs."
msgstr ""
"IDPが署名済みのドキュメントに使用することを想定している署名の正規化方法です。この設定は _OPTIONAL_ です。デフォルトは "
"`\\http://www.w3.org/2001/10/xml-exc-c14n#` で、ほとんどのIDPに対して変更が不要です。"

msgid "metadataUrl"
msgstr "metadataUrl"

msgid ""
"The URL used to retrieve the IDP metadata, currently this is only used to "
"pick up signing and encryption keys periodically which allow cycling of "
"these keys on the IDP without manual changes on the SP side."
msgstr ""
"IDPメタデータを取得するために使用されるURL。現在、これは定期的に署名および暗号化鍵を取得するために使用されます。これにより、SP側を手動で変更することなく、IDPでこれらの鍵を循環できます。"

msgid "IDP AllowedClockSkew sub element"
msgstr "IDP AllowedClockSkewサブ要素"

msgid ""
"The `AllowedClockSkew` optional sub element defines the allowed clock skew "
"between IDP and SP. The default value is 0."
msgstr ""
"オプションのサブ要素 `AllowedClockSkew` は、IDPとSPの間で許可されるクロックスキューを定義します。デフォルト値は0です。"

msgid "<AllowedClockSkew unit=\"MILLISECONDS\">3500</AllowedClockSkew>"
msgstr "<AllowedClockSkew unit=\"MILLISECONDS\">3500</AllowedClockSkew>"

msgid "unit"
msgstr "unit"

msgid ""
"It is possible to define the time unit attached to the value for this "
"element. Allowed values are MICROSECONDS, MILLISECONDS, MINUTES, NANOSECONDS"
" and SECONDS. This is _OPTIONAL_. The default value is `SECONDS`."
msgstr ""
"この要素の値に付加される時間単位を定義することができます。許可される値は、MICROSECONDS、MILLISECONDS、MINUTES、NANOSECONDSおよびSECONDSです。これは"
" _OPTIONAL_です。デフォルト値は `SECONDS` です。"

msgid "IDP SingleSignOnService sub element"
msgstr "IDP SingleSignOnServiceサブ要素"

msgid ""
"The `SingleSignOnService` sub element defines the login SAML endpoint of the"
" IDP. The client adapter will send requests to the IDP formatted via the "
"settings within this element when it wants to login."
msgstr ""
"`SingleSignOnService` "
"サブ要素は、IDPのログインSAMLエンドポイントを定義します。クライアント・アダプターは、ログインしたいときに、この要素内の設定によって書式設定されたIDPにリクエストを送信します。"

msgid ""
"\n"
"<SingleSignOnService signRequest=\"true\"\n"
"                     validateResponseSignature=\"true\"\n"
"                     requestBinding=\"post\"\n"
"                     bindingUrl=\"url\"/>"
msgstr ""
"\n"
"<SingleSignOnService signRequest=\"true\"\n"
"                     validateResponseSignature=\"true\"\n"
"                     requestBinding=\"post\"\n"
"                     bindingUrl=\"url\"/>"

msgid "Here are the config attributes you can define on this element:"
msgstr "この要素に定義できる設定属性は次のとおりです。"

msgid "signRequest"
msgstr "signRequest"

msgid ""
"Should the client sign authn requests? This setting is _OPTIONAL_. Defaults "
"to whatever the IDP `signaturesRequired` element value is."
msgstr ""
"クライアントが認証リクエストに署名する必要があるかどうかの設定です。この設定は _OPTIONAL_ です。デフォルトはIDPの "
"`signaturesRequired` 要素の値です。"

msgid "validateResponseSignature"
msgstr "validateResponseSignature"

msgid ""
"Should the client expect the IDP to sign the assertion response document "
"sent back from an auhtn request? This setting _OPTIONAL_. Defaults to "
"whatever the IDP `signaturesRequired` element value is."
msgstr ""
"クライアントが、認証リクエストからのアサーション・レスポンスのドキュメントが署名されていることを期待するかどうかの設定です。この設定は "
"_OPTIONAL_ です。デフォルトはIDPの `signaturesRequired` 要素の値です。"

msgid "requestBinding"
msgstr "requestBinding"

msgid ""
"This is the SAML binding type used for communicating with the IDP.  This "
"setting is _OPTIONAL_. The default value is `POST`, but you can set it to "
"`REDIRECT` as well."
msgstr ""
"IDPとの通信に使用するSAMLバインディング・タイプです。この設定は _OPTIONAL_ です。デフォルト値は `POST` ですが、 "
"`REDIRECT` に設定することもできます。"

msgid "responseBinding"
msgstr "responseBinding"

msgid ""
"SAML allows the client to request what binding type it wants authn responses"
" to use. The values of this can be `POST` or `REDIRECT`.  This setting is "
"_OPTIONAL_. The default is that the client will not request a specific "
"binding type for responses."
msgstr ""
"SAMLでは、クライアントが認証レスポンスに使用したいバインディング・タイプを要求することができます。この値には、 `POST` または "
"`REDIRECT` を設定できます。この設定は _OPTIONAL_ "
"です。デフォルトでは、クライアントはレスポンスに対して特定のバインディング・タイプを要求しません。"

msgid "assertionConsumerServiceUrl"
msgstr "assertionConsumerServiceUrl"

msgid ""
"URL of the assertion consumer service (ACS) where the IDP login service "
"should send responses to. This setting is _OPTIONAL_. By default it is "
"unset, relying on the configuration in the IdP. When set, it must end in "
"`/saml`, for example `\\http://sp.domain.com/my/endpoint/for/saml`. The "
"value of this property is sent in `AssertionConsumerServiceURL` attribute of"
" SAML `AuthnRequest` message. This property is typically  accompanied by the"
" `responseBinding` attribute."
msgstr ""
"IDPログイン・サービスがレスポンスを送信するアサーション・コンシューマー・サービス（ACS）のURLの設定です。この設定は _OPTIONAL_ "
"です。デフォルトでは未設定で、IdPの設定に依存します。設定されている場合、 "
"`\\http://sp.domain.com/my/endpoint/for/saml` のように、 `/saml` "
"で終わる必要があります。このプロパティーの値は、SAMLの `AuthnRequest` メッセージの "
"`AssertionConsumerServiceURL` 属性で送信されます。このプロパティーは、通常 `responseBinding` "
"属性を伴います。"

msgid "bindingUrl"
msgstr "bindingUrl"

msgid ""
"This is the URL for the IDP login service that the client will send requests"
" to. This setting is _REQUIRED_."
msgstr "これは、クライアントがリクエストを送信するIDPログイン・サービスのURLです。この設定は _REQUIRED_ です。"

msgid "IDP SingleLogoutService sub element"
msgstr "IDP SingleLogoutServiceサブ要素"

msgid ""
"The `SingleLogoutService` sub element defines the logout SAML endpoint of "
"the IDP.   The client adapter will send requests to the IDP formatted via "
"the settings within this element when it wants to logout."
msgstr ""
"`SingleLogoutService` "
"サブ要素は、IDPのログアウトSAMLエンドポイントを定義します。クライアント・アダプターは、ログアウトしたいときに、この要素内の設定によって書式設定されたIDPにリクエストを送信します。"

msgid ""
"<SingleLogoutService validateRequestSignature=\"true\"\n"
"                     validateResponseSignature=\"true\"\n"
"                     signRequest=\"true\"\n"
"                     signResponse=\"true\"\n"
"                     requestBinding=\"redirect\"\n"
"                     responseBinding=\"post\"\n"
"                     postBindingUrl=\"posturl\"\n"
"                     redirectBindingUrl=\"redirecturl\">"
msgstr ""
"<SingleLogoutService validateRequestSignature=\"true\"\n"
"                     validateResponseSignature=\"true\"\n"
"                     signRequest=\"true\"\n"
"                     signResponse=\"true\"\n"
"                     requestBinding=\"redirect\"\n"
"                     responseBinding=\"post\"\n"
"                     postBindingUrl=\"posturl\"\n"
"                     redirectBindingUrl=\"redirecturl\">"

msgid ""
"Should the client sign logout requests it makes to the IDP? This setting is "
"_OPTIONAL_. Defaults to whatever the IDP `signaturesRequired` element value "
"is."
msgstr ""
"IDPへのログアウト・リクエストにクライアントが署名する必要があるかどうかの設定です。この設定は _OPTIONAL_ です。デフォルトはIDPの "
"`signaturesRequired` 要素の値です。"

msgid "signResponse"
msgstr "signResponse"

msgid ""
"Should the client sign logout responses it sends to the IDP requests? This "
"setting is _OPTIONAL_. Defaults to whatever the IDP `signaturesRequired` "
"element value is."
msgstr ""
"IDPへのログアウト・レスポンスにクライアントが署名する必要があるかどうかの設定です。この設定は _OPTIONAL_ です。デフォルトはIDPの "
"`signaturesRequired` 要素の値です。"

msgid "validateRequestSignature"
msgstr "validateRequestSignature"

msgid ""
"Should the client expect signed logout request documents from the IDP? This "
"setting is _OPTIONAL_. Defaults to whatever the IDP `signaturesRequired` "
"element value is."
msgstr ""
"IDPからのログアウト・リクエストのドキュメントが署名されていることをクライアントが期待するかどうかの設定です。この設定は _OPTIONAL_ "
"です。デフォルトはIDPの `signaturesRequired` 要素の値です。"

msgid ""
"Should the client expect signed logout response documents from the IDP? This"
" setting is _OPTIONAL_. Defaults to whatever the IDP `signaturesRequired` "
"element value is."
msgstr ""
"IDPからのログアウト・レスポンスのドキュメントが署名されていることをクライアントが期待するかどうかの設定です。この設定は _OPTIONAL_ "
"です。デフォルトはIDPの `signaturesRequired` 要素の値です。"

msgid ""
"This is the SAML binding type used for communicating SAML requests to the "
"IDP. This setting is _OPTIONAL_. The default value is `POST`, but you can "
"set it to REDIRECT as well."
msgstr ""
"IDPとのSAMLリクエストでの通信に使用するSAMLバインディング・タイプです。この設定は _OPTIONAL_ です。デフォルト値は `POST` "
"ですが、 `REDIRECT` に設定することもできます。"

msgid ""
"This is the SAML binding type used for communicating SAML responses to the "
"IDP. The values of this can be `POST` or `REDIRECT`.  This setting is "
"_OPTIONAL_. The default value is `POST`, but you can set it to `REDIRECT` as"
" well."
msgstr ""
"IDPとのSAMLレスポンスでの通信に使用するSAMLバインディング・タイプです。この値は `POST` または `REDIRECT` "
"にできます。この設定は _OPTIONAL_ です。デフォルト値は `POST` ですが、 `REDIRECT` に設定することもできます。"

msgid "postBindingUrl"
msgstr "postBindingUrl"

msgid ""
"This is the URL for the IDP's logout service when using the POST binding. "
"This setting is _REQUIRED_ if using the `POST` binding."
msgstr ""
"`POST` バインディングを使用する際のIDPのログアウト・サービス用のURLです。 `POST` バインディングを使用する場合、この設定は "
"_REQUIRED_ です。"

msgid "redirectBindingUrl"
msgstr "redirectBindingUrl"

msgid ""
"This is the URL for the IDP's logout service when using the REDIRECT "
"binding. This setting is _REQUIRED_ if using the REDIRECT binding."
msgstr ""
"REDIRECTバインディングを使用する際のIDPのログアウト・サービス用のURLです。REDIRECTバインディングを使用する場合、この設定は "
"_REQUIRED_ です。"

msgid "IDP Keys sub element"
msgstr "IDP Keysサブ要素"

msgid ""
"The Keys sub element of IDP is only used to define the certificate or public"
" key to use to verify documents signed by the IDP. It is defined in the same"
" way as the <<_saml-sp-keys,SP's Keys element>>. But again, you only have to"
" define one certificate or public key reference. Note that, if both IDP and "
"SP are realized by {project_name} server and adapter, respectively, there is"
" no need to specify the keys for signature validation, see below."
msgstr ""
"IDPのKeysサブ要素は、IDPによって署名されたドキュメントの検証に使用する証明書や公開鍵を定義するために使用されます。Keysサブ要素は、<<_saml-"
"sp-"
"keys,SPのKeys要素>>と同じ方法で定義されます。しかし、証明書または公開鍵の参照を1つだけ定義する必要があります。IDPとSPが{project_name}サーバーとアダプターによって実現された場合、それぞれで、署名の検証のために鍵を指定する必要はないことに注意してください（以下を参照してください）。"

msgid ""
"It is possible to configure SP to obtain public keys for IDP signature "
"validation from published certificates automatically, provided both SP and "
"IDP are implemented by {project_name}. This is done by removing all "
"declarations of signature validation keys in Keys sub element. If the Keys "
"sub element would then remain empty, it can be omitted completely. The keys "
"are then automatically obtained by SP from SAML descriptor, location of "
"which is derived from SAML endpoint URL specified in the <<_sp-idp-"
"singlesignonservice,IDP SingleSignOnService sub element>>. Settings of the "
"HTTP client that is used for SAML descriptor retrieval usually needs no "
"additional configuration, however it can be configured in the <<_sp-idp-"
"httpclient,IDP HttpClient sub element>>."
msgstr ""
"SPとIDPの両方が{project_name}で提供された場合、公開された証明書から自動的にIDP署名検証用の公開鍵を取得するようにSPを設定できます。これは、Keysサブ要素内の署名検証鍵のすべての宣言を削除することによって行われます。Keysサブ要素が空であれば、完全に省略できます。鍵は、SAML記述子からSPによって自動的に取得されます。その場所は、<<_sp-"
"idp-singlesignonservice,IDP "
"SingleSignOnServiceサブ要素>>で指定したSAMLエンドポイントURLが基になります。SAML記述子の取得に使用されるHTTPクライアントの設定は、通常追加の設定は必要がありませんが、<<_sp-"
"idp-httpclient,IDP HttpClientサブ要素>>内に設定できます。"

msgid ""
"It is also possible to specify multiple keys for signature verification. "
"This is done by declaring multiple Key elements within Keys sub element that"
" have `signing` attribute set to `true`. This is useful for example in "
"situation when the IDP signing keys are rotated: There is usually a "
"transition period when new SAML protocol messages and assertions are signed "
"with the new key but those signed by previous key should still be accepted."
msgstr ""
"署名検証用の鍵を複数指定することもできます。 `signing` 属性を `true` "
"に設定し、Keysサブ要素内に複数のKey要素を宣言することによって行います。これは、たとえばIDPの署名鍵をローテーションするような状況で役に立ちます。通常、新しいSAMLプロトコルのメッセージとアサーションが新しい鍵で署名されても、以前の鍵で署名されたものを受け入れられる移行期間があります。"

msgid ""
"It is not possible to configure {project_name} to both obtain the keys for "
"signature verification automatically and define additional static signature "
"verification keys."
msgstr ""
"署名検証用の鍵を自動的に取得することと、追加の静的な署名検証の鍵を定義することの、両方を{project_name}に設定することはできません。"

msgid ""
"       <IDP entityID=\"idp\">\n"
"            ...\n"
"            <Keys>\n"
"                <Key signing=\"true\">\n"
"                    <KeyStore resource=\"/WEB-INF/keystore.jks\" password=\"store123\">\n"
"                        <Certificate alias=\"demo\"/>\n"
"                    </KeyStore>\n"
"                </Key>\n"
"            </Keys>\n"
"        </IDP>"
msgstr ""
"       <IDP entityID=\"idp\">\n"
"            ...\n"
"            <Keys>\n"
"                <Key signing=\"true\">\n"
"                    <KeyStore resource=\"/WEB-INF/keystore.jks\" password=\"store123\">\n"
"                        <Certificate alias=\"demo\"/>\n"
"                    </KeyStore>\n"
"                </Key>\n"
"            </Keys>\n"
"        </IDP>"

msgid "IDP HttpClient sub element"
msgstr "IDP HttpClient サブ要素"

msgid ""
"The `HttpClient` optional sub element defines the properties of HTTP client "
"used for automatic obtaining of certificates containing public keys for IDP "
"signature verification via SAML descriptor of the IDP when <<_sp-idp-keys-"
"automatic,enabled>>."
msgstr ""
"オプションである `HttpClient` サブ要素は、HTTPクライアントのプロパティーを定義します。<<_sp-idp-keys-"
"automatic,enabled>>の場合、IDPのSAML記述子による、IDP署名検証用の公開鍵を含む証明書の自動取得に使用されるます。"

msgid ""
"<HttpClient connectionPoolSize=\"10\"\n"
"            disableTrustManager=\"false\"\n"
"            allowAnyHostname=\"false\"\n"
"            clientKeystore=\"classpath:keystore.jks\"\n"
"            clientKeystorePassword=\"pwd\"\n"
"            truststore=\"classpath:truststore.jks\"\n"
"            truststorePassword=\"pwd\"\n"
"            proxyUrl=\"http://proxy/\"\n"
"            socketTimeout=\"5000\"\n"
"            connectionTimeout=\"6000\"\n"
"            connectionTtl=\"500\" />"
msgstr ""
"<HttpClient connectionPoolSize=\"10\"\n"
"            disableTrustManager=\"false\"\n"
"            allowAnyHostname=\"false\"\n"
"            clientKeystore=\"classpath:keystore.jks\"\n"
"            clientKeystorePassword=\"pwd\"\n"
"            truststore=\"classpath:truststore.jks\"\n"
"            truststorePassword=\"pwd\"\n"
"            proxyUrl=\"http://proxy/\"\n"
"            socketTimeout=\"5000\"\n"
"            connectionTimeout=\"6000\"\n"
"            connectionTtl=\"500\" />"

msgid "connectionPoolSize"
msgstr "connectionPoolSize"

msgid ""
"This config option defines how many connections to the {project_name} server"
" should be pooled. This is _OPTIONAL_. The default value is `10`."
msgstr ""
"この設定オプションは、{project_name}サーバーにプールすべき接続数を定義します。これは _OPTIONAL_ です。デフォルトは `20` "
"です。"

msgid "disableTrustManager"
msgstr "disableTrustManager"

msgid "allowAnyHostname"
msgstr "allowAnyHostname"

msgid ""
"If the {project_name} server requires HTTPS and this config option is set to"
" `true` the {project_name} server's certificate is validated via the "
"truststore, but host name validation is not done. This setting should only "
"be used during development and *never* in production as it will partly "
"disable verification of SSL certificates. This seting may be useful in test "
"environments. This is _OPTIONAL_. The default value is `false`."
msgstr ""
"{project_name}サーバーがHTTPSを必要とし、この設定オプションを `true` "
"に設定する場合、トラストストア経由で{project_name}サーバーの証明書は検証されますが、ホスト名の検証は行われません。 "
"SSL証明書の検証が一部無効となるため、この設定は開発時にのみ使用すべきで、プロダクション環境では *決して使用してはいけません* 。これは "
"_OPTIONAL_ です。デフォルトは `false` です。"

msgid ""
"The value is the file path to a truststore file. If you prefix the path with"
" `classpath:`, then the truststore will be obtained from the deployment's "
"classpath instead. Used for outgoing HTTPS communications to the "
"{project_name} server. Client making HTTPS requests need a way to verify the"
" host of the server they are talking to. This is what the trustore does. The"
" keystore contains one or more trusted host certificates or certificate "
"authorities. You can create this truststore by extracting the public "
"certificate of the {project_name} server's SSL keystore. This is _REQUIRED_ "
"unless `disableTrustManager` is `true`."
msgstr ""
"トラストストア・ファイルへのファイルパスです。パスに `classpath:` "
"を付けると、トラストストアはデプロイメントのクラスパスから取得されます。これは{project_name}サーバーへのHTTPS通信に使用されます。HTTPSリクエストを行うクライアントは、通信を行うサーバーのホストを検証する必要があります。これがトラストストアの役割です。キーストアには、1つ以上の信頼されたホストの証明書または認証局が含まれています。このトラストストアは、{project_name}サーバーのSSLキーストアのパブリック証明書を抽出することで作成できます。これは、"
" `disableTrustManager` が `true` でない限り、 _REQUIRED_ です。"

msgid "truststorePassword"
msgstr "truststorePassword"

msgid "clientKeystore"
msgstr "clientKeystore"

msgid "clientKeystorePassword"
msgstr "clientKeystorePassword"

msgid ""
"Password for the client keystore and for the client's key. This is "
"_REQUIRED_ if `clientKeystore` is set."
msgstr ""
"クライアントのキーとクライアントのキーストアのパスワードです。 `clientKeystore` が設定されている場合は、 _REQUIRED_ です。"

msgid "proxyUrl"
msgstr "proxyUrl"

msgid "URL to HTTP proxy to use for HTTP connections. This is _OPTIONAL_."
msgstr "HTTP接続に使用するHTTPプロキシーのURLです。これは _OPTIONAL_ です。"

msgid "socketTimeout"
msgstr "socketTimeout"

msgid "connectionTimeout"
msgstr "connectionTimeout"

msgid "connectionTtl"
msgstr "connectionTtl"

msgid ""
"To be able to secure WAR apps deployed on JBoss EAP or WildFly, you must "
"install and configure the {project_name} SAML Adapter Subsystem."
msgstr ""
"JBoss EAPまたはWildFlyにデプロイされたWARアプリケーションを保護するには、{project_name} "
"SAMLアダプター・サブシステムをインストールして設定する必要があります。"

msgid ""
"You then provide a keycloak config, `/WEB-INF/keycloak-saml.xml` file in "
"your WAR and change the auth-method to KEYCLOAK-SAML within web.xml."
msgstr ""
"そして、WARにkeycloakの設定ファイルである `/WEB-INF/keycloak-saml.xml` を用意し、web.xml内のauth-"
"methodをKEYCLOAK-SAMLに変更します。"

msgid "You install the adapters by using a ZIP file or an RPM."
msgstr "ZIPファイルまたはRPMを使用して、アダプターをインストールします。"

msgid ""
"<<_saml-jboss-adapter-installation, Installing adapters from a ZIP file>>"
msgstr "<<_saml-jboss-adapter-installation, ZIPファイルからアダプターをインストールする>>"

msgid ""
"<<_jboss7_adapter_rpm_saml, Installing JBoss EAP 7 Adapters from an RPM>>"
msgstr "<<_jboss7_adapter_rpm_saml, RPMからのJBoss EAP 7アダプターのインストール>>"

msgid ""
"<<_jboss6_adapter_rpm_saml, Installing JBoss EAP 6 Adapters from an RPM>>"
msgstr "<<_jboss6_adapter_rpm_saml, RPMからのJBoss EAP 6アダプターのインストール>>"

msgid "Installing adapters from a ZIP file"
msgstr "ZIPファイルからアダプタをインストールする"

msgid ""
"Each adapter is a separate download on the {project_name} download site."
msgstr "各アダプターは、{project_name}のダウンロード・サイトで個別にダウンロードできます。"

msgid ""
"We only test and maintain adapter with the most recent version of WildFly "
"available upon the release. Once the new version of WildFly is released, the"
" current adapters become deprecated and support for them will be removed "
"after the next WildFly release. The other alternative is to switch your "
"applications from WildFly to the JBoss EAP, as the JBoss EAP adapter is "
"supported for a much longer period."
msgstr ""
"今回のリリースでは、WildFlyの最新バージョンでのみアダプターのテストとメンテナンスを行っています。WildFlyの新しいバージョンがリリースされると、現在のアダプターは非推奨になり、WildFlyの次のリリース後にサポートが削除されます。もう一つの選択肢は、JBoss"
" EAPアダプターの場合はより長期間サポートされるので、アプリケーションをWildFlyからJBoss EAPに切り替えることです。"

msgid "Install on WildFly 9 or newer on JBoss EAP 7:"
msgstr "WildFly 9以上、またはJBoss EAP 7へのインストールは次のとおりです。"

msgid ""
"$ cd $WILDFLY_HOME\n"
"$ unzip keycloak-saml-wildfly-adapter-dist.zip"
msgstr ""
"$ cd $WILDFLY_HOME\n"
"$ unzip keycloak-saml-wildfly-adapter-dist.zip"

msgid "Install on JBoss EAP 6.x:"
msgstr "JBoss EAP 6.xへのインストールは次のとおりです。"

msgid ""
"$ cd $JBOSS_HOME\n"
"$ unzip keycloak-saml-eap6-adapter-dist.zip"
msgstr ""
"$ cd $JBOSS_HOME\n"
"$ unzip keycloak-saml-eap6-adapter-dist.zip"

msgid ""
"These zip files create new JBoss Modules specific to the WildFly/JBoss EAP "
"SAML Adapter within your WildFly or JBoss EAP distro."
msgstr ""
"これらのzipファイルは、WildFlyまたはJBoss EAP用の配布物内のWildFly/JBoss EAP "
"SAMLアダプターに固有の新しいJBossモジュールを作成します。"

msgid ""
"Use a CLI script to enable the {project_name} SAML Subsystem within your app"
" server's server configuration: `domain.xml` or `standalone.xml`."
msgstr ""
"CLIスクリプトを使用して、アプリケーション・サーバーのサーバー設定（ `domain.xml` または `standalone.xml` ）内で "
"{project_name} SAML Subsystemを有効にします。"

msgid ""
"Start the server and run the script that applies to your application server."
msgstr "サーバーを起動し、アプリケーション・サーバーに適用されるスクリプトを実行します。"

msgid "Install on WildFly 11 or newer."
msgstr "WildFly 11以上へのインストールは次のとおりです。"

msgid ""
"$ cd $JBOSS_HOME\n"
"$ ./bin/jboss-cli.sh -c --file=bin/adapter-elytron-install-saml.cli"
msgstr ""
"$ cd $JBOSS_HOME\n"
"$ ./bin/jboss-cli.sh -c --file=bin/adapter-elytron-install-saml.cli"

msgid "Install on WildFly 10 and older."
msgstr "WildFly 10以前へのインストールは次のとおりです。"

msgid ""
"$ cd $JBOSS_HOME\n"
"$ ./bin/jboss-cli.sh -c --file=bin/adapter-install-saml.cli"
msgstr ""
"$ cd $JBOSS_HOME\n"
"$ ./bin/jboss-cli.sh -c --file=bin/adapter-install-saml.cli"

msgid ""
"It is possible to use the legacy non-Elytron adapter on WildFly 11 or newer "
"as well, meaning you can use `adapter-install-saml.cli` even on those "
"versions. However, we recommend to use the newer Elytron adapter."
msgstr ""
"WildFly 11以上でもレガシーな非Elytronアダプターが使用できます。つまり、それらのバージョンでも `adapter-install-"
"saml.cli` を使用することができます。ただし、新しいElytronアダプターを使用することをお勧めします。"

msgid ""
"The script will add the extension, subsystem, and optional security-domain "
"as described below."
msgstr "スクリプトは、以下に説明するように、extension、subsystem、オプションでsecurity-domainを追加します。"

msgid ""
"<server xmlns=\"urn:jboss:domain:1.4\">\n"
"\n"
"    <extensions>\n"
"        <extension module=\"org.keycloak.keycloak-saml-adapter-subsystem\"/>\n"
"          ...\n"
"    </extensions>\n"
"\n"
"    <profile>\n"
"        <subsystem xmlns=\"urn:jboss:domain:keycloak-saml:1.1\"/>\n"
"         ...\n"
"    </profile>"
msgstr ""
"<server xmlns=\"urn:jboss:domain:1.4\">\n"
"\n"
"    <extensions>\n"
"        <extension module=\"org.keycloak.keycloak-saml-adapter-subsystem\"/>\n"
"          ...\n"
"    </extensions>\n"
"\n"
"    <profile>\n"
"        <subsystem xmlns=\"urn:jboss:domain:keycloak-saml:1.1\"/>\n"
"         ...\n"
"    </profile>"

msgid ""
"The `keycloak` security domain should be used with EJBs and other components"
" when you need the security context created in the secured web tier to be "
"propagated to the EJBs (other EE component) you are invoking. Otherwise this"
" configuration is optional."
msgstr ""
"セキュリティー保護されたWeb層で作成されたセキュリティー・コンテキストを呼び出すEJB（他のEEコンポーネント）に伝播する必要がある場合は、 "
"`keycloak` セキュリティー・ドメインをEJBなどのコンポーネントとともに使用する必要があります。それ以外の場合、この設定はオプションです。"

msgid ""
"\n"
"<server xmlns=\"urn:jboss:domain:1.4\">\n"
" <subsystem xmlns=\"urn:jboss:domain:security:1.2\">\n"
"    <security-domains>\n"
"...\n"
"      <security-domain name=\"keycloak\">\n"
"         <authentication>\n"
"           <login-module code=\"org.keycloak.adapters.jboss.KeycloakLoginModule\"\n"
"                         flag=\"required\"/>\n"
"          </authentication>\n"
"      </security-domain>\n"
"    </security-domains>"
msgstr ""
"\n"
"<server xmlns=\"urn:jboss:domain:1.4\">\n"
" <subsystem xmlns=\"urn:jboss:domain:security:1.2\">\n"
"    <security-domains>\n"
"...\n"
"      <security-domain name=\"keycloak\">\n"
"         <authentication>\n"
"           <login-module code=\"org.keycloak.adapters.jboss.KeycloakLoginModule\"\n"
"                         flag=\"required\"/>\n"
"          </authentication>\n"
"      </security-domain>\n"
"    </security-domains>"

msgid "Setting SameSite value for JSESSIONID cookie"
msgstr "JSESSIONID CookieにSameSite値を設定する"

msgid ""
"Browsers are planning to set the default value for the `SameSite` attribute "
"for cookies to `Lax`. This setting means that cookies will be sent to "
"applications only if the request originates in the same domain. This "
"behavior can affect the SAML POST binding which may become non-functional. "
"To preserve full functionality of the SAML adapter, we recommend setting the"
" `SameSite` value to `None` for the `JSESSIONID` cookie created by your "
"container. Not doing so may result in resetting the container's session with"
" each request to {project_name}."
msgstr ""
"各ブラウザーは、Cookieの `SameSite` 属性のデフォルト値を `Lax` "
"に設定することを計画しています。この設定は、リクエストが同じドメインで発生した場合にのみCookieがアプリケーションに送信されることを意味します。この動作はSAML"
" POSTバインディングに影響を与え、機能しなくなる可能性があります。SAMLアダプターの完全な機能を保持するために、コンテナーによって作成された "
"`JSESSIONID` Cookieの `SameSite` 値を `None` "
"に設定することをお勧めします。そうしないと、{project_name}へのリクエストごとにコンテナーのセッションがリセットされる可能性があります。"

msgid ""
"To avoid setting the `SameSite` attribute to `None`, consider switching to "
"the REDIRECT binding if it is acceptable, or to OIDC protocol where this "
"workaround is not necessary."
msgstr ""
"`SameSite` 属性が `None` "
"に設定されないようにするには、許容できる場合はREDIRECTバインディングに切り替えるか、この回避策が不要な場合はOIDCプロトコルに切り替えることを検討してください。"

msgid ""
"To set the `SameSite` value to `None` for the `JSESSIONID` cookie in "
"Wildfly/EAP, add a file `undertow-handlers.conf` with the following content "
"to the `WEB-INF` directory of your application."
msgstr ""
"Wildfly/EAPの `JSESSIONID` Cookieの `SameSite` 値を `None` に設定するには、以下の内容のファイル "
"`undertow-handlers.conf` をアプリケーションの `WEB-INF` ディレクトリーに追加します。"

msgid "samesite-cookie(mode=None, cookie-pattern=JSESSIONID)"
msgstr "samesite-cookie(mode=None, cookie-pattern=JSESSIONID)"

msgid ""
"The support for this configuration is available in Wildfly from version "
"19.1.0."
msgstr "この設定のサポートは、バージョン19.1.0以降のWildFlyで利用できます。"

msgid "Installing JBoss EAP 7 Adapters from an RPM"
msgstr "RPMからのJBoss EAP 7アダプターのインストール"

msgid ""
"You must subscribe to the JBoss EAP 7 repository before you can install the "
"EAP 7 adapters from an RPM."
msgstr "RPMからEAP 7アダプターをインストールする前に、JBoss EAP 7リポジトリーにサブスクライブする必要があります。"

msgid ""
"Install the EAP 7 adapters for SAML based on your version of Red Hat "
"Enterprise Linux."
msgstr "Red Hat Enterprise Linuxのバージョンに基づき、SAML用のEAP 7アダプターをインストールします。"

msgid "Install on Red Hat Linux 7:"
msgstr "Red Hat Enterprise Linux 7インストールするには、以下を実行します。"

msgid "$ sudo yum install eap7-keycloak-saml-adapter-sso7_5"
msgstr "$ sudo yum install eap7-keycloak-saml-adapter-sso7_5"

msgid "Install on Red Hat Enterprise Linux 8:"
msgstr "Red Hat Enterprise Linux 8インストールするには、以下を実行します。"

msgid "Run the installation script for the SAML module:"
msgstr "SAMLモジュールのインストールスクリプトを実行します。"

msgid ""
"$ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install-"
"saml.cli"
msgstr ""
"$ $EAP_HOME/bin/jboss-cli.sh -c --file=$EAP_HOME/bin/adapter-install-"
"saml.cli"

msgid "Installing JBoss EAP 6 Adapters from an RPM"
msgstr "RPMからのJBoss EAP 6アダプターのインストール"

msgid "Install the EAP 6 adapters for SAML using the following command:"
msgstr "次のコマンドを使用して、SAML用のEAP 6アダプターをインストールします。"

msgid "$ sudo yum install keycloak-saml-adapter-sso7_5-eap6"
msgstr "$ sudo yum install keycloak-saml-adapter-sso7_4-eap6"

msgid ""
"The first thing you must do is create a `keycloak-saml.xml` adapter config "
"file within the `WEB-INF` directory of your WAR. The format of this config "
"file is described in the <<_saml-general-config,General Adapter Config>> "
"section."
msgstr ""
"まず、WARの `WEB-INF` ディレクトリーに `keycloak-saml.xml` "
"アダプター設定ファイルを作成します。この設定ファイルの形式は、<<_saml-general-"
"config,共通アダプター設定>>セクションで説明しています。"

msgid ""
"Next you must set the `auth-method` to `KEYCLOAK-SAML` in `web.xml`. You "
"also have to use standard servlet security to specify role-base constraints "
"on your URLs. Here's an example _web.xml_ file:"
msgstr ""
"次に、 `web.xml` の `KEYCLOAK-SAML` に `auth-method` "
"を設定する必要があります。また、標準サーブレット・セキュリティーを使用して、URLに対してロールベース制約を指定する必要があります。 _web.xml_"
" ファイルの例を次に示します。"

msgid ""
"\n"
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"      version=\"3.0\">\n"
"\n"
"\t<module-name>customer-portal</module-name>\n"
"\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Admins</web-resource-name>\n"
"            <url-pattern>/admin/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>admin</role-name>\n"
"        </auth-constraint>\n"
"        <user-data-constraint>\n"
"            <transport-guarantee>CONFIDENTIAL</transport-guarantee>\n"
"        </user-data-constraint>\n"
"    </security-constraint>\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Customers</web-resource-name>\n"
"            <url-pattern>/customers/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>user</role-name>\n"
"        </auth-constraint>\n"
"        <user-data-constraint>\n"
"            <transport-guarantee>CONFIDENTIAL</transport-guarantee>\n"
"        </user-data-constraint>\n"
"    </security-constraint>\n"
"\n"
"    <login-config>\n"
"        <auth-method>KEYCLOAK-SAML</auth-method>\n"
"        <realm-name>this is ignored currently</realm-name>\n"
"    </login-config>\n"
"\n"
"    <security-role>\n"
"        <role-name>admin</role-name>\n"
"    </security-role>\n"
"    <security-role>\n"
"        <role-name>user</role-name>\n"
"    </security-role>\n"
"</web-app>"
msgstr ""
"\n"
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"      version=\"3.0\">\n"
"\n"
"\t<module-name>customer-portal</module-name>\n"
"\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Admins</web-resource-name>\n"
"            <url-pattern>/admin/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>admin</role-name>\n"
"        </auth-constraint>\n"
"        <user-data-constraint>\n"
"            <transport-guarantee>CONFIDENTIAL</transport-guarantee>\n"
"        </user-data-constraint>\n"
"    </security-constraint>\n"
"    <security-constraint>\n"
"        <web-resource-collection>\n"
"            <web-resource-name>Customers</web-resource-name>\n"
"            <url-pattern>/customers/*</url-pattern>\n"
"        </web-resource-collection>\n"
"        <auth-constraint>\n"
"            <role-name>user</role-name>\n"
"        </auth-constraint>\n"
"        <user-data-constraint>\n"
"            <transport-guarantee>CONFIDENTIAL</transport-guarantee>\n"
"        </user-data-constraint>\n"
"    </security-constraint>\n"
"\n"
"    <login-config>\n"
"        <auth-method>KEYCLOAK-SAML</auth-method>\n"
"        <realm-name>this is ignored currently</realm-name>\n"
"    </login-config>\n"
"\n"
"    <security-role>\n"
"        <role-name>admin</role-name>\n"
"    </security-role>\n"
"    <security-role>\n"
"        <role-name>user</role-name>\n"
"    </security-role>\n"
"</web-app>"

msgid "All standard servlet settings except the `auth-method` setting."
msgstr "`auth-method` の設定を除いて、すべての標準のサーブレット設定です。"

msgid "Securing WARs using the {project_name} SAML Subsystem"
msgstr "{project_name} SAMLサブシステムを使用したWARのセキュリティー保護"

msgid ""
"You do not have to open a WAR to secure it with {project_name}. "
"Alternatively, you can externally secure it via the {project_name} SAML "
"Adapter Subsystem. While you don't have to specify KEYCLOAK-SAML as an "
"`auth-method`, you still have to define the `security-constraints` in "
"`web.xml`. You do not, however, have to create a `WEB-INF/keycloak-saml.xml`"
" file. This metadata is instead defined within the XML in your server's "
"`domain.xml` or `standalone.xml` subsystem configuration section."
msgstr ""
"{project_name}でセキュリティー保護するためにWARを開く必要はありません。代わりに、{project_name} "
"SAMLアダプター・サブシステムを使用して、外部からセキュリティー保護することもできます。KEYCLOAK-SAMLを `auth-method` "
"として指定する必要はありませんが、 `web.xml` に `security-constraints` を定義する必要があります。しかし、 `WEB-"
"INF/keycloak-saml.xml` ファイルを作成する必要はありません。このメタデータは、代わりにサーバーの `domain.xml` または"
" `standalone.xml` のサブシステム設定セクションのXML内で定義されます。"

msgid ""
"\n"
"<extensions>\n"
"  <extension module=\"org.keycloak.keycloak-saml-adapter-subsystem\"/>\n"
"</extensions>\n"
"\n"
"<profile>\n"
"  <subsystem xmlns=\"urn:jboss:domain:keycloak-saml:1.1\">\n"
"    <secure-deployment name=\"WAR MODULE NAME.war\">\n"
"      <SP entityID=\"APPLICATION URL\">\n"
"        ...\n"
"      </SP>\n"
"    </secure-deployment>\n"
"  </subsystem>\n"
"</profile>"
msgstr ""
"\n"
"<extensions>\n"
"  <extension module=\"org.keycloak.keycloak-saml-adapter-subsystem\"/>\n"
"</extensions>\n"
"\n"
"<profile>\n"
"  <subsystem xmlns=\"urn:jboss:domain:keycloak-saml:1.1\">\n"
"    <secure-deployment name=\"WAR MODULE NAME.war\">\n"
"      <SP entityID=\"APPLICATION URL\">\n"
"        ...\n"
"      </SP>\n"
"    </secure-deployment>\n"
"  </subsystem>\n"
"</profile>"

msgid ""
"The `secure-deployment` `name` attribute identifies the WAR you want to "
"secure. Its value is the `module-name` defined in `web.xml` with `.war` "
"appended. The rest of the configuration uses the same XML syntax as "
"`keycloak-saml.xml` configuration defined in <<_saml-general-config,General "
"Adapter Config>>."
msgstr ""
"`secure-deployment` の `name` 属性は保護したいWARを識別します。 `web.xml` 内の `module-name` に"
" `.war` を付加した値となります。残りの設定は、<<_saml-general-config,共通アダプター設定>>で定義された "
"`keycloak-saml.xml` 設定と同じXML構文を使用します。"

msgid "An example configuration:"
msgstr "設定例を次に示します。"

msgid ""
"\n"
"<subsystem xmlns=\"urn:jboss:domain:keycloak-saml:1.1\">\n"
"  <secure-deployment name=\"saml-post-encryption.war\">\n"
"    <SP entityID=\"http://localhost:8080/sales-post-enc/\"\n"
"        sslPolicy=\"EXTERNAL\"\n"
"        nameIDPolicyFormat=\"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\"\n"
"        logoutPage=\"/logout.jsp\"\n"
"        forceAuthentication=\"false\">\n"
"      <Keys>\n"
"        <Key signing=\"true\" encryption=\"true\">\n"
"          <KeyStore resource=\"/WEB-INF/keystore.jks\" password=\"store123\">\n"
"            <PrivateKey alias=\"http://localhost:8080/sales-post-enc/\" password=\"test123\"/>\n"
"            <Certificate alias=\"http://localhost:8080/sales-post-enc/\"/>\n"
"          </KeyStore>\n"
"        </Key>\n"
"      </Keys>\n"
"      <PrincipalNameMapping policy=\"FROM_NAME_ID\"/>\n"
"      <RoleIdentifiers>\n"
"        <Attribute name=\"Role\"/>\n"
"      </RoleIdentifiers>\n"
"      <IDP entityID=\"idp\">\n"
"        <SingleSignOnService signRequest=\"true\"\n"
"            validateResponseSignature=\"true\"\n"
"            requestBinding=\"POST\"\n"
"            bindingUrl=\"http://localhost:8080{kc_realms_path}/saml-demo/protocol/saml\"/>\n"
"\n"
"        <SingleLogoutService\n"
"            validateRequestSignature=\"true\"\n"
"            validateResponseSignature=\"true\"\n"
"            signRequest=\"true\"\n"
"            signResponse=\"true\"\n"
"            requestBinding=\"POST\"\n"
"            responseBinding=\"POST\"\n"
"            postBindingUrl=\"http://localhost:8080{kc_realms_path}/saml-demo/protocol/saml\"\n"
"            redirectBindingUrl=\"http://localhost:8080{kc_realms_path}/saml-demo/protocol/saml\"/>\n"
"        <Keys>\n"
"          <Key signing=\"true\" >\n"
"            <KeyStore resource=\"/WEB-INF/keystore.jks\" password=\"store123\">\n"
"              <Certificate alias=\"saml-demo\"/>\n"
"            </KeyStore>\n"
"          </Key>\n"
"        </Keys>\n"
"      </IDP>\n"
"    </SP>\n"
"   </secure-deployment>\n"
"</subsystem>"
msgstr ""
"\n"
"<subsystem xmlns=\"urn:jboss:domain:keycloak-saml:1.1\">\n"
"  <secure-deployment name=\"saml-post-encryption.war\">\n"
"    <SP entityID=\"http://localhost:8080/sales-post-enc/\"\n"
"        sslPolicy=\"EXTERNAL\"\n"
"        nameIDPolicyFormat=\"urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified\"\n"
"        logoutPage=\"/logout.jsp\"\n"
"        forceAuthentication=\"false\">\n"
"      <Keys>\n"
"        <Key signing=\"true\" encryption=\"true\">\n"
"          <KeyStore resource=\"/WEB-INF/keystore.jks\" password=\"store123\">\n"
"            <PrivateKey alias=\"http://localhost:8080/sales-post-enc/\" password=\"test123\"/>\n"
"            <Certificate alias=\"http://localhost:8080/sales-post-enc/\"/>\n"
"          </KeyStore>\n"
"        </Key>\n"
"      </Keys>\n"
"      <PrincipalNameMapping policy=\"FROM_NAME_ID\"/>\n"
"      <RoleIdentifiers>\n"
"        <Attribute name=\"Role\"/>\n"
"      </RoleIdentifiers>\n"
"      <IDP entityID=\"idp\">\n"
"        <SingleSignOnService signRequest=\"true\"\n"
"            validateResponseSignature=\"true\"\n"
"            requestBinding=\"POST\"\n"
"            bindingUrl=\"http://localhost:8080{kc_realms_path}/saml-demo/protocol/saml\"/>\n"
"\n"
"        <SingleLogoutService\n"
"            validateRequestSignature=\"true\"\n"
"            validateResponseSignature=\"true\"\n"
"            signRequest=\"true\"\n"
"            signResponse=\"true\"\n"
"            requestBinding=\"POST\"\n"
"            responseBinding=\"POST\"\n"
"            postBindingUrl=\"http://localhost:8080{kc_realms_path}/saml-demo/protocol/saml\"\n"
"            redirectBindingUrl=\"http://localhost:8080{kc_realms_path}/saml-demo/protocol/saml\"/>\n"
"        <Keys>\n"
"          <Key signing=\"true\" >\n"
"            <KeyStore resource=\"/WEB-INF/keystore.jks\" password=\"store123\">\n"
"              <Certificate alias=\"saml-demo\"/>\n"
"            </KeyStore>\n"
"          </Key>\n"
"        </Keys>\n"
"      </IDP>\n"
"    </SP>\n"
"   </secure-deployment>\n"
"</subsystem>"

msgid "Tomcat SAML adapters"
msgstr "Tomcat SAMLアダプター"

msgid ""
"To be able to secure WAR apps deployed on Tomcat 7, 8 and 9 you must install"
" the Keycloak Tomcat 7 SAML adapter or Keycloak Tomcat SAML adapter into "
"your Tomcat installation. You then have to provide some extra configuration "
"in each WAR you deploy to Tomcat."
msgstr ""
"Tomcat 7、8、9にデプロイされたWARアプリケーションを保護するには、Keycloak Tomcat 7 "
"SAMLアダプターまたはKeycloak Tomcat "
"SAMLアダプターをTomcatにインストールする必要があります。その後、TomcatにデプロイするWARにもいくつかの設定を行う必要があります。"

msgid ""
"Download the adapter for the Tomcat version on your system from the "
"link:https://www.keycloak.org/downloads[Keycloak Downloads] site:"
msgstr ""
"link:https://www.keycloak.org/downloads[Keycloakダウンロード] "
"サイトから、システムで使用するバージョンのTomcatに対応したアダプターをダウンロードします。"

msgid "Install on the Tomcat version on your system:"
msgstr "以下のようにTomcatにインストールします。"

msgid ""
"$ cd $TOMCAT_HOME/lib\n"
"$ unzip keycloak-saml-tomcat7-adapter-dist.zip"
msgstr ""
"$ cd $TOMCAT_HOME/lib\n"
"$ unzip keycloak-saml-tomcat7-adapter-dist.zip"

msgid ""
"$ cd $TOMCAT_HOME/lib\n"
"$ unzip keycloak-saml-tomcat-adapter-dist.zip"
msgstr ""
"$ cd $TOMCAT_HOME/lib\n"
"$ unzip keycloak-saml-tomcat-adapter-dist.zip"

msgid ""
"Including the adapter's jars within your WEB-INF/lib directory will not "
"work. The Keycloak SAML adapter is implemented as a Valve and valve code "
"must reside in Tomcat's main lib/ directory."
msgstr ""
"アダプターのjarをWEB-INF/libディレクトリーに含めてもうまくいきません。Keycloak "
"SAMLアダプターはValveとして実装されており、ValveのコードはTomcatのメインlib/ディレクトリーに存在する必要があります。"

msgid ""
"Create a `META-INF/context.xml` file in your WAR package. This is a Tomcat "
"specific config file and you must define a Keycloak specific Valve."
msgstr ""
"WARパッケージに `META-INF/context.xml` "
"ファイルを作成します。これはTomcat固有の設定ファイルであり、Keycloak固有のValveを定義する必要があります。"

msgid ""
"<Context path=\"/your-context-path\">\n"
"    <Valve className=\"org.keycloak.adapters.saml.tomcat.SamlAuthenticatorValve\"/>\n"
"</Context>"
msgstr ""
"<Context path=\"/your-context-path\">\n"
"    <Valve className=\"org.keycloak.adapters.saml.tomcat.SamlAuthenticatorValve\"/>\n"
"</Context>"

msgid ""
"Create a `keycloak-saml.xml` adapter config file within the `WEB-INF` "
"directory of your WAR. The format of this config file is described in the "
"<<_saml-general-config,General Adapter Config>> section."
msgstr ""
"次に、WARの `WEB-INF` ディレクトリーに `keycloak-saml.xml` "
"アダプター設定ファイルを作成します。この設定ファイルの形式は、<<_saml-general-"
"config,共通アダプター設定>>のセクションで説明しています。"

msgid ""
"If the `keycloak-saml.xml` does not explicitly set "
"`assertionConsumerServiceUrl`, the SAML adapter will implicitly listen for "
"SAML assertions at the location `/my-context-path/saml`. This has to match "
"`Master SAML Processing URL` in the IDP realm/client settings, for example "
"`\\http://sp.domain.com/my-context-path/saml`. If not, Tomcat will probably "
"redirect infinitely to the IDP login service, as it does not receive the "
"SAML assertion after the user logged in."
msgstr ""
"`keycloak-saml.xml` が明示的に `assertionConsumerServiceUrl` "
"を設定しない場合、SAMLアダプターは暗黙的に `/my-context-path/saml` "
"の場所でSAMLアサーションをリッスンします。これは、IDPのレルム/クライアント設定の `Master SAML Processing URL` "
"と一致しなければなりません。たとえば、 `\\http://sp.domain.com/my-context-path/saml` "
"。そうでない場合、Tomcatはおそらくユーザーがログインした後にSAMLアサーションを受信しないため、IDPログインサービスに無限にリダイレクトします。"

msgid ""
"To set the `SameSite` value to `None` for `JSESSIONID` cookie in Tomcat add "
"following configuration to the`context.xml` of your application. Note, this "
"will set the `SameSite` value to `None` for all cookies created by Tomcat "
"container."
msgstr ""
"Tomcatの `JSESSIONID` Cookieの `SameSite` 値を `None` に設定するには、アプリケーションの "
"`context.xml` に次の設定を追加します。これにより、Tomcatコンテナーによって作成されたすべてのCookieの `SameSite` "
"値が `None` に設定されることに注意してください。"

msgid "<CookieProcessor sameSiteCookies=\"None\" />"
msgstr "<CookieProcessor sameSiteCookies=\"None\" />"

msgid ""
"It is not possible to set the `SameSite` attribute only to a subset of "
"cookies, therefore all cookies created for your application will have this "
"attribute set to `None`."
msgstr ""
"`SameSite` "
"属性をCookieのサブセットのみに設定することはできません。そのため、アプリケーション用に作成されたすべてのCookieでは、この属性が `None`"
" に設定されます。"

msgid ""
"The support for this feature is available in Tomcat from versions 9.0.29 and"
" 8.5.49."
msgstr "この機能のサポートは、バージョン9.0.29および8.5.49のTomcatで利用できます。"

msgid "Jetty SAML adapters"
msgstr "Jetty SAMLアダプター"

msgid ""
"To be able to secure WAR apps deployed on Jetty you must install the "
"{project_name} Jetty 9.x SAML adapter into your Jetty installation. You then"
" provide some extra configuration in each WAR you deploy to Jetty."
msgstr ""
"JettyにデプロイされたWARアプリケーションを保護するには、{project_name} Jetty 9.x "
"SAMLアダプターをJettyにインストールします。その後、JettyにデプロイするWARにもいくつかの設定を行う必要があります。"

msgid "Use the following installation and configuration procedures."
msgstr "以下のインストール手順と設定手順を使用してください。"

msgid "Jetty 9 Installing the adapter"
msgstr "Jetty 9 アダプターのインストール"

msgid ""
"{project_name} has a separate SAML adapter for Jetty 9.x. Adapters are no "
"longer included with the appliance or war distribution. Each adapter is a "
"separate download on the Keycloak download site. They are also available as "
"a maven artifact."
msgstr ""
"{project_name}には、Jetty 9.x "
"用の個別のSAMLアダプターがあります。アダプターは、アプライアンスまたはwarの配布物には含まれなくなりました。各アダプターは、Keycloakダウンロードサイトに個別にダウンロードされます。また、mavenアーティファクトとしても利用可能です。"

msgid "Unzip the Jetty 9.x distro into Jetty 9.x's root directory."
msgstr "Jetty 9.x用の配布物をJetty 9.xのルートディレクトリーに解凍してください。"

msgid ""
"Including adapter's jars within your WEB-INF/lib directory will not work."
msgstr "WEB-INF/libディレクトリー内にアダプターのjarを含めても動作しません。"

msgid ""
"$ cd $JETTY_HOME\n"
"$ unzip keycloak-saml-jetty92-adapter-dist.zip"
msgstr ""
"$ cd $JETTY_HOME\n"
"$ unzip keycloak-saml-jetty92-adapter-dist.zip"

msgid "Enable the keycloak module for your jetty.base."
msgstr "jetty.baseの keycloak モジュールを有効にします。"

msgid ""
"$ cd your-base\n"
"$ java -jar $JETTY_HOME/start.jar --add-to-startd=keycloak"
msgstr ""
"$ cd your-base\n"
"$ java -jar $JETTY_HOME/start.jar --add-to-startd=keycloak"

msgid "Jetty 9 WAR Configuration"
msgstr "Jetty 9のWARの設定"

msgid "Use this procedure to secure a WAR directly."
msgstr "WARを直接セキュリティー保護する場合は、この手順で行います。"

msgid ""
"Create a `WEB-INF/jetty-web.xml` file in your WAR package. This is a Jetty "
"specific config file and you must define a Keycloak specific authenticator "
"within it."
msgstr ""
"WARパッケージの中に `WEB-INF/jetty-web.xml` "
"ファイルを作成します。これはJetty固有の設定ファイルで、Keycloak固有のオーセンティケーター機能を定義する必要があります。"

msgid ""
"<?xml version=\"1.0\"?>\n"
"<!DOCTYPE Configure PUBLIC \"-//Mort Bay Consulting//DTD Configure//EN\" \"http://www.eclipse.org/jetty/configure_9_0.dtd\">\n"
"<Configure class=\"org.eclipse.jetty.webapp.WebAppContext\">\n"
"    <Get name=\"securityHandler\">\n"
"        <Set name=\"authenticator\">\n"
"            <New class=\"org.keycloak.adapters.saml.jetty.KeycloakSamlAuthenticator\">\n"
"            </New>\n"
"        </Set>\n"
"    </Get>\n"
"</Configure>"
msgstr ""
"<?xml version=\"1.0\"?>\n"
"<!DOCTYPE Configure PUBLIC \"-//Mort Bay Consulting//DTD Configure//EN\" \"http://www.eclipse.org/jetty/configure_9_0.dtd\">\n"
"<Configure class=\"org.eclipse.jetty.webapp.WebAppContext\">\n"
"    <Get name=\"securityHandler\">\n"
"        <Set name=\"authenticator\">\n"
"            <New class=\"org.keycloak.adapters.saml.jetty.KeycloakSamlAuthenticator\">\n"
"            </New>\n"
"        </Set>\n"
"    </Get>\n"
"</Configure>"

msgid "Java Servlet filter adapter"
msgstr "Javaサーブレット・フィルター・アダプター"

msgid ""
"If you want to use SAML with a Java servlet application that doesn't have an"
" adapter for that servlet platform, you can opt to use the servlet filter "
"adapter that {project_name} has. This adapter works a little differently "
"than the other adapters. You still have to specify a `/WEB-INF/keycloak-"
"saml.xml` file as defined in the <<_saml-general-config,General Adapter "
"Config>> section, but you do not define security constraints in _web.xml_. "
"Instead you define a filter mapping using the {project_name} servlet filter "
"adapter to secure the url patterns you want to secure."
msgstr ""
"サーブレット・プラットフォーム用のアダプターを持たないJavaサーブレット・アプリケーションでSAMLを使用する場合は、{project_name}にあるサーブレット・フィルター・アダプターを使用することができます。このアダプターは、他のアダプターとは少し異なります。<<_saml-"
"general-config,共通アダプター設定>>セクションで定義されているように `/WEB-INF/keycloak-saml.xml` "
"ファイルを指定する必要がありますが、 _web.xml_ "
"にセキュリティー制約を定義しません。代わりに{project_name}サーブレット・フィルター・アダプターを使用してフィルター・マッピングを定義して、URLパターンでセキュリティー保護します。"

msgid ""
"Backchannel logout works a bit differently than the standard adapters."
"       Instead of invalidating the http session it instead marks the session"
" ID as logged out.       There's just no way of arbitrarily invalidating an "
"http session based on a session ID."
msgstr ""
"バックチャネル・ログアウトは、標準のアダプターとは少し異なります。\n"
"HTTPセッションを無効にするのではなく、セッションIDをログアウトしたものとしてマークします。\n"
"セッションIDに基づいてHTTPセッションを任意に無効にする方法はありません。"

msgid ""
"Backchannel logout does not currently work when you have a clustered "
"application that uses the SAML filter."
msgstr "現時点では、SAMLフィルターを使用するクラスター化されたアプリケーションでは、バックチャネル・ログアウトは機能しません。"

msgid ""
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"      version=\"3.0\">\n"
"\n"
"\t<module-name>customer-portal</module-name>\n"
"\n"
"    <filter>\n"
"        <filter-name>Keycloak Filter</filter-name>\n"
"        <filter-class>org.keycloak.adapters.saml.servlet.SamlFilter</filter-class>\n"
"    </filter>\n"
"    <filter-mapping>\n"
"        <filter-name>Keycloak Filter</filter-name>\n"
"        <url-pattern>/*</url-pattern>\n"
"    </filter-mapping>\n"
"</web-app>"
msgstr ""
"<web-app xmlns=\"http://java.sun.com/xml/ns/javaee\"\n"
"      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n"
"      xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n"
"      version=\"3.0\">\n"
"\n"
"\t<module-name>customer-portal</module-name>\n"
"\n"
"    <filter>\n"
"        <filter-name>Keycloak Filter</filter-name>\n"
"        <filter-class>org.keycloak.adapters.saml.servlet.SamlFilter</filter-class>\n"
"    </filter>\n"
"    <filter-mapping>\n"
"        <filter-name>Keycloak Filter</filter-name>\n"
"        <url-pattern>/*</url-pattern>\n"
"    </filter-mapping>\n"
"</web-app>"

msgid ""
"The {project_name} filter has the same configuration parameters available as"
" the other adapters except you must define them as filter init params "
"instead of context params."
msgstr ""
"{project_name}フィルターは、コンテキスト・パラメータの代わりにフィルター初期化パラメータとして定義する必要がある以外は、他のアダプターと同じ設定パラメータを使用できます。"

msgid ""
"You can define multiple filter mappings if you have various different secure"
" and unsecure url patterns."
msgstr "さまざまな異なる安全なURLパターンと安全でないURLパターンが存在する場合は、複数のフィルター・マッピングを定義できます。"

msgid ""
"You must have a filter mapping that covers `/saml`.          This mapping "
"covers all server callbacks."
msgstr ""
"`/saml` をカバーするフィルター・マッピングが必要です。\n"
"このマッピングは、すべてのサーバー・コールバックを対象としています。"

msgid ""
"When registering SPs with an IdP, you must register "
"`http[s]://hostname/{context-root}/saml` as your Assert Consumer Service URL"
" and Single Logout Service URL."
msgstr ""
"IdPとともにSPを登録するときは、Assert Consumer Service URLとSingle Logout Service URLとして "
"`http[s]://hostname/{context-root}/saml` を登録する必要があります。"

msgid ""
"<dependency>\n"
"   <groupId>org.keycloak</groupId>\n"
"   <artifactId>keycloak-saml-servlet-filter-adapter</artifactId>\n"
"   <version>{project_versionMvn}</version>\n"
"</dependency>"
msgstr ""
"<dependency>\n"
"   <groupId>org.keycloak</groupId>\n"
"   <artifactId>keycloak-saml-servlet-filter-adapter</artifactId>\n"
"   <version>{project_versionMvn}</version>\n"
"</dependency>"

msgid ""
"In order to use <<_saml_multi_tenancy,Multi Tenancy>> the "
"`keycloak.config.resolver` parameter should be passed as a filter parameter."
msgstr ""
"<<_saml_multi_tenancy,マルチテナンシー>>を使用するには、 `keycloak.config.resolver` "
"パラメーターをフィルター・パラメーターとして渡す必要があります。"

msgid ""
"    <filter>\n"
"        <filter-name>Keycloak Filter</filter-name>\n"
"        <filter-class>org.keycloak.adapters.saml.servlet.SamlFilter</filter-class>\n"
"        <init-param>\n"
"            <param-name>keycloak.config.resolver</param-name>\n"
"            <param-value>example.SamlMultiTenantResolver</param-value>\n"
"        </init-param>\n"
"    </filter>"
msgstr ""
"    <filter>\n"
"        <filter-name>Keycloak Filter</filter-name>\n"
"        <filter-class>org.keycloak.adapters.saml.servlet.SamlFilter</filter-class>\n"
"        <init-param>\n"
"            <param-name>keycloak.config.resolver</param-name>\n"
"            <param-value>example.SamlMultiTenantResolver</param-value>\n"
"        </init-param>\n"
"    </filter>"

msgid "Registering with an Identity Provider"
msgstr "アイデンティティー・プロバイダーでの登録"

msgid ""
"For each servlet-based adapter, the endpoint you register for the assert "
"consumer service URL and single logout service must be the base URL of your "
"servlet application with `/saml` appended to it, that is, "
"`$$https://example.com/contextPath/saml$$`."
msgstr ""
"サーブレット・ベース・アダプターごとに、アサート・コンシューマー・サービスURLとシングル・ログアウト・サービスURLに登録するエンドポイントは、 "
"`/saml` が付加されるサーブレット・アプリケーションのベースURLでなければなりません。つまり、 "
"`$$https://example.com/contextPath/saml$$` のようなURLになります。"

msgid ""
"There are multiple ways you can logout from a web application. For Jakarta "
"EE servlet containers, you can call `HttpServletRequest.logout()`. For any "
"other browser application, you can point the browser at any url of your web "
"application that has a security constraint and pass in a query parameter "
"GLO, i.e. `$$http://myapp?GLO=true$$`. This will log you out if you have an "
"SSO session with your browser."
msgstr ""
"Webアプリケーションからログアウトするには、複数の方法があります。Jakarta EEサーブレット・コンテナーの場合は、 "
"`HttpServletRequest.logout()` "
"を呼び出すことができます。他のブラウザーアプリケーションでは、ブラウザーにセキュリティー制約のあるWebアプリケーションのURLを指定し、クエリー・パラメーターGLO、つまり、"
" `$$http://myapp?GLO=true$$` "
"を渡すことができます。これにより、ブラウザーとのSSOセッションがある場合は、ログアウトされます。"

msgid "Logout in clustered environment"
msgstr "クラスター環境でのログアウト"

msgid ""
"Internally, the SAML adapter stores a mapping between the SAML session "
"index, principal name (when known), and HTTP session ID. This mapping can be"
" maintained in JBoss application server family (WildFly 10/11, EAP 6/7) "
"across cluster for distributable applications. As a precondition, the HTTP "
"sessions need to be distributed across cluster (i.e. application is marked "
"with `<distributable/>` tag in application's `web.xml`)."
msgstr ""
"内部的には、SAMLアダプターは、SAMLセッション・インデックス、プリンシパル名（既知の場合）、およびHTTPセッションIDの間のマッピングを保存します。このマッピングは、分散アプリケーション用にJBossアプリケーション・サーバー・ファミリー（Wildfly"
" 10/11、EAP "
"6/7）のクラスター全体で維持されます。前提条件として、HTTPセッションをクラスター全体に分散する必要があります（つまり、アプリケーションの "
"`web.xml` に `<distributable/>` タグが設定されています）。"

msgid ""
"To enable the functionality, add the following section to your "
"`/WEB_INF/web.xml` file:"
msgstr "この機能を有効にするには、 `/WEB_INF/web.xml` ファイルに次のセクションを追加してください。"

msgid "For EAP 7, WildFly 10/11:"
msgstr "EAP 7、WildFly 10/11の場合："

msgid ""
"<context-param>\n"
"    <param-name>keycloak.sessionIdMapperUpdater.classes</param-name>\n"
"    <param-value>org.keycloak.adapters.saml.wildfly.infinispan.InfinispanSessionCacheIdMapperUpdater</param-value>\n"
"</context-param>"
msgstr ""
"<context-param>\n"
"    <param-name>keycloak.sessionIdMapperUpdater.classes</param-name>\n"
"    <param-value>org.keycloak.adapters.saml.wildfly.infinispan.InfinispanSessionCacheIdMapperUpdater</param-value>\n"
"</context-param>"

msgid "For EAP 6:"
msgstr "EAP 6の場合："

msgid ""
"<context-param>\n"
"    <param-name>keycloak.sessionIdMapperUpdater.classes</param-name>\n"
"    <param-value>org.keycloak.adapters.saml.jbossweb.infinispan.InfinispanSessionCacheIdMapperUpdater</param-value>\n"
"</context-param>"
msgstr ""
"<context-param>\n"
"    <param-name>keycloak.sessionIdMapperUpdater.classes</param-name>\n"
"    <param-value>org.keycloak.adapters.saml.jbossweb.infinispan.InfinispanSessionCacheIdMapperUpdater</param-value>\n"
"</context-param>"

msgid ""
"If the session cache of the deployment is named `_deployment-cache_`, the "
"cache used for SAML mapping will be named as `_deployment-cache_.ssoCache`. "
"The name of the cache can be overridden by a context parameter "
"`keycloak.sessionIdMapperUpdater.infinispan.cacheName`. The cache container "
"containing the cache will be the same as the one containing the deployment "
"session cache, but can be overridden by a context parameter "
"`keycloak.sessionIdMapperUpdater.infinispan.containerName`."
msgstr ""
"デプロイメントのセッション・キャッシュの名前が `_deployment-cache_` である場合、SAMLマッピングに使用されるキャッシュは "
"`_deployment-cache_.ssoCache` という名前になります。キャッシュの名前は、コンテキスト・パラメーター "
"`keycloak.sessionIdMapperUpdater.infinispan.cacheName` "
"によってオーバーライドできます。キャッシュを含むキャッシュ・コンテナーは、デプロイメント・セッション・キャッシュを含むキャッシュ・コンテナーと同じですが、コンテキスト・パラメーター"
" `keycloak.sessionIdMapperUpdater.infinispan.containerName` によってオーバーライドできます。"

msgid ""
"By default, the configuration of the SAML mapping cache will be derived from"
" session cache. The configuration can be manually overridden in cache "
"configuration section of the server just the same as other caches."
msgstr ""
"デフォルトでは、SAMLマッピング・キャッシュの設定はセッション・キャッシュから取得されます。この設定は、他のキャッシュとまったく同じサーバーのキャッシュ設定セクションで手動でオーバーライドできます。"

msgid ""
"Currently, to provide reliable service, it is recommended to use replicated "
"cache for the SAML session cache. Using distributed cache may lead to "
"results where the SAML logout request would land to a node with no access to"
" SAML session index to HTTP session mapping which would lead to unsuccessful"
" logout."
msgstr ""
"現在、信頼性の高いサービスを提供するために、SAMLセッション・キャッシュにレプリケート・キャッシュを使用することをお勧めします。分散キャッシュを使用すると、SAMLログアウト・リクエストがSAMLセッション・インデックスからHTTPセッション・マッピングへのアクセスがないノードに到達し、ログアウトに失敗する結果につながる可能性があります。"

msgid "Logout in cross-site scenario"
msgstr "クロスサイトのシナリオでのログアウト"

msgid ""
"The cross-site scenario only applies to WildFly 10 and higher, and EAP 7 and"
" higher."
msgstr "クロスサイトのシナリオは、WildFly 10以上、EAP 7以上にのみ適用されます。"

msgid ""
"Special handling is needed for handling sessions that span multiple data "
"centers. Imagine the following scenario:"
msgstr "複数のデータセンターにまたがるセッションを処理するには、特別な処理が必要です。以下のシナリオを想像してみてください。"

msgid "Login requests are handled within cluster in data center 1."
msgstr "ログイン・リクエストは、データセンター1のクラスター内で処理されます。"

msgid ""
"Admin issues logout request for a particular SAML session, the request lands"
" in data center 2."
msgstr "管理者が特定のSAMLセッションのログアウト・リクエストを発行すると、そのリクエストはデータセンター2に送信されます。"

msgid ""
"The data center 2 has to log out all sessions that are present in data "
"center 1 (and all other data centers that share HTTP sessions)."
msgstr ""
"データセンター2は、データセンター1（およびHTTPセッションを共有する他のすべてのデータセンター）に存在するすべてのセッションをログアウトする必要があります。"

msgid ""
"To cover this case, the SAML session cache described "
"<<_saml_logout_in_cluster,above>> needs to be replicated not only within "
"individual clusters but across all the data centers for example "
"https://access.redhat.com/documentation/en-"
"us/red_hat_data_grid/6.6/html/administration_and_configuration_guide/chap-"
"externalize_sessions#Externalize_HTTP_Session_from_JBoss_EAP_6.x_to_JBoss_Data_Grid[via"
" standalone Infinispan/JDG server]:"
msgstr ""
"このケースをカバーするために、<<_saml_logout_in_cluster,上記>>で記述されたSAMLセッション・キャッシュは、個々のクラスター内だけでなく、すべてのデータセンターにわたってレプリケーションする必要があります。例："
" https://access.redhat.com/documentation/en-"
"us/red_hat_data_grid/6.6/html/administration_and_configuration_guide/chap-"
"externalize_sessions#Externalize_HTTP_Session_from_JBoss_EAP_6.x_to_JBoss_Data_Grid[スタンドアローンInfinispan/JDGサーバー経由]："

msgid "A cache has to be added to the standalone Infinispan/JDG server."
msgstr "スタンドアローンのInfinispan/JDGサーバーにキャッシュを追加する必要があります。"

msgid ""
"The cache from previous item has to be added as a remote store for the "
"respective SAML session cache."
msgstr "前の項目のキャッシュは、それぞれのSAMLセッション・キャッシュ用にリモートストアとして追加する必要があります。"

msgid ""
"Once remote store is found to be present on SAML session cache during "
"deployment, it is watched for changes and the local SAML session cache is "
"updated accordingly."
msgstr ""
"デプロイ中にリモートストアがSAMLセッション・キャッシュに存在すると、変更が監視され、ローカルSAMLセッション・キャッシュがそれに応じて更新されます。"

msgid "Obtaining assertion attributes"
msgstr "アサーション属性の取得"

msgid ""
"After a successful SAML login, your application code may want to obtain "
"attribute values passed with the SAML assertion. "
"`HttpServletRequest.getUserPrincipal()` returns a `Principal` object that "
"you can typecast into a {project_name} specific class called "
"`org.keycloak.adapters.saml.SamlPrincipal`. This object allows you to look "
"at the raw assertion and also has convenience functions to look up attribute"
" values."
msgstr ""
"SAMLログインが成功したら、アプリケーションのコードで、SAMLアサーションに渡された属性値を取得したい場合があるかもしれません。 "
"`HttpServletRequest.getUserPrincipal()` は、 "
"`org.keycloak.adapters.saml.SamlPrincipal` "
"と呼ばれる{project_name}特有のクラスにキャスト可能な、 `Principal` "
"オブジェクトを返します。このオブジェクトには、未加工のアサーションを参照したり、属性値を取得する便利な機能があります。"

msgid ""
"package org.keycloak.adapters.saml;\n"
"\n"
"public class SamlPrincipal implements Serializable, Principal {\n"
"    /**\n"
"     * Get full saml assertion\n"
"     *\n"
"     * @return\n"
"     */\n"
"    public AssertionType getAssertion() {\n"
"       ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Get SAML subject sent in assertion\n"
"     *\n"
"     * @return\n"
"     */\n"
"    public String getSamlSubject() {\n"
"        ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Subject nameID format\n"
"     *\n"
"     * @return\n"
"     */\n"
"    public String getNameIDFormat() {\n"
"        ...\n"
"    }\n"
"\n"
"    @Override\n"
"    public String getName() {\n"
"        ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Convenience function that gets Attribute value by attribute name\n"
"     *\n"
"     * @param name\n"
"     * @return\n"
"     */\n"
"    public List<String> getAttributes(String name) {\n"
"        ...\n"
"\n"
"    }\n"
"\n"
"    /**\n"
"     * Convenience function that gets Attribute value by attribute friendly name\n"
"     *\n"
"     * @param friendlyName\n"
"     * @return\n"
"     */\n"
"    public List<String> getFriendlyAttributes(String friendlyName) {\n"
"        ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Convenience function that gets first  value of an attribute by attribute name\n"
"     *\n"
"     * @param name\n"
"     * @return\n"
"     */\n"
"    public String getAttribute(String name) {\n"
"        ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Convenience function that gets first  value of an attribute by attribute name\n"
"     *\n"
"     *\n"
"     * @param friendlyName\n"
"     * @return\n"
"     */\n"
"    public String getFriendlyAttribute(String friendlyName) {\n"
"        ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Get set of all assertion attribute names\n"
"     *\n"
"     * @return\n"
"     */\n"
"    public Set<String> getAttributeNames() {\n"
"        ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Get set of all assertion friendly attribute names\n"
"     *\n"
"     * @return\n"
"     */\n"
"    public Set<String> getFriendlyNames() {\n"
"        ...\n"
"    }\n"
"}"
msgstr ""
"package org.keycloak.adapters.saml;\n"
"\n"
"public class SamlPrincipal implements Serializable, Principal {\n"
"    /**\n"
"     * Get full saml assertion\n"
"     *\n"
"     * @return\n"
"     */\n"
"    public AssertionType getAssertion() {\n"
"       ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Get SAML subject sent in assertion\n"
"     *\n"
"     * @return\n"
"     */\n"
"    public String getSamlSubject() {\n"
"        ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Subject nameID format\n"
"     *\n"
"     * @return\n"
"     */\n"
"    public String getNameIDFormat() {\n"
"        ...\n"
"    }\n"
"\n"
"    @Override\n"
"    public String getName() {\n"
"        ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Convenience function that gets Attribute value by attribute name\n"
"     *\n"
"     * @param name\n"
"     * @return\n"
"     */\n"
"    public List<String> getAttributes(String name) {\n"
"        ...\n"
"\n"
"    }\n"
"\n"
"    /**\n"
"     * Convenience function that gets Attribute value by attribute friendly name\n"
"     *\n"
"     * @param friendlyName\n"
"     * @return\n"
"     */\n"
"    public List<String> getFriendlyAttributes(String friendlyName) {\n"
"        ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Convenience function that gets first  value of an attribute by attribute name\n"
"     *\n"
"     * @param name\n"
"     * @return\n"
"     */\n"
"    public String getAttribute(String name) {\n"
"        ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Convenience function that gets first  value of an attribute by attribute name\n"
"     *\n"
"     *\n"
"     * @param friendlyName\n"
"     * @return\n"
"     */\n"
"    public String getFriendlyAttribute(String friendlyName) {\n"
"        ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Get set of all assertion attribute names\n"
"     *\n"
"     * @return\n"
"     */\n"
"    public Set<String> getAttributeNames() {\n"
"        ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Get set of all assertion friendly attribute names\n"
"     *\n"
"     * @return\n"
"     */\n"
"    public Set<String> getFriendlyNames() {\n"
"        ...\n"
"    }\n"
"}"

msgid "Error Handling"
msgstr "エラー処理"

msgid ""
"{project_name} has some error handling facilities for servlet based client "
"adapters. When an error is encountered in authentication, the client adapter"
" will call `HttpServletResponse.sendError()`. You can set up an `error-page`"
" within your `web.xml` file to handle the error however you want. The client"
" adapter can throw 400, 401, 403, and 500 errors."
msgstr ""
"{project_name}には、サーブレットベースのクライアント・アダプター用のエラー処理機能があります。認証でエラーが発生すると、クライアント・アダプターは"
" `HttpServletResponse.sendError()` を呼び出します。 `web.xml` ファイル内にerror-"
"pageを設定してエラーを処理することができます。クライアント・アダプターは、400、401、403、500のエラーをスローできます。"

msgid ""
"The client adapter also sets an `HttpServletRequest` attribute that you can "
"retrieve. The attribute name is "
"`org.keycloak.adapters.spi.AuthenticationError`. Typecast this object to: "
"`org.keycloak.adapters.saml.SamlAuthenticationError`. This class can tell "
"you exactly what happened. If this attribute is not set, then the adapter "
"was not responsible for the error code."
msgstr ""
"クライアント・アダプターはまた、取得可能な `HttpServletRequest` 属性を設定します。属性名は、 "
"`org.keycloak.adapters.spi.AuthenticationError` です。このオブジェクトを "
"`org.keycloak.adapters.saml.SamlAuthenticationError` "
"にキャストします。このクラスは、正確に何が起こったかを伝えることができます。この属性が設定されない場合、アダプターはエラーコードに対して何もしません。"

msgid ""
"public class SamlAuthenticationError implements AuthenticationError {\n"
"    public static enum Reason {\n"
"        EXTRACTION_FAILURE,\n"
"        INVALID_SIGNATURE,\n"
"        ERROR_STATUS\n"
"    }\n"
"\n"
"    public Reason getReason() {\n"
"        return reason;\n"
"    }\n"
"    public StatusResponseType getStatus() {\n"
"        return status;\n"
"    }\n"
"}"
msgstr ""
"public class SamlAuthenticationError implements AuthenticationError {\n"
"    public static enum Reason {\n"
"        EXTRACTION_FAILURE,\n"
"        INVALID_SIGNATURE,\n"
"        ERROR_STATUS\n"
"    }\n"
"\n"
"    public Reason getReason() {\n"
"        return reason;\n"
"    }\n"
"    public StatusResponseType getStatus() {\n"
"        return status;\n"
"    }\n"
"}"

msgid "Troubleshooting"
msgstr "トラブルシューティング"

msgid ""
"The best way to troubleshoot problems is to turn on debugging for SAML in "
"both the client adapter and {project_name} Server. Using your logging "
"framework, set the log level to `DEBUG` for the `org.keycloak.saml` package."
" Turning this on allows you to see the SAML requests and response documents "
"being sent to and from the server."
msgstr ""
"問題を解決する最善の方法は、SAMLクライアント・アダプターと{project_name}サーバーの両方でデバッギングを有効にすることです。ロギング・フレームワークを使用して、"
" `org.keycloak.saml` パッケージのログ・レベルを `DEBUG` "
"に設定します。これを有効にすることで、サーバー間で送信されるSAMLのリクエスト/レスポンスのドキュメントを見ることができます。"

msgid ""
"SAML offers the same functionality as OIDC for <<_multi_tenancy,Multi "
"Tenancy>>, meaning that a single target application (WAR) can be secured "
"with multiple {project_name} realms. The realms can be located on the same "
"{project_name} instance or on different instances."
msgstr ""
"SAMLは、<<_multi_tenancy,マルチテナンシー>> "
"についてOIDCと同じ機能を提供します。つまり、単一のターゲット・アプリケーション（WAR）を複数の{project_name}レルムで保護できます。レルムは、同じ{project_name}インスタンスまたは異なるインスタンスに配置できます。"

msgid ""
"To do this, the application must have multiple `keycloak-saml.xml` adapter "
"configuration files."
msgstr "これを行うには、アプリケーションは複数の `keycloak-saml.xml` アダプター設定ファイルを持つ必要があります。"

msgid ""
"While you could have multiple instances of your WAR with different adapter "
"configuration files deployed to different context-paths, this may be "
"inconvenient and you may also want to select the realm based on something "
"other than context-path."
msgstr ""
"異なるコンテキストパスに異なるアダプター設定ファイルをデプロイして、WARの複数のインスタンスを作成することができますが、これは不便であり、コンテキストパス以外のものに基づいてレルムを選択することもできます。"

msgid ""
"{project_name} makes it possible to have a custom config resolver, so you "
"can choose which adapter config is used for each request. In SAML, the "
"configuration is only interesting in the login processing; once the user is "
"logged in, the session is authenticated and it does not matter if the "
"`keycloak-saml.xml` returned is different. For that reason, returning the "
"same configuration for the same session is the correct way to go."
msgstr ""
"{project_name}ではカスタム設定リゾルバーを持つことが可能なため、どのアダプター設定が各リクエストに使用されるかを選択することができます。SAMLでは、設定はログイン処理においてのみ関係しています。ユーザーがログインするとセッションは認証され、返される"
" `keycloak-saml.xml` が異なっていても問題ありません。そのため、同じセッションに対して同じ設定を返すことが正しい方法です。"

msgid ""
"To achieve this, create an implementation of "
"`org.keycloak.adapters.saml.SamlConfigResolver`. The following example uses "
"the `Host` header to locate the proper configuration and load it and the "
"associated elements from the applications's Java classpath:"
msgstr ""
"これを実現するためには、 `org.keycloak.adapters.saml.SamlConfigResolver` "
"の実装を作成してください。次の例では `Host` "
"ヘッダーを使って適切な設定を見つけ、それとアプリケーションのJavaクラスパスから関連する要素をロードしています。"

msgid ""
"package example;\n"
"\n"
"import java.io.InputStream;\n"
"import org.keycloak.adapters.saml.SamlConfigResolver;\n"
"import org.keycloak.adapters.saml.SamlDeployment;\n"
"import org.keycloak.adapters.saml.config.parsers.DeploymentBuilder;\n"
"import org.keycloak.adapters.saml.config.parsers.ResourceLoader;\n"
"import org.keycloak.adapters.spi.HttpFacade;\n"
"import org.keycloak.saml.common.exceptions.ParsingException;\n"
"\n"
"public class SamlMultiTenantResolver implements SamlConfigResolver {\n"
"\n"
"    @Override\n"
"    public SamlDeployment resolve(HttpFacade.Request request) {\n"
"        String host = request.getHeader(\"Host\");\n"
"        String realm = null;\n"
"        if (host.contains(\"tenant1\")) {\n"
"            realm = \"tenant1\";\n"
"        } else if (host.contains(\"tenant2\")) {\n"
"            realm = \"tenant2\";\n"
"        } else {\n"
"            throw new IllegalStateException(\"Not able to guess the keycloak-saml.xml to load\");\n"
"        }\n"
"\n"
"        InputStream is = getClass().getResourceAsStream(\"/\" + realm + \"-keycloak-saml.xml\");\n"
"        if (is == null) {\n"
"            throw new IllegalStateException(\"Not able to find the file /\" + realm + \"-keycloak-saml.xml\");\n"
"        }\n"
"\n"
"        ResourceLoader loader = new ResourceLoader() {\n"
"            @Override\n"
"            public InputStream getResourceAsStream(String path) {\n"
"                return getClass().getResourceAsStream(path);\n"
"            }\n"
"        };\n"
"\n"
"        try {\n"
"            return new DeploymentBuilder().build(is, loader);\n"
"        } catch (ParsingException e) {\n"
"            throw new IllegalStateException(\"Cannot load SAML deployment\", e);\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"package example;\n"
"\n"
"import java.io.InputStream;\n"
"import org.keycloak.adapters.saml.SamlConfigResolver;\n"
"import org.keycloak.adapters.saml.SamlDeployment;\n"
"import org.keycloak.adapters.saml.config.parsers.DeploymentBuilder;\n"
"import org.keycloak.adapters.saml.config.parsers.ResourceLoader;\n"
"import org.keycloak.adapters.spi.HttpFacade;\n"
"import org.keycloak.saml.common.exceptions.ParsingException;\n"
"\n"
"public class SamlMultiTenantResolver implements SamlConfigResolver {\n"
"\n"
"    @Override\n"
"    public SamlDeployment resolve(HttpFacade.Request request) {\n"
"        String host = request.getHeader(\"Host\");\n"
"        String realm = null;\n"
"        if (host.contains(\"tenant1\")) {\n"
"            realm = \"tenant1\";\n"
"        } else if (host.contains(\"tenant2\")) {\n"
"            realm = \"tenant2\";\n"
"        } else {\n"
"            throw new IllegalStateException(\"Not able to guess the keycloak-saml.xml to load\");\n"
"        }\n"
"\n"
"        InputStream is = getClass().getResourceAsStream(\"/\" + realm + \"-keycloak-saml.xml\");\n"
"        if (is == null) {\n"
"            throw new IllegalStateException(\"Not able to find the file /\" + realm + \"-keycloak-saml.xml\");\n"
"        }\n"
"\n"
"        ResourceLoader loader = new ResourceLoader() {\n"
"            @Override\n"
"            public InputStream getResourceAsStream(String path) {\n"
"                return getClass().getResourceAsStream(path);\n"
"            }\n"
"        };\n"
"\n"
"        try {\n"
"            return new DeploymentBuilder().build(is, loader);\n"
"        } catch (ParsingException e) {\n"
"            throw new IllegalStateException(\"Cannot load SAML deployment\", e);\n"
"        }\n"
"    }\n"
"}"

msgid ""
"You must also configure which `SamlConfigResolver` implementation to use "
"with the `keycloak.config.resolver` context-param in your `web.xml`:"
msgstr ""
"また、以下のように、 `web.xml` の `keycloak.config.resolver` context-paramでどの "
"`SamlConfigResolver` 実装を使うかを設定する必要もあります。"

msgid ""
"<web-app>\n"
"    ...\n"
"    <context-param>\n"
"        <param-name>keycloak.config.resolver</param-name>\n"
"        <param-value>example.SamlMultiTenantResolver</param-value>\n"
"    </context-param>\n"
"</web-app>"
msgstr ""
"<web-app>\n"
"    ...\n"
"    <context-param>\n"
"        <param-name>keycloak.config.resolver</param-name>\n"
"        <param-value>example.SamlMultiTenantResolver</param-value>\n"
"    </context-param>\n"
"</web-app>"

msgid "Migration from older versions"
msgstr "以前のバージョンからの移行"

msgid "Migrating to 1.9.0"
msgstr "1.9.0への移行"

msgid "SAML SP Client Adapter changes"
msgstr "SAML SPクライアント・アダプターの変更"

msgid ""
"Keycloak SAML SP Client Adapter now requires a specific endpoint, `/saml` to"
" be registered with your IdP. The SamlFilter must also be bound to /saml in "
"addition to any other binding it has. This had to be done because SAML POST "
"binding would eat the request input stream and this would be really bad for "
"clients that relied on it."
msgstr ""
"Keycloak SAML SPクライアント・アダプターでは、特定のエンドポイント（ `/saml` "
"）がIdPに登録されている必要があります。SamlFilterもまた、他のバインディングに加えて `/saml` "
"にもバインドされている必要があります。SAML "
"POSTバインディングがリクエスト入力ストリームを処理することになるため必要でした。これは、依存するクライアントにとって本当に悪いことです。"

msgid "mod_auth_mellon Apache HTTPD Module"
msgstr "mod_auth_mellon Apache HTTPDモジュール"

msgid ""
"The https://github.com/latchset/mod_auth_mellon[mod_auth_mellon] module is "
"an Apache HTTPD plugin for SAML. If your language/environment supports using"
" Apache HTTPD as a proxy, then you can use mod_auth_mellon to secure your "
"web application with SAML. For more details on this module see the "
"_mod_auth_mellon_ GitHub repo."
msgstr ""
"https://github.com/latchset/mod_auth_mellon[mod_auth_mellon] "
"モジュールは、SAML用のApache HTTPDプラグインです。使用している言語/環境がApache "
"HTTPDをプロキシーとして使用することをサポートしている場合、mod_auth_mellonを使用してWebアプリケーションをSAMLでセキュリティー保護できます。このモジュールの詳細については、"
" _mod_auth_mellon_ のGitHubリポジトリーを参照してください。"

msgid "To configure mod_auth_mellon you need:"
msgstr "mod_auth_mellonを設定するには、以下が必要です。"

msgid ""
"An Identity Provider (IdP) entity descriptor XML file, which describes the "
"connection to {project_name} or another SAML IdP"
msgstr ""
"アイデンティティー・プロバイダー（IdP）のエンティティー記述子XMLファイル。{project_name}または別のSAML "
"IdPへの接続情報を記述します。"

msgid ""
"An SP entity descriptor XML file, which describes the SAML connections and "
"configuration for the application you are securing."
msgstr "SPエンティティー記述子XMLファイル。セキュアにするアプリケーションのSAML接続と設定を記述します。"

msgid ""
"A private key PEM file, which is a text file in the PEM format that defines "
"the private key the application uses to sign documents."
msgstr "秘密鍵PEMファイル。アプリケーションが文書に署名するために使用する秘密鍵を定義するPEM形式のテキストファイルです。"

msgid ""
"A certificate PEM file, which is a text file that defines the certificate "
"for your application."
msgstr "証明書のPEMファイル。アプリケーションの証明書を定義するテキストファイルです。"

msgid "mod_auth_mellon-specific Apache HTTPD module configuration."
msgstr "mod_auth_mellon特有のApache HTTPDモジュールの設定。"

msgid ""
"If you have already defined and registered the client application within a "
"realm on the {project_name} application server, {project_name} can generate "
"all the files you need except the Apache HTTPD module configuration."
msgstr ""
"{project_name}アプリケーション・サーバーのレルム内にクライアント・アプリケーションを定義して登録している場合、{project_name}はApache"
" HTTPDモジュールの設定を除くすべての必要なファイルを生成できます。"

msgid ""
"Perform the following procedure to generate the Apache HTTPD module "
"configuration."
msgstr "以下の手順で、Apache HTTPDモジュールの設定を生成します。"

msgid "Go to the Installation page of your SAML client."
msgstr "SAMLクライアントのインストール・ページに移動します。"

msgid "Select the *Mod Auth Mellon* files option."
msgstr "*Mod Auth Mellon* ファイル・オプションを選択します。"

msgid "mod_auth_mellon config download"
msgstr "mod_auth_mellon設定のダウンロード"

msgid "image:{project_images}/mod-auth-mellon-config-download.png[]"
msgstr "image:{project_images}/mod-auth-mellon-config-download.png[]"

msgid ""
"Click *Download* to download a ZIP file that contains the XML descriptor and"
" PEM files you need."
msgstr "必要なXML記述子とPEMファイルを含むZIPファイルをダウンロードするには、 *Download* をクリックします。"

msgid "Configuring mod_auth_mellon with {project_name}"
msgstr "mod_auth_mellonの{project_name}との設定"

msgid "There are two hosts involved:"
msgstr "関連するホストは2つあります。"

msgid ""
"The host on which {project_name} is running, which will be referred to as "
"$idp_host because {project_name} is a SAML identity provider (IdP)."
msgstr ""
"{project_name}が実行されているホスト。{project_name}がSAMLアイデンティティー・プロバイダー（IdP）であるため、$idp_hostと呼ばれます。"

msgid ""
"The host on which the web application is running, which will be referred to "
"as $sp_host. In SAML an application using an IdP is called a service "
"provider (SP)."
msgstr ""
"Webアプリケーションが実行されているホスト。$sp_hostと呼ばれます。SAMLでは、IdPを使用するアプリケーションをサービス・プロバイダー（SP）と呼びます。"

msgid ""
"All of the following steps need to performed on $sp_host with root "
"privileges."
msgstr "次のすべての手順は、root特権で$sp_hostに対して実行される必要があります。"

msgid "Installing the packages"
msgstr "パッケージのインストール"

msgid "To install the necessary packages, you will need:"
msgstr "必要なパッケージをインストールするには、次のものが必要です。"

msgid "Apache Web Server (httpd)"
msgstr "Apache Webサーバー（httpd）"

msgid "Mellon SAML SP add-on module for Apache"
msgstr "Apache用のMellon SAML SPアドオン・モジュール"

msgid "Tools to create X509 certificates"
msgstr "X509証明書を作成するためのツール"

msgid "To install the necessary packages, run this command:"
msgstr "必要なパッケージをインストールするには、次のコマンドを実行します。"

msgid "yum install httpd mod_auth_mellon mod_ssl openssl"
msgstr "yum install httpd mod_auth_mellon mod_ssl openssl"

msgid "Creating a configuration directory for Apache SAML"
msgstr "Apache SAMLの設定ディレクトリーの作成"

msgid ""
"It is advisable to keep configuration files related to Apache's use of SAML "
"in one location."
msgstr "ApacheのSAML使用に関する設定ファイルは、1か所に保存することをお勧めします。"

msgid ""
"Create a new directory named saml2 located under the Apache configuration "
"root /etc/httpd:"
msgstr "Apache設定ルート（/etc/httpd）の下に、saml2という名前の新しいディレクトリーを作成します。"

msgid "mkdir /etc/httpd/saml2"
msgstr "mkdir /etc/httpd/saml2"

msgid "Configuring the Mellon Service Provider"
msgstr "Mellonサービス・プロバイダーの設定"

msgid ""
"Configuration files for Apache add-on modules are located in the "
"/etc/httpd/conf.d directory and have a file name extension of .conf. You "
"need to create the /etc/httpd/conf.d/mellon.conf file and place Mellon's "
"configuration directives in it."
msgstr ""
"Apacheアドオン・モジュールの設定ファイルは/etc/httpd/conf.dディレクトリーにあり、拡張子は.confです。/etc/httpd/conf.d/mellon.confファイルを作成し、Mellonの設定ディレクティブをその中に置く必要があります。"

msgid ""
"Mellon's configuration directives can roughly be broken down into two "
"classes of information:"
msgstr "Mellonの設定ディレクティブは、大まかに2つのクラスの情報に分類できます。"

msgid "Which URLs to protect with SAML authentication"
msgstr "SAML認証で保護するURL"

msgid "What SAML parameters will be used when a protected URL is referenced."
msgstr "保護されたURLが参照されるときに使用されるSAMLパラメーター。"

msgid ""
"Apache configuration directives typically follow a hierarchical tree "
"structure in the URL space, which are known as locations. You need to "
"specify one or more URL locations for Mellon to protect. You have "
"flexibility in how you add the configuration parameters that apply to each "
"location. You can either add all the necessary parameters to the location "
"block or you can add Mellon parameters to a common location high up in the "
"URL location hierarchy that specific protected locations inherit (or some "
"combination of the two). Since it is common for an SP to operate in the same"
" way no matter which location triggers SAML actions, the example "
"configuration used here places common Mellon configuration directives in the"
" root of the hierarchy and then specific locations to be protected by Mellon"
" can be defined with minimal directives. This strategy avoids duplicating "
"the same parameters for each protected location."
msgstr ""
"Apacheの設定ディレクティブは通常、URL空間の階層ツリー構造に従います。これらは、ロケーションとして知られています。Mellonが保護するURLのロケーションを1つ以上指定する必要があります。各場所に適用される設定パラメーターの追加方法には柔軟性があります。ロケーション・ブロックに必要なすべてのパラメーターを追加するか、特定の保護されたロケーションが継承するURLロケーション階層の上位の共通の場所（またはその両方の組み合わせ）にMellonパラメーターを追加できます。どのロケーションがSAMLアクションをトリガーするかにかかわらず、同じ方法でSPが動作するのが一般的であるため、ここで使用されている設定例では、Mellon設定ディレクティブを階層のルートに置き、Mellonによって保護される特定のロケーションを最小限のディレクティブで定義できます。この戦略は、保護された各ロケーションで同じパラメーターを複製することを回避します。"

msgid ""
"This example has just one protected location: \\https://$sp_host/private."
msgstr "この例では、保護された場所は \\https://$sp_host/private 1つだけです。"

msgid ""
"To configure the Mellon service provider, perform the following procedure."
msgstr "Mellonサービス・プロバイダーの設定は、以下の手順で行います。"

msgid "Create the file /etc/httpd/conf.d/mellon.conf with this content:"
msgstr "/etc/httpd/conf.d/mellon.confファイルを次の内容で作成します。"

msgid ""
" <Location / >\n"
"    MellonEnable info\n"
"    MellonEndpointPath /mellon/\n"
"    MellonSPMetadataFile /etc/httpd/saml2/mellon_metadata.xml\n"
"    MellonSPPrivateKeyFile /etc/httpd/saml2/mellon.key\n"
"    MellonSPCertFile /etc/httpd/saml2/mellon.crt\n"
"    MellonIdPMetadataFile /etc/httpd/saml2/idp_metadata.xml\n"
" </Location>\n"
" <Location /private >\n"
"    AuthType Mellon\n"
"    MellonEnable auth\n"
"    Require valid-user\n"
" </Location>"
msgstr ""
" <Location / >\n"
"    MellonEnable info\n"
"    MellonEndpointPath /mellon/\n"
"    MellonSPMetadataFile /etc/httpd/saml2/mellon_metadata.xml\n"
"    MellonSPPrivateKeyFile /etc/httpd/saml2/mellon.key\n"
"    MellonSPCertFile /etc/httpd/saml2/mellon.crt\n"
"    MellonIdPMetadataFile /etc/httpd/saml2/idp_metadata.xml\n"
" </Location>\n"
" <Location /private >\n"
"    AuthType Mellon\n"
"    MellonEnable auth\n"
"    Require valid-user\n"
" </Location>"

msgid ""
"Some of the files referenced in the code above are created in later steps."
msgstr "上記のコードで参照されているファイルの一部は、後の手順で作成されます。"

msgid "Setting the SameSite value for the cookie used by mod_auth_mellon"
msgstr "mod_auth_mellonが使用するCookieのSameSite値を設定する"

msgid ""
"Browsers are planning to set the default value for the `SameSite` attribute "
"for cookies to `Lax`. This setting means that cookies will be sent to "
"applications only if the request originates in the same domain. This "
"behavior can affect the SAML POST binding which may become non-functional. "
"To preserve full functionality of the _mod_auth_mellon_ module, we recommend"
" setting the `SameSite` value to `None` for the cookie created by "
"_mod_auth_mellon_. Not doing so may result in an inability to login using "
"{project_name}."
msgstr ""
"ブラウザーは、Cookieの `SameSite` 属性のデフォルト値を `Lax` "
"に設定することを計画しています。この設定は、リクエストが同じドメインで発生した場合にのみCookieがアプリケーションに送信されることを意味します。この動作はSAML"
" POSTバインディングに影響を与え、機能しなくなる可能性があります。 _mod_auth_mellon_ モジュールの完全な機能を保持するために、 "
"_mod_auth_mellon_ モジュールによって作成されたCookieの `SameSite` 値を `None` "
"に設定することをお勧めします。そうしないと、{project_name}を使用してログインできなくなる場合があります。"

msgid ""
"To set the `SameSite` value to `None`, add the following configuration to "
"`<Location / >` tag within your `mellon.conf` file."
msgstr ""
"`SameSite` の値を `None` に設定するには、次の設定を `mellon.conf` ファイル内の `<Location / >` "
"タグに追加します。"

msgid ""
"MellonSecureCookie On\n"
"MellonCookieSameSite none"
msgstr ""
"MellonSecureCookie On\n"
"MellonCookieSameSite none"

msgid ""
"The support for this configuration is available in the _mod_auth_mellon_ "
"module from version 0.16.0."
msgstr "この設定のサポートは、バージョン0.16.0以降の _mod_auth_mellon_ モジュールで利用できます。"

msgid "Creating the Service Provider metadata"
msgstr "サービス・プロバイダーのメタデータの作成"

msgid ""
"In SAML IdPs and SPs exchange SAML metadata, which is in XML format. The "
"schema for the metadata is a standard, thus assuring participating SAML "
"entities can consume each other's metadata. You need:"
msgstr ""
"SAMLではIdPとSPがXML形式のSAMLメタデータを交換します。メタデータのスキーマは標準であるため、参加するSAMLエンティティーが互いのメタデータを消費できることが保証されます。必要なものは次のとおりです。"

msgid "Metadata for the IdP that the SP utilizes"
msgstr "SPが利用するIdPのメタデータ"

msgid "Metadata describing the SP provided to the IdP"
msgstr "IdPに提供されたSPを記述するメタデータ"

msgid ""
"One of the components of SAML metadata is X509 certificates. These "
"certificates are used for two purposes:"
msgstr "SAMLメタデータのコンポーネントの1つはX509証明書です。この証明書は、2つの目的で使用されます。"

msgid ""
"Sign SAML messages so the receiving end can prove the message originated "
"from the expected party."
msgstr "受信側が予想される相手から発信されたメッセージを証明できるように、SAMLメッセージに署名します。"

msgid ""
"Encrypt the message during transport (seldom used because SAML messages "
"typically occur on TLS-protected transports)"
msgstr ""
"トランスポート中にメッセージを暗号化します（ほとんどの場合、SAMLメッセージはTLSで保護されたトランスポートで発生するため、使用されません）"

msgid ""
"You can use your own certificates if you already have a Certificate "
"Authority (CA) or you can generate a self-signed certificate. For simplicity"
" in this example a self-signed certificate is used."
msgstr ""
"すでに認証局（CA）がある場合、または自己署名証明書を生成できる場合は、独自の証明書を使用できます。この例では、簡単のため、自己署名証明書が使用されています。"

msgid ""
"Because Mellon's SP metadata must reflect the capabilities of the installed "
"version of mod_auth_mellon, must be valid SP metadata XML, and must contain "
"an X509 certificate (whose creation can be obtuse unless you are familiar "
"with X509 certificate generation) the most expedient way to produce the SP "
"metadata is to use a tool included in the mod_auth_mellon package "
"(mellon_create_metadata.sh). The generated metadata can always be edited "
"later because it is a text file. The tool also creates your X509 key and "
"certificate."
msgstr ""
"MellonのSPメタデータは、mod_auth_mellonのインストールされたバージョンの機能を反映する必要があるため、有効なSPメタデータXMLでなければならず、X509証明書（X509証明書の生成に慣れていない限り、その作成は難解になることがあります）を含む必要があります。SPメタデータを生成する最も便利な方法は、mod_auth_mellonパッケージに含まれているツール（"
" `mellon_create_metadata.sh` "
"）を使用することです。生成されたメタデータは、テキストファイルであるため、後で編集することができます。このツールは、X509の鍵と証明書も作成します。"

msgid ""
"SAML IdPs and SPs identify themselves using a unique name known as an "
"EntityID. To use the Mellon metadata creation tool you need:"
msgstr ""
"SAMLのIdPとSPは、EntityIDという固有の名前を使用して自分自身を識別します。Mellonのメタデータ作成ツールを使用するには、次のものが必要です。"

msgid ""
"The EntityID, which is typically the URL of the SP, and often the URL of the"
" SP where the SP metadata can be retrieved"
msgstr "EntityID。通常SPのURLであり、しばしばSPメタデータを取得できるSPのURLです。"

msgid ""
"The URL where SAML messages for the SP will be consumed, which Mellon calls "
"the MellonEndPointPath."
msgstr "SPのSAMLメッセージが消費されるURL（MellonがMellonEndPointPathを呼び出すURL）。"

msgid "To create the SP metadata, perform the following procedure."
msgstr "SPメタデータを作成するには、以下の手順を実行します。"

msgid "Create a few helper shell variables:"
msgstr "ヘルパーのシェル変数をいくつか作成します。"

msgid ""
"fqdn=`hostname`\n"
"mellon_endpoint_url=\"https://${fqdn}/mellon\"\n"
"mellon_entity_id=\"${mellon_endpoint_url}/metadata\"\n"
"file_prefix=\"$(echo \"$mellon_entity_id\" | sed 's/[^A-Za-z.]/_/g' | sed 's/__*/_/g')\""
msgstr ""
"fqdn=`hostname`\n"
"mellon_endpoint_url=\"https://${fqdn}/mellon\"\n"
"mellon_entity_id=\"${mellon_endpoint_url}/metadata\"\n"
"file_prefix=\"$(echo \"$mellon_entity_id\" | sed 's/[^A-Za-z.]/_/g' | sed 's/__*/_/g')\""

msgid "Invoke the Mellon metadata creation tool by running this command:"
msgstr "次のコマンドを実行して、Mellonメタデータ作成ツールを呼び出します。"

msgid ""
"/usr/libexec/mod_auth_mellon/mellon_create_metadata.sh $mellon_entity_id "
"$mellon_endpoint_url"
msgstr ""
"/usr/libexec/mod_auth_mellon/mellon_create_metadata.sh $mellon_entity_id "
"$mellon_endpoint_url"

msgid ""
"Move the generated files to their destination (referenced in the "
"/etc/httpd/conf.d/mellon.conf file created above):"
msgstr "生成されたファイルを目的の場所に移動します（上記の/etc/httpd/conf.d/mellon.confファイルを参照）。"

msgid ""
"mv ${file_prefix}.cert /etc/httpd/saml2/mellon.crt\n"
"mv ${file_prefix}.key /etc/httpd/saml2/mellon.key\n"
"mv ${file_prefix}.xml /etc/httpd/saml2/mellon_metadata.xml"
msgstr ""
"mv ${file_prefix}.cert /etc/httpd/saml2/mellon.crt\n"
"mv ${file_prefix}.key /etc/httpd/saml2/mellon.key\n"
"mv ${file_prefix}.xml /etc/httpd/saml2/mellon_metadata.xml"

msgid ""
"Adding the Mellon Service Provider to the {project_name} Identity Provider"
msgstr "{project_name}アイデンティティー・プロバイダーにMellonサービス・プロバイダーを追加する"

msgid ""
"Assumption: The {project_name} IdP has already been installed on the "
"$idp_host."
msgstr "仮定: {project_name}のIdPはすでに$idp_hostにインストールされています。"

msgid ""
"{project_name} supports multiple tenancy where all users, clients, and so on"
" are grouped in what is called a realm. Each realm is independent of other "
"realms. You can use an existing realm in your {project_name}, but this "
"example shows how to create a new realm called test_realm and use that "
"realm."
msgstr ""
"{project_name}は複数のテナントをサポートしており、すべてのユーザー、クライアントなどがレルムと呼ばれる領域にグループ化されます。各レルムは他のレルムとは独立しています。{project_name}に既存のレルムを使用できますが、この例では、test_realmという新しいレルムを作成し、そのレルムを使用する方法を示しています。"

msgid ""
"All these operations are performed using the {project_name} Admin Console. "
"You must have the admin username and password for $idp_host to perform the "
"following procedure."
msgstr ""
"これらの操作はすべて、{project_name}管理コンソールで行います。以下の手順を実行するには、 $idp_host "
"の管理者ユーザー名とパスワードが必要です。"

msgid ""
"Open the Admin Console and log on by entering the admin username and "
"password."
msgstr "管理コンソールを開き、管理者のユーザー名とパスワードを入力してログオンします。"

msgid ""
"After logging into the Admin Console, there will be an existing realm. When "
"{project_name} is first set up a root realm, master, is created by default. "
"Any previously created realms are listed in the upper left corner of the "
"Admin Console in a drop-down list."
msgstr ""
"管理コンソールにログインすると、既存のレルムが存在します。{project_name}を最初に設定すると、デフォルトでルート・レルムのmasterが作成されます。以前に作成されたレルムは、管理コンソールの左上隅にドロップダウン・リストに表示されます。"

msgid "From the realm drop-down list select *Add realm*."
msgstr "レルムのドロップダウン・リストから *Add realm* を選択します。"

msgid "In the Name field type `test_realm` and click *Create*."
msgstr "名前フィールドに `test_realm` と入力し、 *Create* をクリックします。"

msgid "Adding the Mellon Service Provider as a client of the realm"
msgstr "Mellonサービス・プロバイダーをレルムのクライアントとして追加する"

msgid ""
"In {project_name} SAML SPs are known as clients. To add the SP we must be in"
" the Clients section of the realm."
msgstr ""
"{project_name}では、SAML SPはクライアントと呼ばれます。SPを追加するには、レルムのクライアントのセクションに移動します。"

msgid ""
"Click the Clients menu item on the left and click *Create* in the upper "
"right corner to create a new client."
msgstr "左側のClientsメニュー項目をクリックし、右上の *Create* をクリックして新しいクライアントを作成します。"

msgid "Adding the Mellon SP client"
msgstr "Mellon SPクライアントの追加"

msgid "To add the Mellon SP client, perform the following procedure."
msgstr "Mellon SPクライアントを追加するには、以下の手順を実行します。"

msgid "Set the client protocol to SAML."
msgstr "クライアント・プロトコルをSAMLに設定します。"

msgid "From the Client Protocol drop down list, select *saml*."
msgstr "Client Protocolのドロップダウン・リストから、 *saml* を選択します。"

msgid ""
"Provide the Mellon SP metadata file created above "
"(/etc/httpd/saml2/mellon_metadata.xml)."
msgstr ""
"上記で作成したMellon SPのメタデータファイル（/etc/httpd/saml2/mellon_metadata.xml）を用意します。"

msgid ""
"Depending on where your browser is running you might have to copy the SP "
"metadata from $sp_host to the machine on which your browser is running so "
"the browser can find the file."
msgstr ""
"ブラウザーが動作している場所によっては、SPメタデータを $sp_host "
"からブラウザーが動作しているマシンにコピーして、ブラウザーがファイルを見つけられるようにする必要があるかもしれません。"

msgid "Click *Save*."
msgstr "*Save* をクリックします。"

msgid "Editing the Mellon SP client"
msgstr "Mellon SPクライアントの編集"

msgid "Use this procedure to set important client configuration parameters."
msgstr "この手順では、重要なクライアント設定パラメーターを設定します。"

msgid "Ensure \"Force POST Binding\" is On."
msgstr "\"Force POST Binding\"がオンになっていることを確認します。"

msgid "Add paosResponse to the Valid Redirect URIs list:"
msgstr "有効なリダイレクトURIリストにpaosResponseを追加します。"

msgid ""
"Copy the postResponse URL in \"Valid Redirect URIs\" and paste it into the "
"empty add text fields just below the \"+\"."
msgstr ""
"\"Valid Redirect URIs\"内のpostResponse URLをコピーし、 "
"\"+\"のすぐ下の空の追加テキスト・フィールドに貼り付けます。"

msgid ""
"Change \"postResponse\" to \"paosResponse\". (The paosResponse URL is needed"
" for SAML ECP.)"
msgstr "\"postResponse\"を\"paosResponse\"に変更します（SAML ECPにはpaosResponse URLが必要です）。"

msgid "Click *Save* at the bottom."
msgstr "下部の *Save* をクリックしてください。"

msgid ""
"Many SAML SPs determine authorization based on a user's membership in a "
"group. The {project_name} IdP can manage user group information but it does "
"not supply the user's groups unless the IdP is configured to supply it as a "
"SAML attribute."
msgstr ""
"多くのSAML "
"SPは、グループ内のユーザーのメンバーシップに基づいて認可を決定します。{project_name}のIdPはユーザー・グループ情報を管理できますが、IdPがSAML属性としてそれを提供するように設定されていない限り、ユーザーのグループは提供されません。"

msgid ""
"Perform the following procedure to configure the IdP to supply the user's "
"groups as as a SAML attribute."
msgstr "以下の手順で、SAML属性としてユーザーのグループを提供するようにIdPを設定します。"

msgid "Click the Mappers tab of the client."
msgstr "クライアントのMapperタブをクリックします。"

msgid "In the upper right corner of the Mappers page, click *Create*."
msgstr "Mapperページの右上にある *Create* をクリックします。"

msgid "From the Mapper Type drop-down list select *Group list*."
msgstr "Mapper Typeのドロップダウン・リストから *Group list* を選択します。"

msgid "Set Name to \"group list\"."
msgstr "\"group list\"に名前を設定します。"

msgid "Set the SAML attribute name to \"groups\"."
msgstr "\"groups\"にSAML属性名を設定します。"

msgid "The remaining steps are performed on $sp_host."
msgstr "残りの手順は$sp_hostで実行されます。"

msgid "Retrieving the Identity Provider metadata"
msgstr "アイデンティティー・プロバイダー・メタデータの取得"

msgid ""
"Now that you have created the realm on the IdP you need to retrieve the IdP "
"metadata associated with it so the Mellon SP recognizes it. In the "
"/etc/httpd/conf.d/mellon.conf file created previously, the "
"MellonIdPMetadataFile is specified as /etc/httpd/saml2/idp_metadata.xml but "
"until now that file has not existed on $sp_host."
msgstr ""
"IdPでレルムを作成したので、それに関連付けられたIdPメタデータを取得して、Mellon "
"SPがそれを認識できるようにする必要があります。前に作成した/etc/httpd/conf.d/mellon.confファイルでは、MellonIdPMetadataFileは/etc/httpd/saml2/idp_metadata.xmlとして指定されていますが、そのファイルは$sp_host上に存在しませんでした。"

msgid "Use this procedure to retrieve that file from the IdP."
msgstr "この手順で、IdPからそのファイルを取得します。"

msgid "Use this command, substituting with the correct value for $idp_host:"
msgstr "このコマンドは、 $idp_host に正しい値を代入して使用してください。"

msgid ""
"curl -k -o /etc/httpd/saml2/idp_metadata.xml \\\n"
"https://$idp_host{kc_realms_path}/test_realm/protocol/saml/descriptor"
msgstr ""
"curl -k -o /etc/httpd/saml2/idp_metadata.xml \\\n"
"https://$idp_host{kc_realms_path}/test_realm/protocol/saml/descriptor"

msgid "Mellon is now fully configured."
msgstr "これでMellonの設定は完了となります。"

msgid ""
"To run a syntax check for Apache configuration files, use this command:"
msgstr "Apacheの設定ファイルのシンタックス・チェックを行うには、このコマンドを使用します。"

msgid "apachectl configtest"
msgstr "apachectl configtest"

msgid ""
"Configtest is equivalent to the -t argument to apachectl. If the "
"configuration test shows any errors, correct them before proceeding."
msgstr "Configtestは apachectl の -t 引数に相当します。設定テストでエラーが示された場合は、先に進む前に修正してください。"

msgid "Restart the Apache server:"
msgstr "Apacheサーバーを再起動します。"

msgid "systemctl restart httpd.service"
msgstr "systemctl restart httpd.service"

msgid ""
"You have now set up both {project_name} as a SAML IdP in the test_realm and "
"mod_auth_mellon as SAML SP protecting the URL $sp_host/protected (and "
"everything beneath it) by authenticating against the ``$idp_host`` IdP."
msgstr ""
"``$ idp_host`` "
"のIdPに対して認証することで、$sp_host/protected（とその配下すべて）のURLを保護するように、test_realmのSAML "
"IdPとして{project_name}を、SAML SPとしてmod_auth_mellonを設定しました。"

msgid "Configuring a Docker registry to use {project_name}"
msgstr "{project_name}を利用するためのDockerレジストリーの設定"

msgid ""
"Docker authentication is disabled by default. To enable see "
"link:{installguide_profile_link}[{installguide_profile_name}]."
msgstr ""
"Docker認証はデフォルトで無効です。有効にするには、link:{installguide_profile_link}[{installguide_profile_name}]を参照してください。"

msgid ""
"This section describes how you can configure a Docker registry to use "
"{project_name} as its authentication server."
msgstr ""
"このセクションでは、{project_name}を認証サーバーとして使用するようにDockerレジストリーを設定する方法について説明します。"

msgid ""
"For more information on how to set up and configure a Docker registry, see "
"the link:https://docs.docker.com/registry/configuration/[Docker Registry "
"Configuration Guide]."
msgstr ""
"Dockerレジストリーを設定および設定する方法の詳細については、link:https://docs.docker.com/registry/configuration/[Docker"
" Registry Configuration Guide]を参照してください。"

msgid "Docker registry configuration file installation"
msgstr "Dockerレジストリーの設定ファイルのインストール"

msgid ""
"For users with more advanced Docker registry configurations, it is generally"
" recommended to provide your own registry configuration file.  The "
"{project_name} Docker provider supports this mechanism via the _Registry "
"Config File_ Format Option.  Choosing this option will generate output "
"similar to the following:"
msgstr ""
"より高度なDockerレジストリー設定を持つユーザーの場合は、通常、独自のレジストリー設定ファイルを提供することをお勧めします。{project_name}"
" Dockerプロバイダーは、 _Registry Config File_ Format "
"Optionを使用してこのメカニズムをサポートしています。このオプションを選択すると、次のような出力が生成されます。"

msgid ""
"auth:\n"
"  token:\n"
"    realm: http://localhost:8080{kc_realms_path}/master/protocol/docker-v2/auth\n"
"    service: docker-test\n"
"    issuer: http://localhost:8080{kc_realms_path}/master"
msgstr ""
"auth:\n"
"  token:\n"
"    realm: http://localhost:8080{kc_realms_path}/master/protocol/docker-v2/auth\n"
"    service: docker-test\n"
"    issuer: http://localhost:8080{kc_realms_path}/master"

msgid ""
"This output can then be copied into any existing registry config file.  See "
"the link:https://docs.docker.com/registry/configuration/[registry config "
"file specification] for more information on how the file should be set up, "
"or start with "
"link:https://github.com/distribution/distribution/blob/main/cmd/registry/config-"
"example.yml[a basic example]."
msgstr ""
"この出力は、既存のレジストリー設定ファイルにコピーできます。ファイルの設定方法の詳細については、link:https://docs.docker.com/registry/configuration/[レジストリー設定ファイルの仕様]を参照してください。または、link:https://github.com/distribution/distribution/blob/main/cmd/registry/config-"
"example.yml[基本的な例]から始めてください。"

msgid ""
"Don't forget to configure the `rootcertbundle` field with the location of "
"the {project_name} realm's public key.  The auth configuration will not work"
" without this argument."
msgstr ""
"`rootcertbundle` "
"フィールドに{project_name}のレルムの公開鍵の場所を設定するのを忘れないでください。auth設定は、この引数なしでは動作しません。"

msgid "Docker registry environment variable override installation"
msgstr "Dockerレジストリー環境変数のオーバーライド・インストール"

msgid ""
"Often times it is appropriate to use a simple environment variable override "
"for develop or POC Docker registries.  While this approach is usually not "
"recommended for production use, it can be helpful when one requires quick-"
"and-dirty way to stand up a registry.  Simply use the _Variable Override_ "
"Format Option from the client installation tab, and an output should appear "
"like the one below:"
msgstr ""
"開発やPOC用のDockerレジストリーに単純な環境変数のオーバーライドを使用することが適切な場合がよくあります。このアプローチは、通常プロダクション環境での使用では推奨されていませんが、レジストリーを立ち上げるための安上がりな方法が必要な場合に役立ちます。クライアント・インストール・タブから"
" _Variable Override_ Format Optionを使用するだけで、出力は次のようになります。"

msgid ""
"REGISTRY_AUTH_TOKEN_REALM: http://localhost:8080{kc_realms_path}/master/protocol/docker-v2/auth\n"
"REGISTRY_AUTH_TOKEN_SERVICE: docker-test\n"
"REGISTRY_AUTH_TOKEN_ISSUER: http://localhost:8080{kc_realms_path}/master"
msgstr ""
"REGISTRY_AUTH_TOKEN_REALM: http://localhost:8080{kc_realms_path}/master/protocol/docker-v2/auth\n"
"REGISTRY_AUTH_TOKEN_SERVICE: docker-test\n"
"REGISTRY_AUTH_TOKEN_ISSUER: http://localhost:8080{kc_realms_path}/master"

msgid ""
"Don't forget to configure the `REGISTRY_AUTH_TOKEN_ROOTCERTBUNDLE` override "
"with the location of the {project_name} realm's public key.  The auth "
"configuration will not work without this argument."
msgstr ""
"`REGISTRY_AUTH_TOKEN_ROOTCERTBUNDLE` "
"オーバーライドを{project_name}レルムの公開鍵の場所で設定するのを忘れないでください。auth設定は、この引数なしでは動作しません。"

msgid "Docker Compose YAML File"
msgstr "Docker Compose YAMLファイル"

msgid ""
"This installation method is meant to be an easy way to get a docker registry"
" authenticating against a {project_name} server.  It is intended for "
"development purposes only and should never be used in a production or "
"production-like environment."
msgstr ""
"このインストール方法は、{project_name}サーバーで認証するDockerレジストリーを構築する簡易的な方法です。これは開発目的のみを対象としており、プロダクション環境やそれと同等の環境には使用しないでください。"

msgid ""
"The zip file installation mechanism provides a quickstart for developers who"
" want to understand how the {project_name} server can interact with the "
"Docker registry.  In order to configure:"
msgstr ""
"zipファイルのインストール・メカニズムは、{project_name}サーバーがDockerレジストリーとどのようにやりとりができるかを理解したい開発者のために、クイックスタートを提供します。"
" 下記のとおりに設定します。"

msgid ""
"From the desired realm, create a client configuration.  At this point you "
"won't have a Docker registry - the quickstart will take care of that part."
msgstr "目的のレルムから、クライアント設定を作成します。この時点で、Dockerレジストリーはありません。クイックスタートがその部分を担当します。"

msgid ""
"Choose the \"Docker Compose YAML\" option from the installation tab and "
"download the .zip file"
msgstr "インストール・タブから\"Docker Compose YAML\"オプションを選択し、.zipファイルをダウンロードします。"

msgid "Unzip the archive to the desired location, and open the directory."
msgstr "アーカイブを目的の場所に解凍し、ディレクトリーを開きます。"

msgid "Start the Docker registry with `docker-compose up`"
msgstr "Dockerレジストリーを `docker-compose up` で起動します。"

msgid ""
"it is recommended that you configure the Docker registry client in a realm "
"other than 'master', since the HTTP Basic auth flow will not present forms."
msgstr ""
"HTTP "
"BASIC認証のフローはフォームを提示しないので、Dockerレジストリー・クライアントを'master'以外のレルムに設定することをお勧めします。"

msgid ""
"Once the above configuration has taken place, and the keycloak server and "
"Docker registry are running, docker authentication should be successful:"
msgstr "上記の設定が完了し、KeycloakサーバーとDockerレジストリーが実行されたら、Docker認証が成功するはずです。"

msgid ""
"[user ~]# docker login localhost:5000 -u $username\n"
"Password: *******\n"
"Login Succeeded"
msgstr ""
"[user ~]# docker login localhost:5000 -u $username\n"
"Password: *******\n"
"Login Succeeded"

msgid "Using the client registration service"
msgstr "クライアント登録サービスの利用"

msgid ""
"In order for an application or service to utilize {project_name} it has to "
"register a client in {project_name}. An admin can do this through the admin "
"console (or admin REST endpoints), but clients can also register themselves "
"through the {project_name} client registration service."
msgstr ""
"{project_name}をアプリケーションまたはサービスで使用するには、{project_name}にクライアントを登録する必要があります。管理者は管理コンソール（または管理RESTエンドポイント）にて登録できますが、クライアント自身でも{project_name}クライアント登録サービスにおいて登録することはできます。"

msgid ""
"The Client Registration Service provides built-in support for {project_name}"
" Client Representations, OpenID Connect Client Meta Data and SAML Entity "
"Descriptors. The Client Registration Service endpoint is "
"`{kc_realms_path}/<realm>/clients-registrations/<provider>`."
msgstr ""
"クライアント登録サービスには、{project_name} Client Representations、OpenID Connect Client "
"Meta DataおよびSAML Entity Descriptorsのビルトインサポートが用意されています。クライアント登録サービスのエンドポイントは"
" `{kc_realms_path}/<realm>/clients-registrations/<provider>` です。"

msgid "The built-in supported `providers` are:"
msgstr "サポートされている組み込みの `provider` は以下のとおりです。"

msgid "default - {project_name} Client Representation (JSON)"
msgstr "default - {project_name} Client Representation（JSON）"

msgid "install - {project_name} Adapter Configuration (JSON)"
msgstr "install - {project_name}アダプター設定 （JSON）"

msgid "openid-connect - OpenID Connect Client Metadata Description (JSON)"
msgstr "openid-connect - OpenID Connectクライアント・メタデータ・ディスクリプション（JSON）"

msgid "saml2-entity-descriptor - SAML Entity Descriptor (XML)"
msgstr "saml2-entity-descriptor - SAMLエンティティー記述子（XML）"

msgid ""
"The following sections will describe how to use the different providers."
msgstr "以下のセクションでは、異なるプロバイダーを使用する方法を説明します。"

msgid "Authentication"
msgstr "認証"

msgid ""
"To invoke the Client Registration Services you usually need a token. The "
"token can be a bearer token, an initial access token or a registration "
"access token. There is an alternative to register new client without any "
"token as well, but then you need to configure Client Registration Policies "
"(see below)."
msgstr ""
"クライアント登録サービスを呼び出すには、通常トークンが必要です。トークンは、ベアラートークン、初期アクセストークン、登録アクセストークンのいずれかです。いずれのトークンも含まず、同様に新規クライアントを登録する方法がありますが、クライアント登録ポリシー（下記参照）を設定する必要があります。"

msgid "Bearer token"
msgstr "ベアラートークン"

msgid ""
"The bearer token can be issued on behalf of a user or a Service Account. The"
" following permissions are required to invoke the endpoints (see "
"link:{adminguide_link}[{adminguide_name}] for more details):"
msgstr ""
"ベアラートークンは、ユーザーやサービス・アカウントに代わって発行されます。エンドポイントを呼び出すには、次のパーミッションが必要です（詳細についてはlink:{adminguide_link}[{adminguide_name}]を参照してください）。"

msgid "create-client or manage-client - To create clients"
msgstr "create-client または manage-client - クライアントの作成権限"

msgid "view-client or manage-client - To view clients"
msgstr "view-client または manage-client - クライアントの参照権限"

msgid "manage-client - To update or delete client"
msgstr "manage-client - クライアントの更新または削除権限"

msgid ""
"If you are using a bearer token to create clients it's recommend to use a "
"token from a Service Account with only the `create-client` role (see "
"link:{adminguide_link}[{adminguide_name}] for more details)."
msgstr ""
"クライアントを作成するためにベアラートークンを使用する場合、 `create-client` "
"ロールのみを持つサービス・アカウントのトークンを使用することをお勧めします（詳細については、link:{adminguide_link}[{adminguide_name}]を参照してください）。"

msgid "Initial Access Token"
msgstr "初期アクセストークン"

msgid ""
"The recommended approach to registering new clients is by using initial "
"access tokens. An initial access token can only be used to create clients "
"and has a configurable expiration as well as a configurable limit on how "
"many clients can be created."
msgstr ""
"新しいクライアントを登録するための推奨される方法は、初期アクセストークンを使用することです。初期アクセストークンは、クライアントを作成する場合にのみ使用でき、有効期限が設定できるだけでなく、クライアントを作成可能な回数の上限も設定できます。"

msgid ""
"An initial access token can be created through the admin console. To create "
"a new initial access token first select the realm in the admin console, then"
" click on `Realm Settings` in the menu on the left, followed by `Client "
"Registration` in the tabs displayed in the page. Then finally click on "
"`Initial Access Tokens` sub-tab."
msgstr ""
"初期アクセストークンは、管理コンソールで作成できます。新たに初期アクセストークンを作成するには、まず管理コンソールでレルムを選択し、左側のメニューの "
"`Realm Settings` 、続いてページに表示されるタブの `Client Registration` をクリックします。そして、最後に "
"`Initial Access Tokens` のサブタブをクリックします。"

msgid ""
"You will now be able to see any existing initial access tokens. If you have "
"access you can delete tokens that are no longer required. You can only "
"retrieve the value of the token when you are creating it. To create a new "
"token click on `Create`. You can now optionally add how long the token "
"should be valid, also how many clients can be created using the token. After"
" you click on `Save` the token value is displayed."
msgstr ""
"これにより既存の初期アクセストークンを参照できるようになります。アクセスできる場合は、不要になったトークンを削除できます。トークン作成時のみその値を取得できます。"
" `Create` "
"をクリックして新しいトークンを作成します。必要に応じてトークンの有効期間や、トークンを使用して作成することができるクライアント数を追加できます。 "
"`Save` をクリックすると、トークンの値が表示されます。"

msgid ""
"It is important that you copy/paste this token now as you won't be able to "
"retrieve it later. If you forget to copy/paste it, then delete the token and"
" create another one."
msgstr ""
"後でトークンを取得することはできないので、このトークンをコピー/ペーストすることが重要です。コピー/ペーストすることを忘れた場合は、そのトークンを削除し、別のトークンを作成してください。"

msgid ""
"The token value is used as a standard bearer token when invoking the Client "
"Registration Services, by adding it to the Authorization header in the "
"request. For example:"
msgstr ""
"リクエストにAuthorizationヘッダーを追加することにより、トークンの値はクライアント登録サービスを呼び出す際の標準ベアラートークンとして使用されます。以下に例を示します。"

msgid "Authorization: bearer eyJhbGciOiJSUz..."
msgstr "Authorization: bearer eyJhbGciOiJSUz..."

msgid "Registration Access Token"
msgstr "登録アクセストークン"

msgid ""
"When you create a client through the Client Registration Service the "
"response will include a registration access token. The registration access "
"token provides access to retrieve the client configuration later, but also "
"to update or delete the client. The registration access token is included "
"with the request in the same way as a bearer token or initial access token. "
"Registration access tokens are only valid once, when it's used the response "
"will include a new token."
msgstr ""
"クライアント登録サービスを介してクライアントを作成する際には、レスポンスには登録アクセストークンが含まれます。登録アクセストークンは、クライアント設定を取得するだけでなく、クライアントの更新や削除のためのアクセス権を提供します。登録アクセストークンは、ベアラートークンや初期アクセストークンと同じ方法でリクエストに含まれます。登録アクセストークンは一度だけ有効であり、それを使用すると新しいトークンがレスポンスに含まれます。"

msgid ""
"If a client was created outside of the Client Registration Service it won't "
"have a registration access token associated with it. You can create one "
"through the admin console. This can also be useful if you lose the token for"
" a particular client. To create a new token find the client in the admin "
"console and click on `Credentials`. Then click on `Generate registration "
"access token`."
msgstr ""
"クライアント登録サービス以外でクライアントが作成された場合、それに関連付けられた登録アクセストークンはありません。管理コンソールを介して、登録アクセストークンを作成できます。これは、特定のクライアントのトークンを紛失した場合に役立ちます。新しいトークンを作成するには、管理コンソールでクライアントを検索し、"
" `Credentials` をクリックします。そして、 `Generate registration access token` をクリックします。"

msgid "{project_name} Representations"
msgstr "{project_name} Representations"

msgid ""
"The `default` client registration provider can be used to create, retrieve, "
"update and delete a client. It uses {project_name} Client Representation "
"format which provides support for configuring clients exactly as they can be"
" configured through the admin console, including for example configuring "
"protocol mappers."
msgstr ""
"`default` "
"クライアント登録プロバイダーは、クライアントを作成、取得、更新、削除するために使用できます。管理コンソールでの設定と同等なクライアント設定のサポートを提供する、{project_name}"
" Client Representation形式を使用します。また、プロトコル・マッパーの設定例が含まれています。"

msgid ""
"To create a client create a Client Representation (JSON) then perform an "
"HTTP POST request to `{kc_realms_path}/<realm>/clients-"
"registrations/default`."
msgstr ""
"クライアントを作成するには、Client Representation（JSON）を作成し、次にHTTP POSTリクエストを "
"`{kc_realms_path}/<realm>/clients-registrations/default` に送信します。"

msgid ""
"It will return a Client Representation that also includes the registration "
"access token. You should save the registration access token somewhere if you"
" want to retrieve the config, update or delete the client later."
msgstr ""
"登録アクセストークンを含むClient "
"Representationが返されます。設定を取得したり、クライアントを後で更新、削除したい場合は、登録アクセストークンをどこかに保存する必要があります。"

msgid ""
"To retrieve the Client Representation perform an HTTP GET request to "
"`{kc_realms_path}/<realm>/clients-registrations/default/<client id>`."
msgstr ""
"Client Representationを取得するには、HTTP GETリクエストを "
"`{kc_realms_path}/<realm>/clients-registrations/default/<client id>` に送信します。"

msgid "It will also return a new registration access token."
msgstr "新しい登録アクセストークンも返します。"

msgid ""
"To update the Client Representation perform an HTTP PUT request with the "
"updated Client Representation to: `{kc_realms_path}/<realm>/clients-"
"registrations/default/<client id>`."
msgstr ""
"Client Representationを更新するには、更新したClient Representationを次のURLにHTTP PUTします：  "
"`{kc_realms_path}/<realm>/clients-registrations/default/<client id>` 。"

msgid ""
"To delete the Client Representation perform an HTTP DELETE request to: "
"`{kc_realms_path}/<realm>/clients-registrations/default/<client id>`"
msgstr ""
"Client Representationを削除するには、HTTP DELETE リクエストを "
"`{kc_realms_path}/<realm>/clients-registrations/default/<client id>` に送信します。"

msgid "{project_name} adapter configuration"
msgstr "{project_name}アダプター設定"

msgid ""
"The `installation` client registration provider can be used to retrieve the "
"adapter configuration for a client. In addition to token authentication you "
"can also authenticate with client credentials using HTTP basic "
"authentication. To do this include the following header in the request:"
msgstr ""
"`installation` クライアント登録プロバイダーは、クライアントのアダプター設定を取得するために使用できます。トークン認証に加えて、HTTP "
"BASIC認証を使用してクライアント・クレデンシャルで認証することもできます。 これを行うには、リクエストに次のヘッダーを含めます。"

msgid "Authorization: basic BASE64(client-id + ':' + client-secret)"
msgstr "Authorization: basic BASE64(client-id + ':' + client-secret)"

msgid ""
"To retrieve the Adapter Configuration then perform an HTTP GET request to "
"`{kc_realms_path}/<realm>/clients-registrations/install/<client id>`."
msgstr ""
"アダプター設定を取得するには、HTTP GETリクエストを `{kc_realms_path}/<realm>/clients-"
"registrations/install/<client id>` に送信します。"

msgid ""
"No authentication is required for public clients. This means that for the "
"JavaScript adapter you can load the client configuration directly from "
"{project_name} using the above URL."
msgstr ""
"パブリック・クライアントは認証が要求されません。これは、JavaScriptアダプターは、上記URLを使用して、直接{project_name}からクライアント設定を読み込めることを意味します。"

msgid "OpenID Connect Dynamic Client Registration"
msgstr "OpenID Connect動的クライアント登録"

msgid ""
"{project_name} implements https://openid.net/specs/openid-connect-"
"registration-1_0.html[OpenID Connect Dynamic Client Registration], which "
"extends https://datatracker.ietf.org/doc/html/rfc7591[OAuth 2.0 Dynamic "
"Client Registration Protocol] and "
"https://datatracker.ietf.org/doc/html/rfc7592[OAuth 2.0 Dynamic Client "
"Registration Management Protocol]."
msgstr ""
"{project_name}は、 https://datatracker.ietf.org/doc/html/rfc7591[OAuth 2.0 "
"Dynamic Client Registration Protocol] と "
"https://datatracker.ietf.org/doc/html/rfc7592[OAuth 2.0 Dynamic Client "
"Registration Management Protocol] を拡張した https://openid.net/specs/openid-"
"connect-registration-1_0.html[OpenID Connect Dynamic Client Registration] "
"を実装しています。"

msgid ""
"The endpoint to use these specifications to register clients in "
"{project_name} is `{kc_realms_path}/<realm>/clients-registrations/openid-"
"connect[/<client id>]`."
msgstr ""
"これらの仕様を使用した、{project_name}にクライアントを登録するエンドポイントは、 "
"`{kc_realms_path}/<realm>/clients-registrations/openid-connect[/<client "
"id>]` です。"

msgid ""
"This endpoint can also be found in the OpenID Connect Discovery endpoint for"
" the realm, `{kc_realms_path}/<realm>/.well-known/openid-configuration`."
msgstr ""
"このエンドポイントは、そのレルムのOpenID Connect Discoveryエンドポイント（ "
"`{kc_realms_path}/<realm>/.well-known/openid-configuration` ）でも見つかります。"

msgid "SAML Entity Descriptors"
msgstr "SAMLエンティティー記述子"

msgid ""
"The SAML Entity Descriptor endpoint only supports using SAML v2 Entity "
"Descriptors to create clients. It doesn't support retrieving, updating or "
"deleting clients. For those operations the {project_name} representation "
"endpoints should be used. When creating a client a {project_name} Client "
"Representation is returned with details about the created client, including "
"a registration access token."
msgstr ""
"SAMLエンティティー記述子エンドポイントは、クライアントを作成するために、SAML "
"v2エンティティー記述子を使用することだけをサポートします。クライアントの取得、更新、削除はサポートしていません。これらの操作に対しては、{project_name}"
" "
"represendationのエンドポイントを使用してください。クライアントを作成すると、作成されたクライアントの詳細とともに、{project_name}"
" Client Representationが返されます（登録アクセストークンを含みます）。"

msgid ""
"To create a client perform an HTTP POST request with the SAML Entity "
"Descriptor to `{kc_realms_path}/<realm>/clients-registrations/saml2-entity-"
"descriptor`."
msgstr ""
"クライアントを作成するには、SAMLエンティティー記述子を使用して `{kc_realms_path}/<realm>/clients-"
"registrations/saml2-entity-descriptor` にHTTP POSTリクエストを送信します。"

msgid ""
"The following example creates a client with the clientId `myclient` using "
"CURL. You need to replace `eyJhbGciOiJSUz...` with a proper initial access "
"token or bearer token."
msgstr ""
"CURLを使用して、クライアントID `myclient` でクライアントを作成する例を次に示します。適切な初期アクセストークンまたはベアラートークンで"
" `eyJhbGciOiJSUz...` を置き換える必要があります。"

msgid ""
"curl -X POST \\\n"
"    -d '{ \"clientId\": \"myclient\" }' \\\n"
"    -H \"Content-Type:application/json\" \\\n"
"    -H \"Authorization: bearer eyJhbGciOiJSUz...\" \\\n"
"    http://localhost:8080{kc_realms_path}/master/clients-registrations/default"
msgstr ""
"curl -X POST \\\n"
"    -d '{ \"clientId\": \"myclient\" }' \\\n"
"    -H \"Content-Type:application/json\" \\\n"
"    -H \"Authorization: bearer eyJhbGciOiJSUz...\" \\\n"
"    http://localhost:8080{kc_realms_path}/master/clients-registrations/default"

msgid "Example using Java Client Registration API"
msgstr "Javaクライアント登録APIを使用した例"

msgid ""
"The Client Registration Java API makes it easy to use the Client "
"Registration Service using Java. To use include the dependency "
"`org.keycloak:keycloak-client-registration-api:>VERSION<` from Maven."
msgstr ""
"クライアント登録Java APIは、Javaを使用してクライアント登録サービスを使いやすくします。使用するには、Mavenに "
"`org.keycloak:keycloak-client-registration-api:>VERSION<` の依存関係を含めてください。"

msgid ""
"For full instructions on using the Client Registration refer to the "
"JavaDocs. Below is an example of creating a client. You need to replace "
"`eyJhbGciOiJSUz...` with a proper initial access token or bearer token."
msgstr ""
"クライアント登録の使用方法の完全な説明は、JavaDocsを参照してください。以下は、クライアントを作成する例です。 "
"`eyJhbGciOiJSUz...` を適切な初期アクセストークンまたはベアラートークンに置き換える必要があります。"

msgid ""
"String token = \"eyJhbGciOiJSUz...\";\n"
"\n"
"ClientRepresentation client = new ClientRepresentation();\n"
"client.setClientId(CLIENT_ID);\n"
"\n"
"ClientRegistration reg = ClientRegistration.create()\n"
"    .url(\"http://localhost:8080{kc_base_path}\", \"myrealm\")\n"
"    .build();\n"
"\n"
"reg.auth(Auth.token(token));\n"
"\n"
"client = reg.create(client);\n"
"\n"
"String registrationAccessToken = client.getRegistrationAccessToken();"
msgstr ""
"String token = \"eyJhbGciOiJSUz...\";\n"
"\n"
"ClientRepresentation client = new ClientRepresentation();\n"
"client.setClientId(CLIENT_ID);\n"
"\n"
"ClientRegistration reg = ClientRegistration.create()\n"
"    .url(\"http://localhost:8080{kc_base_path}\", \"myrealm\")\n"
"    .build();\n"
"\n"
"reg.auth(Auth.token(token));\n"
"\n"
"client = reg.create(client);\n"
"\n"
"String registrationAccessToken = client.getRegistrationAccessToken();"

msgid "Client Registration Policies"
msgstr "クライアント登録ポリシー"

msgid ""
"The current plans are for the Client Registration Policies to be removed in "
"favor of the Client Policies described in the "
"link:{adminguide_link}#_client_policies[{adminguide_name}]. Client Policies "
"are more flexible and support more use cases."
msgstr ""
"現在の計画では、クライアント登録ポリシーは削除され、 "
"link:{adminguide_link}#_client_policies[{adminguide_name}] "
"に記載されているクライアント・ポリシーが採用される予定です。クライアント・ポリシーはより柔軟で、より多くのユースケースをサポートします。"

msgid ""
"{project_name} currently supports two ways how new clients can be registered"
" through Client Registration Service."
msgstr "{project_name}は現在、クライアント登録サービスを介して新しいクライアントを登録できる2つの方法をサポートしています。"

msgid ""
"Authenticated requests - Request to register new client must contain either "
"`Initial Access Token` or `Bearer Token` as mentioned above."
msgstr ""
"認証済みリクエスト - 新しいクライアントを登録するためのリクエストは、前述の `初期アクセストークン` または `ベアラートークン` "
"のいずれかを含める必要があります。"

msgid ""
"Anonymous requests - Request to register new client doesn't need to contain "
"any token at all"
msgstr "匿名リクエスト - 新しいクライアントを登録するためのリクエストは、すべての任意のトークンを含める必要はありません。"

msgid ""
"Anonymous client registration requests are very interesting and powerful "
"feature, however you usually don't want that anyone is able to register new "
"client without any limitations. Hence we have `Client Registration Policy "
"SPI`, which provide a way to limit who can register new clients and under "
"which conditions."
msgstr ""
"匿名クライアント登録リクエストは、非常に面白く、強力な機能ですが、誰でも制限なく新しいクライアントを登録できることを通常は望みません。したがって、そのような条件下で、新しいクライアントを登録できるユーザーを制限する方法を提供する、"
" `Client Registration Policy SPI` があります。"

msgid ""
"In {project_name} admin console, you can click to `Client Registration` tab "
"and then `Client Registration Policies` sub-tab. Here you will see what "
"policies are configured by default for anonymous requests and what policies "
"are configured for authenticated requests."
msgstr ""
"{project_name}管理コンソールで、 `Client Registration` タブ、 `Client Registration "
"Policies` "
"サブタブをクリックします。ここでは、匿名リクエストに対してデフォルトでどのようなポリシーが設定されるか、認証リクエストに対してどのようなポリシーを設定されるかが表示されます。"

msgid ""
"The anonymous requests (requests without any token) are allowed just for "
"creating (registration) of new clients. So when you register new client "
"through anonymous request, the response will contain Registration Access "
"Token, which must be used for Read, Update or Delete request of particular "
"client. However using this Registration Access Token from anonymous "
"registration will be then subject to Anonymous Policy too! This means that "
"for example request for update client also needs to come from Trusted Host "
"if you have `Trusted Hosts` policy. Also for example it won't be allowed to "
"disable `Consent Required` when updating client and when `Consent Required` "
"policy is present etc."
msgstr ""
"匿名リクエスト（トークンの無いリクエスト）は、新しいクライアントを作成（登録）することだけが許可されています。したがって、匿名リクエストを使用して新しいクライアントを登録すると、レスポンスにはそのクライアントの読み取り、更新、削除リクエストに使用する登録アクセストークンが含まれます。ただし、匿名登録レスポンスから取得した登録アクセストークンを使用すると、匿名ポリシーの対象にもなります！これは、たとえば、"
" `Trusted Hosts` "
"ポリシーがあるならば、クライアント更新リクエストも信頼されたホストから送信される必要があることを意味します。また、たとえば、クライアントの更新時に "
"`Consent Required` ポリシーが存在する場合に、 `Consent Required` を無効にするようなことはできません。"

msgid "Currently we have these policy implementations:"
msgstr "現在、以下のポリシーの実装があります。"

msgid ""
"Trusted Hosts Policy - You can configure list of trusted hosts and trusted "
"domains. Request to Client Registration Service can be sent just from those "
"hosts or domains. Request sent from some untrusted IP will be rejected. URLs"
" of newly registered client must also use just those trusted hosts or "
"domains. For example it won't be allowed to set `Redirect URI` of client "
"pointing to some untrusted host. By default, there is not any whitelisted "
"host, so anonymous client registration is de-facto disabled."
msgstr ""
"Trusted Hosts Policy - "
"信頼されたホストと信頼されているドメインの一覧を設定できます。それらのホストやドメインだけからクライアント登録サービスへのリクエストを送信できます。信頼されていないIPから送信されたリクエストは拒否されます。また、新たに登録されたクライアントのURLは、信頼されたホストやドメインだけを使わなければなりません。たとえば、信頼できないホストを指すクライアントの"
" `Redirect URI` "
"を設定することは許可されません。デフォルトでは、ホワイトリストに登録されているホストが無いため、匿名クライアント登録は事実上無効になっています。"

msgid ""
"Consent Required Policy - Newly registered clients will have `Consent "
"Allowed` switch enabled. So after successful authentication, user will "
"always see consent screen when he needs to approve permissions (client "
"scopes). It means that client won't have access to any personal info or "
"permission of user unless user approves it."
msgstr ""
"Consent Required Policy - 新たに登録されたクライアントは、 `Consent Allowed` "
"スイッチが有効になります。したがって、認証成功後、パーミッション（クライアント・スコープ）を承認する必要がある場合、常に同意画面が表示されます。つまり、ユーザーが承認しない限り、クライアントはユーザーの個人情報やパーミッションにアクセスすることができません。"

msgid ""
"Protocol Mappers Policy - Allows to configure list of whitelisted protocol "
"mapper implementations. New client can't be registered or updated if it "
"contains some non-whitelisted protocol mapper. Note that this policy is used"
" for authenticated requests as well, so even for authenticated request there"
" are some limitations which protocol mappers can be used."
msgstr ""
"Protocol Mappers Policy - "
"プロトコル・マッパー実装のホワイトリストを設定できます。ホワイトリストに無いプロトコル・マッパーが含まれている場合は、新たなクライアントを登録または更新できません。このポリシーは認証済みのリクエストにも使用されるため、認証済みのリクエストに対しても、どのプロトコル・マッパーを使用できるかの制限があることに注意してください。"

msgid ""
"Client Scope Policy - Allow to whitelist `Client Scopes`, which can be used "
"with newly registered or updated clients. There are no whitelisted scopes by"
" default; only the client scopes, which are defined as `Realm Default Client"
" Scopes` are whitelisted by default."
msgstr ""
"Client Scope Policy - 新たに登録または更新したクライアントで使うことができる `Client Scopes` "
"のホワイトリスト化を許可します。デフォルトでは、ホワイトリスト化されたスコープはありません。 `Realm Default Client Scopes`"
" として定義されているクライアント・スコープのみがデフォルトでホワイトリストに登録されています。"

msgid ""
"Full Scope Policy - Newly registered clients will have `Full Scope Allowed` "
"switch disabled. This means they won't have any scoped realm roles or client"
" roles of other clients."
msgstr ""
"Full Scope Policy - 新たに登録されたクライアントは `Full Scope Allowed` "
"スイッチが無効に切り替わります。これは、スコープが設定されたレルム・ロールや他のクライアントのクライアント・ロールが無いことを意味します。"

msgid ""
"Max Clients Policy - Rejects registration if current number of clients in "
"the realm is same or bigger than specified limit. It's 200 by default for "
"anonymous registrations."
msgstr ""
"Max Clients Policy - レルム内の現在のクライアント数が指定された制限以上の場合、登録を拒否します。匿名登録のデフォルトは200です。"

msgid ""
"Client Disabled Policy - Newly registered client will be disabled. This "
"means that admin needs to manually approve and enable all newly registered "
"clients. This policy is not used by default even for anonymous registration."
msgstr ""
"Client Disabled Policy - "
"新たに登録されたクライアントは無効になります。これは、管理者が新しく登録された全てのクライアントを手動で承認し、有効にする必要があることを意味します。このポリシーは、匿名登録でもデフォルトでは使用されません。"

msgid "Automating Client Registration with the CLI"
msgstr "CLIによるクライアント登録の自動化"

msgid ""
"The Client Registration CLI is a command-line interface (CLI) tool for "
"application developers to configure new clients in a self-service manner "
"when integrating with {project_name}. It is specifically designed to "
"interact with {project_name} Client Registration REST endpoints."
msgstr ""
"クライアント登録CLIは、アプリケーション開発者が{project_name}と統合する際にセルフ・サービスで新しいクライアントを設定するためのコマンドライン・インターフェイス（CLI）ツールです。"
" これは、{project_name}クライアント登録RESTエンドポイントと対話するように特別に設計されています。"

msgid ""
"It is necessary to create or obtain a client configuration for any "
"application to be able to use {project_name}. You usually configure a new "
"client for each new application hosted on a unique host name. When an "
"application interacts with {project_name}, the application identifies itself"
" with a client ID so {project_name} can provide a login page, single sign-on"
" (SSO) session management, and other services."
msgstr ""
"{project_name}を使用できるように、任意のアプリケーションのクライアント設定を作成または取得する必要があります。通常は、一意のホスト名でホストされる新しいアプリケーションごとに、新しいクライアントを設定します。アプリケーションが{project_name}と対話する際に、アプリケーションはクライアントIDで自身を識別し、{project_name}はログイン・ページ、シングル・サインオン（SSO）セッション管理、およびその他のサービスを提供できます。"

msgid ""
"You can configure application clients from a command line with the Client "
"Registration CLI, and you can use it in shell scripts."
msgstr "アプリケーション・クライアントは、クライアント登録CLIを使用してコマンド・ラインから設定でき、シェルスクリプトで使用できます。"

msgid ""
"To allow a particular user to use `Client Registration CLI` the "
"{project_name} administrator typically uses the Admin Console to configure a"
" new user with proper roles or to configure a new client and client secret "
"to grant access to the Client Registration REST API."
msgstr ""
"特定のユーザーが `クライアント登録CLI` "
"を使用できるようにするため、通常、{project_name}管理者は管理コンソールを使って新しいユーザーを適切なロールで設定するか、クライアント登録REST"
" APIの権限を与えるように新しいクライアントとクライアント・シークレットを設定します 。"

msgid "Configuring a new regular user for use with Client Registration CLI"
msgstr "クライアント登録CLIで使用するための新しい正規ユーザーの設定"

msgid ""
"Log in to the Admin Console (for example, "
"http://localhost:8080{kc_admins_path}) as [command]`admin`."
msgstr ""
"管理コンソール（たとえば、 http://localhost:8080{kc_admins_path}）に [command]`admin` "
"としてログインします。"

msgid "Select a realm to administer."
msgstr "管理するレルムを選択します。"

msgid ""
"If you want to use an existing user, select that user to edit; otherwise, "
"create a new user."
msgstr "既存のユーザーを使用する場合は、編集するユーザーを選択します。それ以外の場合は、新しいユーザーを作成します。"

msgid ""
"Select *Role Mappings > Client Roles > realm-management*. If you are in the "
"master realm, select *NAME-realm*, where `NAME` is the name of the target "
"realm. You can grant access to any other realm to users in the master realm."
msgstr ""
"*Role Mappings > Client Roles > realm-management* "
"を選択します。masterレルムにいる場合は、*NAME-realm* を選択します。ここで、 `NAME` "
"はターゲット・レルムの名前です。masterレルム内のユーザーに他のレルムへのアクセス権を与えることができます。"

msgid ""
"Select *Available Roles > manage-client* to grant a full set of client "
"management permissions. Another option is to choose *view-clients* for read-"
"only or *create-client* to create new clients."
msgstr ""
"*Available Roles > manage-client* "
"を選択して、クライアント管理権限のフルセットを付与します。別の選択肢として、読み取り専用に *view-clients* "
"を、または新しいクライアント作成用に *create-client* を選択します。"

msgid ""
"These permissions grant the user the capability to perform operations "
"without the use of <<_initial_access_token,Initial Access Token>> or "
"<<_registration_access_token,Registration Access Token>>."
msgstr ""
"これらの権限は、ユーザーに<<_initial_access_token,初期アクセストークン>>または<<_registration_access_token,登録アクセストークン>>を使用せずに操作を実行できるようにします。"

msgid ""
"It is possible to not assign any [command]`realm-management` roles to a "
"user. In that case, a user can still log in with the Client Registration CLI"
" but cannot use it without an Initial Access Token. Trying to perform any "
"operations without a token results in a *403 Forbidden* error."
msgstr ""
"[command]`realm-management` "
"ロールをユーザーに割り当てることはできません。その場合、ユーザーはクライアント登録CLIでログインできますが、初期アクセストークンなしでは使用できません。トークンなしで操作を実行しようとすると、"
" *403 Forbidden* エラーが発生します。"

msgid ""
"The Administrator can issue Initial Access Tokens from the Admin Console "
"through the *Realm Settings > Client Registration > Initial Access Token* "
"menu."
msgstr ""
"管理者は、管理コンソールの *Realm Settings > Client Registration > Initial Access Token* "
"メニューから初期アクセストークンを発行できます。"

msgid "Configuring a client for use with the Client Registration CLI"
msgstr "クライアント登録CLIで使用するためのクライアントの設定"

msgid ""
"By default, the server recognizes the Client Registration CLI as the "
"[filename]`admin-cli` client, which is configured automatically for every "
"new realm. No additional client configuration is necessary when logging in "
"with a user name."
msgstr ""
"デフォルトでは、サーバーはクライアント登録CLIを [filename]`admin-cli` "
"クライアントとして認識します。これは新規レルムごとに自動的に設定されます。ユーザー名でログインする場合、追加のクライアント設定は必要ありません。"

msgid ""
"Create a client (for example, [filename]`reg-cli`) if you want to use a "
"separate client configuration for the Client Registration CLI."
msgstr ""
"クライアント登録CLIに別のクライアント設定を使用したい場合は、クライアントを作成します（たとえば、 [filename]`reg-cli` ）。"

msgid "Toggle the *Standard Flow Enabled* setting it to *Off*."
msgstr "*Standard Flow Enabled* を *Off* に設定します。"

msgid ""
"Strengthen the security by configuring the client [filename]`Access Type` as"
" [filename]`Confidential` and selecting *Credentials > ClientId and Secret*."
msgstr ""
"クライアント [filename]`Access Type` を [filename]`Confidential` に設定し、 *Credentials"
" > ClientId and Secret* を選択することで、セキュリティーを強化してください。"

msgid ""
"You can configure either [filename]`Client Id and Secret` or "
"[filename]`Signed JWT` under the *Credentials* tab ."
msgstr ""
"*Credentials* タブの下で、 [filename]`Client Id and Secret` または [filename]`Signed "
"JWT` のいずれかを設定できます。"

msgid ""
"Enable service accounts if you want to use a service account associated with"
" the client by selecting a client to edit in the *Clients* section of the "
"`Admin Console`."
msgstr ""
"クライアントに関連付けられたサービス・アカウントを使用したい場合は、 `管理コンソール` の *Clients* "
"セクションで編集するクライアントを選択することで、サービス・アカウントを有効にします。"

msgid ""
"Under *Settings*, change the *Access Type* to *Confidential*, toggle the "
"*Service Accounts Enabled* setting to *On*, and click *Save*."
msgstr ""
"*Settings* で、 *Access Type* を *Confidential* に変更し、 *Service Accounts "
"Enabled* の設定を *On* に切り替え、 *Save* をクリックします。"

msgid ""
"Click *Service Account Roles* and select desired roles to configure the "
"access for the service account. For the details on what roles to select, see"
" <<_configuring_a_user_for_client_registration_cli>>."
msgstr ""
"*Service Account Roles* "
"をクリックし、目的のロールを選択してサービス・アカウントのアクセスを設定します。選択するロールの詳細については、<<_configuring_a_user_for_client_registration_cli>>を参照してください。"

msgid ""
"Toggle the *Direct Access Grants Enabled* setting it to *On* if you want to "
"use a regular user account instead of a service account."
msgstr ""
"サービス・アカウントの代わりに通常のユーザー・アカウントを使用する場合は、 *Direct Access Grants Enabled* の設定を "
"*On* に切り替えます。"

msgid ""
"If the client is configured as [filename]`Confidential`, provide the "
"configured secret when running [command]`kcreg config credentials` by using "
"the [command]`--secret` option."
msgstr ""
"クライアントが [filename]`Confidential` として設定されている場合、[command]`--secret` "
"オプションを使用して、 [command]`kcreg config credentials` を実行する際に設定されたシークレットを提供してください。"

msgid ""
"Specify which [filename]`clientId` to use (for example, [command]`--client "
"reg-cli`) when running [command]`kcreg config credentials`."
msgstr ""
"[command]`kcreg config credentials` を実行する際に使用する [filename]`clientId` "
"を指定します（たとえば、 [command]`--client reg-cli` ）。"

msgid ""
"With the service account enabled, you can omit specifying the user when "
"running [command]`kcreg config credentials` and only provide the client "
"secret or keystore information."
msgstr ""
"サービス・アカウントを有効にすると、 [command]`kcreg config credentials` "
"を実行するときにユーザーを指定せずに、クライアント・シークレットまたはキーストア情報のみを提供することができます。"

msgid "Installing the Client Registration CLI"
msgstr "クライアント登録CLIのインストール"

msgid ""
"The Client Registration CLI is packaged inside the {project_name} Server "
"distribution. You can find execution scripts inside the [filename]`bin` "
"directory. The Linux script is called [filename]`kcreg.sh`, and the Windows "
"script is called [filename]`kcreg.bat`."
msgstr ""
"クライアント登録CLIは、{project_name}サーバーの配布物内にパッケージ化されています。実行スクリプトは [filename]`bin` "
"ディレクトリにあります。Linuxスクリプトは [filename]`kcreg.sh` で、Windowsスクリプトは "
"[filename]`kcreg.bat` です。"

msgid ""
"Add the {project_name} server directory to your [filename]`PATH` when "
"setting up the client for use from any location on the file system."
msgstr ""
"ファイル・システム上の任意の場所からクライアントを使用できるように設定するときは、{project_name}サーバーのディレクトリーを "
"[filename]`PATH` に追加してください。"

msgid "For example, on:"
msgstr "以下に例を示します。"

msgid "Linux:"
msgstr "Linuxの場合："

msgid ""
"$ export PATH=$PATH:$KEYCLOAK_HOME/bin\n"
"$ kcreg.sh"
msgstr ""
"$ export PATH=$PATH:$KEYCLOAK_HOME/bin\n"
"$ kcreg.sh"

msgid "Windows:"
msgstr "Windowsの場合："

msgid ""
"c:\\> set PATH=%PATH%;%KEYCLOAK_HOME%\\bin\n"
"c:\\> kcreg"
msgstr ""
"c:\\> set PATH=%PATH%;%KEYCLOAK_HOME%\\bin\n"
"c:\\> kcreg"

msgid ""
"[filename]`KEYCLOAK_HOME` refers to a directory where the {project_name} "
"Server distribution was unpacked."
msgstr "[filename]`KEYCLOAK_HOME` は、{project_name}サーバーの配布物が解凍されたディレクトリーを示します。"

msgid "Using the Client Registration CLI"
msgstr "クライアント登録CLIの使用"

msgid "Start an authenticated session by logging in with your credentials."
msgstr "クレデンシャルでログインして、認証されたセッションを開始します。"

msgid "Run commands on the [filename]`Client Registration REST` endpoint."
msgstr "[filename]`Client Registration REST` エンドポイントでコマンドを実行します。"

msgid ""
"$ kcreg.sh config credentials --server http://localhost:8080{kc_base_path} --realm demo --user user --client reg-cli\n"
"$ kcreg.sh create -s clientId=my_client -s 'redirectUris=[\"http://localhost:8980/myapp/*\"]'\n"
"$ kcreg.sh get my_client"
msgstr ""
"$ kcreg.sh config credentials --server http://localhost:8080{kc_base_path} --realm demo --user user --client reg-cli\n"
"$ kcreg.sh create -s clientId=my_client -s 'redirectUris=[\"http://localhost:8980/myapp/*\"]'\n"
"$ kcreg.sh get my_client"

msgid ""
"c:\\> kcreg config credentials --server http://localhost:8080{kc_base_path} --realm demo --user user --client reg-cli\n"
"c:\\> kcreg create -s clientId=my_client -s \"redirectUris=[\\\"http://localhost:8980/myapp/*\\\"]\"\n"
"c:\\> kcreg get my_client"
msgstr ""
"c:\\> kcreg config credentials --server http://localhost:8080{kc_base_path} --realm demo --user user --client reg-cli\n"
"c:\\> kcreg create -s clientId=my_client -s \"redirectUris=[\\\"http://localhost:8980/myapp/*\\\"]\"\n"
"c:\\> kcreg get my_client"

msgid ""
"In a production environment, {project_name} has to be accessed with "
"[filename]`https:` to avoid exposing tokens to network sniffers."
msgstr ""
"プロダクション環境では、ネットワーク・スニファーへのトークンの公開を避けるため、 [filename]`https:` "
"で{project_name}にアクセスする必要があります。"

msgid ""
"If a server's certificate is not issued by one of the trusted certificate "
"authorities (CAs) that are included in Java's default certificate "
"truststore, prepare a [filename]`truststore.jks` file and instruct the "
"Client Registration CLI to use it."
msgstr ""
"サーバーの証明書が、Javaのデフォルトの証明書トラストストアに含まれている信頼できる証明機関（CA）のいずれかによって発行されていない場合は、 "
"[filename]`truststore.jks` ファイルを準備し、クライアント登録CLIに使用するよう指示します。"

msgid ""
"$ kcreg.sh config truststore --trustpass $PASSWORD "
"~/.keycloak/truststore.jks"
msgstr ""
"$ kcreg.sh config truststore --trustpass $PASSWORD "
"~/.keycloak/truststore.jks"

msgid ""
"c:\\> kcreg config truststore --trustpass %PASSWORD% "
"%HOMEPATH%\\.keycloak\\truststore.jks"
msgstr ""
"c:\\> kcreg config truststore --trustpass %PASSWORD% "
"%HOMEPATH%\\.keycloak\\truststore.jks"

msgid "Logging in"
msgstr "ログイン"

msgid ""
"Specify a server endpoint URL and a realm when you log in with the Client "
"Registration CLI."
msgstr "クライアント登録CLIを使用してログインする際は、サーバーのエンドポイントURLとレルムを指定します。"

msgid ""
"Specify a user name or a client id, which results in a special service "
"account being used. When using a user name, you must use a password for the "
"specified user. When using a client ID, you use a client secret or a "
"[filename]`Signed JWT` instead of a password."
msgstr ""
"ユーザー名またはクライアントIDを指定すると、特別なサービス・アカウントが使用されます。ユーザー名を使用する場合は、指定されたユーザーのパスワードを使用する必要があります。クライアントIDを使用する場合は、パスワードの代わりにクライアント・シークレットまたは"
" [filename]`Signed JWT` を使用します。"

msgid ""
"Regardless of the login method, the account that logs in needs proper "
"permissions to be able to perform client registration operations. Keep in "
"mind that any account in a non-master realm can only have permissions to "
"manage clients within the same realm. If you need to manage different "
"realms, you can either configure multiple users in different realms, or you "
"can create a single user in the [filename]`master` realm and add roles for "
"managing clients in different realms."
msgstr ""
"ログイン方法にかかわらず、ログインするアカウントには、クライアント登録操作を実行するための適切な権限が必要です。master以外のレルムのアカウントは、同じレルム内のクライアントを管理する権限しか持てません。異なるレルムを管理する必要がある場合は、複数のユーザーを異なるレルムで設定するか、"
" [filename]`master` レルムで1人のユーザーを作成して、異なるレルムのクライアントを管理するロールを追加します。"

msgid ""
"You cannot configure users with the Client Registration CLI. Use the Admin "
"Console web interface or the Admin Client CLI to configure users. See "
"link:{adminguide_link}[{adminguide_name}] for more details."
msgstr ""
"クライアント登録CLIでユーザーを設定することはできません。管理コンソールのWebインターフェイスまたは管理クライアントCLIを使用して、ユーザーを設定します。詳細については、link:{adminguide_link}[{adminguide_name}]を参照してください。"

msgid ""
"When [filename]`kcreg` successfully logs in, it receives authorization "
"tokens and saves them in a private configuration file so the tokens can be "
"used for subsequent invocations. See "
"<<_working_with_alternative_configurations>> for more information on "
"configuration files."
msgstr ""
"[filename]`kcreg` "
"が正常にログインすると、認可トークンを受信してプライベート設定ファイルに保存し、その後の呼び出しでトークンを使用できるようにします。設定ファイルの詳細については、<<_working_with_alternative_configurations>>を参照してください。"

msgid ""
"See the built-in help for more information on using the Client Registration "
"CLI."
msgstr "クライアント登録CLIの使用方法の詳細については、組み込みのヘルプを参照してください。"

msgid "$ kcreg.sh help"
msgstr "$ kcreg.sh help"

msgid "c:\\> kcreg help"
msgstr "c:\\> kcreg help"

msgid ""
"See [filename]`kcreg config credentials --help` for more information about "
"starting an authenticated session."
msgstr ""
"認証されたセッションの開始についての詳細は、 [filename]`kcreg config credentials --help` "
"を参照してください。"

msgid "Working with alternative configurations"
msgstr "代替設定の使用"

msgid ""
"By default, the Client Registration CLI automatically maintains a "
"configuration file at a default location, "
"[filename]`./.keycloak/kcreg.config`, under the user's home directory. You "
"can use the [command]`--config` option to point to a different file or "
"location to maintain multiple authenticated sessions in parallel. It is the "
"safest way to perform operations tied to a single configuration file from a "
"single thread."
msgstr ""
"デフォルトでは、クライアント登録CLIは、ユーザーのホーム・ディレクトリー配下のデフォルトの場所に設定ファイル（ "
"[filename]`./.keycloak/kcreg.config` ）を自動的に保存します。 [command]`--config` "
"オプションを使うと別のファイルや場所を指すことができ、複数の認証済みセッションを並行して処理できます。1つのスレッドから1つの設定ファイルに結び付けられた操作を実行するのが最も安全な方法です。"

msgid ""
"Do not make the configuration file visible to other users on the system. The"
" configuration file contains access tokens and secrets that should be kept "
"private."
msgstr ""
"システム上の他のユーザーが設定ファイルを参照できないようにしてください。設定ファイルには、非公開にしておくべきアクセストークンとシークレットが含まれています。"

msgid ""
"You might want to avoid storing secrets inside a configuration file by using"
" the [command]`--no-config` option with all of your commands, even though it"
" is less convenient and requires more token requests to do so. Specify all "
"authentication information with each [command]`kcreg` invocation."
msgstr ""
"利便性が低く、より多くのトークン要求が必要ではありますが、すべてのコマンドで [command]`--no-config` "
"オプションを使用することで、設定ファイル内にシークレットを保存しないようにすることができます。 [command]`kcreg` "
"呼び出しごとにすべての認証情報を指定してください。"

msgid "Initial Access and Registration Access Tokens"
msgstr "初期アクセストークンと登録アクセストークン"

msgid ""
"Developers who do not have an account configured at the {project_name} "
"server they want to use can use the Client Registration CLI. This is "
"possible only when the realm administrator issues a developer an Initial "
"Access Token. It is up to the realm administrator to decide how and when to "
"issue and distribute these tokens. The realm administrator can limit the "
"maximum age of the Initial Access Token and the total number of clients that"
" can be created with it."
msgstr ""
"使用したい{project_name}サーバーで設定されたアカウントを持っていない開発者は、クライアント登録CLIを使用できます。レルム管理者が開発者に初期アクセストークンを発行したときだけ、開発者は使用することができます。これらのトークンをいつどのように発行し配布するかは、レルム管理者が決定します。レルム管理者は、初期アクセストークンの最大経過時間と、初期アクセストークンを使用して作成できるクライアントの総数を制限できます。"

msgid ""
"Once a developer has an Initial Access Token, the developer can use it to "
"create new clients without authenticating with [command]`kcreg config "
"credentials`. The Initial Access Token can be stored in the configuration "
"file or specified as part of the [command]`kcreg create` command."
msgstr ""
"開発者が初期アクセストークンを取得すると、開発者はこれを使用して、 [command]`kcreg config credentials` "
"で認証せずに新しいクライアントを作成できます。初期アクセストークンは、設定ファイルに保存するか、 [command]`kcreg create` "
"コマンドの一部として指定することができます。"

msgid ""
"$ kcreg.sh config initial-token $TOKEN\n"
"$ kcreg.sh create -s clientId=myclient"
msgstr ""
"$ kcreg.sh config initial-token $TOKEN\n"
"$ kcreg.sh create -s clientId=myclient"

msgid "or"
msgstr "または"

msgid "$ kcreg.sh create -s clientId=myclient -t $TOKEN"
msgstr "$ kcreg.sh create -s clientId=myclient -t $TOKEN"

msgid ""
"c:\\> kcreg config initial-token %TOKEN%\n"
"c:\\> kcreg create -s clientId=myclient"
msgstr ""
"c:\\> kcreg config initial-token %TOKEN%\n"
"c:\\> kcreg create -s clientId=myclient"

msgid "c:\\> kcreg create -s clientId=myclient -t %TOKEN%"
msgstr "c:\\> kcreg create -s clientId=myclient -t %TOKEN%"

msgid ""
"When using an Initial Access Token, the server response includes a newly "
"issued Registration Access Token. Any subsequent operation for that client "
"needs to be performed by authenticating with that token, which is only valid"
" for that client."
msgstr ""
"初期アクセストークンを使用する場合、サーバー・レスポンスには新しく発行された登録アクセストークンが含まれます。そのクライアントの後続の操作は、そのクライアントに対してのみ有効なトークンで認証することによって実行される必要があります。"

msgid ""
"The Client Registration CLI automatically uses its private configuration "
"file to save and use this token with its associated client. As long as the "
"same configuration file is used for all client operations, the developer "
"does not need to authenticate to read, update, or delete a client that was "
"created this way."
msgstr ""
"クライアント登録CLIはプライベートな設定ファイルを自動的に使用して、このトークンを関連付けられたクライアントと共に保存して使用します。すべてのクライアント操作で同じ設定ファイルが使用されている限り、開発者はこのように作成されたクライアントの読み取り、更新、または削除をするために、認証する必要はありません。"

msgid ""
"See <<_client_registration, Client Registration>> for more information about"
" Initial Access and Registration Access Tokens."
msgstr ""
"初期アクセストークンおよび登録アクセストークンの詳細については、<<_client_registration,クライアント登録>>を参照してください。"

msgid ""
"Run the [command]`kcreg config initial-token --help` and [command]`kcreg "
"config registration-token --help` commands for more information on how to "
"configure tokens with the Client Registration CLI."
msgstr ""
"クライアント登録CLIでトークンを設定する方法の詳細については、 [command]`kcreg config initial-token "
"--help` と [command]`kcreg config registration-token --help` コマンドを実行してください。"

msgid "Creating a client configuration"
msgstr "クライアント設定の作成"

msgid ""
"The first task after authenticating with credentials or configuring an "
"Initial Access Token is usually to create a new client. Often you might want"
" to use a prepared JSON file as a template and set or override some of the "
"attributes."
msgstr ""
"クレデンシャルで認証したり、初期アクセストークンを設定した後の最初のタスクは、通常、新しいクライアントを作成することです。準備されたJSONファイルをテンプレートとして使用し、いくつかの属性を設定または上書きすることがよくあります。"

msgid ""
"The following example shows how to read a JSON file, override any client id "
"it may contain, set any other attributes, and print the configuration to a "
"standard output after successful creation."
msgstr ""
"次の例は、JSONファイルを読み込み、それに含まれるクライアントIDを上書きし、他の属性を設定し、作成が成功した後に標準出力に設定を出力する方法を示しています。"

msgid ""
"$ kcreg.sh create -f client-template.json -s clientId=myclient -s "
"baseUrl=/myclient -s 'redirectUris=[\"/myclient/*\"]' -o"
msgstr ""
"$ kcreg.sh create -f client-template.json -s clientId=myclient -s "
"baseUrl=/myclient -s 'redirectUris=[\"/myclient/*\"]' -o"

msgid ""
"C:\\> kcreg create -f client-template.json -s clientId=myclient -s "
"baseUrl=/myclient -s \"redirectUris=[\\\"/myclient/*\\\"]\" -o"
msgstr ""
"C:\\> kcreg create -f client-template.json -s clientId=myclient -s "
"baseUrl=/myclient -s \"redirectUris=[\\\"/myclient/*\\\"]\" -o"

msgid ""
"Run the [command]`kcreg create --help` for more information about the "
"[command]`kcreg create` command."
msgstr ""
"[command]`kcreg create` コマンドの詳細については、 [command]`kcreg create --help` "
"を実行してください。"

msgid ""
"You can use [command]`kcreg attrs` to list available attributes. Keep in "
"mind that many configuration attributes are not checked for validity or "
"consistency. It is up to you to specify proper values. Remember that you "
"should not have any id fields in your template and should not specify them "
"as arguments to the [command]`kcreg create` command."
msgstr ""
"[command]`kcreg attrs` "
"を使って、利用可能な属性の一覧を取得できます。多くの設定属性の妥当性や一貫性はチェックされません。適切な値を指定する必要があります。また、テンプレートには"
" `id` フィールドを持たせず、  [command]`kcreg create` の引数として指定しないことを忘れないでください。"

msgid "Retrieving a client configuration"
msgstr "クライアント設定の取得"

msgid ""
"You can retrieve an existing client by using the [command]`kcreg get` "
"command."
msgstr "すでに存在するクライアントについては、 [command]`kcreg get` コマンドを使用することで取得できます。"

msgid "$ kcreg.sh get myclient"
msgstr "$ kcreg.sh get myclient"

msgid "C:\\> kcreg get myclient"
msgstr "C:\\> kcreg get myclient"

msgid ""
"You can also retrieve the client configuration as an adapter configuration "
"file, which you can package with your web application."
msgstr "また、Webアプリケーションとパッケージ化できるアダプター設定ファイルとして、クライアント設定を取得することもできます。"

msgid "$ kcreg.sh get myclient -e install > keycloak.json"
msgstr "$ kcreg.sh get myclient -e install > keycloak.json"

msgid "C:\\> kcreg get myclient -e install > keycloak.json"
msgstr "C:\\> kcreg get myclient -e install > keycloak.json"

msgid ""
"Run the [command]`kcreg get --help` command for more information about the "
"[command]`kcreg get` command."
msgstr ""
"[command]`kcreg get` コマンドの詳細については、 [command]`kcreg get --help` "
"コマンドを実行してください。"

msgid "Modifying a client configuration"
msgstr "クライアント設定の更新"

msgid "There are two methods for updating a client configuration."
msgstr "クライアント設定の更新には2つの方法があります。"

msgid ""
"One method is to submit a complete new state to the server after getting the"
" current configuration, saving it to a file, editing it, and posting it back"
" to the server."
msgstr "1つ目の方法は、現在の設定を取得してファイルに保存し、編集してから、新しい状態をサーバーにPOSTで送信する方法です。"

msgid ""
"$ kcreg.sh get myclient > myclient.json\n"
"$ vi myclient.json\n"
"$ kcreg.sh update myclient -f myclient.json"
msgstr ""
"$ kcreg.sh get myclient > myclient.json\n"
"$ vi myclient.json\n"
"$ kcreg.sh update myclient -f myclient.json"

msgid ""
"C:\\> kcreg get myclient > myclient.json\n"
"C:\\> notepad myclient.json\n"
"C:\\> kcreg update myclient -f myclient.json"
msgstr ""
"C:\\> kcreg get myclient > myclient.json\n"
"C:\\> notepad myclient.json\n"
"C:\\> kcreg update myclient -f myclient.json"

msgid ""
"The second method fetches the current client, sets or deletes fields on it, "
"and posts it back in one step."
msgstr "2つ目の方法は、現在のクライアントをフェッチし、そのクライアント上のフィールドを設定または削除し、一度にPOSTで送信する方法です。"

msgid "$ kcreg.sh update myclient -s enabled=false -d redirectUris"
msgstr "$ kcreg.sh update myclient -s enabled=false -d redirectUris"

msgid "C:\\> kcreg update myclient -s enabled=false -d redirectUris"
msgstr "C:\\> kcreg update myclient -s enabled=false -d redirectUris"

msgid ""
"You can also use a file that contains only changes to be applied so you do "
"not have to specify too many values as arguments. In this case, specify "
"[command]`--merge` to tell the Client Registration CLI that rather than "
"treating the JSON file as a full, new configuration, it should treat it as a"
" set of attributes to be applied over the existing configuration."
msgstr ""
"適用される変更のみを含むファイルを使用することもできるので、引数に多くの値を指定する必要はありません。この場合、 [command]`--merge` "
"をクライアント登録CLIに指定すると、JSONファイルは完全な新しい設定として扱われるのではなく、既存の設定に適用される属性のセットとして扱われます。"

msgid "$ kcreg.sh update myclient --merge -d redirectUris -f mychanges.json"
msgstr "$ kcreg.sh update myclient --merge -d redirectUris -f mychanges.json"

msgid "C:\\> kcreg update myclient --merge -d redirectUris -f mychanges.json"
msgstr "C:\\> kcreg update myclient --merge -d redirectUris -f mychanges.json"

msgid ""
"Run the [command]`kcreg update --help` command for more information about "
"the [command]`kcreg update` command."
msgstr ""
"[command]`kcreg update` コマンドの詳細については、 [command]`kcreg update --help` "
"コマンドを実行してください。"

msgid "Deleting a client configuration"
msgstr "クライアント設定の削除"

msgid "Use the following example to delete a client."
msgstr "クライアントを削除するには、以下の例を使用します。 "

msgid "$ kcreg.sh delete myclient"
msgstr "$ kcreg.sh delete myclient"

msgid "C:\\> kcreg delete myclient"
msgstr "C:\\> kcreg delete myclient"

msgid ""
"Run the [command]`kcreg delete --help` command for more information about "
"the [command]`kcreg delete` command."
msgstr ""
"[command]`kcreg delete` コマンドの詳細については、 [command]`kcreg delete --help` "
"コマンドを実行してください。"

msgid "Refreshing invalid Registration Access Tokens"
msgstr "無効な登録アクセストークンのリフレッシュ"

msgid ""
"When performing a create, read, update, and delete (CRUD) operation using "
"the [command]`--no-config` mode, the Client Registration CLI cannot handle "
"Registration Access Tokens for you. In that case, it is possible to lose "
"track of the most recently issued Registration Access Token for a client, "
"which makes it impossible to perform any further CRUD operations on that "
"client without authenticating with an account that has *manage-clients* "
"permissions."
msgstr ""
"[command]`--no-config` "
"モードを使用して作成、読み込み、更新、削除（CRUD）操作を実行すると、クライアント登録CLIは登録アクセストークンを処理できなくなります。その場合、クライアントのために最も最近発行された登録アクセストークンの追跡を失う可能性があり、"
" *manage-clients* 権限を持つアカウントで認証なしでは、そのクライアントでそれ以上のCRUD操作を実行することは不可能になります。"

msgid ""
"If you have permissions, you can issue a new Registration Access Token for "
"the client and have it printed to a standard output or saved to a "
"configuration file of your choice. Otherwise, you have to ask the realm "
"administrator to issue a new Registration Access Token for your client and "
"send it to you. You can then pass it to any CRUD command via the "
"[command]`--token` option. You can also use the [command]`kcreg config "
"registration-token` command to save the new token in a configuration file "
"and have the Client Registration CLI automatically handle it for you from "
"that point on."
msgstr ""
"権限を持っている場合は、クライアント用に新しい登録アクセストークンを発行し、標準出力に出力するか、選択した設定ファイルに保存することができます。それ以外の場合は、レルム管理者にクライアントの新しい登録アクセストークンを発行して、それを送信するよう依頼する必要があります。その際は、"
" [command]`--token` オプションを使ってCRUDコマンドに渡すことができます。また、 [command]`kcreg config "
"registration-token` "
"コマンドを使って新しいトークンを設定ファイルに保存し、クライアント登録CLIが自動的にそれを処理するようにすることもできます。"

msgid ""
"Run the [command]`kcreg update-token --help` command for more information "
"about the [command]`kcreg update-token` command."
msgstr ""
"[command]`kcreg update-token` コマンドの詳細については、 [command]`kcreg update-token "
"--help` コマンドを実行してください。"

msgid ""
"Q: When logging in, I get an error: *Parameter client_assertion_type is "
"missing [invalid_client]*."
msgstr ""
"Q：ログインすると、次のエラーが表示されます：*Parameter client_assertion_type is missing "
"[invalid_client]*."

msgid ""
"A: This error means your client is configured with [filename]`Signed JWT` "
"token credentials, which means you have to use the [command]`--keystore` "
"parameter when logging in."
msgstr ""
"A：このエラーメッセージは、クライアントが [filename]`Signed JWT` "
"のトークン・クレデンシャルで設定されていることを意味します。つまり、ログイン時に [command]`--keystore` "
"パラメータを使用する必要があります。"

msgid "Using token exchange"
msgstr "Token Exchangeの利用"

msgid ""
"{tech_feature_name} is *Technology Preview* and is not fully supported. This"
" feature is disabled by default."
msgstr ""
"{tech_feature_name}は、 *テクノロジー・プレビュー* "
"であり、完全にはサポートされていません。この機能はデフォルトで無効になっています。"

msgid ""
"To enable start the server with `--features=preview` or "
"`--features={tech_feature_id}`"
msgstr ""
"有効にするには、 `--features=preview` または `--features={tech_feature_id}` "
"と入力してサーバーを起動します。"

msgid ""
"In order to use token exchange you should also enable the `token_exchange` "
"feature. Please, take a look at "
"link:{installguide_profile_link}[{installguide_profile_name}]."
msgstr ""
"Token Exchangeを使用するには、 `token_exchange` 機能も有効にする必要があります。 "
"link:{installguide_profile_link}[{installguide_profile_name}] を参照してください。"

msgid "How token exchange works"
msgstr "Token Exchangeの仕組み"

msgid ""
"In {project_name}, token exchange is the process of using a set of "
"credentials or token to obtain an entirely different token. A client may "
"want to invoke on a less trusted application so it may want to downgrade the"
" current token it has. A client may want to exchange a {project_name} token "
"for a token stored for a linked social provider account. You may want to "
"trust external tokens minted by other {project_name} realms or foreign IDPs."
" A client may have a need to impersonate a user.  Here's a short summary of "
"the current capabilities of {project_name} around token exchange."
msgstr ""
"{project_name}において、Token "
"Exchangeとはクレデンシャルまたはトークンのセットを使用して、全く異なるトークンを取得するプロセスです。クライアントは信頼性の低いアプリケーションを呼び出すかもしれず、現在のトークンをダウングレードしたい場合があります。クライアントは、リンクされたソーシャル・プロバイダー・アカウントのために保存されたトークンを、{project_name}トークンに交換したいことがあります。他の{project_name}のレルムや外部IDPによって作成された外部トークンを信頼することができます。クライアントはあるユーザーに成り代わる必要があるかもしれません。Token"
" Exchangeに関する{project_name}の現在の機能の概要を簡単に説明します。"

msgid ""
"A client can exchange an existing {project_name} token created for a "
"specific client for a new token targeted to a different client"
msgstr ""
"クライアントは、特定のクライアントに対して作成された既存の{project_name}トークンを、別のクライアントをターゲットとする新しいトークンと交換することができます"

msgid ""
"A client can exchange an existing {project_name} token for an external "
"token, i.e. a linked Facebook account"
msgstr "クライアントは、既存の{project_name}トークンを外部トークン（つまり、リンクされたFacebookアカウント）と交換できます"

msgid "A client can exchange an external token for a {project_name} token."
msgstr "クライアントは、外部トークンを{project_name}トークンに交換できます。"

msgid "A client can impersonate a user"
msgstr "クライアントは、ユーザーに成り代わることができます。"

msgid ""
"Token exchange in {project_name} is a very loose implementation of the "
"link:https://datatracker.ietf.org/doc/html/rfc8693[OAuth Token Exchange] "
"specification at the IETF. We have extended it a little, ignored some of it,"
" and loosely interpreted other parts of the specification.  It is a simple "
"grant type invocation on a realm's OpenID Connect token endpoint."
msgstr ""
"{project_name}のToken Exchangeは、 "
"link:https://datatracker.ietf.org/doc/html/rfc8693[OAuth Token Exchange] "
"の仕様の非常にルーズな実装です。Keycloakでは、それを少し拡張し、一部を無視し、仕様の他の部分をルーズに解釈しました。これは、あるレルムのOpenID"
" Connectトークン・エンドポイントでの単純なグラントタイプの呼び出しです。"

msgid "{kc_realms_path}/{realm}/protocol/openid-connect/token"
msgstr "{kc_realms_path}/{realm}/protocol/openid-connect/token"

msgid ""
"It accepts form parameters (`application/x-www-form-urlencoded`) as input "
"and the output depends on the type of token you requested an exchange for. "
"Token exchange is a client endpoint so requests must provide authentication "
"information for the calling client. Public clients specify their client "
"identifier as a form parameter.  Confidential clients can also use form "
"parameters to pass their client id and secret, Basic Auth, or however your "
"admin has configured the client authentication flow in your realm."
msgstr ""
"フォーム・パラメーター（ `application/x-www-form-urlencoded` "
"）を入力として受け取り、出力は交換をリクエストしたトークンのタイプに依存します。Token "
"Exchangeはクライアント・エンドポイントであるため、リクエストは呼び出し元のクライアントに認証情報を提供する必要があります。パブリック・クライアントは、クライアント識別子をフォーム・パラメーターとして指定します。コンフィデンシャル・クライアントは、フォーム・パラメーターを使用してクライアントIDとシークレット、BASIC認証を渡すこともできますが、管理者はレルム内でクライアント認証フローを設定することもできます。"

msgid "Form parameters"
msgstr "フォーム・パラメーター"

msgid "client_id"
msgstr "client_id"

msgid ""
"_REQUIRED MAYBE._  This parameter is required for clients using form "
"parameters for authentication.  If you are using Basic Auth, a client JWT "
"token, or client cert authentication, then do not specify this parameter."
msgstr ""
"_REQUIRED MAYBE_ "
"。このパラメーターは、認証にフォーム・パラメーターを使用するクライアントに必要です。BASIC認証、クライアントJWTトークン、またはクライアント証明書認証を使用している場合は、このパラメーターを指定しないでください。"

msgid "client_secret"
msgstr "client_secret"

msgid ""
"_REQUIRED MAYBE_.  This parameter is required for clients using form "
"parameters for authentication and using a client secret as a credential. Do "
"not specify this parameter if client invocations in your realm are "
"authenticated by a different means."
msgstr ""
"_REQUIRED MAYBE_ 。 "
"このパラメーターは、認証にフォーム・パラメーターを使用し、クレデンシャルとしてクライアント・シークレットを使用するクライアントに必要です。レルム内のクライアント呼び出しが別の方法で認証されている場合は、このパラメータを指定しないでください。"

msgid "grant_type"
msgstr "grant_type"

msgid ""
"_REQUIRED._  The value of the parameter must be "
"`urn:ietf:params:oauth:grant-type:token-exchange`."
msgstr ""
"_REQUIRED_ 。パラメータの値は `urn:ietf:params:oauth:grant-type:token-exchange` "
"でなければなりません。"

msgid "subject_token"
msgstr "subject_token"

msgid ""
"_OPTIONAL._  A security token that represents the identity of the party on "
"behalf of whom the request is being made.  It is required if you are "
"exchanging an existing token for a new one."
msgstr ""
"_OPTIONAL_ "
"。リクエストを送信したユーザーの代わりのパーティのアイデンティティーを表すセキュリティー・トークンです。既存のトークンを新しいトークンと交換する場合に必要です。"

msgid "subject_issuer"
msgstr "subject_issuer"

msgid ""
"_OPTIONAL._ Identifies the issuer of the `subject_token`.  It can be left "
"blank if the token comes from the current realm or if the issuer can be "
"determined from the `subject_token_type`.  Otherwise it is required to be "
"specified. Valid values are the alias of an `Identity Provider` configured "
"for your realm.  Or an issuer claim identifier configured by a specific "
"`Identity Provider`."
msgstr ""
"_OPTIONAL_ 。 `subject_token` の発行者を識別します。トークンが現在のレルムによるものの場合、または発行者が "
"`subject_token_type` "
"から決定できる場合は、空白のままにすることができます。それ以外の場合は、指定する必要があります。有効な値は、レルムに設定された `Identity "
"Provider` のエイリアスです。または、特定の `Identity Provider` によって設定された発行者クレーム識別子です。"

msgid "subject_token_type"
msgstr "subject_token_type"

msgid ""
"_OPTIONAL._  This parameter is the type of the token passed with the "
"`subject_token` parameter.  This defaults to `urn:ietf:params:oauth:token-"
"type:access_token` if the `subject_token` comes from the realm and is an "
"access token. If it is an external token, this parameter may or may not have"
" to be specified depending on the requirements of the `subject_issuer`."
msgstr ""
"_OPTIONAL_ 。このパラメーターは `subject_token` パラメーターで渡されるトークンのタイプです。 `subject_token`"
" がレルムのものでアクセストークンである場合、これはデフォルトで `urn:ietf:params:oauth:token-"
"type:access_token` になります。それが外部トークンである場合、このパラメーターは `subject_issuer` "
"の要件に応じて、指定する必要がある場合とない場合があります。"

msgid "requested_token_type"
msgstr "requested_token_type"

msgid ""
"_OPTIONAL._ This parameter represents the type of token the client wants to "
"exchange for.  Currently only oauth and OpenID Connect token types are "
"supported.  The default value for this depends on whether it is "
"`urn:ietf:params:oauth:token-type:refresh_token` in which case you will be "
"returned both an access token and refresh token within the response.  Other "
"appropriate values are `urn:ietf:params:oauth:token-type:access_token` and "
"`urn:ietf:params:oauth:token-type:id_token`"
msgstr ""
"_OPTIONAL_ 。このパラメーターは、クライアントが交換したいトークンのタイプを表します。現在、トークンタイプとしてOAuthとOpenID "
"Connectのみがサポートされています。デフォルト値は、これが `urn:ietf:params:oauth:token-"
"type:refresh_token` "
"であるかどうかによって決まります。この場合、レスポンス内でアクセストークンとリフレッシュトークンの両方が返されます。その他の適切な値は "
"`urn:ietf:params:oauth:token-type:access_token` と "
"`urn:ietf:params:oauth:token-type:id_token` です。"

msgid "audience"
msgstr "audience"

msgid ""
"_OPTIONAL._  This parameter specifies the target client you want the new "
"token minted for."
msgstr "_OPTIONAL_ 。このパラメーターには、新しいトークンを作成する対象となるクライアントを指定します。"

msgid "requested_issuer"
msgstr "requested_issuer"

msgid ""
"_OPTIONAL._  This parameter specifies that the client wants a token minted "
"by an external provider.  It must be the alias of an `Identity Provider` "
"configured within the realm."
msgstr ""
"_OPTIONAL_ "
"。このパラメーターは、クライアントが外部プロバイダーによって作成されたトークンを必要とすることを指定します。これは、レルム内で設定された "
"`Identity Provider` のエイリアスでなければなりません。"

msgid "requested_subject"
msgstr "requested_subject"

msgid ""
"_OPTIONAL._ This specifies a username or user id if your client wants to "
"impersonate a different user."
msgstr "_OPTIONAL_ 。クライアントが別のユーザーに成り代わる場合は、ユーザー名またはユーザーIDを指定します。"

msgid "scope"
msgstr "scope"

msgid ""
"_NOT IMPLEMENTED._ This parameter represents the target set of OAuth and "
"OpenID Connect scopes the client is requesting.  It is not implemented at "
"this time but will be once {project_name} has better support for scopes in "
"general."
msgstr ""
"_NOT IMPLEMENTED_ 。このパラメーターは、クライアントが要求しているOAuthおよびOpenID "
"Connectのスコープのセットを表します。現時点では実装されていませんが、{project_name}がスコープの一般的なサポートを強化した後に利用可能になります。"

msgid ""
"We currently only support OpenID Connect and OAuth exchanges.  Support for "
"SAML based clients and identity providers may be added in the future "
"depending on user demand."
msgstr ""
"現在のところ、OpenID "
"ConnectとOAuthの交換のみサポートしています。SAMLベースのクライアントおよびアイデンティティー・プロバイダーのサポートは、将来、ユーザーの要求に応じて追加される可能性があります。"

msgid "Responses from a token exchange request"
msgstr "Token Exchangeリクエストのレスポンス"

msgid ""
"A successful response from an exchange invocation will return the HTTP 200 "
"response code with a content type that depends on the `requested-token-type`"
" and `requested_issuer` the client asks for.  OAuth requested token types "
"will return a JSON document as described in the "
"link:https://datatracker.ietf.org/doc/html/draft-ietf-oauth-token-"
"exchange-16[OAuth Token Exchange] specification."
msgstr ""
"トークン交換の呼び出しの成功レスポンスは、クライアントがリクエストする `requested-token-type` と "
"`requested_issuer` に依存したコンテンツタイプとともにHTTP "
"200レスポンスコードを返します。OAuthでリクエストされたトークンタイプの場合は、 "
"link:https://datatracker.ietf.org/doc/html/draft-ietf-oauth-token-"
"exchange-16[OAuth Token Exchange] の仕様に記載されているJSONドキュメントを返します。"

msgid ""
"{\n"
"   \"access_token\" : \".....\",\n"
"   \"refresh_token\" : \".....\",\n"
"   \"expires_in\" : \"....\"\n"
" }"
msgstr ""
"{\n"
"   \"access_token\" : \".....\",\n"
"   \"refresh_token\" : \".....\",\n"
"   \"expires_in\" : \"....\"\n"
" }"

msgid ""
"Clients requesting a refresh token will get back both an access and refresh "
"token in the response.  Clients requesting only access token type will only "
"get an access token in the response.  Expiration information may or may not "
"be included for clients requesting an external issuer through the "
"`requested_issuer` paramater."
msgstr ""
"リフレッシュトークンを要求するクライアントは、レスポンス内のアクセストークンとリフレッシュトークンの両方を取得し直します。アクセストークン・タイプのみを要求するクライアントは、レスポンス内のアクセストークンを取得します。"
" `requested_issuer` "
"パラメーターを介して外部発行者を要求するクライアントに対して、有効期限情報が含まれる場合と含まれない場合があります。"

msgid ""
"Error responses generally fall under the 400 HTTP response code category, "
"but other error status codes may be returned depending on the severity of "
"the error.  Error responses may include content depending on the "
"`requested_issuer`. OAuth based exchanges may return a JSON document as "
"follows:"
msgstr ""
"エラーレスポンスは一般的に400 "
"HTTPレスポンス・コード・カテゴリーに該当しますが、エラーの重大度に応じて他のエラー・ステータスコードが返されることがあります。エラーレスポンスには、"
" `requested_issuer` に応じた内容が含まれます。OAuthベースのトークン交換では、次のようにJSON文書が返ることがあります。"

msgid ""
"{\n"
"   \"error\" : \"....\"\n"
"   \"error_description\" : \"....\"\n"
"}"
msgstr ""
"{\n"
"   \"error\" : \"....\"\n"
"   \"error_description\" : \"....\"\n"
"}"

msgid ""
"Additional error claims may be returned depending on the exchange type.  For"
" example, OAuth Identity Providers may include an additional `account-link-"
"url` claim if the user does not have a link to an identity provider.  This "
"link can be used for a client initiated link request."
msgstr ""
"トークン交換のタイプによっては追加のエラークレームが返されることがあります。たとえば、ユーザーがアイデンティティー・プロバイダーへのリンクを持っていない場合、OAuthアイデンティティー・プロバイダーは追加の"
" `account-link-url` クレームを含めることがあります。このリンクは、クライアントが開始したリンクリクエストに使用できます。"

msgid ""
"Token exchange setup requires knowledge of fine grain admin permissions (See"
" the link:{adminguide_link}[{adminguide_name}] for more information).  You "
"will need to grant clients       permission to exchange.  This is discussed "
"more later in this chapter."
msgstr ""
"Token "
"Exchangeのセットアップには細かい粒度の管理権限が必要です（詳細はlink:{adminguide_link}[{adminguide_name}]のリンクを参照してください）。クライアントに交換の権限を付与する必要があります。これについては、この章の後半で説明します。"

msgid ""
"The rest of this chapter discusses the setup requirements and provides "
"examples for different exchange scenarios. For simplicity's sake, let's call"
" a token minted by the current realm as an _internal_ token and a token "
"minted by an external realm or identity provider as an _external_ token."
msgstr ""
"この章では、セットアップの要件について説明し、さまざまな交換のシナリオの例を示します。簡単にするために、現在のレルムで作成されたトークンを _内部_ "
"トークン、外部レルムまたはアイデンティティー・プロバイダーが作成したトークンを _外部_ トークンとして呼ぶことにします。"

msgid "Internal token to internal token exchange"
msgstr "内部トークンから内部トークンへの交換"

msgid ""
"With an internal token to token exchange you have an existing token minted "
"to a specific client and you want to exchange this token for a new one "
"minted for a different target client.  Why would you want to do this?  This "
"generally happens+ when a client has a token minted for itself, and needs to"
" make additional requests to other applications that require different "
"claims and permissions within the access token.  Other reasons this type of "
"exchange might be required is if you need to perform a \"permission "
"downgrade\" where your app needs to invoke on a less trusted app and you "
"don't want to propagate your current access token."
msgstr ""
"内部トークンから内部トークンへの交換で、特定のクライアントに発行された既存のトークンを、別のターゲット・クライアント用に作成された新しいトークンと交換する必要があります。なぜこれをしたいのでしょうか？これは一般に、クライアントはトークンを持っているが、別のアクセストークンのクレームと権限を必要とする他のアプリケーションに対して、追加のリクエストを行う必要がある場合に発生します。このタイプの交換が必要なその他の理由は、信頼性の低いアプリケーションでアプリケーションを呼び出す必要があり、現在のアクセストークンを伝播したくない場合に\"権限のダウングレード\"を実行する必要がある場合です。"

msgid "Granting permission for the exchange"
msgstr "交換のためのパーミッションを付与"

msgid ""
"Clients that want to exchange tokens for a different client need to be "
"authorized in the Admin Console. You need to define a `token-exchange` fine "
"grain permission in the target client you want permission to exchange to."
msgstr ""
"別のクライアントとトークンを交換したいクライアントは、管理コンソールで認可される必要があります。交換の権限を与えたいターゲット・クライアントに "
"`token-exchange` のきめ細かい権限を定義する必要があります。"

msgid "Target Client Permission"
msgstr "ターゲット・クライアントの権限"

msgid ""
"image:{project_images}/exchange-target-client-permission-unset.png[Target "
"Client Permission]"
msgstr ""
"image:{project_images}/exchange-target-client-permission-unset.png[Target "
"Client Permission]"

msgid "Toggle *Permissions Enabled* to *ON*."
msgstr "*Permissions Enabled* を *ON* にトグルします。"

msgid "image:{project_images}/exchange-target-client-permission-set.png[]"
msgstr "image:{project_images}/exchange-target-client-permission-set.png[]"

msgid "That page displays a *token-exchange* link."
msgstr "そのページには *token-exchange* のリンクが表示されます。"

msgid "Click that link to start defining the permission."
msgstr "このリンクをクリックすると、パーミッションの定義が開始されます。"

msgid "This setup page displays."
msgstr "この設定ページが表示されます。"

msgid "Target Client Exchange Permission Setup"
msgstr "ターゲット・クライアントの交換権限のセットアップ"

msgid ""
"image:{project_images}/exchange-target-client-permission-setup.png[Target "
"Client Exchange Permission Setup]"
msgstr ""
"image:{project_images}/exchange-target-client-permission-setup.png[Target "
"Client Exchange Permission Setup]"

msgid ""
"Define a policy for this permission by clicking the *Authorization* link"
msgstr "このパーミッションに関するポリシーを定義するには、 Authorization* のリンクをクリックします。"

msgid "Click the *Policies* tab."
msgstr "*Policies* タブをクリックします。"

msgid "Create a *Client* Policy."
msgstr "*Client* ポリシーを作成します。"

msgid "Client Policy Creation"
msgstr "クライアント・ポリシーの作成"

msgid "image:{project_images}/exchange-target-client-policy.png[]"
msgstr "image:{project_images}/exchange-target-client-policy.png[]"

msgid ""
"Enter in the starting client that is the authenticated client that is "
"requesting a token exchange."
msgstr "Token Exchangeを要求している認証済みクライアントである開始クライアントを入力します。"

msgid ""
"After you create this policy, go back to the target client's *token-"
"exchange* permission and add the client policy you just defined."
msgstr ""
"このポリシーを作成した後、対象のクライアントの *token-exchange* "
"パーミッションに戻り、先ほど定義したクライアント・ポリシーを追加してください。"

msgid "Apply Client Policy"
msgstr "クライアント・ポリシーの適用"

msgid ""
"image:{project_images}/exchange-target-client-exchange-apply-policy.png[]"
msgstr ""
"image:{project_images}/exchange-target-client-exchange-apply-policy.png[]"

msgid ""
"Your client now has permission to invoke.  If you do not do this correctly, "
"you will get a 403 Forbidden response if you try to make an exchange."
msgstr ""
"これでクライアントは交換を実行する権限を持ちます。これを正しく行わないで交換しようとすると、403 Forbiddenのレスポンスが表示されます。"

msgid "Making the request"
msgstr "リクエストの作成"

msgid ""
"When your client is exchanging an existing token for a token targeting "
"another client, you use the `audience` parameter. This parameter must be the"
" client identifier for the target client that you configured in the Admin "
"Console."
msgstr ""
"クライアントがターゲットとする別のクライアントのトークンを既存のトークンと交換しているときは、 `audience` "
"パラメーターを使用します。このパラメーターは、管理コンソールで設定したターゲット・クライアントのクライアント識別子である必要があります。"

msgid ""
"curl -X POST \\\n"
"    -d \"client_id=starting-client\" \\\n"
"    -d \"client_secret=the client secret\" \\\n"
"    --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\\n"
"    -d \"subject_token=....\" \\\n"
"    --data-urlencode \"requested_token_type=urn:ietf:params:oauth:token-type:refresh_token\" \\\n"
"    -d \"audience=target-client\" \\\n"
"    http://localhost:8080{kc_realms_path}/myrealm/protocol/openid-connect/token"
msgstr ""
"curl -X POST \\\n"
"    -d \"client_id=starting-client\" \\\n"
"    -d \"client_secret=the client secret\" \\\n"
"    --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\\n"
"    -d \"subject_token=....\" \\\n"
"    --data-urlencode \"requested_token_type=urn:ietf:params:oauth:token-type:refresh_token\" \\\n"
"    -d \"audience=target-client\" \\\n"
"    http://localhost:8080{kc_realms_path}/myrealm/protocol/openid-connect/token"

msgid ""
"The `subject_token` parameter must be an access token for the target realm."
"  If your `requested_token_type` parameter is a refresh token type, then the"
" response will contain both an access token, refresh token, and expiration."
"  Here's an example JSON response you get back from this call."
msgstr ""
"`subject_token` パラメーターは、ターゲット・レルムのアクセストークンでなければなりません。 `requested_token_type`"
" "
"パラメーターがリフレッシュトークン・タイプの場合、レスポンスにはアクセストークン、リフレッシュトークン、および有効期限の全てが含まれます。この呼び出しから返されるJSONレスポンスの例を、次に示します。"

msgid ""
"{\n"
"   \"access_token\" : \"....\",\n"
"   \"refresh_token\" : \"....\",\n"
"   \"expires_in\" : 3600\n"
"}"
msgstr ""
"{\n"
"   \"access_token\" : \"....\",\n"
"   \"refresh_token\" : \"....\",\n"
"   \"expires_in\" : 3600\n"
"}"

msgid "Internal token to external token exchange"
msgstr "内部トークンから外部トークンへの交換"

msgid ""
"You can exchange a realm token for an externl token minted by an external "
"identity provider.  This external identity provider must be configured "
"within the `Identity Provider` section of the Admin Console.  Currently only"
" OAuth/OpenID Connect based external identity providers are supported, this "
"includes all social providers.  {project_name} does not perform a "
"backchannel exchange to the external provider.  So if the account is not "
"linked, you will not be able to get the external token.  To be able to "
"obtain an external token one of these conditions must be met:"
msgstr ""
"レルムのトークンを、外部アイデンティティー・プロバイダーによって作成された外部トークンに交換することができます。この外部アイデンティティー・プロバイダーは、管理コンソールの"
" `Identity Provider` セクション内で設定する必要があります。現在のところ、OAuth/OpenID "
"Connectベースの外部アイデンティティー・プロバイダーのみがサポートされています。これには、すべてのソーシャル・プロバイダーが含まれます。{project_name}は、外部プロバイダーへのバックチャネル交換を実行しません。したがって、アカウントがリンクされていない場合、外部トークンを取得することはできません。外部トークンを取得するには、次のいずれかの条件を満たす必要があります。"

msgid ""
"The user must have logged in with the external identity provider at least "
"once"
msgstr "ユーザーは、外部アイデンティティー・プロバイダーに少なくとも1回はログインしている必要があります。"

msgid ""
"The user must have linked with the external identity provider through the "
"User Account Service"
msgstr "ユーザーは、外部アイデンティティー・プロバイダーにユーザー・アカウント・サービスを介してリンクしている必要があります。"

msgid ""
"The user account was linked through the external identity provider using "
"link:{developerguide_link}[Client Initiated Account Linking] API."
msgstr ""
"ユーザー・アカウントは、link:{developerguide_link}[Client Initiated Account Linking] "
"APIを使用して外部アイデンティティー・プロバイダーを介してリンクされています。"

msgid ""
"Finally, the external identity provider must have been configured to store "
"tokens, or, one of the above actions must have been performed with the same "
"user session as the internal token you are exchanging."
msgstr ""
"最後に、外部アイデンティティー・プロバイダーがトークンを保存するように設定されている必要があります。または、上記のアクションの1つが、交換する内部トークンと同じユーザー・セッションで実行されている必要があります。"

msgid ""
"If the account is not linked, the exchange response will contain a link you "
"can use to establish it.  This is discussed more in the "
"<<_internal_external_making_request, Making the Request>> section."
msgstr ""
"アカウントがリンクされていない場合、交換レスポンスにはリンクの確立に使用できるリンクが含まれます。これについては、<<_internal_external_making_request,"
" リクエストの実行>>のセクションで詳しく説明します。"

msgid ""
"Internal to external token exchange requests will be denied with a 403, "
"Forbidden response until you grant permission for the calling client to "
"exchange tokens with the external identity provider.  To grant permission to"
" the client, you go to the identity provider's configuration page to the "
"*Permissions* tab."
msgstr ""
"呼び出し側のクライアントに外部アイデンティティー・プロバイダーとトークンを交換する権限を与えるまで、内部トークンから外部トークンへの交換リクエストは、403"
" Forbiddenレスポンスで拒否されます。クライアントに権限を与えるには、アイデンティティー・プロバイダーの設定ページの *Permissions*"
" タブに移動します。"

msgid "Identity Provider Permission"
msgstr "アイデンティティー・プロバイダーの権限"

msgid "image:{project_images}/exchange-idp-permission-unset.png[]"
msgstr "image:{project_images}/exchange-idp-permission-unset.png[]"

msgid "image:{project_images}/exchange-idp-permission-set.png[]"
msgstr "image:{project_images}/exchange-idp-permission-set.png[]"

msgid "The page displays *token-exchange* link."
msgstr "*token-exchange* のリンクが表示されます。"

msgid "Click the link to start defining the permission."
msgstr "このリンクをクリックすると、パーミッションの定義が開始されます。"

msgid "This setup page appears."
msgstr "この設定ページが表示されます。"

msgid "Identity Provider Exchange Permission Setup"
msgstr "アイデンティティー・プロバイダーの交換権限のセットアップ"

msgid ""
"image:{project_images}/exchange-idp-permission-setup.png[Identity Provider "
"Exchange Permission Setup]"
msgstr ""
"image:{project_images}/exchange-idp-permission-setup.png[Identity Provider "
"Exchange Permission Setup]"

msgid ""
"Click the *Authorization* link and go to the *Policies* tab to create a "
"client policy."
msgstr "*Authorization* のリンクをクリックし、 *Policies* タブに移動して、クライアント・ポリシーを作成します。"

msgid ""
"image:{project_images}/exchange-idp-client-policy.png[Client Policy "
"Creation]"
msgstr ""
"image:{project_images}/exchange-idp-client-policy.png[Client Policy "
"Creation]"

msgid ""
"Enter the starting client that is the authenticated client that is "
"requesting a token exchange."
msgstr "Token Exchangeを要求している認証済みクライアントである開始クライアントを入力します。"

msgid ""
"Return to the identity provider's *token-exchange* permission and add the "
"client policy you just defined."
msgstr ""
"アイデンティティー・プロバイダーの *token-exchange* パーミッションに戻り、先ほど定義したクライアント・ポリシーを追加します。"

msgid ""
"image:{project_images}/exchange-idp-apply-policy.png[Apply Client Policy]"
msgstr ""
"image:{project_images}/exchange-idp-apply-policy.png[Apply Client Policy]"

msgid ""
"When your client is exchanging an existing internal token to an external "
"one, you provide the `requested_issuer` parameter.  The parameter must be "
"the alias of a configured identity provider."
msgstr ""
"クライアントが既存の内部トークンを外部トークンと交換する場合は、 `requested_issuer` "
"パラメーターを指定します。パラメーターは、設定済みのアイデンティティー・プロバイダーのエイリアスでなければなりません。"

msgid ""
"curl -X POST \\\n"
"    -d \"client_id=starting-client\" \\\n"
"    -d \"client_secret=the client secret\" \\\n"
"    --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\\n"
"    -d \"subject_token=....\" \\\n"
"    --data-urlencode \"requested_token_type=urn:ietf:params:oauth:token-type:access_token\" \\\n"
"    -d \"requested_issuer=google\" \\\n"
"    http://localhost:8080{kc_realms_path}/myrealm/protocol/openid-connect/token"
msgstr ""
"curl -X POST \\\n"
"    -d \"client_id=starting-client\" \\\n"
"    -d \"client_secret=the client secret\" \\\n"
"    --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\\n"
"    -d \"subject_token=....\" \\\n"
"    --data-urlencode \"requested_token_type=urn:ietf:params:oauth:token-type:access_token\" \\\n"
"    -d \"requested_issuer=google\" \\\n"
"    http://localhost:8080{kc_realms_path}/myrealm/protocol/openid-connect/token"

msgid ""
"The `subject_token` parameter must be an access token for the target realm."
"  The `requested_token_type` parameter must be `urn:ietf:params:oauth:token-"
"type:access_token` or left blank.  No other requested token type is "
"supported at this time.  Here's an example successful JSON response you get "
"back from this call."
msgstr ""
"`subject_token` パラメーターは、ターゲット・レルムのアクセス・トークンでなければなりません。 "
"`requested_token_type` パラメーターは、 `urn:ietf:params:oauth:token-"
"type:access_token` "
"またはブランクのままでなければなりません。現時点では、それ以外の要求されたトークン・タイプはサポートされていません。この呼び出しから返される成功のJSONレスポンスの例を次に示します。"

msgid ""
"{\n"
"   \"access_token\" : \"....\",\n"
"   \"expires_in\" : 3600\n"
"   \"account-link-url\" : \"https://....\"\n"
"}"
msgstr ""
"{\n"
"   \"access_token\" : \"....\",\n"
"   \"expires_in\" : 3600\n"
"   \"account-link-url\" : \"https://....\"\n"
"}"

msgid ""
"If the external identity provider is not linked for whatever reason, you "
"will get an HTTP 400 response code with this JSON document:"
msgstr ""
"外部アイデンティティー・プロバイダーが何らかの理由でリンクされていない場合は、このJSONドキュメントでHTTP 400レスポンス・コードが返ります。"

msgid ""
"{\n"
"   \"error\" : \"....\",\n"
"   \"error_description\" : \"...\"\n"
"   \"account-link-url\" : \"https://....\"\n"
"}"
msgstr ""
"{\n"
"   \"error\" : \"....\",\n"
"   \"error_description\" : \"...\"\n"
"   \"account-link-url\" : \"https://....\"\n"
"}"

msgid ""
"The `error` claim will be either `token_expired` or `not_linked`.  The "
"`account-link-url` claim is provided so that the client can perform "
"link:{developerguide_link}[Client Initiated Account Linking].  Most, if not "
"all, providers require linking through browser OAuth protocol.  With the "
"`account-link-url` just add a `redirect_uri` query parameter to it and you "
"can forward browsers to perform the link."
msgstr ""
"`error` クレームは、 `token_expired` か `not_linked` のどちらかになります。 `account-link-url`"
" クレームは、クライアントがlink:{developerguide_link}[Client Initiated Account "
"Linking]を実行できるように提供されています。ほとんど(すべて？)のプロバイダーは、ブラウザーOAuthプロトコルを介してリンクする必要があります。"
" `account-link-url` では、 `redirect_uri` "
"クエリー・パラメータを追加するだけで、ブラウザを転送してリンクを実行することができます。"

msgid "External token to internal token exchange"
msgstr "外部トークンから内部トークンへの交換"

msgid ""
"You can trust and exchange external tokens minted by external identity "
"providers for internal tokens.  This can be used to bridge between realms or"
" just to trust tokens from your social provider.  It works similarly to an "
"identity provider browser login in that a new user is imported into your "
"realm if it doesn't exist."
msgstr ""
"外部アイデンティティー・プロバイダーが発行した外部トークンを信頼して、内部トークンに交換することができます。これは、レルム間のブリッジや、ソーシャル・プロバイダーのトークンの信頼に使用できます。これは、アイデンティティー・プロバイダーのブラウザーのログインと同様に動作します。新しいユーザーが存在しない場合、そのユーザーはレルムにインポートされます。"

msgid ""
"The current limitation on external token exchanges is that if the external "
"token maps to an existing user an        exchange will not be allowed unless"
" the existing user already has an account link to the external identity"
"        provider."
msgstr ""
"外部トークン交換の現在の制限は、外部トークンが既存のユーザーにマップされている場合、既存のユーザーに外部アイデンティティー・プロバイダーへのアカウント・リンクがない限り、交換は許可されないということです。"

msgid ""
"When the exchange is complete, a user session will be created within the "
"realm, and you will receive an access and or refresh token depending on the "
"`requested_token_type` parameter value.  You should note that this new user "
"session will remain active until it times out or until you call the logout "
"endpoint of the realm passing this new access token."
msgstr ""
"交換が完了すると、レルム内にユーザー・セッションが作成され、 `requested_token_type` "
"パラメーター値に応じて、アクセストークンまたはリフレッシュトークンを受け取れます。この新しいユーザー・セッションは、タイムアウトするまで、またはこの新しいアクセストークンを渡すレルムのログアウト・エンドポイントを呼び出すまで、アクティブなままであることに注意してください。"

msgid ""
"These types of changes required a configured identity provider in the Admin "
"Console."
msgstr "これらのタイプの変更には、管理コンソールで設定されたアイデンティティー・プロバイダーが必要でした。"

msgid ""
"SAML identity providers are not supported at this time.  Twitter tokens "
"cannot be exchanged either."
msgstr "現時点では、SAMLアイデンティティー・プロバイダーはサポートされていません。Twitterのトークンも交換できません。"

msgid ""
"Before external token exchanges can be done, you grant permission for the "
"calling client to make the exchange.  This permission is granted in the same"
" manner as <<_grant_permission_external_exchange, internal to external "
"permission is granted>>."
msgstr ""
"外部トークンの交換が可能になる前に、発信側のクライアントが交換を行うためのパーミッションを与えます。このパーミッションは、<<_grant_permission_external_exchange,"
" 内部トークンから外部トークンへの交換パーミッションの付与>>と同じ方法で付与されます。"

msgid ""
"If you also provide an `audience` parameter whose value points to a "
"different client other than the calling one, you must also grant the calling"
" client permission to exchange to the target client specific in the "
"`audience` parameter.  How to do this is <<_client_to_client_permission, "
"discussed earlier>> in this section."
msgstr ""
"値が呼び出し側以外の別のクライアントを指し示す `audience` パラメーターも指定した場合、呼び出し側クライアントに `audience` "
"パラメーターで特定のターゲット・クライアントに交換する権限を与える必要があります。これを行う方法については、このセクションの<<_client_to_client_permission,"
" 前半>>で説明しています。"

msgid ""
"The `subject_token_type` must either be `urn:ietf:params:oauth:token-"
"type:access_token` or `urn:ietf:params:oauth:token-type:jwt`. If the type is"
" `urn:ietf:params:oauth:token-type:access_token` you specify the "
"`subject_issuer` parameter and it must be the alias of the configured "
"identity provider.  If the type is `urn:ietf:params:oauth:token-type:jwt`, "
"the provider will be matched via the `issuer` claim within the JWT which "
"must be the alias of the provider, or a registered issuer within the "
"providers configuration."
msgstr ""
"`subject_token_type` は、 `urn:ietf:params:oauth:token-type:access_token` または "
"`urn:ietf:params:oauth:token-type:jwt` のいずれかでなければなりません。タイプが "
"`urn:ietf:params:oauth:token-type:access_token` の場合、 `subject_issuer` "
"パラメーターを指定しなければなりません。また、設定されたアイデンティティー・プロバイダーのエイリアスにします。タイプが "
"`urn:ietf:params:oauth:token-type:jwt` の場合、プロバイダーは、プロバイダーのエイリアスであるJWT内の "
"`issuer` クレームまたは、プロバイダー設定内の登録された発行者と一致します。"

msgid ""
"For validation, if the token is an access token, the provider's user info "
"service will be invoked to validate the token.  A successful call will mean "
"that the access token is valid.  If the subject token is a JWT and if the "
"provider has signature validation enabled, that will be attempted, "
"otherwise, it will default to also invoking on the user info service to "
"validate the token."
msgstr ""
"トークンがアクセストークンである場合、プロバイダーのUserInfoサービスが呼び出されてトークンを検証します。呼び出しが成功することは、アクセストークンが有効であることを意味します。サブジェクト・トークンがJWTであり、プロバイダーが署名検証を有効にしている場合は、それが試行され、そうでない場合は、デフォルトでトークンを検証するためにUserInfoサービスが呼び出されます。"

msgid ""
"By default, the internal token minted will use the calling client to "
"determine what's in the token using the protocol mappers defined for the "
"calling client.  Alternatively, you can specify a different target client "
"using the `audience` parameter."
msgstr ""
"デフォルトでは、発行された内部トークンは、呼び出し元クライアント用に定義されたプロトコル・マッパーを使用してトークンの内容を判断するため、呼び出し元クライアントを使用します。あるいは、"
" `audience` パラメーターを使って別のターゲット・クライアントを指定することもできます。"

msgid ""
"curl -X POST \\\n"
"    -d \"client_id=starting-client\" \\\n"
"    -d \"client_secret=the client secret\" \\\n"
"    --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\\n"
"    -d \"subject_token=....\" \\\n"
"    -d \"subject_issuer=myOidcProvider\" \\\n"
"    --data-urlencode \"subject_token_type=urn:ietf:params:oauth:token-type:access_token\" \\\n"
"    -d \"audience=target-client\" \\\n"
"    http://localhost:8080{kc_realms_path}/myrealm/protocol/openid-connect/token"
msgstr ""
"curl -X POST \\\n"
"    -d \"client_id=starting-client\" \\\n"
"    -d \"client_secret=the client secret\" \\\n"
"    --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\\n"
"    -d \"subject_token=....\" \\\n"
"    -d \"subject_issuer=myOidcProvider\" \\\n"
"    --data-urlencode \"subject_token_type=urn:ietf:params:oauth:token-type:access_token\" \\\n"
"    -d \"audience=target-client\" \\\n"
"    http://localhost:8080{kc_realms_path}/myrealm/protocol/openid-connect/token"

msgid ""
"If your `requested_token_type` parameter is a refresh token type, then the "
"response will contain both an access token, refresh token, and expiration.  "
"Here's an example JSON response you get back from this call."
msgstr ""
"`requested_token_type` "
"パラメーターがリフレッシュトークン・タイプの場合、レスポンスにはアクセストークン、リフレッシュトークン、および有効期限の両方が含まれます。この呼び出しで返されるJSONレスポンスの例を次に示します。"

msgid "Impersonation"
msgstr "成り代わり"

msgid ""
"For internal and external token exchanges, the client can request on behalf "
"of a user to impersonate a different user. For example, you may have an "
"admin application that needs to impersonate a user so that a support "
"engineer can debug a problem."
msgstr ""
"内部トークン交換と外部トークン交換の場合、クライアントはユーザーの代わりに別のユーザーに成り代わるように要求できます。たとえば、サポート・エンジニアが問題をデバッグできるように、ユーザーに成り変わる必要がある管理アプリケーションがあるとします。"

msgid ""
"The user that the subject token represents must have permission to "
"impersonate other users.  See the link:{adminguide_link}[{adminguide_name}] "
"on how to enable this permission.  It can be done through a role or through "
"fine grain admin permissions."
msgstr ""
"サブジェクト・トークンが表すユーザーには、他のユーザーに成り代わる権限が必要です。この権限を有効にする方法については、link:{adminguide_link}[{adminguide_name}]を参照してください。ロールを通じて、またはきめ細かい管理権限を使って行うことができます。"

msgid ""
"Make the request as described in other chapters except additionally specify "
"the `requested_subject` parameter.  The value of this parameter must be a "
"username or user id."
msgstr ""
"追加で `requested_subject` "
"パラメーターを指定している点を除いて、他の章で説明したようにリクエストを行います。このパラメーターの値は、ユーザー名またはユーザーIDでなければなりません。"

msgid ""
"curl -X POST \\\n"
"    -d \"client_id=starting-client\" \\\n"
"    -d \"client_secret=the client secret\" \\\n"
"    --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\\n"
"    -d \"subject_token=....\" \\\n"
"    --data-urlencode \"requested_token_type=urn:ietf:params:oauth:token-type:access_token\" \\\n"
"    -d \"audience=target-client\" \\\n"
"    -d \"requested_subject=wburke\" \\\n"
"    http://localhost:8080{kc_realms_path}/myrealm/protocol/openid-connect/token"
msgstr ""
"curl -X POST \\\n"
"    -d \"client_id=starting-client\" \\\n"
"    -d \"client_secret=the client secret\" \\\n"
"    --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\\n"
"    -d \"subject_token=....\" \\\n"
"    --data-urlencode \"requested_token_type=urn:ietf:params:oauth:token-type:access_token\" \\\n"
"    -d \"audience=target-client\" \\\n"
"    -d \"requested_subject=wburke\" \\\n"
"    http://localhost:8080{kc_realms_path}/myrealm/protocol/openid-connect/token"

msgid "Direct Naked Impersonation"
msgstr "ダイレクト・ネイキッドな成り代わり"

msgid ""
"You can make an internal token exchange request without providing a "
"`subject_token`.  This is called a direct naked impersonation because it "
"places a lot of trust in a client as that client can impersonate any user in"
" the realm. You might need this to bridge for applications where it is "
"impossible to obtain a subject token to exchange.  For example, you may be "
"integrating a legacy application that performs login directly with LDAP.  In"
" that case, the legacy app is able to authenticate users itself, but not "
"able to obtain a token."
msgstr ""
"`subject_token` "
"を指定せずに、内部トークンの交換要求を行うことができます。これは、ダイレクト・ネイキッドな成り代わりと呼ばれます。クライアントがそのレルム内の任意のユーザーに成り代わる可能性があるため、クライアントに多くの信頼を置くからです。交換するサブジェクト・トークンを取得することが不可能なアプリケーションをブリッジするためにこれが必要となるかもしれません。たとえば、LDAPに直接ログインするレガシー・アプリケーションを統合したいかもしれません。その場合、従来のアプリケーションはユーザー自身を認証できますが、トークンを取得することができません。"

msgid ""
"It is very risky to enable direct naked impersonation for a client.  If the "
"client's credentials are ever          stolen, that client can impersonate "
"any user in the system."
msgstr ""
"クライアントにダイレクト・ネイキッドな成り代わりを有効にすることは非常に危険です。クライアントのクレデンシャルが盗まれた場合、そのクライアントはシステム内のすべてのユーザーに成り代わる可能性があります。"

msgid ""
"If the `audience` parameter is provided, then the calling client must have "
"permission to exchange to the client.  How to set this up is discussed "
"earlier in this chapter."
msgstr ""
"`audience` "
"パラメーターが提供されている場合、呼び出し側クライアントはクライアントとの交換権限を持っていなければなりません。これを設定する方法については、この章の前半で説明します。"

msgid ""
"Additionally, the calling client must be granted permission to impersonate "
"users.  In the Admin Console."
msgstr "さらに、呼び出し側のクライアントには、ユーザーになりすますためのパーミッションが付与されている必要があります。管理コンソールで"

msgid "Click *Users* in the menu."
msgstr "メニューの *Users* をクリックします。"

msgid "Click the *Permissions* tab."
msgstr "*Permissions* タブをクリックします。"

msgid "User Permissions"
msgstr "ユーザー・パーミッション"

msgid ""
"image:{project_images}/exchange-users-permission-unset.png[User Permissions]"
msgstr ""
"image:{project_images}/exchange-users-permission-unset.png[User Permissions]"

msgid "Toggle *Permissions Enabled* to true."
msgstr "*Permissions Enabled* をtrueにトグルします。"

msgid "image:{project_images}/exchange-users-permission-set.png[]"
msgstr "image:{project_images}/exchange-users-permission-set.png[]"

msgid "The page displays an *impersonation* link."
msgstr "ページには、 *impersonation* リンクが表示されます。"

msgid "Users Impersonation Permission Setup"
msgstr "ユーザー成り代わり権限のセットアップ"

msgid ""
"image:{project_images}/exchange-users-permission-setup.png[Users "
"Impersonation Permission Setup]"
msgstr ""
"image:{project_images}/exchange-users-permission-setup.png[Users "
"Impersonation Permission Setup]"

msgid "Click the *Authorization* link"
msgstr "*Authorization* のリンクをクリックします。"

msgid "Go to the *Policies* tab and create a client policy."
msgstr "*Policies* タブで、クライアント・ポリシーを作成します。"

msgid ""
"image:{project_images}/exchange-users-client-policy.png[Client Policy "
"Creation]"
msgstr ""
"image:{project_images}/exchange-users-client-policy.png[Client Policy "
"Creation]"

msgid ""
"Return to the users' *impersonation* permission and add the client policy "
"you just defined."
msgstr "ユーザーの *impersonation* パーミッションに戻り、先ほど定義したクライアント・ポリシーを追加します。"

msgid ""
"image:{project_images}/exchange-users-apply-policy.png[Apply Client Policy]"
msgstr ""
"image:{project_images}/exchange-users-apply-policy.png[Apply Client Policy]"

msgid ""
"Your client now has permission to impersonate users.  If you do not do this "
"correctly, you will get a 403 Forbidden response if you try to make this "
"type of exchange."
msgstr ""
"クライアントにユーザーに成り代わる権限が付与されました。これを正しく行わないと、これを交換のタイプにしようとする際に、403 "
"Forbiddenのレスポンスが表示されます。"

msgid "Public clients are not allowed to do direct naked impersonations."
msgstr "パブリック・クライアントはダイレクト・ネイキッドな成り代わりを行うことができません。"

msgid ""
"To make the request, simply specify the `requested_subject` parameter.  This"
" must be the username or user id of a valid user.  You can also specify an "
"`audience` parameter if you wish."
msgstr ""
"リクエストを行うには、 `requested_subject` "
"パラメーターを指定してください。これは、有効なユーザーのユーザー名またはユーザーIDでなければなりません。また、必要に応じて `audience` "
"パラメーターを指定することもできます。"

msgid ""
"curl -X POST \\\n"
"    -d \"client_id=starting-client\" \\\n"
"    -d \"client_secret=the client secret\" \\\n"
"    --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\\n"
"    -d \"requested_subject=wburke\" \\\n"
"    http://localhost:8080{kc_realms_path}/myrealm/protocol/openid-connect/token"
msgstr ""
"curl -X POST \\\n"
"    -d \"client_id=starting-client\" \\\n"
"    -d \"client_secret=the client secret\" \\\n"
"    --data-urlencode \"grant_type=urn:ietf:params:oauth:grant-type:token-exchange\" \\\n"
"    -d \"requested_subject=wburke\" \\\n"
"    http://localhost:8080{kc_realms_path}/myrealm/protocol/openid-connect/token"

msgid "Expand permission model with service accounts"
msgstr "サービス・アカウントのパーミッション・モデルの拡張"

msgid ""
"When granting clients permission to exchange, you don't necessarily  "
"manually enable those permissions for each and every client. If the client "
"has a service account associated with it, you can use a role to group "
"permissions together and assign exchange permissions by assigning a role to "
"the client's service account.  For example, you might define a `naked-"
"exchange` role and any service account that has that role can do a naked "
"exchange."
msgstr ""
"クライアントに交換の権限を付与する際に、クライアントごとに権限を手動で有効にする必要はありません。クライアントに関連付けられているサービス・アカウントがある場合は、ロールを使用して権限をグループ化し、クライアントのサービス・アカウントにロールを割り当てて、交換の権限を割り当てることができます。たとえば、"
" `naked-exchange` ロールを定義し、そのロールを持つサービス・アカウントでネイキッドな交換を行うことができます。"

msgid "Exchange vulnerabilities"
msgstr "交換の脆弱性"

msgid ""
"When you start allowing token exchanges, there are various things you have "
"to both be aware of and careful of."
msgstr "Token Exchangeの許可を行う上で、意識して気をつけなければならないさまざまなことがあります。"

msgid ""
"The first is public clients.  Public clients do not have or require a client"
" credential in order to perform an exchange.  Anybody that has a valid token"
" will be able to __impersonate__ the public client and perform the exchanges"
" that public client is allowed to perform.  If there are any untrustworthy "
"clients that are managed by your realm, public clients may open up "
"vulnerabilities in your permission models. This is why direct naked "
"exchanges do not allow public clients and will abort with an error if the "
"calling client is public."
msgstr ""
"1つはパブリック・クライアントです。パブリック・クライアントは、交換を実行するためにクライアント・クレデンシャルを持たない、または必要としません。有効なトークンを持っていれば、パブリック・クライアントに__偽装__することができ、パブリック・クライアントに実行が許可されている交換を実行できます。レルムで管理されている信頼できないクライアントがある場合、パブリック・クライアントは許可モデルで脆弱性を公開する可能性があります。このため、ダイレクト・ネイキッド交換ではパブリック・クライアントは許可されず、呼び出し元のクライアントがパブリックの場合は、エラーで中止されます。"

msgid ""
"It is possible to exchange social tokens provided by Facebook, Google, etc. "
"for a realm token.  Be careful and vigilante on what the exchange token is "
"allowed to do as its not hard to create fake accounts on these social "
"websites.  Use default roles, groups, and identity provider mappers to "
"control what attributes and roles are assigned to the external social user."
msgstr ""
"FacebookやGoogleなどが提供するソーシャル・トークンをレルム・トークンと交換することが可能です。これらのソーシャル・ウェブサイト上で偽のアカウントを作成するのが難しくないため、交換するトークンで何ができるのかを注意して自警してください。デフォルトのロール、グループ、およびアイデンティティー・プロバイダーのマッパーを使用して、外部ソーシャル・ユーザーに割り当てられる属性とロールを制御します。"

msgid ""
"Direct naked exchanges are quite dangerous.  You are putting a lot of trust "
"in the calling client that it will never leak out its client credentials.  "
"If those credentials are leaked, then the thief can impersonate anybody in "
"your system.  This is in direct contrast to confidential clients that have "
"existing tokens.  You have two factors of authentication, the access token "
"and the client credentials, and you're only dealing with one user.  So use "
"direct naked exchanges sparingly."
msgstr ""
"ダイレクト・ネイキッド交換は非常に危険です。呼び出し元のクライアントに対して、クライアントのクレデンシャルが漏洩しないということを非常に信頼しています。これらのクレデンシャルが漏洩した場合、攻撃者はシステム内の誰かに偽装する可能性があります。これは、既存のトークンを持つコンフィデンシャル・クライアントとはまったく対照的です。2要素の認証（アクセストークンとクライアントのクレデンシャル）がありますが、1ユーザーしか扱っていません。したがって、ダイレクト・ネイキッド交換は控えめに使用してください。"
