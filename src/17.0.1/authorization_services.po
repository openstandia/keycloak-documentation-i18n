msgid ""
msgstr ""
"Content-Type: text/plain; charset=UTF-8\n"

msgid "{authorizationguide_name}"
msgstr ""

msgid "*{release_header_guide}* icon:angle-down[]"
msgstr ""

msgid "{gettingstarted_link}[{gettingstarted_name_short}]"
msgstr ""

msgid "{installguide_link}[{installguide_name_short}]"
msgstr ""

msgid "{adapterguide_link}[{adapterguide_name_short}]"
msgstr ""

msgid "{adminguide_link}[{adminguide_name_short}]"
msgstr ""

msgid "{developerguide_link}[{developerguide_name_short}]"
msgstr ""

msgid "{upgradingguide_link}[{upgradingguide_name_short}]"
msgstr ""

msgid "{releasenotes_link}[{releasenotes_name_short}]"
msgstr ""

msgid "Version *{project_version}* _{release_header_latest_link}[Click here for latest]_"
msgstr ""

msgid "Overview"
msgstr ""

msgid "{project_name} supports fine-grained authorization policies and is able to combine different access control mechanisms such as:"
msgstr ""

msgid "**Attribute-based access control (ABAC)**"
msgstr ""

msgid "**Role-based access control (RBAC)**"
msgstr ""

msgid "**User-based access control (UBAC)**"
msgstr ""

msgid "**Context-based access control (CBAC)**"
msgstr ""

msgid "**Rule-based access control**"
msgstr ""

msgid "Using JavaScript"
msgstr ""

msgid "**Time-based access control**"
msgstr ""

msgid "**Support for custom access control mechanisms (ACMs) through a Service Provider Interface (SPI)**"
msgstr ""

msgid "{project_name} is based on a set of administrative UIs and a RESTful API, and provides the necessary means to create permissions for your protected resources and scopes, associate those permissions with authorization policies, and enforce authorization decisions in your applications and services."
msgstr ""

msgid "Resource servers (applications or services serving protected resources) usually rely on some kind of information to decide if access should be granted to a protected resource. For RESTful-based resource servers, that information is usually obtained from a security token, usually sent as a bearer token on every request to the server. For web applications that rely on a session to authenticate users, that information is usually stored in a user's session and retrieved from there for each request."
msgstr ""

msgid "Frequently, resource servers only perform authorization decisions based on role-based access control (RBAC), where the roles granted to the user trying to access protected resources are checked against the roles mapped to these same resources. While roles are very useful and used by applications, they also have a few limitations:"
msgstr ""

msgid "Resources and roles are tightly coupled and changes to roles (such as adding, removing, or changing an access context) can impact multiple resources"
msgstr ""

msgid "Changes to your security requirements can imply deep changes to application code to reflect these changes"
msgstr ""

msgid "Depending on your application size, role management might become difficult and error-prone"
msgstr ""

msgid "It is not the most flexible access control mechanism. Roles do not represent who you are and lack contextual information. If you have been granted a role, you have at least some access."
msgstr ""

msgid "Considering that today we need to consider heterogeneous environments where users are distributed across different regions, with different local policies, using different devices, and with a high demand for information sharing, {project_name} Authorization Services can help you improve the authorization capabilities of your applications and services by providing:"
msgstr ""

msgid "Resource protection using fine-grained authorization policies and different access control mechanisms"
msgstr ""

msgid "Centralized Resource, Permission, and Policy Management"
msgstr ""

msgid "Centralized Policy Decision Point"
msgstr ""

msgid "REST security based on a set of REST-based authorization services"
msgstr ""

msgid "Authorization workflows and User-Managed Access"
msgstr ""

msgid "The infrastructure to help avoid code replication across projects (and redeploys) and quickly adapt to changes in your security requirements."
msgstr ""

msgid "Architecture"
msgstr ""

msgid "image:images/authz-arch-overview.png[alt=\"{project_name} AuthZ Architecture Overview\"]"
msgstr ""

msgid "From a design perspective, Authorization Services is based on a well-defined set of authorization patterns providing these capabilities:"
msgstr ""

msgid "**Policy Administration Point (PAP)**"
msgstr ""

msgid "Provides a set of UIs based on the {project_name} Administration Console to manage resource servers, resources, scopes, permissions, and policies. Part of this is also accomplished remotely through the use of the <<_service_protection_api, Protection API>>."
msgstr ""

msgid "**Policy Decision Point (PDP)**"
msgstr ""

msgid "Provides a distributable policy decision point to where authorization requests are sent and policies are evaluated accordingly with the permissions being requested. For more information, see <<_service_obtaining_permissions, Obtaining Permissions>>."
msgstr ""

msgid "**Policy Enforcement Point (PEP)**"
msgstr ""

msgid "Provides implementations for different environments to actually enforce authorization decisions at the resource server side. {project_name} provides some built-in <<_enforcer_overview, Policy Enforcers>>."
msgstr ""

msgid "**Policy Information Point (PIP)**"
msgstr ""

msgid "Being based on {project_name} Authentication Server, you can obtain attributes from identities and runtime environment during the evaluation of authorization policies."
msgstr ""

msgid "The Authorization Process"
msgstr ""

msgid "Three main processes define the necessary steps to understand how to use {project_name} to enable fine-grained authorization to your applications:"
msgstr ""

msgid "*Resource Management*"
msgstr ""

msgid "*Permission and Policy Management*"
msgstr ""

msgid "*Policy Enforcement*"
msgstr ""

msgid "Resource Management"
msgstr ""

msgid "*Resource Management* involves all the necessary steps to define what is being protected."
msgstr ""

msgid "image:images/resource-mgmt-process.png[alt=\"Resource Management Overview\"]"
msgstr ""

msgid "First, you need to specify {project_name} what are you looking to protect, which usually represents a web application or a set of one or more services. For more information on resource servers see <<_overview_terminology, Terminology>>."
msgstr ""

msgid "Resource servers are managed using the {project_name} Administration Console. There you can enable any registered client application as a resource server and start managing the resources and scopes you want to protect."
msgstr ""

msgid "image:images/rs-r-scopes.png[alt=\"Resource Server Overview\"]"
msgstr ""

msgid "A resource can be a web page, a RESTFul resource, a file in your file system, an EJB, and so on. They can represent a group of resources (just like a Class in Java) or they can represent a single and specific resource."
msgstr ""

msgid "For instance, you might have a _Bank Account_ resource that represents all banking accounts and use it to define the authorization policies that are common to all banking accounts. However, you might want to define specific policies for _Alice Account_ (a resource instance that belongs to a customer), where only the owner is allowed to access some information or perform an operation."
msgstr ""

msgid "Resources can be managed using the {project_name} Administration Console or the <<_service_protection_api, Protection API>>. In the latter case, resource servers are able to manage their resources remotely."
msgstr ""

msgid "Scopes usually represent the actions that can be performed on a resource, but they are not limited to that. You can also use scopes to represent one or more attributes within a resource."
msgstr ""

msgid "Permission and Policy Management"
msgstr ""

msgid "Once you have defined your resource server and all the resources you want to protect, you must set up permissions and policies."
msgstr ""

msgid "This process involves all the necessary steps to actually define the security and access requirements that govern your resources."
msgstr ""

msgid "image:images/policy-mgmt-process.png[alt=\"Permission and Policy Management Overview\"]"
msgstr ""

msgid "Policies define the conditions that must be satisfied to access or perform operations on something (resource or scope), but they are not tied to what they are protecting. They are generic and can be reused to build permissions or even more complex policies."
msgstr ""

msgid "For instance, to allow access to a group of resources only for users granted with a role \"User Premium\", you can use RBAC (Role-based Access Control)."
msgstr ""

msgid "{project_name} provides a few built-in policy types (and their respective policy providers) covering the most common access control mechanisms. You can even create policies based on rules written using JavaScript."
msgstr ""

msgid "Once you have your policies defined, you can start defining your permissions. Permissions are coupled with the resource they are protecting. Here you specify what you want to protect (resource or scope) and the policies that must be satisfied to grant or deny permission."
msgstr ""

msgid "Policy Enforcement"
msgstr ""

msgid "*Policy Enforcement* involves the necessary steps to actually enforce authorization decisions to a resource server. This is achieved by enabling a *Policy Enforcement Point* or PEP at the resource server that is capable of communicating with the authorization server, ask for authorization data and control access to protected resources based on the decisions and permissions returned by the server."
msgstr ""

msgid "image:images/pep-pattern-diagram.png[alt=\"PEP Overview\"]"
msgstr ""

msgid "{project_name} provides some built-in <<_enforcer_overview, Policy Enforcers>> implementations that you can use to protect your applications depending on the platform they are running on."
msgstr ""

msgid "Authorization Services"
msgstr ""

msgid "Authorization services consist of the following RESTFul endpoints:"
msgstr ""

msgid "*Token Endpoint*"
msgstr ""

msgid "*Resource Management Endpoint*"
msgstr ""

msgid "*Permission Management Endpoint*"
msgstr ""

msgid "Each of these services provides a specific API covering the different steps involved in the authorization process."
msgstr ""

msgid "Token Endpoint"
msgstr ""

msgid "OAuth2 clients (such as front end applications) can obtain access tokens from the server using the token endpoint and use these same tokens to access resources protected by a resource server (such as back end services). In the same way, {project_name} Authorization Services provide extensions to OAuth2 to allow access tokens to be issued based on the processing of all policies associated with the resource(s) or scope(s) being requested. This means that resource servers can enforce access to their protected resources based on the permissions granted by the server and held by an access token. In {project_name} Authorization Services the access token with permissions is called a Requesting Party Token or RPT for short."
msgstr ""

msgid "For more information, see <<_service_obtaining_permissions, Obtaining Permissions>>."
msgstr ""

msgid "Protection API"
msgstr ""

msgid "The *Protection API* is a set of https://docs.kantarainitiative.org/uma/wg/oauth-uma-federated-authz-2.0-09.html[UMA-compliant] endpoint-providing operations for resource servers to help them manage their resources, scopes, permissions, and policies associated with them. Only resource servers are allowed to access this API, which also requires a *uma_protection* scope."
msgstr ""

msgid "The operations provided by the Protection API can be organized in two main groups:"
msgstr ""

msgid "Create Resource"
msgstr ""

msgid "Delete Resource"
msgstr ""

msgid "Find by Id"
msgstr ""

msgid "Query"
msgstr ""

msgid "*Permission Management*"
msgstr ""

msgid "Issue Permission Tickets"
msgstr ""

msgid "By default, Remote Resource Management is enabled. You can change that using the {project_name} Administration Console and only allow resource management through the console."
msgstr ""

msgid "When using the UMA protocol, the issuance of Permission Tickets by the Protection API is an important part of the whole authorization process. As described in a subsequent section, they represent the permissions being requested by the client and that are sent to the server to obtain a final token with all permissions granted during the evaluation of the permissions and policies associated with the resources and scopes being requested."
msgstr ""

msgid "For more information, see <<_service_protection_api, Protection API>>."
msgstr ""

msgid "Terminology"
msgstr ""

msgid "Before going further, it is important to understand these terms and concepts introduced by {project_name} Authorization Services."
msgstr ""

msgid "Resource Server"
msgstr ""

msgid "Per OAuth2 terminology, a resource server is the server hosting the protected resources and capable of accepting and responding to protected resource requests."
msgstr ""

msgid "Resource servers usually rely on some kind of information to decide whether access to a protected resource should be granted. For RESTful-based resource servers, that information is usually carried in a security token, typically sent as a bearer token along with every request to the server. Web applications that rely on a session to authenticate users usually store that information in the user's session and retrieve it from there for each request."
msgstr ""

msgid "In {project_name}, any *confidential* client application can act as a resource server. This client's resources and their respective scopes are protected and governed by a set of authorization policies."
msgstr ""

msgid "Resource"
msgstr ""

msgid "A resource is part of the assets of an application and the organization. It can be a set of one or more endpoints, a classic web resource such as an HTML page, and so on. In authorization policy terminology, a resource is the _object_ being protected."
msgstr ""

msgid "Every resource has a unique identifier that can represent a single resource or a set of resources. For instance, you can manage a _Banking Account Resource_ that represents and defines a set of authorization policies for all banking accounts. But you can also have a different resource named _Alice's Banking Account_, which represents a single resource owned by a single customer, which can have its own set of authorization policies."
msgstr ""

msgid "Scope"
msgstr ""

msgid "A resource's scope is a bounded extent of access that is possible to perform on a resource. In authorization policy terminology, a scope is one of the potentially many _verbs_ that can logically apply to a resource."
msgstr ""

msgid "It usually indicates what can be done with a given resource. Example of scopes are view, edit, delete, and so on. However, scope can also be related to specific information provided by a resource. In this case, you can have a project resource and a cost scope, where the cost scope is used to define specific policies and permissions for users to access a project's cost."
msgstr ""

msgid "Permission"
msgstr ""

msgid "Consider this simple and very common permission:"
msgstr ""

msgid "A permission associates the object being protected with the policies that must be evaluated to determine whether access is granted."
msgstr ""

msgid "*X* CAN DO *Y* ON RESOURCE *Z*"
msgstr ""

msgid "where ..."
msgstr ""

msgid "*X* represents one or more users, roles, or groups, or a combination of them. You can also use claims and context here."
msgstr ""

msgid "*Y* represents an action to be performed, for example, write, view, and so on."
msgstr ""

msgid "*Z* represents a protected resource, for example, \"/accounts\"."
msgstr ""

msgid "{project_name} provides a rich platform for building a range of permission strategies ranging from simple to very complex, rule-based dynamic permissions. It provides flexibility and helps to:"
msgstr ""

msgid "Reduce code refactoring and permission management costs"
msgstr ""

msgid "Support a more flexible security model, helping you to easily adapt to changes in your security requirements"
msgstr ""

msgid "Make changes at runtime; applications are only concerned about the resources and scopes being protected and not how they are protected."
msgstr ""

msgid "Policy"
msgstr ""

msgid "A policy defines the conditions that must be satisfied to grant access to an object. Unlike permissions, you do not specify the object being protected but rather the conditions that must be satisfied for access to a given object (for example, resource, scope, or both). Policies are strongly related to the different access control mechanisms (ACMs) that you can use to protect your resources. With policies, you can implement strategies for attribute-based access control (ABAC), role-based access control (RBAC), context-based access control, or any combination of these."
msgstr ""

msgid "{project_name} leverages the concept of policies and how you define them by providing the concept of aggregated policies, where you can build a \"policy of policies\" and still control the behavior of the evaluation. Instead of writing one large policy with all the conditions that must be satisfied for access to a given resource, the policies implementation in {project_name} Authorization Services follows the divide-and-conquer technique. That is, you can create individual policies, then reuse them with different permissions and build more complex policies by combining individual policies."
msgstr ""

msgid "Policy Provider"
msgstr ""

msgid "Policy providers are implementations of specific policy types. {project_name} provides built-in policies, backed by their corresponding policy providers, and you can create your own policy types to support your specific requirements."
msgstr ""

msgid "{project_name} provides a SPI (Service Provider Interface) that you can use to plug in your own policy provider implementations."
msgstr ""

msgid "Permission Ticket"
msgstr ""

msgid "A permission ticket is a special type of token defined by the User-Managed Access (UMA) specification that provides an opaque structure whose form is determined by the authorization server. This structure represents the resources and/or scopes being requested by a client, the access context, as well as the policies that must be applied to a request for authorization data (requesting party token [RPT])."
msgstr ""

msgid "In UMA, permission tickets are crucial to support person-to-person sharing and also person-to-organization sharing. Using permission tickets for authorization workflows enables a range of scenarios from simple to complex, where resource owners and resource servers have complete control over their resources based on fine-grained policies that govern the access to these resources."
msgstr ""

msgid "In the UMA workflow, permission tickets are issued by the authorization server to a resource server, which returns the permission ticket to the client trying to access a protected resource. Once the client receives the ticket, it can make a request for an RPT (a final token holding authorization data) by sending the ticket back to the authorization server."
msgstr ""

msgid "For more information on permission tickets, see <<_service_user_managed_access, User-Managed Access>> and the https://docs.kantarainitiative.org/uma/wg/oauth-uma-grant-2.0-09.html[UMA] specification."
msgstr ""

msgid "Getting Started"
msgstr ""

msgid "Before you can use this tutorial, you need to complete the installation of {project_name} and create the initial admin user as shown in the link:{gettingstarted_link}[{gettingstarted_name}] tutorial. There is one caveat to this. You have to run a separate {appserver_name} instance on the same machine as {project_name} Server. This separate instance will run your Java Servlet application. Because of this you will have to run the {project_name} under a different port so that there are no port conflicts when running on the same machine. Use the `jboss.socket.binding.port-offset` system property on the command line. The value of this property is a number that will be added to the base value of every port opened by {project_name} Server."
msgstr ""

msgid "To boot {project_name} Server:"
msgstr ""

msgid "Linux/Unix"
msgstr ""

msgid "$ .../bin/kc.sh start-dev --http-port 8180"
msgstr ""

msgid "Windows"
msgstr ""

msgid "> ...\\bin\\kc.bat start-dev --http-port 8180"
msgstr ""

msgid "For more details about how to install and configure a {appserver_name}, please follow the steps on the link:{adapterguide_link}[{adapterguide_name}] tutorial."
msgstr ""

msgid "After installing and booting both servers you should be able to access {project_name} Admin Console at http://localhost:8180{kc_admins_path}/ and also the {appserver_name} instance at http://localhost:8080."
msgstr ""

msgid "Securing a Servlet Application"
msgstr ""

msgid "The purpose of this getting started guide is to get you up and running as quickly as possible so that you can experiment with and test various authorization features provided by {project_name}. This quick tour relies heavily on the default database and server configurations and does not cover complex deployment options. For more information on features or configuration options, see the appropriate sections in this documentation."
msgstr ""

msgid "This guide explains key concepts about {project_name} Authorization Services:"
msgstr ""

msgid "Enabling fine-grained authorization for a client application"
msgstr ""

msgid "Configuring a client application to be a resource server, with protected resources"
msgstr ""

msgid "Defining permissions and authorization policies to govern access to protected resources"
msgstr ""

msgid "Enabling policy enforcement in your applications."
msgstr ""

msgid "Creating a Realm and a User"
msgstr ""

msgid "The first step in this tutorial is to create a realm and a user in that realm. Then, within the realm we will create a single client application, which then becomes a <<_overview_terminology, resource server>> for which you need to enable authorization services."
msgstr ""

msgid "To create a realm and a user complete the following steps:"
msgstr ""

msgid "Create a realm with a name *hello-world-authz*. Once created, a page similar to the following is displayed:"
msgstr ""

msgid "Realm hello-world-authz"
msgstr ""

msgid "image:{project_images}/getting-started/hello-world/create-realm.png[alt=\"Realm hello-world-authz\"]"
msgstr ""

msgid "Create a user for your newly created realm. Click *Users*. The user list page opens."
msgstr ""

msgid "On the right side of the empty user list, click *Add User*."
msgstr ""

msgid "To create a new user, complete the *Username*, *Email*, *First Name*, and *Last Name* fields. Click the *User Enabled* switch to *On*, and then click *Save*."
msgstr ""

msgid "Add User"
msgstr ""

msgid "image:{project_images}/getting-started/hello-world/create-user.png[alt=\"Add User\"]"
msgstr ""

msgid "Set a password for the user by clicking the *Credentials* tab."
msgstr ""

msgid "Set User Password"
msgstr ""

msgid "image:{project_images}/getting-started/hello-world/reset-user-pwd.png[alt=\"Set User Password\"]"
msgstr ""

msgid "Complete the *New Password* and *Password Confirmation* fields with a password and click the *Temporary* switch to *OFF*."
msgstr ""

msgid "Click *Set Password* to set the user's password."
msgstr ""

msgid "Enabling Authorization Services"
msgstr ""

msgid "You can enable authorization services in an existing client application configured to use the OpenID Connect Protocol. You can also create a new client."
msgstr ""

msgid "To create a new client, complete the following steps:"
msgstr ""

msgid "Click *Clients* to start creating a new client application and fill in the *Client ID*, *Client Protocol*, and *Root URL* fields."
msgstr ""

msgid "Create Client Application"
msgstr ""

msgid "image:{project_images}/getting-started/hello-world/create-client.png[alt=\"Create Client Application\"]"
msgstr ""

msgid "Click *Save*. The Client Details page is displayed."
msgstr ""

msgid "On the Client Details page, select *confidential* in the *Access Type* field, change the *Authorization Enabled* switch to *ON*, and then click *Save*. A new *Authorization* tab is displayed for the client."
msgstr ""

msgid "Client Details"
msgstr ""

msgid "image:{project_images}/getting-started/hello-world/enable-authz.png[alt=\"Client Details\"]"
msgstr ""

msgid "Click the *Authorization* tab and an Authorization Settings page similar to the following is displayed:"
msgstr ""

msgid "Authorization Settings"
msgstr ""

msgid "image:{project_images}/getting-started/hello-world/authz-settings.png[alt=\"Authorization Settings\"]"
msgstr ""

msgid "When you enable authorization services for a client application, {project_name} automatically creates several <<_resource_server_default_config, default settings>> for your client authorization configuration."
msgstr ""

msgid "For more information about authorization configuration, see <<_resource_server_enable_authorization, Enabling Authorization Services>>."
msgstr ""

msgid "Build, Deploy, and Test Your Application"
msgstr ""

msgid "Now that the *app-authz-vanilla* resource server (or client) is properly configured and authorization services are enabled, it can be deployed to the server."
msgstr ""

msgid "The project and code for the application you are going to deploy is available in link:{quickstartRepo_link}[{quickstartRepo_name}].  You will need the following installed on your machine and available in your PATH before you can continue:"
msgstr ""

msgid "Java JDK 8"
msgstr ""

msgid "Apache Maven 3.1.1 or higher"
msgstr ""

msgid "Git"
msgstr ""

msgid "You can obtain the code by cloning the repository at {quickstartRepo_link}. The quickstarts are designed to work with the most recent Keycloak release."
msgstr ""

msgid "Follow these steps to download the code."
msgstr ""

msgid "Clone Project"
msgstr ""

msgid "$ git clone {quickstartRepo_link}"
msgstr ""

msgid "The application we are about to build and deploy is located at"
msgstr ""

msgid "$ cd {quickstartRepo_dir}/app-authz-jee-vanilla"
msgstr ""

msgid "Obtaining the Adapter Configuration"
msgstr ""

msgid "You must first obtain the adapter configuration before building and deploying the application."
msgstr ""

msgid "To obtain the adapter configuration from the {project_name} Administration Console, complete the following steps."
msgstr ""

msgid "Click *Clients*. In the client listing, click the *app-authz-vanilla* client application. The Client Details page opens."
msgstr ""

msgid "Click the *Installation* tab. From the Format Option dropdown list, select *Keycloak OIDC JSON*. The adapter configuration is displayed in JSON format. Click *Download*."
msgstr ""

msgid "Adapter Configuration"
msgstr ""

msgid "image:{project_images}/getting-started/hello-world/adapter-config.png[alt=\"Adapter Configuration\"]"
msgstr ""

msgid "Move the file `keycloak.json` to the `app-authz-jee-vanilla/config` directory."
msgstr ""

msgid "(optional) By default, the policy enforcer responds with a `403` status code when the user lacks permission to access protected resources on the resource server. However, you can also specify a redirection URL for unauthorized users. To specify a redirection URL, edit the *keycloak.json* file you updated in step 3 and replace the `policy-enforcer` configuration with the following:"
msgstr ""

msgid ""
"\"policy-enforcer\": {\n"
"    \"on-deny-redirect-to\" : \"/app-authz-vanilla/error.jsp\"\n"
"}"
msgstr ""

msgid "This change specifies to the policy enforcer to redirect users to a `/app-authz-vanilla/error.jsp` page if a user does not have the necessary permissions to access a protected resource, rather than an unhelpful `403 Unauthorized` message."
msgstr ""

msgid "Building and Deploying the Application"
msgstr ""

msgid "To build and deploy the application execute the following command:"
msgstr ""

msgid ""
"$ cd {quickstartRepo_dir}/app-authz-jee-vanilla\n"
"$ mvn clean package wildfly:deploy"
msgstr ""

msgid "Testing the Application"
msgstr ""

msgid "If your application was successfully deployed you can access it at http://localhost:8080/app-authz-vanilla[http://localhost:8080/app-authz-vanilla]. The {project_name} Login page opens."
msgstr ""

msgid "Login Page"
msgstr ""

msgid "image:{project_images}/getting-started/hello-world/login-page.png[alt=\"Login Page\"]"
msgstr ""

msgid "Log in as *alice* using the password you specified for that user. After authenticating, the following page is displayed:"
msgstr ""

msgid "Hello World Authz Main Page"
msgstr ""

msgid "image:{project_images}/getting-started/hello-world/main-page.png[alt=\"Hello World Authz Main Page\"]"
msgstr ""

msgid "The <<_resource_server_default_config, default settings>> defined by {project_name} when you enable authorization services for a client application provide a simple policy that always grants access to the resources protected by this policy."
msgstr ""

msgid "You can start by changing the default permissions and policies and test how your application responds, or even create new policies using the different <<_policy_overview, policy types>> provided by {project_name}."
msgstr ""

msgid "There are a plenty of things you can do now to test this application. For example, you can change the default policy by clicking the Authorization tab for the client, then `Policies` tab, then click on `Default Policy` in the list to allow you to change it as follows:"
msgstr ""

msgid ""
"// The default value is $evaluation.grant(),\n"
"// let's see what happens when we change it to $evaluation.deny()\n"
"$evaluation.deny();\n"
msgstr ""

msgid "Now, log out of the demo application and log in again. You can no longer access the application."
msgstr ""

msgid "image:{project_images}/getting-started/hello-world/access-denied-page.png[alt=\"Access Denied Page\"]"
msgstr ""

msgid "Let's fix that now, but instead of changing the `Default Policy` code we are going to change the `Logic` to `Negative` using the dropdown list below the policy code text area. That re-enables access to the application as we are negating the result of that policy, which is by default denying all requests for access. Again, before testing this change, be sure to log out and log in again."
msgstr ""

msgid "Next Steps"
msgstr ""

msgid "There are additional things you can do, such as:"
msgstr ""

msgid "Create a scope, define a policy and permission for it, and test it on the application side. Can the user perform an action (or anything else represented by the scope you created)?"
msgstr ""

msgid "Create different types of policies such as <<_policy_js, JavaScript-based>>, and associate these policies with the `Default Permission`."
msgstr ""

msgid "Apply multiple policies to the `Default Permission` and test the behavior. For example, combine multiple policies and change the `Decision Strategy` accordingly."
msgstr ""

msgid "For more information about how to view and test permissions inside your application see <<_enforcer_authorization_context, Obtaining the Authorization Context>>."
msgstr ""

msgid "Authorization Quickstarts"
msgstr ""

msgid "In addition to the *app-authz-jee-vanilla* quickstart that was used as a sample application in the previous section, the link:{quickstartRepo_link}[{quickstartRepo_name}] contains other applications that make use of the authorization services described in this documentation."
msgstr ""

msgid "The authorization quickstarts have been designed so that authorization services are displayed in different scenarios and using different technologies and integrations. It is not meant as a comprehensive set of all the possible use cases involving authorization but they should provide a starting point for users interested in understanding how the authorization services can be used in their own applications."
msgstr ""

msgid "Each quickstart has a `README` file with instructions on how to build, deploy, and test the sample application. The following table provides a brief description of the available authorization quickstarts:"
msgstr ""

msgid "Name"
msgstr ""

msgid "Description"
msgstr ""

msgid "https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-jee-servlet[app-authz-jee-servlet]"
msgstr ""

msgid "Demonstrates how to enable fine-grained authorization to a Jakarta EE application in order to protect specific resources and build a dynamic menu based on the permissions obtained from a Keycloak Server."
msgstr ""

msgid "https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-jee-vanilla[app-authz-jee-vanilla]"
msgstr ""

msgid "Demonstrates how to enable fine-grained authorization to a Jakarta EE application and use the default authorization settings to protect all resources in the application."
msgstr ""

msgid "https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-rest-springboot[app-authz-rest-springboot]"
msgstr ""

msgid "Demonstrates how to protect a SpringBoot REST service using Keycloak Authorization Services."
msgstr ""

msgid "https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-springboot[app-authz-springboot]"
msgstr ""

msgid "Demonstrates how to write a SpringBoot Web application where both authentication and authorization aspects are managed by Keycloak."
msgstr ""

msgid "https://github.com/keycloak/keycloak-quickstarts/tree/latest/app-authz-uma-photoz[app-authz-uma-photoz]"
msgstr ""

msgid "A simple application based on HTML5+AngularJS+JAX-RS that demonstrates how to enable User-Managed Access to your application and let users to manage permissions for their resources."
msgstr ""

msgid "Managing Resource Servers"
msgstr ""

msgid "According to the OAuth2 specification, a resource server is a server hosting the protected resources and capable of accepting and responding to protected resource requests."
msgstr ""

msgid "In {project_name}, resource servers are provided with a rich platform for enabling fine-grained authorization for their protected resources, where authorization decisions can be made based on different access control mechanisms."
msgstr ""

msgid "Any client application can be configured to support fine-grained permissions. In doing so, you are conceptually turning the client application into a resource server."
msgstr ""

msgid "Creating a Client Application"
msgstr ""

msgid "The first step to enable {project_name} Authorization Services is to create the client application that you want to turn into a resource server."
msgstr ""

msgid "To create a client application, complete the following steps:"
msgstr ""

msgid "Click *Clients*."
msgstr ""

msgid "Clients"
msgstr ""

msgid "image:{project_images}/resource-server/client-list.png[alt=\"Clients\"]"
msgstr ""

msgid "On this page, click *Create*."
msgstr ""

msgid "Create Client"
msgstr ""

msgid "image:{project_images}/resource-server/client-create.png[alt=\"Create Client\"]"
msgstr ""

msgid "Type the `Client ID` of the client. For example, _my-resource-server_."
msgstr ""

msgid "Type the `Root URL` for your application. For example:"
msgstr ""

msgid "http://${host}:${port}/my-resource-server"
msgstr ""

msgid "Click *Save*. The client is created and the client Settings page opens. A page similar to the following is displayed:"
msgstr ""

msgid "Client Settings"
msgstr ""

msgid "image:{project_images}/resource-server/client-enable-authz.png[alt=\"Client Settings\"]"
msgstr ""

msgid "To turn your OIDC Client Application into a resource server and enable fine-grained authorization, select *Access type* *confidential* and click the *Authorization Enabled* switch to *ON* then click *Save*."
msgstr ""

msgid "image:{project_images}/resource-server/client-enable-authz.png[alt=\"Enabling Authorization Services\"]"
msgstr ""

msgid "A new Authorization tab is displayed for this client. Click the *Authorization* tab and a page similar to the following is displayed:"
msgstr ""

msgid "Resource Server Settings"
msgstr ""

msgid "image:{project_images}/resource-server/authz-settings.png[alt=\"Resource Server Settings\"]"
msgstr ""

msgid "The Authorization tab contains additional sub-tabs covering the different steps that you must follow to actually protect your application's resources. Each tab is covered separately by a specific topic in this documentation. But here is a quick description about each one:"
msgstr ""

msgid "*Settings*"
msgstr ""

msgid "General settings for your resource server. For more details about this page see the xref:resource_server_settings[Resource Server Settings] section."
msgstr ""

msgid "*Resource*"
msgstr ""

msgid "From this page, you can manage your application's <<_resource_overview, resources>>."
msgstr ""

msgid "*Authorization Scopes*"
msgstr ""

msgid "From this page, you can manage <<_resource_overview, scopes>>."
msgstr ""

msgid "*Policies*"
msgstr ""

msgid "From this page, you can manage <<_policy_overview, authorization policies>> and define the conditions that must be met to grant a permission."
msgstr ""

msgid "*Permissions*"
msgstr ""

msgid "From this page, you can manage the <<_permission_overview, permissions>> for your protected resources and scopes by linking them with the policies you created."
msgstr ""

msgid "*Evaluate*"
msgstr ""

msgid "From this page, you can <<_policy_evaluation_overview, simulate authorization requests>> and view the result of the evaluation of the permissions and authorization policies you have defined."
msgstr ""

msgid "*Export Settings*"
msgstr ""

msgid "From this page, you can <<_resource_server_import_config, export>> the authorization settings to a JSON file."
msgstr ""

msgid "On the Resource Server Settings page, you can configure the policy enforcement mode, allow remote resource management, and export the authorization configuration settings."
msgstr ""

msgid "*Policy Enforcement Mode*"
msgstr ""

msgid "Specifies how policies are enforced when processing authorization requests sent to the server."
msgstr ""

msgid "*Enforcing*"
msgstr ""

msgid "(default mode) Requests are denied by default even when there is no policy associated with a given resource."
msgstr ""

msgid "*Permissive*"
msgstr ""

msgid "Requests are allowed even when there is no policy associated with a given resource."
msgstr ""

msgid "*Disabled*"
msgstr ""

msgid "Disables the evaluation of all policies and allows access to all resources."
msgstr ""

msgid "*Decision Strategy*"
msgstr ""

msgid "This configurations changes how the policy evaluation engine decides whether or not a resource or scope should be granted based on the outcome from all evaluated permissions. `Affirmative` means that at least one permission must evaluate to a positive decision in order grant access to a resource and its scopes. `Unanimous` means that all permissions must evaluate to a positive decision in order for the final decision to be also positive. As an example, if two permissions for a same resource or scope are in conflict (one of them is granting access and the other is denying access), the permission to the resource or scope will be granted if the choosen strategy is `Affirmative`. Otherwise, a single deny from any permission will also deny access to the resource or scope."
msgstr ""

msgid "*Remote Resource Management*"
msgstr ""

msgid "Specifies whether resources can be managed remotely by the resource server. If false, resources can be managed only from the administration console."
msgstr ""

msgid "Default Configuration"
msgstr ""

msgid "When you create a resource server, {project_name} creates a default configuration for your newly created resource server."
msgstr ""

msgid "The default configuration consists of:"
msgstr ""

msgid "A default protected resource representing all resources in your application."
msgstr ""

msgid "A policy that always grants access to the resources protected by this policy."
msgstr ""

msgid "A permission that governs access to all resources based on the default policy."
msgstr ""

msgid "The default protected resource is referred to as the *default resource* and you can view it if you navigate to the *Resources* tab."
msgstr ""

msgid "Default Resource"
msgstr ""

msgid "image:{project_images}/resource-server/default-resource.png[alt=\"Default Resource\"]"
msgstr ""

msgid "This resource defines a `Type`, namely `urn:my-resource-server:resources:default` and a `URI` `/*`. Here, the `URI` field defines a wildcard pattern that indicates to {project_name} that this resource represents all the paths in your application. In other words, when enabling <<_enforcer_overview, policy enforcement>> for your application, all the permissions associated with the resource will be examined before granting access."
msgstr ""

msgid "The `Type` mentioned previously defines a value that can be used to create <<_permission_typed_resource, typed resource permissions>> that must be applied to the default resource or any other resource you create using the same type."
msgstr ""

msgid "The default policy is referred to as the *only from realm policy* and you can view it if you navigate to the *Policies* tab."
msgstr ""

msgid "Default Policy"
msgstr ""

msgid "image:{project_images}/resource-server/default-policy.png[alt=\"Default Policy\"]"
msgstr ""

msgid "This policy is a <<_policy_js, JavaScript-based policy>> defining a condition that always grants access to the resources protected by this policy. If you click this policy you can see that it defines a rule as follows:"
msgstr ""

msgid ""
"// by default, grants any permission associated with this policy\n"
"$evaluation.grant();"
msgstr ""

msgid "Lastly, the default permission is referred to as the *default permission* and you can view it if you navigate to the *Permissions* tab."
msgstr ""

msgid "Default Permission"
msgstr ""

msgid "image:{project_images}/resource-server/default-permission.png[alt=\"Default Permission\"]"
msgstr ""

msgid "This permission is a <<_permission_create_resource, resource-based permission>>, defining a set of one or more policies that are applied to all resources with a given type."
msgstr ""

msgid "Changing the Default Configuration"
msgstr ""

msgid "You can change the default configuration by removing the default resource, policy, or permission definitions and creating your own."
msgstr ""

msgid "The default resource is created with an **URI** that maps to any resource or path in your application using a **/*** pattern. Before creating your own resources, permissions and policies, make sure the default configuration doesn't conflict with your own settings."
msgstr ""

msgid "The default configuration defines a resource that maps to all paths in your application. If you are about to write permissions to your own resources, be sure to remove the *Default Resource* or change its ```URIS``` fields to a more specific paths in your application. Otherwise, the policy associated with the default resource (which by default always grants access) will allow {project_name} to grant access to any protected resource."
msgstr ""

msgid "Export and Import Authorization Configuration"
msgstr ""

msgid "The configuration settings for a resource server (or client) can be exported and downloaded. You can also import an existing configuration file for a resource server. Importing and exporting a configuration file is helpful when you want to create an initial configuration for a resource server or to update an existing configuration. The configuration file contains definitions for:"
msgstr ""

msgid "Protected resources and scopes"
msgstr ""

msgid "Policies"
msgstr ""

msgid "Permissions"
msgstr ""

msgid "Exporting a Configuration File"
msgstr ""

msgid "To export a configuration file, complete the following steps:"
msgstr ""

msgid "Navigate to the *Resource Server Settings* page."
msgstr ""

msgid "Click the *Export Settings* tab."
msgstr ""

msgid "On this page, click *Export*."
msgstr ""

msgid "Export Settings"
msgstr ""

msgid "image:{project_images}/resource-server/authz-export.png[alt=\"Export Settings\"]"
msgstr ""

msgid "The configuration file is exported in JSON format and displayed in a text area, from which you can copy and paste. You can also click *Download* to download the configuration file and save it."
msgstr ""

msgid "Importing a Configuration File"
msgstr ""

msgid "To import a configuration file, complete the following steps:"
msgstr ""

msgid "Import Settings"
msgstr ""

msgid "image:{project_images}/resource-server/authz-settings.png[alt=\"Import Settings\"]"
msgstr ""

msgid "To import a configuration file for a resource server, click *Select file* to select a file containing the configuration you want to import."
msgstr ""

msgid "Managing Resources and Scopes"
msgstr ""

msgid "Resource management is straightforward and generic. After creating a resource server, you can start creating the resources and scopes that you want to protect. Resources and scopes can be managed by navigating to the *Resource* and *Authorization Scopes* tabs, respectively."
msgstr ""

msgid "Viewing Resources"
msgstr ""

msgid "On the *Resource* page, you see a list of the resources associated with a resource server."
msgstr ""

msgid "Resources"
msgstr ""

msgid "image:{project_images}/resource/view.png[alt=\"Resources\"]"
msgstr ""

msgid "The resource list provides information about the protected resources, such as:"
msgstr ""

msgid "Type"
msgstr ""

msgid "URIS"
msgstr ""

msgid "Owner"
msgstr ""

msgid "Associated scopes, if any"
msgstr ""

msgid "Associated permissions"
msgstr ""

msgid "From this list, you can also directly create a permission by clicking *Create Permission* for the resource for which you want to create the permission."
msgstr ""

msgid "Before creating permissions for your resources, be sure you have already defined the policies that you want to associate with the permission."
msgstr ""

msgid "Creating Resources"
msgstr ""

msgid "Creating a resource is straightforward and generic. Your main concern is the granularity of the resources you create. In other words, resources can be created to represent a set of one or more resources and the way you define them is crucial to managing permissions."
msgstr ""

msgid "To create a new resource, click *Create* in the right upper corner of the resource listing."
msgstr ""

msgid "Add Resource"
msgstr ""

msgid "image:{project_images}/resource/create.png[alt=\"Add Resource\"]"
msgstr ""

msgid "In {project_name}, a resource defines a small set of information that is common to different types of resources, such as:"
msgstr ""

msgid "*Name*"
msgstr ""

msgid "A human-readable and unique string describing this resource."
msgstr ""

msgid "*Type*"
msgstr ""

msgid "A string uniquely identifying the type of a set of one or more resources. The type is a _string_ used to group different resource instances. For example, the default type for the default resource that is automatically created is `urn:resource-server-name:resources:default`"
msgstr ""

msgid "*URIS*"
msgstr ""

msgid "URIS that provides the locations/addresses for the resource. For HTTP resources, the URIS are usually the relative paths used to serve these resources."
msgstr ""

msgid "*Scopes*"
msgstr ""

msgid "One or more scopes to associate with the resource."
msgstr ""

msgid "Resource Attributes"
msgstr ""

msgid "Resources may have attributes associated with them. These attributes can be used to provide additional information about a resource and to provide additional information to policies when evaluating permissions associated with a resource."
msgstr ""

msgid "Each attribute is a key and value pair where the value can be a set of one or many strings. Multiple values can be defined for an attribute by separating each value with a comma."
msgstr ""

msgid "Typed Resources"
msgstr ""

msgid "The type field of a resource can be used to group different resources together, so they can be protected using a common set of permissions."
msgstr ""

msgid "Resource Owners"
msgstr ""

msgid "Resources also have an owner. By default, resources are owned by the resource server."
msgstr ""

msgid "However, resources can also be associated with users, so you can create permissions based on the resource owner. For example, only the resource owner is allowed to delete or update a given resource."
msgstr ""

msgid "Managing Resources Remotely"
msgstr ""

msgid "Resource management is also exposed through the <<_service_protection_api, Protection API>> to allow resource servers to remotely manage their resources."
msgstr ""

msgid "When using the Protection API, resource servers can be implemented to manage resources owned by their users. In this case, you can specify the user identifier to configure a resource as belonging to a specific user."
msgstr ""

msgid "{project_name} provides resource servers complete control over their resources. In the future, we should be able to allow users to control their own resources as well as approve authorization requests and manage permissions, especially when using the UMA protocol."
msgstr ""

msgid "Managing Policies"
msgstr ""

msgid "As mentioned previously, policies define the conditions that must be satisfied before granting access to an object."
msgstr ""

msgid "You can view all policies associated with a resource server by clicking the *Policy* tab when editing a resource server."
msgstr ""

msgid "image:{project_images}/policy/view.png[alt=\"Policies\"]"
msgstr ""

msgid "On this tab, you can view the list of previously created policies as well as create and edit a policy."
msgstr ""

msgid "To create a new policy, in the upper right corner of the policy list, select a policy type from the `Create policy` dropdown list. Details about each policy type are described in this section."
msgstr ""

msgid "User-Based Policy"
msgstr ""

msgid "You can use this type of policy to define conditions for your permissions where a set of one or more users is permitted to access an object."
msgstr ""

msgid "To create a new user-based policy, select *User* in the dropdown list in the upper right corner of the policy listing."
msgstr ""

msgid "Add a User-Based Policy"
msgstr ""

msgid "image:{project_images}/policy/create-user.png[alt=\"Add User-Based Policy\"]"
msgstr ""

msgid "Configuration"
msgstr ""

msgid "A human-readable and unique string identifying the policy. A best practice is to use names that are closely related to your business and security requirements, so you can identify them more easily."
msgstr ""

msgid "*Description*"
msgstr ""

msgid "A string containing details about this policy."
msgstr ""

msgid "*Users*"
msgstr ""

msgid "Specifies which users are given access by this policy."
msgstr ""

msgid "*Logic*"
msgstr ""

msgid "The <<_policy_logic, Logic>> of this policy to apply after the other conditions have been evaluated."
msgstr ""

msgid "Role-Based Policy"
msgstr ""

msgid "You can use this type of policy to define conditions for your permissions where a set of one or more roles is permitted to access an object."
msgstr ""

msgid "By default, roles added to this policy are not specified as required and the policy will grant access if the user requesting access has been granted any of these roles. However, you can specify a specific role as <<_policy_rbac_required, required>> if you want to enforce a specific role. You can also combine required and non-required roles, regardless of whether they are realm or client roles."
msgstr ""

msgid "Role policies can be useful when you need more restricted role-based access control (RBAC), where specific roles must be enforced to grant access to an object. For instance, you can enforce that a user must consent to allowing a client application (which is acting on the user's behalf) to access the user's resources. You can use {project_name} Client Scope Mapping to enable consent pages or even enforce clients to explicitly provide a scope when obtaining access tokens from a {project_name} server."
msgstr ""

msgid "To create a new role-based policy, select *Role* in the dropdown list in the upper right corner of the policy listing."
msgstr ""

msgid "Add Role-Based Policy"
msgstr ""

msgid "image:{project_images}/policy/create-role.png[alt=\"Add Role-Based Policy\"]"
msgstr ""

msgid "A human-readable and unique string describing the policy. A best practice is to use names that are closely related to your business and security requirements, so you can identify them more easily."
msgstr ""

msgid "*Realm Roles*"
msgstr ""

msgid "Specifies which *realm* roles are permitted by this policy."
msgstr ""

msgid "*Client Roles*"
msgstr ""

msgid "Specifies which *client* roles are permitted by this policy. To enable this field must first select a `Client`."
msgstr ""

msgid "Defining a Role as Required"
msgstr ""

msgid "When creating a role-based policy, you can specify a specific role as `Required`. When you do that, the policy will grant access only if the user requesting access has been granted *all* the *required* roles. Both realm and client roles can be configured as such."
msgstr ""

msgid "Example of Required Role"
msgstr ""

msgid "image:{project_images}/policy/create-role.png[alt=\"Example of Required Role\"]"
msgstr ""

msgid "To specify a role as required, select the `Required` checkbox for the role you want to configure as required."
msgstr ""

msgid "Required roles can be useful when your policy defines multiple roles but only a subset of them are mandatory. In this case, you can combine realm and client roles to enable an even more fine-grained role-based access control (RBAC) model for your application. For example, you can have policies specific for a client and require a specific client role associated with that client. Or you can enforce that access is granted only in the presence of a specific realm role. You can also combine both approaches within the same policy."
msgstr ""

msgid "JavaScript-Based Policy"
msgstr ""

msgid "If your policy implementation is using Attribute based access control (ABAC) as in the examples below, then please make sure that users are not able to edit the protected attributes and the corresponding attributes are read-only. See the details in the link:{adminguide_link}#_read_only_user_attributes[Threat model mitigation chapter]."
msgstr ""

msgid "You can use this type of policy to define conditions for your permissions using JavaScript. It is one of the rule-based policy types supported by {project_name}, and provides flexibility to write any policy based on the <<_policy_evaluation_api, Evaluation API>>."
msgstr ""

msgid "To create a new JavaScript-based policy, select *JavaScript* in the dropdown list in the upper right corner of the policy listing."
msgstr ""

msgid "By default, JavaScript Policies can not be uploaded to the server. You should prefer deploying your JS Policies directly to the server as described in link:{developerguide_jsproviders_link}[{developerguide_jsproviders_name}]. If you still want to use the {project_name} Administration Console to manage your JS policies you should enable the `Upload Scripts` feature."
msgstr ""

msgid "Add JavaScript Policy"
msgstr ""

msgid "image:{project_images}/policy/create-js.png[alt=\"Add JavaScript Policy\"]"
msgstr ""

msgid "*Code*"
msgstr ""

msgid "The JavaScript code providing the conditions for this policy."
msgstr ""

msgid "Creating a JS Policy from a Deployed JAR File"
msgstr ""

msgid "{project_name} allows you to deploy a JAR file in order to deploy scripts to the server. Please, take a look at link:{developerguide_jsproviders_link}[{developerguide_jsproviders_name}] for more details."
msgstr ""

msgid "Once you have your scripts deployed, you should be able to select the scripts you deployed from the list of available policy providers."
msgstr ""

msgid "Examples"
msgstr ""

msgid "Checking for attributes from the evaluation context"
msgstr ""

msgid "Here is a simple example of a JavaScript-based policy that uses attribute-based access control (ABAC) to define a condition based on an attribute obtained from the execution context:"
msgstr ""

msgid ""
"var context = $evaluation.getContext();\n"
"var contextAttributes = context.getAttributes();\n"
"\n"
"if (contextAttributes.containsValue('kc.client.network.ip_address', '127.0.0.1')) {\n"
"    $evaluation.grant();\n"
"}"
msgstr ""

msgid "Checking for attributes from the current identity"
msgstr ""

msgid "Here is a simple example of a JavaScript-based policy that uses attribute-based access control (ABAC) to define a condition based on an attribute obtained associated with the current identity:"
msgstr ""

msgid ""
"var context = $evaluation.getContext();\n"
"var identity = context.getIdentity();\n"
"var attributes = identity.getAttributes();\n"
"var email = attributes.getValue('email').asString(0);\n"
"\n"
"if (email.endsWith('@keycloak.org')) {\n"
"    $evaluation.grant();\n"
"}"
msgstr ""

msgid "Where these attributes are mapped from whatever claim is defined in the token that was used in the authorization request."
msgstr ""

msgid "Checking for roles granted to the current identity"
msgstr ""

msgid "You can also use Role-Based Access Control (RBAC) in your policies. In the example below, we check if a user is granted with a `keycloak_user` *realm* role:"
msgstr ""

msgid ""
"var context = $evaluation.getContext();\n"
"var identity = context.getIdentity();\n"
"\n"
"if (identity.hasRealmRole('keycloak_user')) {\n"
"    $evaluation.grant();\n"
"}"
msgstr ""

msgid "Or you can check if a user is granted with a `my-client-role` *client* role, where `my-client` is the client id of the client application:"
msgstr ""

msgid ""
"var context = $evaluation.getContext();\n"
"var identity = context.getIdentity();\n"
"\n"
"if (identity.hasClientRole('my-client', 'my-client-role')) {\n"
"    $evaluation.grant();\n"
"}"
msgstr ""

msgid "Checking for roles granted to an user"
msgstr ""

msgid "To check for realm roles granted to an user:"
msgstr ""

msgid ""
"var realm = $evaluation.getRealm();\n"
"\n"
"if (realm.isUserInRealmRole('marta', 'role-a')) {\n"
"    $evaluation.grant();\n"
"}"
msgstr ""

msgid "Or for client roles granted to an user:"
msgstr ""

msgid ""
"var realm = $evaluation.getRealm();\n"
"\n"
"if (realm.isUserInClientRole('marta', 'my-client', 'some-client-role')) {\n"
"    $evaluation.grant();\n"
"}"
msgstr ""

msgid "Checking for roles granted to a group"
msgstr ""

msgid "To check for realm roles granted to a group:"
msgstr ""

msgid ""
"var realm = $evaluation.getRealm();\n"
"\n"
"if (realm.isGroupInRole('/Group A/Group D', 'role-a')) {\n"
"    $evaluation.grant();\n"
"}"
msgstr ""

msgid "Pushing arbitrary claims to the resource server"
msgstr ""

msgid "To push arbitrary claims to the resource server in order to provide additional information on how permissions should be enforced:"
msgstr ""

msgid ""
"var permission = $evaluation.getPermission();\n"
"\n"
"// decide if permission should be granted\n"
"\n"
"if (granted) {\n"
"    permission.addClaim('claim-a', 'claim-a');\n"
"    permission.addClaim('claim-a', 'claim-a1');\n"
"    permission.addClaim('claim-b', 'claim-b');\n"
"}\n"
msgstr ""

msgid "Checking for group membership"
msgstr ""

msgid ""
"var realm = $evaluation.getRealm();\n"
"\n"
"if (realm.isUserInGroup('marta', '/Group A/Group B')) {\n"
"    $evaluation.grant();\n"
"}"
msgstr ""

msgid "Mixing different access control mechanisms"
msgstr ""

msgid "You can also use a combination of several access control mechanisms. The example below shows how roles(RBAC) and claims/attributes(ABAC) checks can be used within the same policy. In this case we check if user is granted with `admin` role or has an e-mail from `keycloak.org` domain:"
msgstr ""

msgid ""
"var context = $evaluation.getContext();\n"
"var identity = context.getIdentity();\n"
"var attributes = identity.getAttributes();\n"
"var email = attributes.getValue('email').asString(0);\n"
"\n"
"if (identity.hasRealmRole('admin') || email.endsWith('@keycloak.org')) {\n"
"    $evaluation.grant();\n"
"}"
msgstr ""

msgid "When writing your own rules, keep in mind that the *$evaluation* object is an object implementing *org.keycloak.authorization.policy.evaluation.Evaluation*. For more information about what you can access from this interface, see the <<_policy_evaluation_api, Evaluation API>>."
msgstr ""

msgid "Time-Based Policy"
msgstr ""

msgid "You can use this type of policy to define time conditions for your permissions."
msgstr ""

msgid "To create a new time-based policy, select *Time* in the dropdown list in the upper right corner of the policy listing."
msgstr ""

msgid "Add Time Policy"
msgstr ""

msgid "image:{project_images}/policy/create-time.png[alt=\"Add Time Policy\"]"
msgstr ""

msgid "*Not Before*"
msgstr ""

msgid "Defines the time before which access must *not* be granted. Permission is granted only if the current date/time is later than or equal to this value."
msgstr ""

msgid "*Not On or After*"
msgstr ""

msgid "Defines the time after which access must *not* be granted. Permission is granted only if the current date/time is earlier than or equal to this value."
msgstr ""

msgid "*Day of Month*"
msgstr ""

msgid "Defines the day of month that access must be granted. You can also specify a range of dates. In this case, permission is granted only if the current day of the month is between or equal to the two values specified."
msgstr ""

msgid "*Month*"
msgstr ""

msgid "Defines the month that access must be granted. You can also specify a range of months. In this case, permission is granted only if the current month is between or equal to the two values specified."
msgstr ""

msgid "*Year*"
msgstr ""

msgid "Defines the year that access must be granted. You can also specify a range of years. In this case, permission is granted only if the current year is between or equal to the two values specified."
msgstr ""

msgid "*Hour*"
msgstr ""

msgid "Defines the hour that access must be granted. You can also specify a range of hours. In this case, permission is granted only if current hour is between or equal to the two values specified."
msgstr ""

msgid "*Minute*"
msgstr ""

msgid "Defines the minute that access must be granted. You can also specify a range of minutes. In this case, permission is granted only if the current minute is between or equal to the two values specified."
msgstr ""

msgid "Access is only granted if all conditions are satisfied. {project_name} will perform an _AND_ based on the outcome of each condition."
msgstr ""

msgid "Aggregated Policy"
msgstr ""

msgid "As mentioned previously, {project_name} allows you to build a policy of policies, a concept referred to as policy aggregation. You can use policy aggregation to reuse existing policies to build more complex ones and keep your permissions even more decoupled from the policies that are evaluated during the processing of authorization requests."
msgstr ""

msgid "To create a new aggregated policy, select *Aggregated* in the dropdown list located in the right upper corner of the policy listing."
msgstr ""

msgid "Add an Aggregated Policy"
msgstr ""

msgid "image:{project_images}/policy/create-aggregated.png[alt=\"Add Aggregated Policy\"]"
msgstr ""

msgid "Let's suppose you have a resource called _Confidential Resource_ that can be accessed only by users from the _keycloak.org_ domain and from a certain range of IP addresses. You can create a single policy with both conditions. However, you want to reuse the domain part of this policy to apply to permissions that operates regardless of the originating network."
msgstr ""

msgid "You can create separate policies for both domain and network conditions and create a third policy based on the combination of these two policies. With an aggregated policy, you can freely combine other policies and then apply the new aggregated policy to any permission you want."
msgstr ""

msgid "When creating aggregated policies, be mindful that you are not introducing a circular reference or dependency between policies. If a circular dependency is detected, you cannot create or update the policy."
msgstr ""

msgid "A human-readable and unique string describing the policy. We strongly suggest that you use names that are closely related with your business and security requirements, so you can identify them more easily and also know what they mean."
msgstr ""

msgid "A string with more details about this policy."
msgstr ""

msgid "*Apply Policy*"
msgstr ""

msgid "Defines a set of one or more policies to associate with the aggregated policy. To associate a policy you can either select an existing policy or create a new one by selecting the type of the policy you want to create."
msgstr ""

msgid "The decision strategy for this permission."
msgstr ""

msgid "Decision Strategy for Aggregated Policies"
msgstr ""

msgid "When creating aggregated policies, you can also define the decision strategy that will be used to determine the final decision based on the outcome from each policy."
msgstr ""

msgid "*Unanimous*"
msgstr ""

msgid "The default strategy if none is provided. In this case, _all_ policies must evaluate to a positive decision for the final decision to be also positive."
msgstr ""

msgid "*Affirmative*"
msgstr ""

msgid "In this case, _at least one_ policy must evaluate to a positive decision in order for the final decision to be also positive."
msgstr ""

msgid "*Consensus*"
msgstr ""

msgid "In this case, the number of positive decisions must be greater than the number of negative decisions. If the number of positive and negative decisions is the same, the final decision will be negative."
msgstr ""

msgid "Client-Based Policy"
msgstr ""

msgid "You can use this type of policy to define conditions for your permissions where a set of one or more clients is permitted to access an object."
msgstr ""

msgid "To create a new client-based policy, select *Client* in the dropdown list in the upper right corner of the policy listing."
msgstr ""

msgid "Add a Client-Based Policy"
msgstr ""

msgid "image:images/policy/create-client.png[alt=\"Add Client-Based Policy\"]"
msgstr ""

msgid "*Clients*"
msgstr ""

msgid "Specifies which clients are given access by this policy."
msgstr ""

msgid "Group-Based Policy"
msgstr ""

msgid "You can use this type of policy to define conditions for your permissions where a set of one or more groups (and their hierarchies) is permitted to access an object."
msgstr ""

msgid "To create a new group-based policy, select *Group* in the dropdown list in the upper right corner of the policy listing."
msgstr ""

msgid "Add Group-Based Policy"
msgstr ""

msgid "image:{project_images}/policy/create-group.png[alt=\"Add Group-Based Policy\"]"
msgstr ""

msgid "*Groups Claim*"
msgstr ""

msgid "Specifies the name of the claim in the token holding the group names and/or paths. Usually, authorization requests are processed based on an ID Token or Access Token previously issued to a client acting on behalf of some user. If defined, the token must include a claim from where this policy is going to obtain the groups the user is a member of. If not defined, user's groups are obtained from your realm configuration."
msgstr ""

msgid "*Groups*"
msgstr ""

msgid "Allows you to select the groups that should be enforced by this policy when evaluating permissions. After adding a group, you can extend access to children of the group by marking the checkbox *Extend to Children*. If left unmarked, access restrictions only applies to the selected group."
msgstr ""

msgid "Extending Access to Child Groups"
msgstr ""

msgid "By default, when you add a group to this policy, access restrictions will only apply to members of the selected group."
msgstr ""

msgid "Under some circumstances, it might be necessary to allow access not only to the group itself but to any child group in the hierarchy. For any group added you can mark a checkbox *Extend to Children* in order to extend access to child groups."
msgstr ""

msgid "image:{project_images}/policy/create-group-extend-children.png[alt=\"Extending Access to Child Groups\"]"
msgstr ""

msgid "In the example above, the policy is granting access for any user member of *IT* or any of its children."
msgstr ""

msgid "Client Scope-Based Policy"
msgstr ""

msgid "You can use this type of policy to define conditions for your permissions where a set of one or more client scopes is permitted to access an object."
msgstr ""

msgid "By default, client scopes added to this policy are not specified as required and the policy will grant access if the client requesting access has been granted any of these client scopes. However, you can specify a specific client scope as <<_policy_client_scope_required, required>> if you want to enforce a specific client scope."
msgstr ""

msgid "To create a new client scope-based policy, select *Client Scope* in the dropdown list in the upper right corner of the policy listing."
msgstr ""

msgid "Add Client Scope-Based Policy"
msgstr ""

msgid "image:images/policy/create-client-scope.png[alt=\"Add Client Scope-Based Policy\"]"
msgstr ""

msgid "*Client Scopes*"
msgstr ""

msgid "Specifies which client scopes are permitted by this policy."
msgstr ""

msgid "Defining a Client Scope as Required"
msgstr ""

msgid "When creating a client scope-based policy, you can specify a specific client scope as `Required`. When you do that, the policy will grant access only if the client requesting access has been granted *all* the *required* client scopes."
msgstr ""

msgid "Example of Required Client Scope"
msgstr ""

msgid "image:images/policy/create-client-scope.png[alt=\"Example of Required Client Scope\"]"
msgstr ""

msgid "To specify a client scope as required, select the `Required` checkbox for the client scope you want to configure as required."
msgstr ""

msgid "Required client scopes can be useful when your policy defines multiple client scopes but only a subset of them are mandatory."
msgstr ""

msgid "Regex-Based Policy"
msgstr ""

msgid "You can use this type of policy to define regex conditions for your permissions."
msgstr ""

msgid "To create a new regex-based policy, select *Regex* in the item list in the upper right corner of the policy listing."
msgstr ""

msgid "Add Regex-Based Policy"
msgstr ""

msgid "image:images/policy/create-regex.png[alt=\"Add Regex-Based Policy\"]"
msgstr ""

msgid "*Target Claim*"
msgstr ""

msgid "Specifies the name of the target claim in the token."
msgstr ""

msgid "*Regex Pattern*"
msgstr ""

msgid "Specifies the regex pattern."
msgstr ""

msgid "Positive and Negative Logic"
msgstr ""

msgid "Policies can be configured with positive or negative logic. Briefly, you can use this option to define whether the policy result should be kept as it is or be negated."
msgstr ""

msgid "For example, suppose you want to create a policy where only users *not* granted with a specific role should be given access. In this case, you can create a role-based policy using that role and set its *Logic* field to *Negative*. If you keep *Positive*, which is the default behavior, the policy result will be kept as it is."
msgstr ""

msgid "Policy Evaluation API"
msgstr ""

msgid "When writing rule-based policies using JavaScript, {project_name} provides an Evaluation API that provides useful information to help determine whether a permission should be granted."
msgstr ""

msgid "This API consists of a few interfaces that provide you access to information, such as"
msgstr ""

msgid "The permission being evaluated, representing both the resource and scopes being requested."
msgstr ""

msgid "The attributes associated with the resource being requested"
msgstr ""

msgid "Runtime environment and any other attribute associated with the execution context"
msgstr ""

msgid "Information about users such as group membership and roles"
msgstr ""

msgid "The main interface is *org.keycloak.authorization.policy.evaluation.Evaluation*, which defines the following contract:"
msgstr ""

msgid ""
"public interface Evaluation {\n"
"\n"
"    /**\n"
"     * Returns the {@link ResourcePermission} to be evaluated.\n"
"     *\n"
"     * @return the permission to be evaluated\n"
"     */\n"
"    ResourcePermission getPermission();\n"
"\n"
"    /**\n"
"     * Returns the {@link EvaluationContext}. Which provides access to the whole evaluation runtime context.\n"
"     *\n"
"     * @return the evaluation context\n"
"     */\n"
"    EvaluationContext getContext();\n"
"\n"
"    /**\n"
"     * Returns a {@link Realm} that can be used by policies to query information.\n"
"     *\n"
"     * @return a {@link Realm} instance\n"
"     */\n"
"    Realm getRealm();\n"
"\n"
"    /**\n"
"     * Grants the requested permission to the caller.\n"
"     */\n"
"    void grant();\n"
"\n"
"    /**\n"
"     * Denies the requested permission.\n"
"     */\n"
"    void deny();\n"
"}"
msgstr ""

msgid "When processing an authorization request, {project_name} creates an `Evaluation` instance before evaluating any policy. This instance is then passed to each policy to determine whether access is *GRANT* or *DENY*."
msgstr ""

msgid "Policies determine this by invoking the `grant()` or `deny()` methods on an `Evaluation` instance. By default, the state of the `Evaluation` instance is denied, which means that your policies must explicitly invoke the `grant()` method to indicate to the policy evaluation engine that permission should be granted."
msgstr ""

msgid "For more information about the Evaluation API see the {apidocs_link}[JavaDocs]."
msgstr ""

msgid "The Evaluation Context"
msgstr ""

msgid "The evaluation context provides useful information to policies during their evaluation."
msgstr ""

msgid ""
"public interface EvaluationContext {\n"
"\n"
"    /**\n"
"     * Returns the {@link Identity} that represents an entity (person or non-person) to which the permissions must be granted, or not.\n"
"     *\n"
"     * @return the identity to which the permissions must be granted, or not\n"
"     */\n"
"    Identity getIdentity();\n"
"\n"
"    /**\n"
"     * Returns all attributes within the current execution and runtime environment.\n"
"     *\n"
"     * @return the attributes within the current execution and runtime environment\n"
"     */\n"
"    Attributes getAttributes();\n"
"}"
msgstr ""

msgid "From this interface, policies can obtain:"
msgstr ""

msgid "The authenticated `Identity`"
msgstr ""

msgid "Information about the execution context and runtime environment"
msgstr ""

msgid "The `Identity` is built based on the OAuth2 Access Token that was sent along with the authorization request, and this construct has access to all claims extracted from the original token. For example, if you are using a _Protocol Mapper_ to include a custom claim in an OAuth2 Access Token you can also access this claim from a policy and use it to build your conditions."
msgstr ""

msgid "The `EvaluationContext` also gives you access to attributes related to both the execution and runtime environments. For now, there only a few built-in attributes."
msgstr ""

msgid "Execution and Runtime Attributes"
msgstr ""

msgid "kc.time.date_time"
msgstr ""

msgid "Current date and time"
msgstr ""

msgid "String. Format `MM/dd/yyyy hh:mm:ss`"
msgstr ""

msgid "kc.client.network.ip_address"
msgstr ""

msgid "IPv4 address of the client"
msgstr ""

msgid "String"
msgstr ""

msgid "kc.client.network.host"
msgstr ""

msgid "Client's host name"
msgstr ""

msgid "kc.client.id"
msgstr ""

msgid "The client id"
msgstr ""

msgid "kc.client.user_agent"
msgstr ""

msgid "The value of the 'User-Agent' HTTP header"
msgstr ""

msgid "String[]"
msgstr ""

msgid "kc.realm.name"
msgstr ""

msgid "The name of the realm"
msgstr ""

msgid "Managing Permissions"
msgstr ""

msgid "A permission associates the object being protected and the policies that must be evaluated to decide whether access should be granted."
msgstr ""

msgid "After creating the resources you want to protect and the policies you want to use to protect these resources, you can start managing permissions. To manage permissions, click the *Permissions* tab when editing a resource server."
msgstr ""

msgid "image:{project_images}/permission/view.png[alt=\"Permissions\"]"
msgstr ""

msgid "Permissions can be created to protect two main types of objects:"
msgstr ""

msgid "*Resources*"
msgstr ""

msgid "To create a permission, select the permission type you want to create from the dropdown list in the upper right corner of the permission listing. The following sections describe these two types of objects in more detail."
msgstr ""

msgid "Creating Resource-Based Permissions"
msgstr ""

msgid "A resource-based permission defines a set of one or more resources to protect using a set of one or more authorization policies."
msgstr ""

msgid "To create a new resource-based permission, select *Resource-based* in the dropdown list in the upper right corner of the permission listing."
msgstr ""

msgid "Add Resource-Based Permission"
msgstr ""

msgid "image:{project_images}/permission/create-resource.png[alt=\"Add Resource-Based Permission\"]"
msgstr ""

msgid "A human-readable and unique string describing the permission. A best practice is to use names that are closely related to your business and security requirements, so you can identify them more easily."
msgstr ""

msgid "A string containing details about this permission."
msgstr ""

msgid "*Apply To Resource Type*"
msgstr ""

msgid "Specifies if the permission is applied to all resources with a given type. When selecting this field, you are prompted to enter the resource type to protect."
msgstr ""

msgid "Resource Type"
msgstr ""

msgid "Defines the resource type to protect. When defined, this permission is evaluated for all resources matching that type."
msgstr ""

msgid "Defines a set of one or more resources to protect."
msgstr ""

msgid "Defines a set of one or more policies to associate with a permission. To associate a policy you can either select an existing policy or create a new one by selecting the type of the policy you want to create."
msgstr ""

msgid "The <<_permission_decision_strategies, Decision Strategy>> for this permission."
msgstr ""

msgid "Typed Resource Permission"
msgstr ""

msgid "Resource permissions can also be used to define policies that are to be applied to all resources with a given <<_resource_create_type, type>>. This form of resource-based permission can be useful when you have resources sharing common access requirements and constraints."
msgstr ""

msgid "Frequently, resources within an application can be categorized (or typed) based on the data they encapsulate or the functionality they provide. For example, a financial application can manage different banking accounts where each one belongs to a specific customer. Although they are different banking accounts, they share common security requirements and constraints that are globally defined by the banking organization. With typed resource permissions, you can define common policies to apply to all banking accounts, such as:"
msgstr ""

msgid "Only the owner can manage his account"
msgstr ""

msgid "Only allow access from the owner's country and/or region"
msgstr ""

msgid "Enforce a specific authentication method"
msgstr ""

msgid "To create a typed resource permission, click <<_permission_create_resource_apply_resource_type, Apply to Resource Type>> when creating a new resource-based permission. With `Apply to Resource Type` set to `On`, you can specify the type that you want to protect as well as the policies that are to be applied to govern access to all resources with type you have specified."
msgstr ""

msgid "Example of a Typed Resource Permission"
msgstr ""

msgid "image:{project_images}/permission/typed-resource-perm-example.png[alt=\"Example of a Typed Resource Permission\"]"
msgstr ""

msgid "Creating Scope-Based Permissions"
msgstr ""

msgid "A scope-based permission defines a set of one or more scopes to protect using a set of one or more authorization policies. Unlike resource-based permissions, you can use this permission type to create permissions not only for a resource, but also for the scopes associated with it, providing more granularity when defining the permissions that govern your resources and the actions that can be performed on them."
msgstr ""

msgid "To create a new scope-based permission, select *Scope-based* in the dropdown list in the upper right corner of the permission listing."
msgstr ""

msgid "Add Scope-Based Permission"
msgstr ""

msgid "image:{project_images}/permission/create-scope.png[alt=\"Add Scope-Based Permission\"]"
msgstr ""

msgid "Restricts the scopes to those associated with the selected resource. If none is selected, all scopes are available."
msgstr ""

msgid "Defines a set of one or more scopes to protect."
msgstr ""

msgid "Policy Decision Strategies"
msgstr ""

msgid "When associating policies with a permission, you can also define a decision strategy to specify how to evaluate the outcome of the associated policies to determine access."
msgstr ""

msgid "In this case, _at least one_ policy must evaluate to a positive decision for the final decision to be also positive."
msgstr ""

msgid "In this case, the number of positive decisions must be greater than the number of negative decisions. If the number of positive and negative decisions is equal, the final decision will be negative."
msgstr ""

msgid "Evaluating and Testing Policies"
msgstr ""

msgid "When designing your policies, you can simulate authorization requests to test how your policies are being evaluated."
msgstr ""

msgid "You can access the Policy Evaluation Tool by clicking the `Evaluate` tab when editing a resource server. There you can specify different inputs to simulate real authorization requests and test the effect of your policies."
msgstr ""

msgid "image:{project_images}/policy-evaluation-tool/policy-evaluation-tool.png[alt=\"Policy Evaluation Tool\"]"
msgstr ""

msgid "Providing Identity Information"
msgstr ""

msgid "The *Identity Information* filters can be used to specify the user requesting permissions."
msgstr ""

msgid "Providing Contextual Information"
msgstr ""

msgid "The *Contextual Information* filters can be used to define additional attributes to the evaluation context, so that policies can obtain these same attributes."
msgstr ""

msgid "Providing the Permissions"
msgstr ""

msgid "The *Permissions* filters can be used to build an authorization request. You can request permissions for a set of one or more resources and scopes. If you want to simulate authorization requests based on all protected resources and scopes, click *Add* without specifying any `Resources` or `Scopes`."
msgstr ""

msgid "When you've specified your desired values, click *Evaluate*."
msgstr ""

msgid "{project_name} Authorization Services are built on top of well-known standards such as the OAuth2 and User-Managed Access specifications."
msgstr ""

msgid "In addition to the issuance of RPTs, {project_name} Authorization Services also provides a set of RESTful endpoints that allow resources servers to manage their protected resources, scopes, permissions and policies, helping developers to extend or integrate these capabilities into their applications in order to support fine-grained authorization."
msgstr ""

msgid "Discovering Authorization Services Endpoints and Metadata"
msgstr ""

msgid "{project_name} provides a discovery document from which clients can obtain all necessary information to interact with {project_name} Authorization Services, including endpoint locations and capabilities."
msgstr ""

msgid "The discovery document can be obtained from:"
msgstr ""

msgid ""
"curl -X GET \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm}/.well-known/uma2-configuration"
msgstr ""

msgid "Where `${host}:${port}` is the hostname (or IP address) and port where {project_name} is running and `${realm}` is the name of a realm in {project_name}."
msgstr ""

msgid "As a result, you should get a response as follows:"
msgstr ""

msgid ""
"{\n"
"\n"
"    // some claims are expected here\n"
"\n"
"    // these are the main claims in the discovery document about Authorization Services endpoints location\n"
"    \"token_endpoint\": \"http://${host}:${port}{kc_realms_path}/${realm}/protocol/openid-connect/token\",\n"
"    \"token_introspection_endpoint\": \"http://${host}:${port}{kc_realms_path}/${realm}/protocol/openid-connect/token/introspect\",\n"
"    \"resource_registration_endpoint\": \"http://${host}:${port}{kc_realms_path}/${realm}/authz/protection/resource_set\",\n"
"    \"permission_endpoint\": \"http://${host}:${port}{kc_realms_path}/${realm}/authz/protection/permission\",\n"
"    \"policy_endpoint\": \"http://${host}:${port}{kc_realms_path}/${realm}/authz/protection/uma-policy\"\n"
"}"
msgstr ""

msgid "Each of these endpoints expose a specific set of capabilities:"
msgstr ""

msgid "**token_endpoint**"
msgstr ""

msgid "A OAuth2-compliant Token Endpoint that supports the `urn:ietf:params:oauth:grant-type:uma-ticket` grant type. Through this endpoint clients can send authorization requests and obtain an RPT with all permissions granted by {project_name}."
msgstr ""

msgid "**token_introspection_endpoint**"
msgstr ""

msgid "A OAuth2-compliant Token Introspection Endpoint which clients can use to query the server to determine the active state of an RPT and to determine any other information associated with the token, such as the permissions granted by {project_name}."
msgstr ""

msgid "**resource_registration_endpoint**"
msgstr ""

msgid "A UMA-compliant Resource Registration Endpoint which resource servers can use to manage their protected resources and scopes. This endpoint provides operations create, read, update and delete resources and scopes in {project_name}."
msgstr ""

msgid "**permission_endpoint**"
msgstr ""

msgid "A UMA-compliant Permission Endpoint which resource servers can use to manage permission tickets. This endpoint provides operations create, read, update, and delete permission tickets in {project_name}."
msgstr ""

msgid "Obtaining Permissions"
msgstr ""

msgid "To obtain permissions from {project_name} you send an authorization request to the token endpoint. As a result, {project_name} will evaluate all policies associated with the resource(s) and scope(s) being requested and issue an RPT with all permissions granted by the server."
msgstr ""

msgid "Clients are allowed to send authorization requests to the token endpoint using the following parameters:"
msgstr ""

msgid "*grant_type*"
msgstr ""

msgid "This parameter is *required*. Must be `urn:ietf:params:oauth:grant-type:uma-ticket`."
msgstr ""

msgid "**ticket**"
msgstr ""

msgid "This parameter is *optional*. The most recent permission ticket received by the client as part of the UMA authorization process."
msgstr ""

msgid "**claim_token**"
msgstr ""

msgid "This parameter is *optional*. A string representing additional claims that should be considered by the server when evaluating permissions for the resource(s) and scope(s) being requested. This parameter allows clients to push claims to {project_name}. For more details about all supported token formats see `claim_token_format` parameter."
msgstr ""

msgid "**claim_token_format**"
msgstr ""

msgid "This parameter is *optional*. A string indicating the format of the token specified in the `claim_token` parameter. {project_name} supports two token formats: `urn:ietf:params:oauth:token-type:jwt` and `https://openid.net/specs/openid-connect-core-1_0.html#IDToken`. The `urn:ietf:params:oauth:token-type:jwt` format indicates that the `claim_token` parameter references an access token. The `https://openid.net/specs/openid-connect-core-1_0.html#IDToken` indicates that the `claim_token` parameter references an OpenID Connect ID Token."
msgstr ""

msgid "**rpt**"
msgstr ""

msgid "This parameter is *optional*. A previously issued RPT which permissions should also be evaluated and added in a new one. This parameter allows clients in possession of an RPT to perform incremental authorization where permissions are added on demand."
msgstr ""

msgid "**permission**"
msgstr ""

msgid "This parameter is *optional*. A string representing a set of one or more resources and scopes the client is seeking access. This parameter can be defined multiple times in order to request permission for multiple resource and scopes. This parameter is an extension to `urn:ietf:params:oauth:grant-type:uma-ticket` grant type in order to allow clients to send authorization requests without a permission ticket. The format of the string must be: `RESOURCE_ID#SCOPE_ID`. For instance: `Resource A#Scope A`, `Resource A#Scope A, Scope B, Scope C`, `Resource A`, `#Scope A`."
msgstr ""

msgid "**audience**"
msgstr ""

msgid "This parameter is *optional*. The client identifier of the resource server to which the client is seeking access. This parameter is mandatory in case the `permission` parameter is defined. It serves as a hint to {project_name} to indicate the context in which permissions should be evaluated."
msgstr ""

msgid "**response_include_resource_name**"
msgstr ""

msgid "This parameter is *optional*. A boolean value indicating to the server whether resource names should be included in the RPT's permissions. If false, only the resource identifier is included."
msgstr ""

msgid "**response_permissions_limit**"
msgstr ""

msgid "This parameter is *optional*. An integer N that defines a limit for the amount of permissions an RPT can have. When used together with `rpt` parameter, only the last N requested permissions will be kept in the RPT."
msgstr ""

msgid "**submit_request**"
msgstr ""

msgid "This parameter is *optional*. A boolean value indicating whether the server should create permission requests to the resources and scopes referenced by a permission ticket. This parameter only has effect if used together with the `ticket` parameter as part of a UMA authorization process."
msgstr ""

msgid "**response_mode**"
msgstr ""

msgid "This parameter is *optional*. A string value indicating how the server should respond to authorization requests. This parameter is specially useful when you are mainly interested in either the overall decision or the permissions granted by the server, instead of a standard OAuth2 response. Possible values are:"
msgstr ""

msgid "`decision`"
msgstr ""

msgid "Indicates that responses from the server should only represent the overall decision by returning a JSON with the following format:"
msgstr ""

msgid ""
"{\n"
"    'result': true\n"
"}"
msgstr ""

msgid "If the authorization request does not map to any permission, a `403` HTTP status code is returned instead."
msgstr ""

msgid "`permissions`"
msgstr ""

msgid "Indicates that responses from the server should contain any permission granted by the server by returning a JSON with the following format:"
msgstr ""

msgid ""
"[\n"
"    {\n"
"        'rsid': 'My Resource'\n"
"        'scopes': ['view', 'update']\n"
"    },\n"
"\n"
"    ...\n"
"]"
msgstr ""

msgid "Example of a authorization request when a client is seeking access to two resources protected by a resource server."
msgstr ""

msgid ""
"curl -X POST \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm}/protocol/openid-connect/token \\\n"
"  -H \"Authorization: Bearer ${access_token}\" \\\n"
"  --data \"grant_type=urn:ietf:params:oauth:grant-type:uma-ticket\" \\\n"
"  --data \"audience={resource_server_client_id}\" \\\n"
"  --data \"permission=Resource A#Scope A\" \\\n"
"  --data \"permission=Resource B#Scope B\""
msgstr ""

msgid "Example of a authorization request when a client is seeking access to any resource and scope protected by a resource server."
msgstr ""

msgid ""
"curl -X POST \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm}/protocol/openid-connect/token \\\n"
"  -H \"Authorization: Bearer ${access_token}\" \\\n"
"  --data \"grant_type=urn:ietf:params:oauth:grant-type:uma-ticket\" \\\n"
"  --data \"audience={resource_server_client_id}\""
msgstr ""

msgid "Example of an authorization request when a client is seeking access to a UMA protected resource after receiving a permission ticket from the resource server as part of the authorization process:"
msgstr ""

msgid ""
"curl -X POST \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm}/protocol/openid-connect/token \\\n"
"  -H \"Authorization: Bearer ${access_token}\" \\\n"
"  --data \"grant_type=urn:ietf:params:oauth:grant-type:uma-ticket\" \\\n"
"  --data \"ticket=${permission_ticket}"
msgstr ""

msgid "If {project_name} assessment process results in issuance of permissions, it issues the RPT with which it has associated the permissions:"
msgstr ""

msgid "{project_name} responds to the client with the RPT"
msgstr ""

msgid ""
"HTTP/1.1 200 OK\n"
"Content-Type: application/json\n"
"...\n"
"{\n"
"    \"access_token\": \"${rpt}\",\n"
"}"
msgstr ""

msgid "The response from the server is just like any other response from the token endpoint when using some other grant type. The RPT can be obtained from the `access_token` response parameter. If the client is not authorized, {project_name} responds with a `403` HTTP status code:"
msgstr ""

msgid "{project_name} denies the authorization request"
msgstr ""

msgid ""
"HTTP/1.1 403 Forbidden\n"
"Content-Type: application/json\n"
"...\n"
"{\n"
"    \"error\": \"access_denied\",\n"
"    \"error_description\": \"request_denied\"\n"
"}"
msgstr ""

msgid "Client Authentication Methods"
msgstr ""

msgid "Clients need to authenticate to the token endpoint in order to obtain an RPT. When using the `urn:ietf:params:oauth:grant-type:uma-ticket` grant type, clients can use any of these authentication methods:"
msgstr ""

msgid "*Bearer Token*"
msgstr ""

msgid "Clients should send an access token as a Bearer credential in an HTTP Authorization header to the token endpoint."
msgstr ""

msgid "Example: an authorization request using an access token to authenticate to the token endpoint"
msgstr ""

msgid ""
"curl -X POST \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm}/protocol/openid-connect/token \\\n"
"  -H \"Authorization: Bearer ${access_token}\" \\\n"
"  --data \"grant_type=urn:ietf:params:oauth:grant-type:uma-ticket\""
msgstr ""

msgid "This method is especially useful when the client is acting on behalf of a user. In this case, the bearer token is an access token previously issued by {project_name} to some client acting on behalf of a user (or on behalf of itself). Permissions will be evaluated considering the access context represented by the access token. For instance, if the access token was issued to Client A acting on behalf of User A, permissions will be granted depending on the resources and scopes to which User A has access."
msgstr ""

msgid "*Client Credentials*"
msgstr ""

msgid "Clients can use any of the client authentication methods supported by {project_name}. For instance, client_id/client_secret or JWT."
msgstr ""

msgid "Example: an authorization request using client id and client secret to authenticate to the token endpoint"
msgstr ""

msgid ""
"curl -X POST \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm}/protocol/openid-connect/token \\\n"
"  -H \"Authorization: Basic cGhvdGg6L7Jl13RmfWgtkk==pOnNlY3JldA==\" \\\n"
"  --data \"grant_type=urn:ietf:params:oauth:grant-type:uma-ticket\""
msgstr ""

msgid "Pushing Claims"
msgstr ""

msgid "When obtaining permissions from the server you can push arbitrary claims in order to have these claims available to your policies when evaluating permissions."
msgstr ""

msgid "If you are obtaining permissions from the server *without* using a permission ticket (UMA flow), you can send an authorization request to the token endpoint as follows:"
msgstr ""

msgid ""
"curl -X POST \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm}/protocol/openid-connect/token \\\n"
"  --data \"grant_type=urn:ietf:params:oauth:grant-type:uma-ticket\" \\\n"
"  --data \"claim_token=ewogICAib3JnYW5pemF0aW9uIjogWyJhY21lIl0KfQ==\" \\\n"
"  --data \"claim_token_format=urn:ietf:params:oauth:token-type:jwt\" \\\n"
"  --data \"client_id={resource_server_client_id}\" \\\n"
"  --data \"client_secret={resource_server_client_secret}\" \\\n"
"  --data \"audience={resource_server_client_id}\""
msgstr ""

msgid "The `claim_token` parameter expects a BASE64 encoded JSON with a format similar to the example below:"
msgstr ""

msgid ""
"{\n"
"    \"organization\" : [\"acme\"]\n"
"}"
msgstr ""

msgid "The format expects one or more claims where the value for each claim must be an array of strings."
msgstr ""

msgid "Pushing Claims Using UMA"
msgstr ""

msgid "For more details about how to push claims when using UMA and permission tickets, please take a look at <<_service_protection_permission_api_papi, Permission API>>"
msgstr ""

msgid "User-Managed Access"
msgstr ""

msgid "{project_name} Authorization Services is based on User-Managed Access or UMA for short. UMA is a specification that enhances OAuth2 capabilities in the following ways:"
msgstr ""

msgid "*Privacy*"
msgstr ""

msgid "Nowadays, user privacy is becoming a huge concern, as more and more data and devices are available and connected to the cloud. With UMA and {project_name}, resource servers can enhance their capabilities in order to improve how their resources are protected in respect to user privacy where permissions are granted based on policies defined by the user."
msgstr ""

msgid "*Party-to-Party Authorization*"
msgstr ""

msgid "Resource owners (e.g.: regular end-users) can manage access to their resources and authorize other parties (e.g: regular end-users) to access these resources. This is different than OAuth2 where consent is given to a client application acting on behalf of a user, with UMA resource owners are allowed to consent access to other users, in a completely asynchronous manner."
msgstr ""

msgid "*Resource Sharing*"
msgstr ""

msgid "Resource owners are allowed to manage permissions to their resources and decide who can access a particular resource and how. {project_name} can then act as a sharing management service from which resource owners can manage their resources."
msgstr ""

msgid "{project_name} is a UMA 2.0 compliant authorization server that provides most UMA capabilities."
msgstr ""

msgid "As an example, consider a user Alice (resource owner) using an Internet Banking Service (resource server) to manage her Bank Account (resource). One day, Alice decides to open her bank account to Bob (requesting party), a accounting professional. However, Bob should only have access to view (scope) Alice's account."
msgstr ""

msgid "As a resource server, the Internet Banking Service must be able to protect Alice's Bank Account. For that, it relies on {project_name} Resource Registration Endpoint to create a resource in the server representing Alice's Bank Account."
msgstr ""

msgid "At this moment, if Bob tries to access Alice's Bank Account, access will be denied. The Internet Banking Service defines a few default policies for banking accounts. One of them is that only the owner, in this case Alice, is allowed to access her bank account."
msgstr ""

msgid "However, Internet Banking Service in respect to Alice's privacy also allows her to change specific policies for the banking account. One of these policies that she can change is to define which people are allowed to view her bank account. For that, Internet Banking Service relies on {project_name} to provide to Alice a space where she can select individuals and the operations (or data) they are allowed to access. At any time, Alice can revoke access or grant additional permissions to Bob."
msgstr ""

msgid "Authorization Process"
msgstr ""

msgid "In UMA, the authorization process starts when a client tries to access a UMA protected resource server."
msgstr ""

msgid "A UMA protected resource server expects a bearer token in the request where the token is an RPT. When a client requests a resource at the resource server without a RPT:"
msgstr ""

msgid "Client requests a protected resource without sending an RPT"
msgstr ""

msgid ""
"curl -X GET \\\n"
"  http://${host}:${port}/my-resource-server/resource/1bfdfe78-a4e1-4c2d-b142-fc92b75b986f"
msgstr ""

msgid "The resource server sends a response back to the client with a permission `ticket` and a `as_uri` parameter with the location of a {project_name} server to where the ticket should be sent in order to obtain an RPT."
msgstr ""

msgid "Resource server responds with a permission ticket"
msgstr ""

msgid ""
"HTTP/1.1 401 Unauthorized\n"
"WWW-Authenticate: UMA realm=\"${realm}\",\n"
"    as_uri=\"https://${host}:${port}{kc_realms_path}/${realm}\",\n"
"    ticket=\"016f84e8-f9b9-11e0-bd6f-0021cc6004de\""
msgstr ""

msgid "The permission ticket is a special type of token issued by {project_name} Permission API. They represent the permissions being requested (e.g.: resources and scopes) as well any other information associated with the request. Only resource servers are allowed to create those tokens."
msgstr ""

msgid "Now that the client has a permission ticket and also the location of a {project_name} server, the client can use the discovery document to obtain the location of the token endpoint and send an authorization request."
msgstr ""

msgid "Client sends an authorization request to the token endpoint to obtain an RPT"
msgstr ""

msgid "The response from the server is just like any other response from the token endpoint when using some other grant type. The RPT can be obtained from the `access_token` response parameter. In case the client is not authorized to have permissions {project_name} responds with a `403` HTTP status code:"
msgstr ""

msgid "Submitting Permission Requests"
msgstr ""

msgid "As part of the authorization process, clients need first to obtain a permission ticket from a UMA protected resource server in order to exchange it with an RPT at the {project_name} Token Endpoint."
msgstr ""

msgid "By default, {project_name} responds with a `403` HTTP status code and a `request_denied` error in case the client can not be issued with an RPT."
msgstr ""

msgid "Such response implies that {project_name} could not issue an RPT with the permissions represented by a permission ticket."
msgstr ""

msgid "In some situations, client applications may want to start an asynchronous authorization flow and let the owner of the resources being requested decide whether or not access should be granted. For that, clients can use the `submit_request` request parameter along with an authorization request to the token endpoint:"
msgstr ""

msgid ""
"curl -X POST \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm}/protocol/openid-connect/token \\\n"
"  -H \"Authorization: Bearer ${access_token}\" \\\n"
"  --data \"grant_type=urn:ietf:params:oauth:grant-type:uma-ticket\" \\\n"
"  --data \"ticket=${permission_ticket} \\\n"
"  --data \"submit_request=true\""
msgstr ""

msgid "When using the `submit_request` parameter, {project_name} will persist a permission request for each resource to which access was denied. Once created, resource owners can check their account and manage their permissions requests."
msgstr ""

msgid "You can think about this functionality as a `Request Access` button in your application, where users can ask other users for access to their resources."
msgstr ""

msgid "Managing Access to Users Resources"
msgstr ""

msgid "Users can manage access to their resources using the {project_name} User Account Service. To enable this functionality, you must first enable User-Managed Access for your realm. To do so, open the realm settings page in {project_name} Administration Console and enable the User-Managed Access switch."
msgstr ""

msgid "image:{project_images}/service/account-my-resource.png[alt=\"My Resources\"]"
msgstr ""

msgid "On the left side menu, the `My Resources` option leads to a page where users are able to:"
msgstr ""

msgid "Manage Permission Requests that *Need my approval*"
msgstr ""

msgid "This section contains a list of all permission requests awaiting approval. These requests are connected to the parties (users) requesting access to a particular resource. Users are allowed to approve or deny these requests."
msgstr ""

msgid "Manage *My resources*"
msgstr ""

msgid "This section contains a list of all resources owned by the user. Users can click on a resource for more details and share the resource with others."
msgstr ""

msgid "Manage *Resources shared with me*"
msgstr ""

msgid "This section contains a list of all resources shared with the user."
msgstr ""

msgid "Manage *Your requests waiting approval*"
msgstr ""

msgid "This section contains a list of permission requests sent by the user that are waiting for the approval of another user or resource owner."
msgstr ""

msgid "When the user choose to detail own of his resources by clicking on any resource in the \"My resources\" listing, he is redirected to a page as follows:"
msgstr ""

msgid "image:{project_images}/service/account-my-resource-detail.png[alt=\"Resource Detail\"]"
msgstr ""

msgid "From this page the users are able to:"
msgstr ""

msgid "Manage *People with access to this resource*"
msgstr ""

msgid "This section contains a list of people with access to this resource. Users are allowed to revoke access by clicking on the `Revoke` button or by removing a specific `Permission`."
msgstr ""

msgid "Share the resource with others"
msgstr ""

msgid "By typing the username or e-mail of another user, the user is able to share the resource and select the permissions he wants to grant access."
msgstr ""

msgid "The Protection API provides a UMA-compliant set of endpoints providing:"
msgstr ""

msgid "With this endpoint, resource servers can manage their resources remotely and enable <<_enforcer_overview, policy enforcers>> to query the server for the resources that need protection."
msgstr ""

msgid "In the UMA protocol, resource servers access this endpoint to create permission tickets. {project_name} also provides endpoints to manage the state of permissions and query permissions."
msgstr ""

msgid "*Policy API*"
msgstr ""

msgid "{project_name} leverages the UMA Protection API to allow resource servers to manage permissions for their users. In addition to the Resource and Permission APIs, {project_name} provides a Policy API from where permissions can be set to resources by resource servers on behalf of their users."
msgstr ""

msgid "An important requirement for this API is that _only_ resource servers are allowed to access its endpoints using a special OAuth2 access token called a protection API token (PAT). In UMA, a PAT is a token with the scope *uma_protection*."
msgstr ""

msgid "What is a PAT and How to Obtain It"
msgstr ""

msgid "A *protection API token* (PAT) is a special OAuth2 access token with a scope defined as  *uma_protection*. When you create a resource server, {project_name} automatically creates a role, _uma_protection_, for the corresponding client application and associates it with the client's service account."
msgstr ""

msgid "Service Account granted with *uma_protection* role"
msgstr ""

msgid "image:{project_images}/service/rs-uma-protection-role.png[alt=\"Service Account granted with uma_protection role\"]"
msgstr ""

msgid "Resource servers can obtain a PAT from {project_name} like any other OAuth2 access token. For example, using curl:"
msgstr ""

msgid ""
"curl -X POST \\\n"
"    -H \"Content-Type: application/x-www-form-urlencoded\" \\\n"
"    -d 'grant_type=client_credentials&client_id=${client_id}&client_secret=${client_secret}' \\\n"
"    \"http://localhost:8080{kc_realms_path}/${realm_name}/protocol/openid-connect/token\""
msgstr ""

msgid "The example above is using the *client_credentials* grant type to obtain a PAT from the server. As a result, the server returns a response similar to the following:"
msgstr ""

msgid ""
"{\n"
"  \"access_token\": ${PAT},\n"
"  \"expires_in\": 300,\n"
"  \"refresh_expires_in\": 1800,\n"
"  \"refresh_token\": ${refresh_token},\n"
"  \"token_type\": \"bearer\",\n"
"  \"id_token\": ${id_token},\n"
"  \"not-before-policy\": 0,\n"
"  \"session_state\": \"ccea4a55-9aec-4024-b11c-44f6f168439e\"\n"
"}"
msgstr ""

msgid "{project_name} can authenticate your client application in different ways. For simplicity, the *client_credentials* grant type is used here, which requires a _client_id_ and a _client_secret_. You can choose to use any supported authentication method."
msgstr ""

msgid "Managing Resources"
msgstr ""

msgid "Resource servers can manage their resources remotely using a UMA-compliant endpoint."
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/resource_set"
msgstr ""

msgid "This endpoint provides operations outlined as follows (entire path omitted for clarity):"
msgstr ""

msgid "Create resource set description: POST /resource_set"
msgstr ""

msgid "Read resource set description: GET /resource_set/{_id}"
msgstr ""

msgid "Update resource set description: PUT /resource_set/{_id}"
msgstr ""

msgid "Delete resource set description: DELETE /resource_set/{_id}"
msgstr ""

msgid "List resource set descriptions: GET /resource_set"
msgstr ""

msgid "For more information about the contract for each of these operations, see https://docs.kantarainitiative.org/uma/wg/oauth-uma-federated-authz-2.0-09.html#reg-api[UMA Resource Registration API]."
msgstr ""

msgid "Creating a Resource"
msgstr ""

msgid "To create a resource you must send an HTTP POST request as follows:"
msgstr ""

msgid ""
"curl -v -X POST \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/resource_set \\\n"
"  -H 'Authorization: Bearer '$pat \\\n"
"  -H 'Content-Type: application/json' \\\n"
"  -d '{\n"
"     \"name\":\"Tweedl Social Service\",\n"
"     \"type\":\"http://www.example.com/rsrcs/socialstream/140-compatible\",\n"
"     \"icon_uri\":\"http://www.example.com/icons/sharesocial.png\",\n"
"     \"resource_scopes\":[\n"
"         \"read-public\",\n"
"         \"post-updates\",\n"
"         \"read-private\",\n"
"         \"http://www.example.com/scopes/all\"\n"
"      ]\n"
"  }'"
msgstr ""

msgid "By default, the owner of a resource is the resource server. If you want to define a different owner, such as an specific user, you can send a request as follows:"
msgstr ""

msgid ""
"curl -v -X POST \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/resource_set \\\n"
"  -H 'Authorization: Bearer '$pat \\\n"
"  -H 'Content-Type: application/json' \\\n"
"  -d '{\n"
"     \"name\":\"Alice Resource\",\n"
"     \"owner\": \"alice\"\n"
"  }'"
msgstr ""

msgid "Where the property `owner` can be set with the username or the identifier of the user."
msgstr ""

msgid "Creating User-Managed Resources"
msgstr ""

msgid "By default, resources created via Protection API can not be managed by resource owners through the <<_service_authorization_my_resources, User Account Service>>."
msgstr ""

msgid "To create resources and allow resource owners to manage these resources, you must set `ownerManagedAccess` property as follows:"
msgstr ""

msgid ""
"curl -v -X POST \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/resource_set \\\n"
"  -H 'Authorization: Bearer '$pat \\\n"
"  -H 'Content-Type: application/json' \\\n"
"  -d '{\n"
"     \"name\":\"Alice Resource\",\n"
"     \"owner\": \"alice\",\n"
"     \"ownerManagedAccess\": true\n"
"  }'"
msgstr ""

msgid "Updating Resources"
msgstr ""

msgid "To update an existing resource, send an HTTP PUT request as follows:"
msgstr ""

msgid ""
"curl -v -X PUT \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/resource_set/{resource_id} \\\n"
"  -H 'Authorization: Bearer '$pat \\\n"
"  -H 'Content-Type: application/json' \\\n"
"  -d '{\n"
"     \"_id\": \"Alice Resource\",\n"
"     \"name\":\"Alice Resource\",\n"
"     \"resource_scopes\": [\n"
"        \"read\"\n"
"     ]\n"
"  }'"
msgstr ""

msgid "Deleting Resources"
msgstr ""

msgid "To delete an existing resource, send an HTTP DELETE request as follows:"
msgstr ""

msgid ""
"curl -v -X DELETE \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/resource_set/{resource_id} \\\n"
"  -H 'Authorization: Bearer '$pat"
msgstr ""

msgid "Querying Resources"
msgstr ""

msgid "To query the resources by `id`, send an HTTP GET request as follows:"
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/resource_set/{resource_id}"
msgstr ""

msgid "To query resources given a `name`, send an HTTP GET request as follows:"
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/resource_set?name=Alice Resource"
msgstr ""

msgid "By default, the `name` filter will match any resource with the given pattern. To restrict the query to only return resources with an exact match, use:"
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/resource_set?name=Alice Resource&exactName=true"
msgstr ""

msgid "To query resources given an `uri`, send an HTTP GET request as follows:"
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/resource_set?uri=/api/alice"
msgstr ""

msgid "To query resources given an `owner`, send an HTTP GET request as follows:"
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/resource_set?owner=alice"
msgstr ""

msgid "To query resources given an `type`, send an HTTP GET request as follows:"
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/resource_set?type=albums"
msgstr ""

msgid "To query resources given an `scope`, send an HTTP GET request as follows:"
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/resource_set?scope=read"
msgstr ""

msgid "When querying the server for permissions use parameters `first` and `max` results to limit the result."
msgstr ""

msgid "Managing Permission Requests"
msgstr ""

msgid "Resource servers using the UMA protocol can use a specific endpoint to manage permission requests. This endpoint provides a UMA-compliant flow for registering permission requests and obtaining a permission ticket."
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/permission"
msgstr ""

msgid "A <<_overview_terminology_permission_ticket, permission ticket>> is a special security token type representing a permission request. Per the UMA specification, a permission ticket is:"
msgstr ""

msgid "`A correlation handle that is conveyed from an authorization server to a resource server, from a resource server to a client, and ultimately from a client back to an authorization server, to enable the authorization server to assess the correct policies to apply to a request for authorization data.`"
msgstr ""

msgid "In most cases, you won't need to deal with this endpoint directly. {project_name} provides a <<_enforcer_overview, policy enforcer>> that enables UMA for your resource server so it can obtain a permission ticket from the authorization server, return this ticket to client application, and enforce authorization decisions based on a final requesting party token (RPT)."
msgstr ""

msgid "The process of obtaining permission tickets from {project_name} is performed by resource servers and not regular client applications, where permission tickets are obtained when a client tries to access a protected resource without the necessary grants to access the resource. The issuance of permission tickets is an important aspects when using UMA as it allows resource servers to:"
msgstr ""

msgid "Abstract from clients the data associated with the resources protected by the resource server"
msgstr ""

msgid "Register in the {project_name} authorization requests which in turn can be used later in workflows to grant access based on the resource's owner consent"
msgstr ""

msgid "Decouple resource servers from authorization servers and allow them to protect and manage their resources using different authorization servers"
msgstr ""

msgid "Client wise, a permission ticket has also important aspects that its worthy to highlight:"
msgstr ""

msgid "Clients don't need to know about how authorization data is associated with protected resources. A permission ticket is completely opaque to clients."
msgstr ""

msgid "Clients can have access to resources on different resource servers and protected by different authorization servers"
msgstr ""

msgid "These are just some of the benefits brought by UMA where other aspects of UMA are strongly based on permission tickets, specially regarding privacy and user controlled access to their resources."
msgstr ""

msgid "Creating Permission Ticket"
msgstr ""

msgid "To create a permission ticket, send an HTTP POST request as follows:"
msgstr ""

msgid ""
"curl -X POST \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/permission \\\n"
"  -H 'Authorization: Bearer '$pat \\\n"
"  -H 'Content-Type: application/json' \\\n"
"  -d '[\n"
"  {\n"
"    \"resource_id\": \"{resource_id}\",\n"
"    \"resource_scopes\": [\n"
"      \"view\"\n"
"    ]\n"
"  }\n"
"]'"
msgstr ""

msgid "When creating tickets you can also push arbitrary claims and associate these claims with the ticket:"
msgstr ""

msgid ""
"curl -X POST \\\n"
"  http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/permission \\\n"
"  -H 'Authorization: Bearer '$pat \\\n"
"  -H 'Content-Type: application/json' \\\n"
"  -d '[\n"
"  {\n"
"    \"resource_id\": \"{resource_id}\",\n"
"    \"resource_scopes\": [\n"
"      \"view\"\n"
"    ],\n"
"    \"claims\": {\n"
"        \"organization\": [\"acme\"]\n"
"    }\n"
"  }\n"
"]'"
msgstr ""

msgid "Where these claims will be available to your policies when evaluating permissions for the resource and scope(s) associated with the permission ticket."
msgstr ""

msgid "Other non UMA-compliant endpoints"
msgstr ""

msgid "Creating permission ticket"
msgstr ""

msgid "To grant permissions for a specific resource with id {resource_id} to a user with id {user_id}, as an owner of the resource send an HTTP POST request as follows:"
msgstr ""

msgid ""
"curl -X POST \\\n"
"     http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/permission/ticket \\\n"
"     -H 'Authorization: Bearer '$access_token \\\n"
"     -H 'Content-Type: application/json' \\\n"
"     -d '{\n"
"       \"resource\": \"{resource_id}\",\n"
"       \"requester\": \"{user_id}\",\n"
"       \"granted\": true,\n"
"       \"scopeName\": \"view\"\n"
"     }'"
msgstr ""

msgid "Getting permission tickets"
msgstr ""

msgid ""
"curl http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/permission/ticket \\\n"
"     -H 'Authorization: Bearer '$access_token"
msgstr ""

msgid "You can use any of these query parameters:"
msgstr ""

msgid "`scopeId`"
msgstr ""

msgid "`resourceId`"
msgstr ""

msgid "`owner`"
msgstr ""

msgid "`requester`"
msgstr ""

msgid "`granted`"
msgstr ""

msgid "`returnNames`"
msgstr ""

msgid "`first`"
msgstr ""

msgid "`max`"
msgstr ""

msgid "Updating permission ticket"
msgstr ""

msgid ""
"curl -X PUT \\\n"
"     http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/permission/ticket \\\n"
"     -H 'Authorization: Bearer '$access_token \\\n"
"     -H 'Content-Type: application/json' \\\n"
"     -d '{\n"
"       \"id\": \"{ticket_id}\"\n"
"       \"resource\": \"{resource_id}\",\n"
"       \"requester\": \"{user_id}\",\n"
"       \"granted\": false,\n"
"       \"scopeName\": \"view\"\n"
"     }'"
msgstr ""

msgid "Deleting permission ticket"
msgstr ""

msgid ""
"curl -X DELETE http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/permission/ticket/{ticket_id} \\\n"
"     -H 'Authorization: Bearer '$access_token"
msgstr ""

msgid "Managing Resource Permissions using the Policy API"
msgstr ""

msgid "The Policy API is available at:"
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm_name}/authz/protection/uma-policy/{resource_id}"
msgstr ""

msgid "This API is protected by a bearer token that must represent a consent granted by the user to the resource server to manage permissions on his behalf. The bearer token can be a regular access token obtained from the token endpoint using:"
msgstr ""

msgid "Resource Owner Password Credentials Grant Type"
msgstr ""

msgid "Token Exchange, in order to exchange an access token granted to some client (public client) for a token where audience is the resource server"
msgstr ""

msgid "Associating a Permission with a Resource"
msgstr ""

msgid "To associate a permission with a specific resource you must send a HTTP POST request as follows:"
msgstr ""

msgid ""
"curl -X POST \\\n"
"  http://localhost:8180{kc_realms_path}/photoz/authz/protection/uma-policy/{resource_id} \\\n"
"  -H 'Authorization: Bearer '$access_token \\\n"
"  -H 'Cache-Control: no-cache' \\\n"
"  -H 'Content-Type: application/json' \\\n"
"  -d '{\n"
"\t\"name\": \"Any people manager\",\n"
"\t\"description\": \"Allow access to any people manager\",\n"
"\t\"scopes\": [\"read\"],\n"
"\t\"roles\": [\"people-manager\"]\n"
"}'"
msgstr ""

msgid "In the example above we are creating and associating a new permission to a resource represented by `resource_id` where any user with a role `people-manager` should be granted with the `read` scope."
msgstr ""

msgid "You can also create policies using other access control mechanisms, such as using groups:"
msgstr ""

msgid ""
"curl -X POST \\\n"
"  http://localhost:8180{kc_realms_path}/photoz/authz/protection/uma-policy/{resource_id} \\\n"
"  -H 'Authorization: Bearer '$access_token \\\n"
"  -H 'Cache-Control: no-cache' \\\n"
"  -H 'Content-Type: application/json' \\\n"
"  -d '{\n"
"\t\"name\": \"Any people manager\",\n"
"\t\"description\": \"Allow access to any people manager\",\n"
"\t\"scopes\": [\"read\"],\n"
"\t\"groups\": [\"/Managers/People Managers\"]\n"
"}'"
msgstr ""

msgid "Or a specific client:"
msgstr ""

msgid ""
"curl -X POST \\\n"
"  http://localhost:8180{kc_realms_path}/photoz/authz/protection/uma-policy/{resource_id} \\\n"
"  -H 'Authorization: Bearer '$access_token \\\n"
"  -H 'Cache-Control: no-cache' \\\n"
"  -H 'Content-Type: application/json' \\\n"
"  -d '{\n"
"\t\"name\": \"Any people manager\",\n"
"\t\"description\": \"Allow access to any people manager\",\n"
"\t\"scopes\": [\"read\"],\n"
"\t\"clients\": [\"my-client\"]\n"
"}'"
msgstr ""

msgid "Or even using a custom policy using JavaScript:"
msgstr ""

msgid "{tech_feature_name} is *Deprecated* and will be removed in future releases. This feature is disabled by default."
msgstr ""

msgid "To enable start the server with `{tech_feature_setting}` . For more details see link:{installguide_profile_link}[{installguide_profile_name}]."
msgstr ""

msgid ""
"curl -X POST \\\n"
"  http://localhost:8180{kc_realms_path}/photoz/authz/protection/uma-policy/{resource_id} \\\n"
"  -H 'Authorization: Bearer '$access_token \\\n"
"  -H 'Cache-Control: no-cache' \\\n"
"  -H 'Content-Type: application/json' \\\n"
"  -d '{\n"
"\t\"name\": \"Any people manager\",\n"
"\t\"description\": \"Allow access to any people manager\",\n"
"\t\"scopes\": [\"read\"],\n"
"\t\"condition\": \"if (isPeopleManager()) {$evaluation.grant()}\"\n"
"}'"
msgstr ""

msgid "It is also possible to set any combination of these access control mechanisms."
msgstr ""

msgid "To update an existing permission, send an HTTP PUT request as follows:"
msgstr ""

msgid ""
"curl -X PUT \\\n"
"  http://localhost:8180{kc_realms_path}/photoz/authz/protection/uma-policy/{permission_id} \\\n"
"  -H 'Authorization: Bearer '$access_token \\\n"
"  -H 'Content-Type: application/json' \\\n"
"  -d '{\n"
"    \"id\": \"21eb3fed-02d7-4b5a-9102-29f3f09b6de2\",\n"
"    \"name\": \"Any people manager\",\n"
"    \"description\": \"Allow access to any people manager\",\n"
"    \"type\": \"uma\",\n"
"    \"scopes\": [\n"
"        \"album:view\"\n"
"    ],\n"
"    \"logic\": \"POSITIVE\",\n"
"    \"decisionStrategy\": \"UNANIMOUS\",\n"
"    \"owner\": \"7e22131a-aa57-4f5f-b1db-6e82babcd322\",\n"
"    \"roles\": [\n"
"        \"user\"\n"
"    ]\n"
"}'"
msgstr ""

msgid "Removing a Permission"
msgstr ""

msgid "To remove a permission associated with a resource, send an HTTP DELETE request as follows:"
msgstr ""

msgid ""
"curl -X DELETE \\\n"
"  http://localhost:8180{kc_realms_path}/photoz/authz/protection/uma-policy/{permission_id} \\\n"
"  -H 'Authorization: Bearer '$access_token"
msgstr ""

msgid "Querying Permission"
msgstr ""

msgid "To query the permissions associated with a resource, send an HTTP GET request as follows:"
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm}/authz/protection/uma-policy?resource={resource_id}"
msgstr ""

msgid "To query the permissions given its name, send an HTTP GET request as follows:"
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm}/authz/protection/uma-policy?name=Any people manager"
msgstr ""

msgid "To query the permissions associated with a specific scope, send an HTTP GET request as follows:"
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm}/authz/protection/uma-policy?scope=read"
msgstr ""

msgid "To query all permissions, send an HTTP GET request as follows:"
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm}/authz/protection/uma-policy"
msgstr ""

msgid "Requesting Party Token"
msgstr ""

msgid "A requesting party token (RPT) is a https://datatracker.ietf.org/doc/html/rfc7519[JSON web token (JWT)] digitally signed using https://datatracker.ietf.org/doc/html/rfc7515[JSON web signature (JWS)]. The token is built based on the OAuth2 access token previously issued by {project_name} to a specific client acting on behalf of a user or on its own behalf."
msgstr ""

msgid "When you decode an RPT, you see a payload similar to the following:"
msgstr ""

msgid ""
"{\n"
"  \"authorization\": {\n"
"      \"permissions\": [\n"
"        {\n"
"          \"resource_set_id\": \"d2fe9843-6462-4bfc-baba-b5787bb6e0e7\",\n"
"          \"resource_set_name\": \"Hello World Resource\"\n"
"        }\n"
"      ]\n"
"  },\n"
"  \"jti\": \"d6109a09-78fd-4998-bf89-95730dfd0892-1464906679405\",\n"
"  \"exp\": 1464906971,\n"
"  \"nbf\": 0,\n"
"  \"iat\": 1464906671,\n"
"  \"sub\": \"f1888f4d-5172-4359-be0c-af338505d86c\",\n"
"  \"typ\": \"kc_ett\",\n"
"  \"azp\": \"hello-world-authz-service\"\n"
"}"
msgstr ""

msgid "From this token you can obtain all permissions granted by the server from the *permissions* claim."
msgstr ""

msgid "Also note that permissions are directly related with the resources/scopes you are protecting and completely decoupled from the access control methods that were used to actually grant and issue these same permissions."
msgstr ""

msgid "Introspecting a Requesting Party Token"
msgstr ""

msgid "Sometimes you might want to introspect a requesting party token (RPT) to check its validity or obtain the permissions within the token to enforce authorization decisions on the resource server side."
msgstr ""

msgid "There are two main use cases where token introspection can help you:"
msgstr ""

msgid "When client applications need to query the token validity to obtain a new one with the same or additional permissions"
msgstr ""

msgid "When enforcing authorization decisions at the resource server side, especially when none of the built-in <<_enforcer_overview, policy enforcers>> fits your application"
msgstr ""

msgid "Obtaining Information about an RPT"
msgstr ""

msgid "The token introspection is essentially a https://datatracker.ietf.org/doc/html/rfc7662[OAuth2 token introspection]-compliant endpoint from which you can obtain information about an RPT."
msgstr ""

msgid "http://${host}:${port}{kc_realms_path}/${realm_name}/protocol/openid-connect/token/introspect"
msgstr ""

msgid "To introspect an RPT using this endpoint, you can send a request to the server as follows:"
msgstr ""

msgid ""
"curl -X POST \\\n"
"    -H \"Authorization: Basic aGVsbG8td29ybGQtYXV0aHotc2VydmljZTpzZWNyZXQ=\" \\\n"
"    -H \"Content-Type: application/x-www-form-urlencoded\" \\\n"
"    -d 'token_type_hint=requesting_party_token&token=${RPT}' \\\n"
"    \"http://localhost:8080{kc_realms_path}/hello-world-authz/protocol/openid-connect/token/introspect\""
msgstr ""

msgid "The request above is using HTTP BASIC and passing the client's credentials (client ID and secret) to authenticate the client attempting to introspect the token, but you can use any other client authentication method supported by {project_name}."
msgstr ""

msgid "The introspection endpoint expects two parameters:"
msgstr ""

msgid "*token_type_hint*"
msgstr ""

msgid "Use *requesting_party_token* as the value for this parameter, which indicates that you want to introspect an RPT."
msgstr ""

msgid "*token*"
msgstr ""

msgid "Use the token string as it was returned by the server during the authorization process as the value for this parameter."
msgstr ""

msgid "As a result, the server response is:"
msgstr ""

msgid ""
"{\n"
"  \"permissions\": [\n"
"    {\n"
"      \"resource_id\": \"90ccc6fc-b296-4cd1-881e-089e1ee15957\",\n"
"      \"resource_name\": \"Hello World Resource\"\n"
"    }\n"
"  ],\n"
"  \"exp\": 1465314139,\n"
"  \"nbf\": 0,\n"
"  \"iat\": 1465313839,\n"
"  \"aud\": \"hello-world-authz-service\",\n"
"  \"active\": true\n"
"}"
msgstr ""

msgid "If the RPT is not active, this response is returned instead:"
msgstr ""

msgid ""
"{\n"
"  \"active\": false\n"
"}"
msgstr ""

msgid "Do I Need to Invoke the Server Every Time I Want to Introspect an RPT?"
msgstr ""

msgid "No. Just like a regular access token issued by a {project_name} server, RPTs also use the  https://datatracker.ietf.org/doc/html/rfc7519[JSON web token (JWT)] specification as the default format."
msgstr ""

msgid "If you want to validate these tokens without a call to the remote introspection endpoint, you can decode the RPT and query for its validity locally. Once you decode the token, you can also use the permissions within the token to enforce authorization decisions."
msgstr ""

msgid "This is essentially what the <<_enforcer_overview, policy enforcers>> do. Be sure to:"
msgstr ""

msgid "Validate the signature of the RPT (based on the realm's public key)"
msgstr ""

msgid "Query for token validity based on its _exp_, _iat_, and _aud_ claims"
msgstr ""

msgid "Authorization Client Java API"
msgstr ""

msgid "Depending on your requirements, a resource server should be able to manage resources remotely or even check for permissions programmatically. If you are using Java, you can access the {project_name} Authorization Services using the Authorization Client API."
msgstr ""

msgid "It is targeted for resource servers that want to access the different endpoints provided by the server such as the Token Endpoint, Resource, and Permission management endpoints."
msgstr ""

msgid "Maven Dependency"
msgstr ""

msgid ""
"<dependencies>\n"
"    <dependency>\n"
"        <groupId>org.keycloak</groupId>\n"
"        <artifactId>keycloak-authz-client</artifactId>\n"
"        <version>${KEYCLOAK_VERSION}</version>\n"
"    </dependency>\n"
"</dependencies>"
msgstr ""

msgid "The client configuration is defined in a ``keycloak.json`` file as follows:"
msgstr ""

msgid ""
"{\n"
"  \"realm\": \"hello-world-authz\",\n"
"  \"auth-server-url\" : \"http://localhost:8080{kc_base_path}\",\n"
"  \"resource\" : \"hello-world-authz-service\",\n"
"  \"credentials\": {\n"
"    \"secret\": \"secret\"\n"
"  }\n"
"}"
msgstr ""

msgid "*realm* (required)"
msgstr ""

msgid "The name of the realm."
msgstr ""

msgid "*auth-server-url* (required)"
msgstr ""

msgid "The base URL of the {project_name} server. All other {project_name} pages and REST service endpoints are derived from this. It is usually in the form https://host:port{kc_base_path}."
msgstr ""

msgid "*resource* (required)"
msgstr ""

msgid "The client-id of the application. Each application has a client-id that is used to identify the application."
msgstr ""

msgid "*credentials* (required)"
msgstr ""

msgid "Specifies the credentials of the application. This is an object notation where the key is the credential type and the value is the value of the credential type."
msgstr ""

msgid "The configuration file is usually located in your application's classpath, the default location from where the client is going to try to find a ```keycloak.json``` file."
msgstr ""

msgid "Creating the Authorization Client"
msgstr ""

msgid "Considering you have a ```keycloak.json``` file in your classpath, you can create a new ```AuthzClient``` instance as follows:"
msgstr ""

msgid ""
"    // create a new instance based on the configuration defined in a keycloak.json located in your classpath\n"
"    AuthzClient authzClient = AuthzClient.create();"
msgstr ""

msgid "Obtaining User Entitlements"
msgstr ""

msgid "Here is an example illustrating how to obtain user entitlements:"
msgstr ""

msgid ""
"// create a new instance based on the configuration defined in keycloak.json\n"
"AuthzClient authzClient = AuthzClient.create();\n"
"\n"
"// create an authorization request\n"
"AuthorizationRequest request = new AuthorizationRequest();\n"
"\n"
"// send the entitlement request to the server in order to\n"
"// obtain an RPT with all permissions granted to the user\n"
"AuthorizationResponse response = authzClient.authorization(\"alice\", \"alice\").authorize(request);\n"
"String rpt = response.getToken();\n"
"\n"
"System.out.println(\"You got an RPT: \" + rpt);\n"
"\n"
"// now you can use the RPT to access protected resources on the resource server"
msgstr ""

msgid "Here is an example illustrating how to obtain user entitlements for a set of one or more resources:"
msgstr ""

msgid ""
"// create a new instance based on the configuration defined in keycloak.json\n"
"AuthzClient authzClient = AuthzClient.create();\n"
"\n"
"// create an authorization request\n"
"AuthorizationRequest request = new AuthorizationRequest();\n"
"\n"
"// add permissions to the request based on the resources and scopes you want to check access\n"
"request.addPermission(\"Default Resource\");\n"
"\n"
"// send the entitlement request to the server in order to\n"
"// obtain an RPT with permissions for a single resource\n"
"AuthorizationResponse response = authzClient.authorization(\"alice\", \"alice\").authorize(request);\n"
"String rpt = response.getToken();\n"
"\n"
"System.out.println(\"You got an RPT: \" + rpt);\n"
"\n"
"// now you can use the RPT to access protected resources on the resource server"
msgstr ""

msgid "Creating a Resource Using the Protection API"
msgstr ""

msgid ""
"// create a new instance based on the configuration defined in keycloak.json\n"
"AuthzClient authzClient = AuthzClient.create();\n"
"\n"
"// create a new resource representation with the information we want\n"
"ResourceRepresentation newResource = new ResourceRepresentation();\n"
"\n"
"newResource.setName(\"New Resource\");\n"
"newResource.setType(\"urn:hello-world-authz:resources:example\");\n"
"\n"
"newResource.addScope(new ScopeRepresentation(\"urn:hello-world-authz:scopes:view\"));\n"
"\n"
"ProtectedResource resourceClient = authzClient.protection().resource();\n"
"ResourceRepresentation existingResource = resourceClient.findByName(newResource.getName());\n"
"\n"
"if (existingResource != null) {\n"
"    resourceClient.delete(existingResource.getId());\n"
"}\n"
"\n"
"// create the resource on the server\n"
"ResourceRepresentation response = resourceClient.create(newResource);\n"
"String resourceId = response.getId();\n"
"\n"
"// query the resource using its newly generated id\n"
"ResourceRepresentation resource = resourceClient.findById(resourceId);\n"
"\n"
"System.out.println(resource);"
msgstr ""

msgid "Introspecting an RPT"
msgstr ""

msgid ""
"// create a new instance based on the configuration defined in keycloak.json\n"
"AuthzClient authzClient = AuthzClient.create();\n"
"\n"
"// send the authorization request to the server in order to\n"
"// obtain an RPT with all permissions granted to the user\n"
"AuthorizationResponse response = authzClient.authorization(\"alice\", \"alice\").authorize();\n"
"String rpt = response.getToken();\n"
"\n"
"// introspect the token\n"
"TokenIntrospectionResponse requestingPartyToken = authzClient.protection().introspectRequestingPartyToken(rpt);\n"
"\n"
"System.out.println(\"Token status is: \" + requestingPartyToken.getActive());\n"
"System.out.println(\"Permissions granted by the server: \");\n"
"\n"
"for (Permission granted : requestingPartyToken.getPermissions()) {\n"
"    System.out.println(granted);\n"
"}"
msgstr ""

msgid "Policy Enforcers"
msgstr ""

msgid "Policy Enforcement Point (PEP) is a design pattern and as such you can implement it in different ways. {project_name} provides all the necessary means to implement PEPs for different platforms, environments, and programming languages. {project_name} Authorization Services presents a RESTful API, and leverages OAuth2 authorization capabilities for fine-grained authorization using a centralized authorization server."
msgstr ""

msgid "A PEP is responsible for enforcing access decisions from the {project_name} server where these decisions are taken by evaluating the policies associated with a protected resource. It acts as a filter or interceptor in your application in order to check whether or not a particular request to a protected resource can be fulfilled based on the permissions granted by these decisions."
msgstr ""

msgid "Permissions are enforced depending on the protocol you are using. When using UMA, the policy enforcer always expects an RPT as a bearer token in order to decide whether or not a request can be served. That means clients should first obtain an RPT from {project_name} before sending requests to the resource server."
msgstr ""

msgid "However, if you are not using UMA, you can also send regular access tokens to the resource server. In this case, the policy enforcer will try to obtain permissions directly from the server."
msgstr ""

msgid "If you are using any of the {project_name} OIDC adapters, you can easily enable the policy enforcer by adding the following property to your *keycloak.json* file:"
msgstr ""

msgid "keycloak.json"
msgstr ""

msgid ""
"{\n"
" \"policy-enforcer\": {}\n"
"}"
msgstr ""

msgid "When you enable the policy enforcer all requests sent your application are intercepted and access to protected resources will be granted depending on the permissions granted by {project_name} to the identity making the request."
msgstr ""

msgid "Policy enforcement is strongly linked to your application's paths and the <<_resource_overview, resources>> you created for a resource server using the {project_name} Administration Console. By default, when you create a resource server, {project_name} creates a <<_resource_server_default_config, default configuration>> for your resource server so you can enable policy enforcement quickly."
msgstr ""

msgid "To enable policy enforcement for your application, add the following property to your *keycloak.json* file:"
msgstr ""

msgid ""
"{\n"
"  \"policy-enforcer\": {}\n"
"}"
msgstr ""

msgid "Or a little more verbose if you want to manually define the resources being protected:"
msgstr ""

msgid ""
"{\n"
"  \"policy-enforcer\": {\n"
"    \"user-managed-access\" : {},\n"
"    \"enforcement-mode\" : \"ENFORCING\",\n"
"    \"paths\": [\n"
"      {\n"
"        \"path\" : \"/someUri/*\",\n"
"        \"methods\" : [\n"
"          {\n"
"            \"method\": \"GET\",\n"
"            \"scopes\" : [\"urn:app.com:scopes:view\"]\n"
"          },\n"
"          {\n"
"            \"method\": \"POST\",\n"
"            \"scopes\" : [\"urn:app.com:scopes:create\"]\n"
"          }\n"
"        ]\n"
"      },\n"
"      {\n"
"        \"name\" : \"Some Resource\",\n"
"        \"path\" : \"/usingPattern/{id}\",\n"
"        \"methods\" : [\n"
"          {\n"
"            \"method\": \"DELETE\",\n"
"            \"scopes\" : [\"urn:app.com:scopes:delete\"]\n"
"          }\n"
"        ]\n"
"      },\n"
"      {\n"
"        \"path\" : \"/exactMatch\"\n"
"      },\n"
"      {\n"
"        \"name\" : \"Admin Resources\",\n"
"        \"path\" : \"/usingWildCards/*\"\n"
"      }\n"
"    ]\n"
"  }\n"
"}"
msgstr ""

msgid "Here is a description of each configuration option:"
msgstr ""

msgid "*policy-enforcer*"
msgstr ""

msgid "Specifies the configuration options that define how policies are actually enforced and optionally the paths you want to protect. If not specified, the policy enforcer queries the server for all resources associated with the resource server being protected. In this case, you need to ensure the resources are properly configured with a <<_resource_create_uri, URIS>> property that matches the paths you want to protect."
msgstr ""

msgid "*user-managed-access*"
msgstr ""

msgid "Specifies that the adapter uses the UMA protocol. If specified, the adapter queries the server for permission tickets and returns them to clients according to the UMA specification. If not specified, the policy enforcer will be able to enforce permissions based on regular access tokens or RPTs. In this case, before denying access to the resource when the token lacks permission, the policy enforcer will try to obtain permissions directly from the server."
msgstr ""

msgid "*enforcement-mode*"
msgstr ""

msgid "Specifies how policies are enforced."
msgstr ""

msgid "*ENFORCING*"
msgstr ""

msgid "*PERMISSIVE*"
msgstr ""

msgid "*DISABLED*"
msgstr ""

msgid "Completely disables the evaluation of policies and allows access to any resource. When `enforcement-mode` is `DISABLED` applications are still able to obtain all permissions granted by {project_name} through the <<_enforcer_authorization_context, Authorization Context>>"
msgstr ""

msgid "*on-deny-redirect-to*"
msgstr ""

msgid "Defines a URL where a client request is redirected when an \"access denied\" message is obtained from the server. By default, the adapter responds with a 403 HTTP status code."
msgstr ""

msgid "*path-cache*"
msgstr ""

msgid "Defines how the policy enforcer should track associations between paths in your application and resources defined in {project_name}. The cache is needed to avoid unnecessary requests to a {project_name} server by caching associations between paths and protected resources."
msgstr ""

msgid "*lifespan*"
msgstr ""

msgid "Defines the time in milliseconds when the entry should be expired. If not provided, default value is *30000*. A value equal to 0 can be set to completely disable the cache. A value equal to -1 can be set to disable the expiry of the cache."
msgstr ""

msgid "*max-entries*"
msgstr ""

msgid "Defines the limit of entries that should be kept in the cache. If not provided, default value is *1000*."
msgstr ""

msgid "*paths*"
msgstr ""

msgid "Specifies the paths to protect. This configuration is optional. If not defined, the policy enforcer will discover all paths by fetching the resources you defined to your application in {project_name}, where these resources are defined with `URIS` representing some paths in your application."
msgstr ""

msgid "*name*"
msgstr ""

msgid "The name of a resource on the server that is to be associated with a given path. When used in conjunction with a *path*, the policy enforcer ignores the resource's *URIS* property and uses the path you provided instead."
msgstr ""

msgid "*path*"
msgstr ""

msgid "(required) A URI relative to the application's context path. If this option is specified, the policy enforcer queries the server for a resource with a *URI* with the same value. Currently a very basic logic for path matching is supported. Examples of valid paths are:"
msgstr ""

msgid "Wildcards: `/*`"
msgstr ""

msgid "Suffix: `/*.html`"
msgstr ""

msgid "Sub-paths: `/path/*`"
msgstr ""

msgid "Path parameters: /resource/{id}"
msgstr ""

msgid "Exact match: /resource"
msgstr ""

msgid "Patterns: /{version}/resource, /api/{version}/resource, /api/{version}/resource/*"
msgstr ""

msgid "*methods*"
msgstr ""

msgid "The HTTP methods (for example, GET, POST, PATCH) to protect and how they are associated with the scopes for a given resource in the server."
msgstr ""

msgid "*method*"
msgstr ""

msgid "The name of the HTTP method."
msgstr ""

msgid "*scopes*"
msgstr ""

msgid "An array of strings with the scopes associated with the method. When you associate scopes with a specific method, the client trying to access a protected resource (or path) must provide an RPT that grants permission to all scopes specified in the list. For example, if you define a method _POST_ with a scope _create_, the RPT must contain a permission granting access to the _create_ scope when performing a POST to the path."
msgstr ""

msgid "*scopes-enforcement-mode*"
msgstr ""

msgid "A string referencing the enforcement mode for the scopes associated with a method. Values can be *ALL* or *ANY*. If *ALL*, all defined scopes must be granted in order to access the resource using that method. If *ANY*, at least one scope should be granted in order to gain access to the resource using that method. By default, enforcement mode is set to *ALL*."
msgstr ""

msgid "*claim-information-point*"
msgstr ""

msgid "Defines a set of one or more claims that must be resolved and pushed to the {project_name} server in order to make these claims available to policies. See <<_enforcer_claim_information_point, Claim Information Point>> for more details."
msgstr ""

msgid "*lazy-load-paths*"
msgstr ""

msgid "Specifies how the adapter should fetch the server for resources associated with paths in your application. If *true*, the policy enforcer is going to fetch resources on-demand accordingly with the path being requested. This configuration is specially useful when you don't want to fetch all resources from the server during deployment (in case you have provided no `paths`) or in case you have defined only a sub set of `paths` and want to fetch others on-demand."
msgstr ""

msgid "*http-method-as-scope*"
msgstr ""

msgid "Specifies how scopes should be mapped to HTTP methods. If set to *true*, the policy enforcer will use the HTTP method from the current request to check whether or not access should be granted. When enabled, make sure your resources in {project_name} are associated with scopes representing each HTTP method you are protecting."
msgstr ""

msgid "Defines a set of one or more *global* claims that must be resolved and pushed to the {project_name} server in order to make these claims available to policies. See <<_enforcer_claim_information_point, Claim Information Point>> for more details."
msgstr ""

msgid "Claim Information Point"
msgstr ""

msgid "A Claim Information Point (CIP) is responsible for resolving claims and pushing these claims to the {project_name} server in order to provide more information about the access context to policies. They can be defined as a configuration option to the policy-enforcer in order to resolve claims from different sources, such as:"
msgstr ""

msgid "HTTP Request (parameters, headers, body, etc)"
msgstr ""

msgid "External HTTP Service"
msgstr ""

msgid "Static values defined in configuration"
msgstr ""

msgid "Any other source by implementing the Claim Information Provider SPI"
msgstr ""

msgid "When pushing claims to the {project_name} server, policies can base decisions not only on who a user is but also by taking context and contents into account, based on who, what, why, when, where, and which for a given transaction. It is all about Contextual-based Authorization and how to use runtime information in order to support fine-grained authorization decisions."
msgstr ""

msgid "Obtaining information from the HTTP Request"
msgstr ""

msgid "Here are several examples showing how you can extract claims from an HTTP request:"
msgstr ""

msgid ""
"\"policy-enforcer\": {\n"
"    \"paths\": [\n"
"      {\n"
"        \"path\": \"/protected/resource\",\n"
"        \"claim-information-point\": {\n"
"          \"claims\": {\n"
"            \"claim-from-request-parameter\": \"{request.parameter['a']}\",\n"
"            \"claim-from-header\": \"{request.header['b']}\",\n"
"            \"claim-from-cookie\": \"{request.cookie['c']}\",\n"
"            \"claim-from-remoteAddr\": \"{request.remoteAddr}\",\n"
"            \"claim-from-method\": \"{request.method}\",\n"
"            \"claim-from-uri\": \"{request.uri}\",\n"
"            \"claim-from-relativePath\": \"{request.relativePath}\",\n"
"            \"claim-from-secure\": \"{request.secure}\",\n"
"            \"claim-from-json-body-object\": \"{request.body['/a/b/c']}\",\n"
"            \"claim-from-json-body-array\": \"{request.body['/d/1']}\",\n"
"            \"claim-from-body\": \"{request.body}\",\n"
"            \"claim-from-static-value\": \"static value\",\n"
"            \"claim-from-multiple-static-value\": [\"static\", \"value\"],\n"
"            \"param-replace-multiple-placeholder\": \"Test {keycloak.access_token['/custom_claim/0']} and {request.parameter['a']} \"\n"
"          }\n"
"        }\n"
"      }\n"
"    ]\n"
"  }"
msgstr ""

msgid "Obtaining information from an External HTTP Service"
msgstr ""

msgid "Here are several examples showing how you can extract claims from an external HTTP Service:"
msgstr ""

msgid ""
"\"policy-enforcer\": {\n"
"    \"paths\": [\n"
"      {\n"
"        \"path\": \"/protected/resource\",\n"
"        \"claim-information-point\": {\n"
"          \"http\": {\n"
"            \"claims\": {\n"
"              \"claim-a\": \"/a\",\n"
"              \"claim-d\": \"/d\",\n"
"              \"claim-d0\": \"/d/0\",\n"
"              \"claim-d-all\": [\"/d/0\", \"/d/1\"]\n"
"            },\n"
"            \"url\": \"http://mycompany/claim-provider\",\n"
"            \"method\": \"POST\",\n"
"            \"headers\": {\n"
"              \"Content-Type\": \"application/x-www-form-urlencoded\",\n"
"              \"header-b\": [\"header-b-value1\", \"header-b-value2\"],\n"
"              \"Authorization\": \"Bearer {keycloak.access_token}\"\n"
"            },\n"
"            \"parameters\": {\n"
"              \"param-a\": [\"param-a-value1\", \"param-a-value2\"],\n"
"              \"param-subject\": \"{keycloak.access_token['/sub']}\",\n"
"              \"param-user-name\": \"{keycloak.access_token['/preferred_username']}\",\n"
"              \"param-other-claims\": \"{keycloak.access_token['/custom_claim']}\"\n"
"            }\n"
"          }\n"
"        }\n"
"      }\n"
"    ]\n"
"  }"
msgstr ""

msgid "Static Claims"
msgstr ""

msgid ""
"\"policy-enforcer\": {\n"
"    \"paths\": [\n"
"      {\n"
"        \"path\": \"/protected/resource\",\n"
"        \"claim-information-point\": {\n"
"          \"claims\": {\n"
"            \"claim-from-static-value\": \"static value\",\n"
"            \"claim-from-multiple-static-value\": [\"static\", \"value\"],\n"
"          }\n"
"        }\n"
"      }\n"
"    ]\n"
"  }"
msgstr ""

msgid "Claim Information Provider SPI"
msgstr ""

msgid "The Claim Information Provider SPI can be used by developers to support different claim information points in case none of the built-ins providers are enough to address their requirements."
msgstr ""

msgid "For example, to implement a new CIP provider you need to implement `org.keycloak.adapters.authorization.ClaimInformationPointProviderFactory` and `ClaimInformationPointProvider` and also provide the file `META-INF/services/org.keycloak.adapters.authorization.ClaimInformationPointProviderFactory` in your application`s classpath."
msgstr ""

msgid "Example of `org.keycloak.adapters.authorization.ClaimInformationPointProviderFactory`:"
msgstr ""

msgid ""
"public class MyClaimInformationPointProviderFactory implements ClaimInformationPointProviderFactory<MyClaimInformationPointProvider> {\n"
"\n"
"    @Override\n"
"    public String getName() {\n"
"        return \"my-claims\";\n"
"    }\n"
"\n"
"    @Override\n"
"    public void init(PolicyEnforcer policyEnforcer) {\n"
"\n"
"    }\n"
"\n"
"    @Override\n"
"    public MyClaimInformationPointProvider create(Map<String, Object> config) {\n"
"        return new MyClaimInformationPointProvider(config);\n"
"    }\n"
"}"
msgstr ""

msgid "Every CIP provider must be associated with a name, as defined above in the `MyClaimInformationPointProviderFactory.getName` method. The name will be used to map the configuration from the `claim-information-point` section in the `policy-enforcer` configuration to the implementation."
msgstr ""

msgid "When processing requests, the policy enforcer will call the MyClaimInformationPointProviderFactory.create method in order to obtain an instance of MyClaimInformationPointProvider. When called, any configuration defined for this particular CIP provider (via claim-information-point) is passed as a map."
msgstr ""

msgid "Example of `ClaimInformationPointProvider`:"
msgstr ""

msgid ""
"public class MyClaimInformationPointProvider implements ClaimInformationPointProvider {\n"
"\n"
"    private final Map<String, Object> config;\n"
"\n"
"    public MyClaimInformationPointProvider(Map<String, Object> config) {\n"
"        this.config = config;\n"
"    }\n"
"\n"
"    @Override\n"
"    public Map<String, List<String>> resolve(HttpFacade httpFacade) {\n"
"        Map<String, List<String>> claims = new HashMap<>();\n"
"\n"
"        // put whatever claim you want into the map\n"
"\n"
"        return claims;\n"
"    }\n"
"}"
msgstr ""

msgid "Obtaining the Authorization Context"
msgstr ""

msgid "When policy enforcement is enabled, the permissions obtained from the server are available through `org.keycloak.AuthorizationContext`. This class provides several methods you can use to obtain permissions and ascertain whether a permission was granted for a particular resource or scope."
msgstr ""

msgid "Obtaining the Authorization Context in a Servlet Container"
msgstr ""

msgid ""
"    HttpServletRequest request = ... // obtain javax.servlet.http.HttpServletRequest\n"
"    KeycloakSecurityContext keycloakSecurityContext =\n"
"        (KeycloakSecurityContext) request\n"
"            .getAttribute(KeycloakSecurityContext.class.getName());\n"
"    AuthorizationContext authzContext =\n"
"        keycloakSecurityContext.getAuthorizationContext();"
msgstr ""

msgid "For more details about how you can obtain a `KeycloakSecurityContext` consult the adapter configuration. The example above should be sufficient to obtain the context when running an application using any of the servlet containers supported by {project_name}."
msgstr ""

msgid "The authorization context helps give you more control over the decisions made and returned by the server. For example, you can use it to build a dynamic menu where items are hidden or shown depending on the permissions associated with a resource or scope."
msgstr ""

msgid ""
"if (authzContext.hasResourcePermission(\"Project Resource\")) {\n"
"    // user can access the Project Resource\n"
"}\n"
"\n"
"if (authzContext.hasResourcePermission(\"Admin Resource\")) {\n"
"    // user can access administration resources\n"
"}\n"
"\n"
"if (authzContext.hasScopePermission(\"urn:project.com:project:create\")) {\n"
"    // user can create new projects\n"
"}"
msgstr ""

msgid "The `AuthorizationContext` represents one of the main capabilities of {project_name} Authorization Services. From the examples above, you can see that the protected resource is not directly associated with the policies that govern them."
msgstr ""

msgid "Consider some similar code using role-based access control (RBAC):"
msgstr ""

msgid ""
"if (User.hasRole('user')) {\n"
"    // user can access the Project Resource\n"
"}\n"
"\n"
"if (User.hasRole('admin')) {\n"
"    // user can access administration resources\n"
"}\n"
"\n"
"if (User.hasRole('project-manager')) {\n"
"    // user can create new projects\n"
"}"
msgstr ""

msgid "Although both examples address the same requirements, they do so in different ways. In RBAC, roles only _implicitly_ define access for their resources. With {project_name} you gain the capability to create more manageable code that focuses directly on your resources whether you are using RBAC, attribute-based access control (ABAC), or any other BAC variant. Either you have the permission for a given resource or scope, or you don't."
msgstr ""

msgid "Now, suppose your security requirements have changed and in addition to project managers, PMOs can also create new projects."
msgstr ""

msgid "Security requirements change, but with {project_name} there is no need to change your application code to address the new requirements. Once your application is based on the resource and scope identifier, you need only change the configuration of the permissions or policies associated with a particular resource in the authorization server. In this case, the permissions and policies associated with the `Project Resource` and/or the scope `urn:project.com:project:create` would be changed."
msgstr ""

msgid "Using the AuthorizationContext to obtain an Authorization Client Instance"
msgstr ""

msgid "The ```AuthorizationContext``` can also be used to obtain a reference to the <<_service_client_api, Authorization Client API>> configured to your application:"
msgstr ""

msgid ""
"    ClientAuthorizationContext clientContext = ClientAuthorizationContext.class.cast(authzContext);\n"
"    AuthzClient authzClient = clientContext.getClient();"
msgstr ""

msgid "In some cases, resource servers protected by the policy enforcer need to access the APIs provided by the authorization server. With an ```AuthzClient``` instance in hands, resource servers can interact with the server in order to create resources or check for specific permissions programmatically."
msgstr ""

msgid "JavaScript Integration"
msgstr ""

msgid "The {project_name} Server comes with a JavaScript library you can use to interact with a resource server protected by a policy enforcer. This library is based on the {project_name} JavaScript adapter, which can be integrated to allow your client to obtain permissions from a {project_name} Server."
msgstr ""

msgid "You can obtain this library from a running a {project_name} Server instance by including the following `script` tag in your web page:"
msgstr ""

msgid "<script src=\"http://...{kc_js_path}/keycloak-authz.js\"></script>"
msgstr ""

msgid "Once you do that, you can create a `KeycloakAuthorization` instance as follows:"
msgstr ""

msgid ""
"var keycloak = ... // obtain a Keycloak instance from keycloak.js library\n"
"var authorization = new KeycloakAuthorization(keycloak);"
msgstr ""

msgid "The *keycloak-authz.js* library provides two main features:"
msgstr ""

msgid "Obtain permissions from the server using a permission ticket, if you are accessing a UMA protected resource server."
msgstr ""

msgid "Obtain permissions from the server by sending the resources and scopes the application wants to access."
msgstr ""

msgid "In both cases, the library allows you to easily interact with both resource server and {project_name} Authorization Services to obtain tokens with permissions your client can use as bearer tokens to access the protected resources on a resource server."
msgstr ""

msgid "Handling Authorization Responses from a UMA-Protected Resource Server"
msgstr ""

msgid "If a resource server is protected by a policy enforcer, it responds to client requests based on the permissions carried along with a bearer token. Typically, when you try to access a resource server with a bearer token that is lacking permissions to access a protected resource, the resource server responds with a *401* status code and a `WWW-Authenticate` header."
msgstr ""

msgid "See <<_service_uma_authorization_process, UMA Authorization Process>> for more information."
msgstr ""

msgid "What your client needs to do is extract the permission ticket from the ```WWW-Authenticate``` header returned by the resource server and use the library to send an authorization request as follows:"
msgstr ""

msgid ""
"// prepare a authorization request with the permission ticket\n"
"var authorizationRequest = {};\n"
"authorizationRequest.ticket = ticket;\n"
"\n"
"// send the authorization request, if successful retry the request\n"
"Identity.authorization.authorize(authorizationRequest).then(function (rpt) {\n"
"    // onGrant\n"
"}, function () {\n"
"    // onDeny\n"
"}, function () {\n"
"    // onError\n"
"});"
msgstr ""

msgid "The `authorize` function is completely asynchronous and supports a few callback functions to receive notifications from the server:"
msgstr ""

msgid "`onGrant`: The first argument of the function. If authorization was successful and the server returned an RPT with the requested permissions, the callback receives the RPT."
msgstr ""

msgid "`onDeny`: The second argument of the function. Only called if the server has denied the authorization request."
msgstr ""

msgid "`onError`: The third argument of the function. Only called if the server responds unexpectedly."
msgstr ""

msgid "Most applications should use the `onGrant` callback to retry a request after a 401 response. Subsequent requests should include the RPT as a bearer token for retries."
msgstr ""

msgid "Obtaining Entitlements"
msgstr ""

msgid "The ```keycloak-authz.js``` library provides an `entitlement` function that you can use to obtain an RPT from the server by providing the resources and scopes your client wants to access."
msgstr ""

msgid "Example about how to obtain an RPT with permissions for all resources and scopes the user can access"
msgstr ""

msgid ""
"authorization.entitlement('my-resource-server-id').then(function (rpt) {\n"
"    // onGrant callback function.\n"
"    // If authorization was successful you'll receive an RPT\n"
"    // with the necessary permissions to access the resource server\n"
"});"
msgstr ""

msgid "Example about how to obtain an RPT with permissions for specific resources and scopes"
msgstr ""

msgid ""
"authorization.entitlement('my-resource-server', {\n"
"    \"permissions\": [\n"
"        {\n"
"            \"id\" : \"Some Resource\"\n"
"        }\n"
"    ]\n"
"}).then(function (rpt) {\n"
"    // onGrant\n"
"});"
msgstr ""

msgid "When using the `entitlement` function, you must provide the _client_id_ of the resource server you want to access."
msgstr ""

msgid "The `entitlement` function is completely asynchronous and supports a few callback functions to receive notifications from the server:"
msgstr ""

msgid "Authorization Request"
msgstr ""

msgid "Both ```authorize``` and ```entitlement``` functions accept an authorization request object. This object can be set with the following properties:"
msgstr ""

msgid "*permissions*"
msgstr ""

msgid "An array of objects representing the resource and scopes. For instance:"
msgstr ""

msgid ""
"var authorizationRequest = {\n"
"   \"permissions\": [\n"
"       {\n"
"           \"id\" : \"Some Resource\",\n"
"           \"scopes\" : [\"view\", \"edit\"]\n"
"       }\n"
"   ]\n"
"}"
msgstr ""

msgid "*metadata*"
msgstr ""

msgid "An object where its properties define how the authorization request should be processed by the server."
msgstr ""

msgid "*response_include_resource_name*"
msgstr ""

msgid "A boolean value indicating to the server if resource names should be included in the RPT's permissions. If false, only the resource identifier is included."
msgstr ""

msgid "*response_permissions_limit*"
msgstr ""

msgid "An integer N that defines a limit for the amount of permissions an RPT can have. When used together with `rpt` parameter, only the last N requested permissions will be kept in the RPT"
msgstr ""

msgid "*submit_request*"
msgstr ""

msgid "A boolean value indicating whether the server should create permission requests to the resources and scopes referenced by a permission ticket. This parameter will only take effect when used together with the `ticket` parameter as part of a UMA authorization process."
msgstr ""

msgid "Obtaining the RPT"
msgstr ""

msgid "If you have already obtained an RPT using any of the authorization functions provided by the library, you can always obtain the RPT as follows from the authorization object (assuming that it has been initialized by one of the techniques shown earlier):"
msgstr ""

msgid "var rpt = authorization.rpt;"
msgstr ""

msgid "Setting Up TLS/HTTPS"
msgstr ""

msgid "When the server is using HTTPS, ensure your adapter is configured as follows:"
msgstr ""

msgid ""
"{\n"
"  \"truststore\": \"path_to_your_trust_store\",\n"
"  \"truststore-password\": \"trust_store_password\"\n"
"}"
msgstr ""

msgid "The configuration above enables TLS/HTTPS to the Authorization Client, making possible to access a {project_name} Server remotely using the HTTPS scheme."
msgstr ""

msgid "It is strongly recommended that you enable TLS/HTTPS when accessing the {project_name} Server endpoints."
msgstr ""
