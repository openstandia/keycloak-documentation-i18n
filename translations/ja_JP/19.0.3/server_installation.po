# 
# Translators:
# naoto watanabe <nabenao11@gmail.com>, 2023
# n.watanabe <nwatanabe.ase@gmail.com>, 2023
# Tsukasa Amano <t.amano@pro-japan.co.jp>, 2023
# Yoshikazu Nojima <mail@ynojima.net>, 2023
# jic_m_mito <jic-m-mito@nri.co.jp>, 2023
# Kohei Tamura <ktamura.biz.80@gmail.com>, 2023
# Hiroyuki Wada <wadahiro@gmail.com>, 2023
# 
msgid ""
msgstr ""
"Last-Translator: Hiroyuki Wada <wadahiro@gmail.com>, 2023\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid "{installguide_name}"
msgstr "{installguide_name}"

msgid "*{release_header_guide}* icon:angle-down[]"
msgstr "*{release_header_guide}* icon:angle-down[]"

msgid "{gettingstarted_link}[{gettingstarted_name_short}]"
msgstr "{gettingstarted_link}[{gettingstarted_name_short}]"

msgid "{adapterguide_link}[{adapterguide_name_short}]"
msgstr "{adapterguide_link}[{adapterguide_name_short}]"

msgid "{adminguide_link}[{adminguide_name_short}]"
msgstr "{adminguide_link}[{adminguide_name_short}]"

msgid "{developerguide_link}[{developerguide_name_short}]"
msgstr "{developerguide_link}[{developerguide_name_short}]"

msgid "{authorizationguide_link}[{authorizationguide_name_short}]"
msgstr "{authorizationguide_link}[{authorizationguide_name_short}]"

msgid "{upgradingguide_link}[{upgradingguide_name_short}]"
msgstr "{upgradingguide_link}[{upgradingguide_name_short}]"

msgid "{releasenotes_link}[{releasenotes_name_short}]"
msgstr "{releasenotes_link}[{releasenotes_name_short}]"

msgid ""
"Version *{project_version}* _{release_header_latest_link}[Click here for "
"latest]_"
msgstr "バージョン *{project_version}* _{release_header_latest_link}[最新はこちらをクリック]_"

msgid "This guide is for the legacy WildFly distribution of Keycloak."
msgstr "このガイドは、KeycloakのレガシーなWildFlyディストリビューション用です。"

msgid ""
"For the new Quarkus powered distribution check out the new "
"https://www.keycloak.org/guides#server[Server Guides]."
msgstr ""
"Quarkusによる新しいディストリビューションについては、新しい "
"https://www.keycloak.org/guides#server[Server Guides] をチェックしてください。"

msgid "Guide Overview"
msgstr "ガイドの概要"

msgid ""
"The purpose of this guide is to walk through the steps that need to be "
"completed prior to booting up the {project_name} server for the first time."
"  If you just want to test drive {project_name}, it pretty much runs out of "
"the box with its own embedded and local-only database.  For  actual "
"deployments that are going to be run in production you'll need to decide how"
" you want to manage server configuration  at runtime (standalone or domain "
"mode), configure a shared database for {project_name} storage, set up "
"encryption and HTTPS,  and finally set up {project_name} to run in a "
"cluster.  This guide walks through each and every aspect of any pre-boot  "
"decisions and setup you must do prior to deploying the server."
msgstr ""
"このガイドの目的は、{project_name}サーバーの初回起動の前に完了する必要があるいくつかの手順について説明することです。{project_name}をテストしたいだけの場合は、組み込みのローカル専用のデータベースでそのまま実行する方がよいでしょう。実際にプロダクション環境にデプロイしたい場合は、まずどのようにランタイム（スタンドアローン・モードまたはドメインモード）でサーバー設定を管理するか決定して、{project_name}の共有データベースを設定し、暗号化とHTTPSの設定を行い、最後に{project_name}をセットアップしてクラスター内で起動する必要があります。このガイドは、{project_name}サーバーをデプロイする前に、起動に先んじて定義と設定が必要なすべての手順を、ひとつひとつ説明していきます。"

msgid ""
"One thing to particularly note is that {project_name} is derived from the "
"{appserver_name} Application Server. Many aspects of configuring "
"{project_name} revolve around {appserver_name} configuration elements.  "
"Often this guide will direct you to documentation outside of the manual if "
"you want to dive into more detail."
msgstr ""
"ただし、{project_name}は{appserver_name} Application "
"Serverに基づいていて、{project_name}の設定は{appserver_name}の設定項目と密接に関わっています。そのためこのガイドでは、詳細な説明について、このチュートリアルとは別の外部ドキュメントを紹介することがあります。その点は留意ください。"

msgid "Recommended additional external documentation"
msgstr "推奨される追加の外部ドキュメント"

msgid ""
"{project_name} is built on top of the {appserver_name} application server "
"and its sub-projects like Infinispan (for caching) and Hibernate (for "
"persistence). This guide only covers basics for infrastructure-level "
"configuration.  It is highly recommended that you peruse the documentation "
"for {appserver_name} and its sub projects. Here is the link to the "
"documentation:"
msgstr ""
"{project_name}は{appserver_name}アプリケーション・サーバーに追加構築されたもので、Infinispan（キャッシュのため）およびHibernate（永続化のため）のようなサブプロジェクトのひとつです。このガイドでは、基本的なインフラ構築レベルの設定のみ説明します。したがって、是非{appserver_name}およびそのサブプロジェクトのドキュメントを熟読することをお勧めします。ドキュメントへのリンクは以下のとおりです。"

msgid "link:{appserver_admindoc_link}[_{appserver_admindoc_name}_]"
msgstr "link:{appserver_admindoc_link}[_{appserver_admindoc_name}_]"

msgid "Installing the software"
msgstr "ソフトウェアのインストール"

msgid ""
"Installing {project_name} is as simple as downloading it and unzipping it. "
"This chapter reviews system requirements as well as the directory structure "
"of the distribution."
msgstr ""
"{project_name}のインストールは、ダウンロードして解凍するだけです。この章では、配布物のディレクトリー構造とシステム要件について説明します。"

msgid "Installation prerequisites"
msgstr "インストールの前提条件"

msgid "These prerequisites exist for installing the {project_name} server:"
msgstr "これらの前提条件は、{project_name} サーバーをインストールするために存在します。"

msgid "Can run on any operating system that runs Java"
msgstr "Javaが実行可能なオペレーティング・システム"

msgid "Java 8 JRE or Java 11 JRE"
msgstr "Java 8 JREまたはJava 11 JRE"

msgid "zip or gzip and tar"
msgstr "zipまたはgzip、およびtar"

msgid "At least 512M of RAM"
msgstr "RAM512M以上"

msgid "At least 1G of diskspace"
msgstr "ディスクスペース1G以上"

msgid ""
"A shared external database like PostgreSQL, MySQL, Oracle, etc.  "
"{project_name} requires an external shared database if you want to run in a "
"cluster.   Please see the <<_database,database configuration>> section of "
"this guide for more information."
msgstr ""
"PostgreSQL、MySQL、Oracleなどの共有外部データベース。{project_name}をクラスターで実行する場合は、外部共有データベースが必要です。詳細については、このガイドの<<_database,データベース設定>>のセクションを参照してください。"

msgid ""
"Network multicast support on your machine if you want to run in a cluster.  "
"{project_name} can be clustered without multicast, but this requires a bunch"
" of configuration changes.  Please see the <<_clustering,clustering>> "
"section of this guide for more information."
msgstr ""
"マルチキャストなしでもクラスターを構成できますが、多くの設定変更が必要になります。詳しくは、このガイドの<<_clustering,クラスタリング>>セクションを参照してください。"

msgid ""
"On Linux, it is recommended to use `/dev/urandom` as a source of random data"
" to prevent {project_name} hanging due to lack of available entropy, unless "
"`/dev/random` usage is mandated by your security policy. To achieve that on "
"Oracle JDK 8 and OpenJDK 8, set the `java.security.egd` system property on "
"startup to `file:/dev/urandom`."
msgstr ""
"Linuxにおいては、セキュリティー・ポリシーにより `/dev/random` の使用が義務付けられている場合を除き、ランダムデータのソースとして "
"`/dev/urandom` "
"を使用することをお勧めします。エントロピー不足が原因で{project_name}が固まるのを防ぐことができます。Oracle JDK "
"8およびOpenJDK 8でこれを使用するには、 起動時の `java.security.egd` システム・プロパティーを "
"`file:/dev/urandom` に設定してください。"

msgid "Installing the Keycloak server"
msgstr "Keycloakサーバーのインストール"

msgid "The Keycloak Server has two downloadable distributions:"
msgstr "Keycloakサーバーには、ダウンロード可能な2つの配布物があります。"

msgid "`keycloak-{project_version}.[zip|tar.gz]`"
msgstr "`keycloak-{project_version}.[zip|tar.gz]`"

msgid ""
"This file is the server only distribution.  It contains nothing other than "
"the scripts and binaries to run the Keycloak Server."
msgstr "このファイルは、サーバーのみの配布物です。Keycloakサーバーを実行するためのスクリプトとバイナリー以外は何も含まれていません。"

msgid "`keycloak-overlay-{project_version}.[zip|tar.gz]`"
msgstr "`keycloak-overlay-{project_version}.[zip|tar.gz]`"

msgid ""
"This file is a WildFly add-on that you can use to install the Keycloak "
"Server on top of an existing WildFly distribution.  We do not support users "
"who want to run their applications and Keycloak on the same server instance."
msgstr ""
"このファイルは、既存のWildFlyディストリビューションの上にKeycloakサーバーをインストールするために使用できるWildFlyアドオンです。 "
"アプリケーションとKeycloakを同じサーバー・インスタンスで動作させたいというユーザーには対応していません。"

msgid "Procedure"
msgstr "手順"

msgid ""
"To install the Keycloak server, run your operating system's `unzip` or "
"`gunzip` and `tar` utilities on the "
"`keycloak-{project_version}.[zip|tar.gz]` file."
msgstr ""
"Keycloakサーバーをインストールするには、お使いのOSの `unzip` または `gunzip` と `tar` ユーティリティーを "
"`keycloak-{project_version}.[zip|tar.gz]` ファイル上で実行します。"

msgid ""
"To install the Keycloak Service Pack, it must be installed on a different "
"server instance."
msgstr "Keycloak Service Packをインストールするには、別のサーバー・インスタンスにインストールする必要があります。"

msgid "Change to the root directory of your WildFly distribution."
msgstr "あなたのWildFlyディストリビューションのルート・ディレクトリーに移動します。"

msgid "Unzip the `keycloak-overlay-{project_version}.[zip|tar.gz]` file."
msgstr "`keycloak-overlay-{project_version}.[zip|tar.gz]` ファイルを解凍してください。"

msgid "Open the bin directory in a shell."
msgstr "シェルでbinディレクトリーを開きます。"

msgid "Run `./jboss-cli.[sh|bat] --file=keycloak-install.cli`."
msgstr "`./jboss-cli.[sh|bat] --file=keycloak-install.cli` を実行します。"

msgid "Important directories"
msgstr "重要なディレクトリ"

msgid ""
"The following are some important directories in the server distribution."
msgstr "サーバー配布物の中で重要なディレクトリを以下に示します。"

msgid "_bin/_"
msgstr "_bin/_"

msgid ""
"This contains various scripts to either boot the server or perform some "
"other management action on the server."
msgstr "サーバーの起動またはサーバー上でその他管理操作を行う、さまざまなスクリプトが含まれています。"

msgid "_domain/_"
msgstr "_domain/_"

msgid ""
"This contains configuration files and working directory when running "
"{project_name} in <<_domain-mode,domain mode>>."
msgstr ""
"{project_name}を<<_domain-"
"mode,ドメインモード>>で実行する場合の、設定ファイルとワーキング・ディレクトリーが含まれています。"

msgid "_modules/_"
msgstr "_modules/_"

msgid "These are all the Java libraries used by the server."
msgstr "サーバー上で使用されるすべてのJavaライブラリーです。"

msgid "_standalone/_"
msgstr "_standalone/_"

msgid ""
"This contains configuration files and working directory when running "
"{project_name} in <<_standalone-mode,standalone mode>>."
msgstr ""
"{project_name}を<<_standalone-"
"mode,スタンドアローン・モード>>で実行する場合の、設定ファイルとワーキング・ディレクトリーが含まれています。"

msgid "_standalone/deployments/_"
msgstr "_standalone/deployments/_"

msgid ""
"If you are writing extensions to {project_name}, you can put your extensions"
" here.  See the link:{developerguide_link}[{developerguide_name}] for more "
"information on this."
msgstr ""
"{project_name}の拡張を作成する場合、ここに配置することができます。詳しくは、 "
"{developerguide_link}[{developerguide_name}] を参照してください。"

msgid "_themes/_"
msgstr "_themes/_"

msgid ""
"This directory contains all the html, style sheets, JavaScript files, and "
"images used to display any UI screen displayed by the server. Here you can "
"modify an existing theme or create your own.  See the "
"link:{developerguide_link}[{developerguide_name}] for more information on "
"this."
msgstr ""
"このディレクトリーには、サーバーによって表示されるUI画面を表示するために使用されるすべてのHTML、スタイルシート、JavaScriptファイル、および画像が含まれます。ここでは、既存のテーマを変更したり、独自のテーマを作成したりすることができます。詳細については、"
" {developerguide_link}[{developerguide_name}] を参照してください。"

msgid "Using operating modes"
msgstr "動作モードの使い方"

msgid ""
"Before deploying {project_name} in a production environment you need to "
"decide which type of operating mode you are going to use."
msgstr "プロダクション環境に{project_name}を導入する前に、どのタイプの動作モードを使用するかを決める必要があります。"

msgid "Will you run {project_name} within a cluster?"
msgstr "{project_name}をクラスター内で実行するか？"

msgid "Do you want a centralized way to manage your server configurations?"
msgstr "サーバーの設定を一元的に管理したいか？"

msgid ""
"Your choice of operating mode affects how you configure databases, configure"
" caching and even how you boot the server."
msgstr "動作モードの選択は、データベースの設定やキャッシングの設定、さらにはサーバーの起動方法にも影響します。"

msgid ""
"The {project_name} is built on top of the {appserver_name} Application "
"Server.  This guide will only      go over the basics for deployment within "
"a specific mode.  If you want specific information on this, a better place"
"      to go would be the "
"link:{appserver_admindoc_link}[_{appserver_admindoc_name}_]."
msgstr ""
"{project_name}は{appserver_name}アプリケーション・サーバー上に構築されています。このガイドでは、基本的な特定のモードでのデプロイメントについて説明します。詳しくは、link:{appserver_admindoc_link}[_{appserver_admindoc_name}_]を参照してください。"

msgid "Using standalone mode"
msgstr "スタンドアローン・モードの使用"

msgid ""
"Standalone operating mode is only useful when you want to run one, and only "
"one {project_name} server instance. It is not usable for clustered "
"deployments and all caches are non-distributed and local-only.  It is not "
"recommended that you use standalone mode in production as you will have a "
"single point of failure.  If your standalone mode server goes down, users "
"will not be able to log in.  This mode is really only useful to test drive "
"and play with the features of {project_name}"
msgstr ""
"スタンドアローン動作モードは、サーバーに1つの{project_name}サーバー・インスタンスを起動する場合にのみ有効です。クラスター構成には使用できません。また、キャッシュは分散されておらずローカル専用です。スタンドアローン・モードは単一障害点となりえるので、プロダクション環境での使用はお勧めしません。スタンドアローン・モードのサーバーがダウンした場合、ユーザーはログインできなくなります。そのため、このモードはテストおよび{project_name}の機能を試す目的にのみ有効です。"

msgid "Booting in standalone mode"
msgstr "スタンドアローン・モードでの起動"

msgid ""
"When running the server in standalone mode, there is a specific script you "
"need to boot the server depending on your operating system.  These scripts "
"live in the _bin/_ directory of the server distribution."
msgstr ""
"スタンドアローン・モードでサーバーを実行する場合、使用するオペレーティング・システムに応じて、サーバーを起動するために必要な特定のスクリプトがあります。これらのスクリプトは、サーバー配布物の"
" _bin/_ ディレクトリーにあります。"

msgid "Standalone Boot Scripts"
msgstr "スタンドアローン起動スクリプト"

msgid "image:{project_images}/standalone-boot-files.png[]"
msgstr "image:{project_images}/standalone-boot-files.png[]"

msgid "To boot the server:"
msgstr "サーバーを起動するには下記を実行します。"

msgid "Linux/Unix"
msgstr "Linux/Unix"

msgid "$ .../bin/standalone.sh"
msgstr "$ .../bin/standalone.sh"

msgid "Windows"
msgstr "Windows"

msgid "> ...\\bin\\standalone.bat"
msgstr "> ...\\bin\\standalone.bat"

msgid "Standalone configuration"
msgstr "スタンドアローン・モード構成"

msgid ""
"The bulk of this guide walks you through how to configure infrastructure "
"level aspects of {project_name}.  These aspects are configured in a "
"configuration file that is specific to the application server that "
"{project_name} is a derivative of.  In the standalone operation mode, this "
"file lives in _.../standalone/configuration/standalone.xml_.  This file is "
"also used to configure non-infrastructure level things that are specific to "
"{project_name} components."
msgstr ""
"このガイドの大半は、{project_name}の基盤レベルの設定について説明します。このレベルの設定は、{project_name}が構築されたアプリケーション・サーバーに特化した設定ファイル内に定義されます。スタンドアローン動作モードでは、このファイルは"
" _.../standalone/configuration/standalone.xml_ "
"にあります。また、このファイルは{project_name}のコンポーネントに特化した非基盤レベルの設定にも使用されます。"

msgid "Standalone Config File"
msgstr "スタンドアローン設定ファイル"

msgid "image:{project_images}/standalone-config-file.png[]"
msgstr "image:{project_images}/standalone-config-file.png[]"

msgid ""
"Any changes you make to this file while the server is running will not take "
"effect and may even be overwritten       by the server.  Instead use the "
"command line scripting or the web console of {appserver_name}.  See       "
"the link:{appserver_admindoc_link}[_{appserver_admindoc_name}_] for more "
"information."
msgstr ""
"サーバーの実行中にこのファイルに変更を加えても、反映されず、サーバーに上書きされる可能性があります。その場合は、代わりに{appserver_name}のwebコンソールまたはコマンドライン・スクリプトを使用します。詳しくは、link:{appserver_admindoc_link}[_{appserver_admindoc_name}_]を参照してください。"

msgid "Using standalone clustered mode"
msgstr "スタンドアローン・クラスター・モードの使用"

msgid ""
"Standalone clustered operation mode applies when you want to run "
"{project_name} within a cluster.  This mode requires that you have a copy of"
" the {project_name} distribution on each machine where you want to run a "
"server instance. This mode can be very easy to deploy initially, but can "
"become quite cumbersome. To make a configuration change, you modify each "
"distribution on each machine.  For a large cluster, this mode can become "
"time consuming and error prone."
msgstr ""
"スタンドアローン・クラスター動作モードは、クラスター内で{project_name}を実行するときに適用します。このモードでは、サーバー・インスタンスを実行する各マシンに{project_name}の配布物のコピーが保存されている必要があります。このモードは、最初は非常に簡単にデプロイできますが、後でかなり煩雑になる可能性があります。設定を変更するには、各マシンの配布物を修正します。大規模なクラスターの場合、時間がかかり、エラーも発生しやすくなります。"

msgid "Standalone clustered configuration"
msgstr "スタンドアローン・クラスター設定"

msgid ""
"The distribution has a mostly pre-configured app server configuration file "
"for running within a cluster.  It has all the specific infrastructure "
"settings for networking, databases, caches, and discovery.  This file "
"resides in _.../standalone/configuration/standalone-ha.xml_.  There's a few "
"things missing from this configuration. You can't run {project_name} in a "
"cluster without configuring a shared database connection.  You also need to "
"deploy some type of load balancer in front of the cluster.  The "
"<<_clustering,clustering>> and <<_database,database>> sections of this guide"
" walk you through these things."
msgstr ""
"この配布物には、クラスター内で実行するためのアプリケーション・サーバーの設定ファイルが含まれており、その大半は設定が済んでいます。ネットワーク、データベース、キャッシュ、およびディスカバリーのための基盤設定がすべて含まれています。このファイルは"
" _.../standalone/configuration/standalone-ha.xml_ "
"にあります。しかし、この設定だけでは足りません。共有データベース接続を設定せずに、クラスター内で{project_name}を実行することはできません。また、クラスターのフロントに何らかのロードバランサーを配備する必要があります。このガイドの<<_clustering,クラスタリング>>と<<_database,データベース>>のセクションでは、これらのことを説明します。"

msgid "Standalone HA Config"
msgstr "スタンドアローンHA設定"

msgid "image:{project_images}/standalone-ha-config-file.png[]"
msgstr "image:{project_images}/standalone-ha-config-file.png[]"

msgid "Booting in standalone clustered mode"
msgstr "スタンドアローン・クラスター・モードでの起動"

msgid ""
"You use the same boot scripts to start {project_name} as you do in "
"standalone mode.  The difference is that you pass in an additional flag to "
"point to the HA config file."
msgstr ""
"{project_name}を起動するには、スタンドアローン・モードで実行したのと同じ起動スクリプトを使用します。スタンドアローン・モードとの違いは、HA設定ファイルを指し示す追加フラグを渡すという点になります。"

msgid "Standalone Clustered Boot Scripts"
msgstr "スタンドアローン・クラスター起動スクリプト"

msgid "$ .../bin/standalone.sh --server-config=standalone-ha.xml"
msgstr "$ .../bin/standalone.sh --server-config=standalone-ha.xml"

msgid "> ...\\bin\\standalone.bat --server-config=standalone-ha.xml"
msgstr "> ...\\bin\\standalone.bat --server-config=standalone-ha.xml"

msgid "Using domain clustered mode"
msgstr "ドメイン・クラスター・モードの使用"

msgid ""
"Domain mode is a way to centrally manage and publish the configuration for "
"your servers."
msgstr "ドメインモードとは、サーバーの設定を一元管理し、クラスター内の各サーバーに反映させる方法です。"

msgid ""
"Running a cluster in standard mode can quickly become aggravating as the "
"cluster grows in size.  Every time you need to make a configuration change, "
"you  perform it on each node in the cluster.  Domain mode solves this "
"problem by providing a central place to store and publish configurations.  "
"It can be quite complex to set up, but it is worth it in the end. This "
"capability is built into the {appserver_name} Application Server which "
"{project_name} derives from."
msgstr ""
"標準モードでクラスターを実行すると、クラスターが大きくなり、煩雑化する可能性があります。設定を変更する必要があるたびに、クラスター内の各ノードでそれを実行します。一方、ドメインモードの場合は、設定を保存しパブリッシュするために一元管理する場所を提供することで、この問題を解決できます。セットアップにはかなり手間がかかりますが、最終的にはその工数は見合うことになります。この機能は{project_name}が構成される{appserver_name}アプリケーション・サーバーに組み込まれています。"

msgid ""
"The guide will go over the very basics of domain mode.  Detailed steps on "
"how to set up domain mode in a cluster should be obtained from the        "
"link:{appserver_admindoc_link}[_{appserver_admindoc_name}_]."
msgstr ""
"このガイドでは、ドメインモードの初歩的なところを説明します。クラスター内でのドメインモードのセットアップ手順について、詳しくは、link:{appserver_admindoc_link}[_{appserver_admindoc_name}_]を参照してください。"

msgid "Here are some of the basic concepts of running in domain mode."
msgstr "ドメインモードを実行する基本的なコンセプトは、以下のとおりです。"

msgid "domain controller"
msgstr "ドメイン・コントローラー"

msgid ""
"The domain controller is a process that is responsible for storing, "
"managing, and publishing the general configuration for each node in the "
"cluster.  This process is the central point from which nodes in a cluster "
"obtain their configuration."
msgstr ""
"ドメイン・コントローラーとは、クラスター内の各ノードの一般的な設定を保存、管理、パブリッシュする役割をもつ、プロセスのことです。また、クラスター内の各ノードが取得する設定を一元管理するデータベースでもあります。"

msgid "host controller"
msgstr "ホスト・コントローラー"

msgid ""
"The host controller is responsible for managing server instances on a "
"specific machine.  You configure it to run one or more server instances.  "
"The domain controller can also interact with the host controllers on each "
"machine to manage the cluster.  To reduce the number of running process, a "
"domain controller also acts as a host controller on the machine it runs on."
msgstr ""
"ホスト・コントローラーの役割は、特定のマシン内のサーバー・インスタンスを管理することです。1つ以上のサーバー・インスタンスを実行できるよう、ホスト・コントローラーを設定することになります。また、ドメイン・コントローラーはクラスターを管理するために、各マシン内のホスト・コントローラーと連携します。実行プロセスを減らすために、ドメイン・コントローラーに、特定のマシン内のホスト・コントローラーとしての役割を担わせることもできます。"

msgid "domain profile"
msgstr "ドメイン・プロファイル"

msgid ""
"A domain profile is a named set of configuration that can be used by a "
"server to boot from.  A domain controller can define multiple domain "
"profiles that are consumed by different servers."
msgstr ""
"ドメイン・プロファイルとは、サーバーを起動するために使用する、名前付きの設定セットです。ドメイン・コントローラーで、複数のドメイン・プロファイルを定義することができます。そして、さまざまなサーバーがこのドメイン・プロファイルを使うことになります。"

msgid "server group"
msgstr "サーバーグループ"

msgid ""
"A server group is a collection of servers.  They are managed and configured "
"as one.  You can assign a domain profile to a server group and every service"
" in that group will use that domain profile as their configuration."
msgstr ""
"サーバーグループとは、サーバーの集合体です。ひとつの集合体として管理、設定されます。サーバーグループに、ドメイン・プロファイルを割り当てることができます。そして、そのドメイン・プロファイルはサーバーグループ内のサービスの設定として使用されます。"

msgid ""
"In domain mode, a domain controller is started on a master node.  The "
"configuration for the cluster resides in the domain controller. Next a host "
"controller is started on each machine in the cluster.  Each host controller "
"deployment configuration specifies how many {project_name} server instances "
"will be started on that machine.  When the host controller boots up, it "
"starts as many {project_name} server instances as it was configured to do.  "
"These server instances pull their configuration from the domain controller."
msgstr ""
"ドメインモードでは、マスターノード上でドメイン・コントローラーが起動されます。クラスターの設定は、ドメイン・コントローラー内にあります。次に、ホスト・コントローラーがクラスター内の各マシンで起動されます。各ホスト・コントローラーのデプロイ設定では、そのマシンで起動する{project_name}サーバー・インスタンスの数を指定します。ホスト・コントローラーが起動すると、指定された数の{project_name}サーバー・インスタンスが起動します。これらのサーバー・インスタンスは、ドメイン・コントローラーから設定を取得します。"

msgid ""
"In some environments, such as Microsoft Azure, the domain mode is not "
"applicable. Please consult the {appserver_name} documentation."
msgstr ""
"Microsoft Azureなどの一部の環境では、ドメインモードは適用されません。{appserver_name}のドキュメントを参照してください。"

msgid "Domain configuration"
msgstr "ドメイン設定"

msgid ""
"Various other chapters in this guide walk you through configuring various "
"aspects like databases, HTTP network connections, caches, and other "
"infrastructure related things.  While standalone mode uses the "
"_standalone.xml_ file to configure these things, domain mode uses the "
"_.../domain/configuration/domain.xml_ configuration file.  This is where the"
" domain profile and server group for the {project_name} server are defined."
msgstr ""
"このガイドの各章では、データベース、HTTPネットワーク接続、キャッシュ、およびその他の基盤関連のさまざまな設定について説明します。これらを設定するために、スタンドアローン・モードでは"
"  _standalone.xml_ ファイルを使用するのに対して、ドメインモードでは "
"_.../domain/configuration/domain.xml_ "
"を使用します。Keycloakサーバーのドメイン・プロファイルとサーバーグループは、以下で定義されます。"

msgid "domain.xml"
msgstr "domain.xml"

msgid "image:{project_images}/domain-file.png[]"
msgstr "image:{project_images}/domain-file.png[]"

msgid ""
"Any changes you make to this file while the domain controller is running "
"will not take effect and may even be overwritten       by the server.  "
"Instead use the command line scripting or the web console of "
"{appserver_name}.  See       the "
"link:{appserver_admindoc_link}[_{appserver_admindoc_name}_] for more "
"information."
msgstr ""
"ドメイン・コントローラーの実行中にこのファイルに変更を加えても、変更されず、サーバーに上書きされる可能性があります。その場合は、代わりに{appserver_name}のwebコンソールまたはコマンドライン・スクリプトを使用します。詳しくは、link:{appserver_admindoc_link}[_{appserver_admindoc_name}_]を参照してください。"

msgid ""
"Let's look at some aspects of this _domain.xml_ file.  The `auth-server-"
"standalone` and `auth-server-clustered` `profile` XML blocks are where you "
"are going to make the bulk of your configuration decisions. You'll be "
"configuring things here like network connections, caches, and database "
"connections."
msgstr ""
"この _domain.xml_ ファイルの特徴を確認していきましょう。 `auth-server-standalone` と `auth-server-"
"clustered` の `profile` "
"のXMLブロックでは、どのような設定にするかの大半を定義します。そして、ネットワーク接続、キャッシュ、データベース接続などを設定します。"

msgid "auth-server profile"
msgstr "認証サーバー・プロファイル"

msgid ""
"    <profiles>\n"
"        <profile name=\"auth-server-standalone\">\n"
"            ...\n"
"        </profile>\n"
"        <profile name=\"auth-server-clustered\">\n"
"            ...\n"
"        </profile>"
msgstr ""
"    <profiles>\n"
"        <profile name=\"auth-server-standalone\">\n"
"            ...\n"
"        </profile>\n"
"        <profile name=\"auth-server-clustered\">\n"
"            ...\n"
"        </profile>"

msgid ""
"The `auth-server-standalone` profile is a non-clustered setup.  The `auth-"
"server-clustered` profile is the clustered setup."
msgstr ""
"`auth-server-standalone` プロファイルは、非クラスター構成のセットアップ用です。一方 `auth-server-"
"clustered` プロファイルは、クラスター構成のセットアップ用です。"

msgid ""
"If you scroll down further, you'll see various `socket-binding-groups` "
"defined."
msgstr "スクロールダウンしていくと、定義済みの `socket-binding-groups` が表示されます。"

msgid "socket-binding-groups"
msgstr "socket-binding-groups"

msgid ""
"    <socket-binding-groups>\n"
"        <socket-binding-group name=\"standard-sockets\" default-interface=\"public\">\n"
"           ...\n"
"        </socket-binding-group>\n"
"        <socket-binding-group name=\"ha-sockets\" default-interface=\"public\">\n"
"           ...\n"
"        </socket-binding-group>\n"
"        <!-- load-balancer-sockets should be removed in production systems and replaced with a better software or hardware based one -->\n"
"        <socket-binding-group name=\"load-balancer-sockets\" default-interface=\"public\">\n"
"           ...\n"
"        </socket-binding-group>\n"
"    </socket-binding-groups>"
msgstr ""
"    <socket-binding-groups>\n"
"        <socket-binding-group name=\"standard-sockets\" default-interface=\"public\">\n"
"           ...\n"
"        </socket-binding-group>\n"
"        <socket-binding-group name=\"ha-sockets\" default-interface=\"public\">\n"
"           ...\n"
"        </socket-binding-group>\n"
"        <!-- load-balancer-sockets should be removed in production systems and replaced with a better software or hardware based one -->\n"
"        <socket-binding-group name=\"load-balancer-sockets\" default-interface=\"public\">\n"
"           ...\n"
"        </socket-binding-group>\n"
"    </socket-binding-groups>"

msgid ""
"This configration defines the default port mappings for various connectors "
"that are opened with each {project_name} server instance.  Any value that "
"contains `${...}` is a value that can be overridden on the command line with"
" the `-D` switch, i.e."
msgstr ""
"この設定では、各{project_name}サーバー・インスタンスによって開かれる、さまざまなコネクターのデフォルトポートマッピングを定義します。 "
"`${...}` を含む値はコマンドラインの `-D` スイッチで上書きできる値です。すなわち、以下のように上書きできます。"

msgid "$ domain.sh -Djboss.http.port=80"
msgstr "$ domain.sh -Djboss.http.port=80"

msgid ""
"The definition of the server group for {project_name} resides in the "
"`server-groups` XML block.  It specifies the domain profile that is used "
"(`default`) and also some default boot arguments for the Java VM when the "
"host controller boots an instance.  It also binds a `socket-binding-group` "
"to the server group."
msgstr ""
"{project_name}のサーバーグループの定義は、 `server-groups` "
"のXMLブロックにあります。ホスト・コントローラーがインスタンスを起動する場合、この定義により、 `default` "
"で使用されているドメイン・プロファイル、およびJava VMのデフォルト起動引数が指定されます。また、 `socket-binding-group` "
"はサーバーグループにバインドされます。"

msgid ""
"    <server-groups>\n"
"        <!-- load-balancer-group should be removed in production systems and replaced with a better software or hardware based one -->\n"
"        <server-group name=\"load-balancer-group\" profile=\"load-balancer\">\n"
"            <jvm name=\"default\">\n"
"                <heap size=\"64m\" max-size=\"512m\"/>\n"
"            </jvm>\n"
"            <socket-binding-group ref=\"load-balancer-sockets\"/>\n"
"        </server-group>\n"
"        <server-group name=\"auth-server-group\" profile=\"auth-server-clustered\">\n"
"            <jvm name=\"default\">\n"
"                <heap size=\"64m\" max-size=\"512m\"/>\n"
"            </jvm>\n"
"            <socket-binding-group ref=\"ha-sockets\"/>\n"
"        </server-group>\n"
"    </server-groups>"
msgstr ""
"    <server-groups>\n"
"        <!-- load-balancer-group should be removed in production systems and replaced with a better software or hardware based one -->\n"
"        <server-group name=\"load-balancer-group\" profile=\"load-balancer\">\n"
"            <jvm name=\"default\">\n"
"                <heap size=\"64m\" max-size=\"512m\"/>\n"
"            </jvm>\n"
"            <socket-binding-group ref=\"load-balancer-sockets\"/>\n"
"        </server-group>\n"
"        <server-group name=\"auth-server-group\" profile=\"auth-server-clustered\">\n"
"            <jvm name=\"default\">\n"
"                <heap size=\"64m\" max-size=\"512m\"/>\n"
"            </jvm>\n"
"            <socket-binding-group ref=\"ha-sockets\"/>\n"
"        </server-group>\n"
"    </server-groups>"

msgid "Host controller configuration"
msgstr "ホスト・コントローラー設定"

msgid ""
"{project_name} comes with two host controller configuration files that "
"reside in the _.../domain/configuration/_ directory: _host-master.xml_ and "
"_host-slave.xml_.  _host-master.xml_ is configured to boot up a domain "
"controller, a load balancer, and one {project_name} server instance.  _host-"
"slave.xml_ is configured to talk to the domain controller and boot up one "
"{project_name} server instance."
msgstr ""
"{project_name}には、 _.../domain/configuration/_ ディレクトリーにある、 _host-master.xml_ "
"と _host-slave.xml_ の2つのホスト・コントローラー設定ファイルが付属しています。 _host-master.xml_ "
"はドメイン・コントローラー、ロードバランサー、および1つの{project_name}サーバー・インスタンスを起動するように設定されています。一方、 "
"_host-slave.xml_ "
"はドメイン・コントローラーと通信し、1つの{project_name}サーバー・インスタンスを起動するように設定されています。"

msgid ""
"The load balancer is not a required service.  It exists so that you can "
"easily test drive clustering on your development        machine.  While "
"usable in production, you have the option of replacing it if you have a "
"different hardware or software        based load balancer you want to use."
msgstr ""
"ロードバランサーは必須サービスではありません。これは、開発マシン上でクラスタリングを簡単にテストできるようにするものです。プロダクション環境で使用可能ですが、使いたい別のハードウェアまたはソフトウェア・ベースのロードバランサーがあるなら、置き換えるかどうかを選択できます。"

msgid "Host Controller Config"
msgstr "ホスト・コントローラー設定"

msgid "image:{project_images}/host-files.png[]"
msgstr "image:{project_images}/host-files.png[]"

msgid ""
"To disable the load balancer server instance, edit _host-master.xml_ and "
"comment out or remove the `\"load-balancer\"` entry."
msgstr ""
"ロードバランサー・サーバー・インスタンスを無効にするには、 _host-master.xml_ を編集し、 \"load-balancer\" "
"エントリーをコメントアウトまたは削除します。"

msgid ""
"    <servers>\n"
"        <!-- remove or comment out next line -->\n"
"        <server name=\"load-balancer\" group=\"loadbalancer-group\"/>\n"
"        ...\n"
"    </servers>"
msgstr ""
"    <servers>\n"
"        <!-- remove or comment out next line -->\n"
"        <server name=\"load-balancer\" group=\"loadbalancer-group\"/>\n"
"        ...\n"
"    </servers>"

msgid ""
"Another interesting thing to note about this file is the declaration of the "
"authentication server instance.  It has a `port-offset` setting.  Any "
"network port defined in the _domain.xml_ `socket-binding-group` or the "
"server group will have the value of `port-offset` added to it.  For this "
"sample domain setup, we do this so that ports opened by the load balancer "
"server don't conflict with the authentication server instance that is "
"started."
msgstr ""
"このファイルのもう一つの興味深い点は、認証サーバー・インスタンスの宣言です。これには、 `port-offset` という設定があります。 "
"_domain.xml_  の `socket-binding-group` やサーバーグループで定義されたネットワークポートには、 `port-"
"offset` "
"の値が追加されます。このサンプルドメインの設定では、ロードバランサー・サーバーが開くポートが、起動している認証サーバー・インスタンスと衝突しないように、このようにしています。"

msgid ""
"    <servers>\n"
"        ...\n"
"        <server name=\"server-one\" group=\"auth-server-group\" auto-start=\"true\">\n"
"             <socket-bindings port-offset=\"150\"/>\n"
"        </server>\n"
"    </servers>"
msgstr ""
"    <servers>\n"
"        ...\n"
"        <server name=\"server-one\" group=\"auth-server-group\" auto-start=\"true\">\n"
"             <socket-bindings port-offset=\"150\"/>\n"
"        </server>\n"
"    </servers>"

msgid "Server instance working directories"
msgstr "サーバー・インスタンス・ワーキング・ディレクトリー"

msgid ""
"Each {project_name} server instance defined in your host files creates a "
"working directory under _.../domain/servers/{SERVER NAME}_. Additional "
"configuration can be put there, and any temporary, log, or data files the "
"server instance needs or creates go there too. The structure of these per "
"server directories ends up looking like any other {appserver_name} booted "
"server."
msgstr ""
"ホスト・ファイルに定義されている各{project_name}サーバー・インスタンスにより、 _.../domain/servers/{SERVER "
"NAME}_ "
"の下に作業ディレクトリーが作成されます。そこに追加の設定を保存でき、サーバー・インスタンスが必要とする、または作成する一時ファイル、ログファイル、データファイルも保存することができます。これらのサーバー・ディレクトリーごとの構造は、他の{appserver_name}ブートサーバーと同じようなものになります。"

msgid "Working Directories"
msgstr "ワーキング・ディレクトリー"

msgid "image:{project_images}/domain-server-dir.png[]"
msgstr "image:{project_images}/domain-server-dir.png[]"

msgid "Booting in domain clustered mode"
msgstr "ドメイン・クラスター・モードでの起動"

msgid ""
"When running the server in domain mode, there is a specific script you need "
"to run to boot the server depending on your operating system.  These scripts"
" live in the _bin/_ directory of the server distribution."
msgstr ""
"ドメインモードでサーバーを実行する場合、オペレーティング・システム固有の起動スクリプトを実行する必要があります。これらのスクリプトは、サーバー配布物の "
"_bin/_ ディレクトリーにあります。"

msgid "Domain Boot Script"
msgstr "ドメイン起動スクリプト"

msgid "image:{project_images}/domain-boot-files.png[]"
msgstr "image:{project_images}/domain-boot-files.png[]"

msgid "$ .../bin/domain.sh --host-config=host-master.xml"
msgstr "$ .../bin/domain.sh --host-config=host-master.xml"

msgid "> ...\\bin\\domain.bat --host-config=host-master.xml"
msgstr "> ...\\bin\\domain.bat --host-config=host-master.xml"

msgid ""
"When running the boot script you will need to pass in the host controlling "
"configuration file you are going to use via the `--host-config` switch."
msgstr "起動スクリプトを実行する場合、 `--host-config` スイッチ経由で、使用するホスト制御設定ファイルを渡す必要があります。"

msgid "Testing with a sample clustered domain"
msgstr "クラスター化されたドメインのサンプルを使ったテスト"

msgid ""
"You can test drive clustering using the sample _domain.xml_ configuration.  "
"This sample domain is meant to run on one machine and boots up:"
msgstr ""
"サンプルの _domain.xml_ 設定を使用してクラスタリングをテストできます。このサンプルドメインは、1台のマシンで実行され、以下を起動します。"

msgid "a domain controller"
msgstr "ドメイン・コントローラー"

msgid "an HTTP load balancer"
msgstr "HTTPロードバランサー"

msgid "two {project_name} server instances"
msgstr "2つの{project_name}サーバー・インスタンス"

msgid ""
"Run the `domain.sh` script twice to start two separate host controllers."
msgstr "2つのホスト・コントローラーを起動するために、`domain.sh` スクリプトを2回実行します。"

msgid ""
"The first one is the master host controller that starts a domain controller,"
" an HTTP load balancer, and one {project_name} authentication server "
"instance.  The second one is a slave host controller that starts up only an "
"authentication server instance."
msgstr ""
"1つ目はマスター・ホスト・コントローラーで、ドメイン・コントローラー、HTTPロードバランサー、1つの{project_name}認証サーバー・インスタンスを起動します。2つ目はスレーブ・ホスト・コントローラーで、認証サーバーのインスタンスのみを起動します。"

msgid ""
"Configure the slave host controller so that it can talk securely to the "
"domain controller. Perform these steps:"
msgstr "スレーブ・ホスト・コントローラーがドメイン・コントローラーと安全に通信できるように設定します。以下の手順を実行してください。"

msgid ""
"If you omit these steps, the slave host cannot obtain the centralized "
"configuration from the domain controller."
msgstr "これらの手順を省略すると、スレーブホストはドメイン・コントローラーから集中管理された設定を取得できません。"

msgid ""
"Set up a secure connection by creating a server admin user and a secret that"
" are shared between the master and the slave."
msgstr "マスターとスレーブの間で共有されるサーバー管理者のユーザーとシークレットを作成し、安全な接続を設定します。"

msgid "Run the `.../bin/add-user.sh` script."
msgstr "`.../bin/add-user.sh` スクリプトを実行してください。"

msgid ""
"Select `Management User` when the script asks about the type of user to  "
"add."
msgstr "スクリプトで追加するユーザーの種類を尋ねられたら、 `Management User` を選択します。"

msgid ""
"This choice generates a secret that you cut and paste into the "
"_.../domain/configuration/host-slave.xml_ file."
msgstr ""
"この選択により、 _.../domain/configuration/host-slave.xml_ "
"ファイルにカット＆ペーストするシークレットが生成されます。"

msgid "Add App Server Admin"
msgstr "アプリケーション・サーバー管理者の追加"

msgid ""
"$ add-user.sh\n"
" What type of user do you wish to add?\n"
"  a) Management User (mgmt-users.properties)\n"
"  b) Application User (application-users.properties)\n"
" (a): a\n"
" Enter the details of the new user to add.\n"
" Using realm 'ManagementRealm' as discovered from the existing property files.\n"
" Username : admin\n"
" Password recommendations are listed below. To modify these restrictions edit the add-user.properties configuration file.\n"
"  - The password should not be one of the following restricted values {root, admin, administrator}\n"
"  - The password should contain at least 8 characters, 1 alphabetic character(s), 1 digit(s), 1 non-alphanumeric symbol(s)\n"
"  - The password should be different from the username\n"
" Password :\n"
" Re-enter Password :\n"
" What groups do you want this user to belong to? (Please enter a comma separated list, or leave blank for none)[ ]:\n"
" About to add user 'admin' for realm 'ManagementRealm'\n"
" Is this correct yes/no? yes\n"
" Added user 'admin' to file '/.../standalone/configuration/mgmt-users.properties'\n"
" Added user 'admin' to file '/.../domain/configuration/mgmt-users.properties'\n"
" Added user 'admin' with groups to file '/.../standalone/configuration/mgmt-groups.properties'\n"
" Added user 'admin' with groups to file '/.../domain/configuration/mgmt-groups.properties'\n"
" Is this new user going to be used for one AS process to connect to another AS process?\n"
" e.g. for a slave host controller connecting to the master or for a Remoting connection for server to server EJB calls.\n"
" yes/no? yes\n"
" To represent the user add the following to the server-identities definition <secret value=\"bWdtdDEyMyE=\" />"
msgstr ""
"$ add-user.sh\n"
" What type of user do you wish to add?\n"
"  a) Management User (mgmt-users.properties)\n"
"  b) Application User (application-users.properties)\n"
" (a): a\n"
" Enter the details of the new user to add.\n"
" Using realm 'ManagementRealm' as discovered from the existing property files.\n"
" Username : admin\n"
" Password recommendations are listed below. To modify these restrictions edit the add-user.properties configuration file.\n"
"  - The password should not be one of the following restricted values {root, admin, administrator}\n"
"  - The password should contain at least 8 characters, 1 alphabetic character(s), 1 digit(s), 1 non-alphanumeric symbol(s)\n"
"  - The password should be different from the username\n"
" Password :\n"
" Re-enter Password :\n"
" What groups do you want this user to belong to? (Please enter a comma separated list, or leave blank for none)[ ]:\n"
" About to add user 'admin' for realm 'ManagementRealm'\n"
" Is this correct yes/no? yes\n"
" Added user 'admin' to file '/.../standalone/configuration/mgmt-users.properties'\n"
" Added user 'admin' to file '/.../domain/configuration/mgmt-users.properties'\n"
" Added user 'admin' with groups to file '/.../standalone/configuration/mgmt-groups.properties'\n"
" Added user 'admin' with groups to file '/.../domain/configuration/mgmt-groups.properties'\n"
" Is this new user going to be used for one AS process to connect to another AS process?\n"
" e.g. for a slave host controller connecting to the master or for a Remoting connection for server to server EJB calls.\n"
" yes/no? yes\n"
" To represent the user add the following to the server-identities definition <secret value=\"bWdtdDEyMyE=\" />"

msgid ""
"The add-user.sh script does not add the user to the {project_name} server "
"but to the underlying JBoss Enterprise Application Platform. The credentials"
" used and generated in this script are only for demonstration purposes. "
"Please use the ones generated on your system."
msgstr ""
"add-user.sh スクリプトは、ユーザーを {project_name} サーバーに追加するのではなく、基盤となるJBoss Enterprise"
" Application "
"Platformに追加します。このスクリプトで使用および生成されるクレデンシャルは、デモ目的でのみ使用されます。お使いのシステムで生成されたものを使用してください。"

msgid ""
"Cut and paste the secret value into the _.../domain/configuration/host-"
"slave.xml_ file as follows:"
msgstr ""
"_.../domain/configuration/host-slave.xml_ "
"ファイルにシークレットの値をカット・アンド・ペーストすると、以下のようになります。"

msgid ""
"     <management>\n"
"         <security-realms>\n"
"             <security-realm name=\"ManagementRealm\">\n"
"                 <server-identities>\n"
"                     <secret value=\"bWdtdDEyMyE=\"/>\n"
"                 </server-identities>"
msgstr ""
"     <management>\n"
"         <security-realms>\n"
"             <security-realm name=\"ManagementRealm\">\n"
"                 <server-identities>\n"
"                     <secret value=\"bWdtdDEyMyE=\"/>\n"
"                 </server-identities>"

msgid ""
"Add the _username_ of the created user in the "
"_.../domain/configuration/host-slave.xml_ file:"
msgstr ""
"作成したユーザーの _username_ も _.../domain/configuration/host-slave.xml_ ファイルに追加します。"

msgid "     <remote security-realm=\"ManagementRealm\" username=\"admin\">"
msgstr "     <remote security-realm=\"ManagementRealm\" username=\"admin\">"

msgid ""
"Run the boot script twice to simulate a two node cluster on one development "
"machine."
msgstr "ブートスクリプトを2回実行して、1台の開発マシンで2つのノードクラスターをシミュレートします。"

msgid "Boot up master"
msgstr "マスターの起動"

msgid "$ domain.sh --host-config=host-master.xml"
msgstr "$ domain.sh --host-config=host-master.xml"

msgid "Boot up slave"
msgstr "スレーブの起動"

msgid "$ domain.sh --host-config=host-slave.xml"
msgstr "$ domain.sh --host-config=host-slave.xml"

msgid "Open your browser and go to http://localhost:8080/auth to try it out."
msgstr "ブラウザーを開いてhttp://localhost:8080/authにアクセスし、試してみてください。"

msgid "Using cross-site replication mode"
msgstr "クロスサイト・レプリケーション・モードの使用"

msgid ""
"{tech_feature_name} is *Technology Preview* and is not fully supported."
msgstr "{tech_feature_name}は、 *テクノロジー・プレビュー* であり、完全にはサポートされていません。"

msgid ""
"Use cross-site replication mode to run {project_name} in a cluster across "
"multiple data centers. Typically you use data center sites that are in "
"different geographic regions. When using this mode, each data center will "
"have its own cluster of {project_name} servers."
msgstr ""
"クロスサイト・レプリケーション・モードを使用して、複数のデータセンターにまたがるクラスターで{project_name}を実行します。一般的には、異なる地域にあるデータセンターのサイトを使用します。このモードを使用すると、各データセンターは{project_name}サーバーの独自のクラスターを持つことになります。"

msgid ""
"This documentation will refer to the following example architecture diagram "
"to illustrate and describe a simple cross-site replication use case."
msgstr "このドキュメントでは、以下のアーキテクチャー図の例を参照して、シンプルなクロスサイト・レプリケーションのユースケースを説明します。"

msgid "Example Architecture Diagram"
msgstr "アーキテクチャー図の例"

msgid "image:{project_images}/cross-dc-architecture.png[]"
msgstr "image:{project_images}/cross-dc-architecture.png[]"

msgid "Prerequisites"
msgstr "前提条件"

msgid ""
"As this is an advanced topic, we recommend you first read the following, "
"which provide valuable background knowledge:"
msgstr "これは高度なトピックのため、最初に以下を読み、背景にある重要な知識を身につけておくことをお勧めします。"

msgid ""
"link:{installguide_clustering_link}[Clustering with {project_name}] When "
"setting up for cross-site replication, you will use more independent "
"{project_name} clusters, so you must understand how a cluster works and the "
"basic concepts and requirements such as load balancing, shared databases, "
"and multicasting."
msgstr ""
"link:{installguide_clustering_link}[{project_name}によるクラスタリング] "
"クロスデータセンター・レプリケーションを設定する場合、より独立した{project_name}クラスターを使用するため、クラスターの仕組みや、ロード・バランシング、共有データベース、マルチキャストなどの基本的な概念と要件を理解する必要があります。"

msgid ""
"link:https://infinispan.org/docs/11.0.x/titles/xsite/xsite.html#xsite_replication[Infinispan"
" Cross-Site Replication] replicates data across clusters in separate "
"geographic locations."
msgstr ""
"link:https://infinispan.org/docs/11.0.x/titles/xsite/xsite.html#xsite_replication[Infinispan"
" Cross-Site Replication] は、地理的に離れた場所にあるクラスター間でデータをレプリケーションします。 "

msgid "Technical details"
msgstr "技術的な詳細"

msgid ""
"This section provides an introduction to the concepts and details of how "
"{project_name} cross-site replication is accomplished."
msgstr "このセクションでは、{project_name}クロスサイト・レプリケーションの仕組みについて概念と詳細について説明します。"

msgid "Data"
msgstr "Data"

msgid ""
"{project_name} is stateful application. It uses the following as data "
"sources:"
msgstr "{project_name}はステートフルなアプリケーションです。データソースとして以下のものを使用します。"

msgid ""
"A database is used to persist permanent data, such as user information."
msgstr "データベースは、ユーザー情報などの永続的なデータを保持するために使用されます。"

msgid ""
"An Infinispan cache is used to cache persistent data from the database and "
"also to save some short-lived and frequently-changing metadata, such as for "
"user sessions. Infinispan is usually much faster than a database, however "
"the data saved using Infinispan are not permanent and is not expected to "
"persist across cluster restarts."
msgstr ""
"Infinispanキャッシュは、永続化データをデータベースからキャッシュし、短期間で頻繁に変化するメタデータ（ユーザー・セッションなど）を節約するためにも使用されます。Infinispanは通常、データベースよりもはるかに高速ですが、Infinispanを使用して保存されたデータは永続的ではなく、クラスターを再起動後も維持できるとは限りません。"

msgid ""
"In our example architecture, there are two data centers called `site1` and "
"`site2`. For cross-site replication, we must make sure that both sources of "
"data work reliably and that {project_name} servers from `site1` are "
"eventually able to read the data saved by {project_name} servers on `site2` "
"."
msgstr ""
"このアーキテクチャーの例では、 `site1` と `site2` "
"と呼ばれる2つのデータセンターがあります。クロスサイト・レプリケーションでは、両方のデータソースが確実に動作し、 `site2` "
"の{project_name}サーバーによって保存されたデータを `site1` "
"の{project_name}サーバーが最終的に読み取ることができるようにする必要があります。"

msgid "Based on the environment, you have the option to decide if you prefer:"
msgstr "環境に基づいて、次の選択肢から決める必要があります。"

msgid ""
"Reliability - which is typically used in Active/Active mode. Data written on"
" `site1` must be visible immediately on `site2`."
msgstr ""
"信頼性 - 通常はアクティブ/アクティブモードで使用されます。 `site1` で記述されたデータは `site2` ですぐに表示される必要があります。"

msgid ""
"Performance - which is typically used in Active/Passive mode. Data written "
"on `site1` does not need to be visible immediately on `site2`. In some "
"cases, the data may not be visible on `site2` at all."
msgstr ""
"パフォーマンス - 通常はアクティブ/パッシブモードで使用されます。 `site1` で記述されたデータはすぐに `site2` "
"で表示される必要はありません。状況によって、 `site2` でデータが表示されないこともあります。"

msgid "For more details, see <<Modes>>."
msgstr "詳細は、<<modes>>を参照してください。"

msgid "Request processing"
msgstr "リクエスト処理"

msgid ""
"An end user's browser sends an HTTP request to the "
"link:{installguide_loadbalancer_link}[front end load balancer]. This load "
"balancer is usually HTTPD or WildFly with mod_cluster, NGINX, HA Proxy, or "
"perhaps some other kind of software or hardware load balancer."
msgstr ""
"エンドユーザーのブラウザーは、HTTPリクエストをlink:{installguide_loadbalancer_link}[フロント・エンド・ロードバランサー]に送信します。このロードバランサーは、通常mod_cluster、NGINX、HA"
" Proxy、またはその他のソフトウェアかハードウェア・ロードバランサーを使用するHTTPDまたはWildFlyです。"

msgid ""
"The load balancer then forwards the HTTP requests it receives to the "
"underlying {project_name} instances, which can be spread among multiple data"
" centers. Load balancers typically offer support for "
"link:{installguide_stickysessions_link}[sticky sessions], which means that "
"the load balancer is able to always forward all HTTP requests from the same "
"user to the same {project_name} instance in same data center."
msgstr ""
"ロードバランサーは、基になる{project_name}インスタンスに、受け取ったHTTPリクエストを転送します。このインスタンスは、複数のデータセンターに分散させることができます。ロードバランサーは通常、link:{installguide_stickysessions_link}[スティッキー・セッション]をサポートしています。つまり、ロードバランサーは、同じデータセンターの同じ{project_name}インスタンスに、同じユーザーのすべてのHTTPリクエストを常に転送することができます。"

msgid ""
"HTTP requests that are sent from client applications to the load balancer "
"are called `backchannel requests`. These are not seen by an end user's "
"browser and therefore can not be part of a sticky session between the user "
"and the load balancer. For backchannel requests, the loadbalancer can "
"forward the HTTP request to any {project_name} instance in any data center. "
"This is challenging as some OpenID Connect and some SAML flows require "
"multiple HTTP requests from both the user and the application. Because we "
"can not reliably depend on sticky sessions to force all the related requests"
" to be sent to the same {project_name} instance in the same data center, we "
"must instead replicate some data across data centers, so the data are seen "
"by subsequent HTTP requests during a particular flow."
msgstr ""
"クライアント・アプリケーションからロードバランサーに送られたHTTPリクエストは `バックチャネル・リクエスト` "
"と呼ばれます。これらはエンドユーザーのブラウザーからは見えないので、ユーザーとロードバランサー間でスティッキー・セッションの一部になることはできません。バックチャネル・リクエストの場合、ロードバランサーは、HTTPリクエストを任意のデータセンター内のいずれかの{project_name}インスタンスに転送することができます。これは、いくつかのOpenID"
" "
"ConnectといくつかのSAMLフローがユーザーとアプリケーションの両方から複数のHTTPリクエストを必要とするため、難しい問題です。関連するすべてのリクエストを同じデータセンター内の同じ{project_name}インスタンスに送信するのにスティッキー・セッションに完全に依存することはできないため、代わりに、データセンター間で一部のデータをレプリケートする必要があります。それにより、データは特定のフロー中の後続のHTTPリクエストによって表示されます。"

msgid "Modes"
msgstr "モード"

msgid ""
"According your requirements, there are two basic operating modes for cross-"
"site replication:"
msgstr "要件に応じて、クロスサイト・レプリケーションには2つの基本的な動作モードがあります。"

msgid ""
"Active/Passive - Here the users and client applications send the requests "
"just to the {project_name} nodes in just a single data center. The second "
"data center is used just as a `backup` for saving the data. In case of the "
"failure in the main data center, the data can be usually restored from the "
"second data center."
msgstr ""
"アクティブ/パッシブ - "
"ユーザーとクライアント・アプリケーションは、単一のデータセンター内の{project_name}ノードにのみリクエストを送信します。第2のデータセンターは、データを保存するための"
" `バックアップ` としてのみ使用されます。メインのデータセンターに障害が発生した場合、通常は第2のデータセンターからデータを復旧します。"

msgid ""
"Active/Active - Here the users and client applications send the requests to "
"the {project_name} nodes in both data centers. It means that data need to be"
" visible immediately on both sites and available to be consumed immediately "
"from {project_name} servers on both sites. This is especially true if "
"{project_name} server writes some data on `site1`, and it is required that "
"the data are available immediately for reading by {project_name} servers on "
"`site2` immediately after the write on `site1` is finished."
msgstr ""
"アクティブ/アクティブ - "
"ユーザーとクライアント・アプリケーションは、両方のデータセンターの{project_name}ノードにリクエストを送信します。つまり、両方のサイトですぐにデータを表示し、"
" 両方のサイトの{project_name}サーバーからデータをすぐに使用できるようにする必要があります。これは、{project_name}サーバーが"
" `site1` に何かしらのデータを書き込む場合に特に当てはまります。また、 `site1` への書き込みが完了した直後に、 `site2` "
"の{project_name}サーバーがデータをすぐに読み取ることができるようにする必要があります。"

msgid ""
"The active/passive mode is better for performance. For more information "
"about how to configure caches for either mode, see: <<backups>>."
msgstr ""
"アクティブ/パッシブモードは、パフォーマンスに優れています。いずれかのモードでキャッシュを設定する方法の詳細については、 <<backups>> "
"を参照してください。"

msgid "Database"
msgstr "データベース"

msgid ""
"{project_name} uses a relational database management system (RDBMS) to "
"persist some metadata about realms, clients, users, and so on. See "
"link:{installguide_database_link}[this chapter] of the server installation "
"guide for more details. In a cross-site replication setup, we assume that "
"either both data centers talk to the same database or that every data center"
" has its own database node and both database nodes are synchronously "
"replicated across the data centers. In both cases, it is required that when "
"a {project_name} server on `site1` persists some data and commits the "
"transaction, those data are immediately visible by subsequent DB "
"transactions on `site2`."
msgstr ""
"{project_name}は、リレーショナル・データベース・マネジメント・システム（RDBMS）を使用して、レルム、クライアント、ユーザーなどのメタデータを保持します。詳細については、サーバーインストールガイドのlink:{installguide_database_link}[この章]を参照してください。クロスサイト・レプリケーションのセットアップでは、両方のデータセンターが同じデータベースと通信するか、すべてのデータセンターに独自のデータベース・ノードがあり、両方のデータベース・ノードがデータセンター間で同期レプリケートされると想定しています。どちらの場合でも、"
" `site1` の{project_name}サーバーがデータを保持してトランザクションをコミットすると、 `site2` "
"の後続のDBトランザクションによって、それらのデータがすぐに表示される必要があります。"

msgid ""
"Details of DB setup are out-of-scope for {project_name}, however many RDBMS "
"vendors like MariaDB and Oracle offer replicated databases and synchronous "
"replication. We test {project_name} with these vendors:"
msgstr ""
"DBのセットアップの詳細については、{project_name}の範囲外ですが、MariaDBやOracleなどのRDBMSベンダーの多くは、レプリケートされたデータベースと同期レプリケーションを提供しています。これらのベンダーを使用して、{project_name}をテストしています。"

msgid "Oracle Database 19c RAC"
msgstr "Oracle Database 19c RAC"

msgid "Galera 3.12 cluster for MariaDB server version 10.1.19-MariaDB"
msgstr "Galera 3.12 cluster for MariaDB server version 10.1.19-MariaDB"

msgid "Infinispan caches"
msgstr "Infinispanキャッシュ"

msgid ""
"This section begins with a high level description of the Infinispan caches. "
"More details of the cache setup follow."
msgstr "このセクションでは、Infinispanキャッシュの概要を説明していきます。キャッシュの設定の詳細は以下のとおりです。"

msgid "Authentication sessions"
msgstr "認証セッション"

msgid ""
"In {project_name} we have the concept of authentication sessions. There is a"
" separate Infinispan cache called `authenticationSessions` used to save data"
" during authentication of particular user. Requests from this cache usually "
"involve only a browser and the {project_name} server, not the application. "
"Here we can rely on sticky sessions and the `authenticationSessions` cache "
"content does not need to be replicated across data centers, even if you are "
"in Active/Active mode."
msgstr ""
"{project_name}には、認証セッションの概念があります。 `authenticationSessions` "
"と呼ばれる別のInfinispanキャッシュがあり、特定のユーザーの認証時にデータを保存するのに使用されます。このキャッシュからのリクエストには通常、ブラウザーと{project_name}サーバーのみが関与し、アプリケーションは関与しません。ここでは、アクティブ/アクティブモードであっても、スティッキー・セッションに依存することができ、"
" `authenticationSessions` キャッシュ・コンテンツをデータセンター間でレプリケートする必要はありません。"

msgid "Action tokens"
msgstr "アクション・トークン"

msgid ""
"We also have the concept of link:{developerguide_actiontoken_link}[action "
"tokens], which are used typically for scenarios when the user needs to "
"confirm an action asynchronously by email. For example, during the `forget "
"password` flow the `actionTokens` Infinispan cache is used to track metadata"
" about related action tokens, such as which action token was already used, "
"so it can't be reused second time. This usually needs to be replicated "
"across data centers."
msgstr ""
"link:{developerguide_actiontoken_link}[アクション・トークン]の概念もあります。アクション・トークンは、通常、ユーザーが電子メールでアクションを非同期で確認する必要があるシナリオで使用されます。たとえば、"
" `forget password` フローの間に、 `actionTokens` "
"Infinispanキャッシュは、どのアクション・トークンがすでに使用されているかなどの関連するアクション・トークンに関するメタデータを追跡するために使用されるため、2度目は再利用できません。これは通常、データセンター間でレプリケートする必要があります。"

msgid "Caching and invalidation of persistent data"
msgstr "永続データのキャッシングと無効化"

msgid ""
"{project_name} uses Infinispan to cache persistent data to avoid many "
"unnecessary requests to the database. Caching improves performance, however "
"it adds an additional challenge. When some {project_name} server updates any"
" data, all other {project_name} servers in all data centers need to be aware"
" of it, so they invalidate particular data from their caches. {project_name}"
" uses local Infinispan caches called `realms`, `users`, and `authorization` "
"to cache persistent data."
msgstr ""
"{project_name}はInfinispanを使用して永続化データをキャッシュし、データベースへの不要なリクエストを多く回避します。キャッシュによりパフォーマンスは改善されますが、さらなる問題が加わります。一部の{project_name}サーバーがデータを更新した場合、すべてのデータセンターの他のすべての{project_name}サーバーはそのことに気づく必要があるため、それらのキャッシュから特定のデータを無効にします。{project_name}は、"
" `realms` 、 `users` 、および `authorization` "
"と呼ばれるローカルInfinispanキャッシュを使用して、永続化データをキャッシュします。"

msgid ""
"We use a separate cache, `work`, which is replicated across all data "
"centers. The work cache itself does not cache any real data. It is used only"
" for sending invalidation messages between cluster nodes and data centers. "
"In other words, when data is updated, such as the user `john`, the "
"{project_name} node sends the invalidation message to all other cluster "
"nodes in the same data center and also to all other data centers. After "
"receiving the invalidation notice, every node then invalidates the "
"appropriate data from their local cache."
msgstr ""
"すべてのデータセンターでレプリケートされる、別のキャッシュ `work` "
"を使用します。workキャッシュ自体は実際のデータをキャッシュしません。クラスターノードとデータセンター間で無効化メッセージを送信する場合にのみ使用されます。つまり、データ（ユーザー"
" `john` "
"のようなデータ）が更新されると、{project_name}ノードは、同じデータセンター内の他のすべてのクラスターノード、および他のすべてのデータセンターに無効化メッセージを送信します。すべてのノードは、無効通知を受信した後、ローカル・キャッシュから適切なデータを無効にします。"

msgid "User sessions"
msgstr "ユーザー・セッション"

msgid ""
"There are Infinispan caches called `sessions`, `clientSessions`, "
"`offlineSessions`, and `offlineClientSessions`, all of which usually need to"
" be replicated across data centers. These caches are used to save data about"
" user sessions, which are valid for the length of a user's browser session. "
"The caches must handle the HTTP requests from the end user and from the "
"application. As described above, sticky sessions can not be reliably used in"
" this instance, but we still want to ensure that subsequent HTTP requests "
"can see the latest data. For this reason, the data are usually replicated "
"across data centers."
msgstr ""
"`sessions` 、 `clientSessions` 、 `offlineSessions` 、および "
"`offlineClientSessions` "
"と呼ばれるInfinispanキャッシュがあり、それらのすべては通常、データセンター間でレプリケートされる必要があります。これらのキャッシュは、ユーザー・セッションに関するデータを保存するために使用され、ユーザーのブラウザー・セッションの長さに対して有効です。キャッシュは、エンドユーザーとアプリケーションからのHTTPリクエストを処理する必要があります。前述のとおり、このインスタンスではスティッキー・セッションを信頼性をもって使用することはできませんが、後続のHTTPリクエストが最新のデータを確認できるようにする必要があります。このため、データは通常、データセンター間でレプリケートされます。"

msgid "Brute force protection"
msgstr "ブルートフォース保護"

msgid ""
"Finally the `loginFailures` cache is used to track data about failed logins,"
" such as how many times the user `john` entered a bad password. The details "
"are described link:{adminguide_bruteforce_link}[here]. It is up to the admin"
" whether this cache should be replicated across data centers. To have an "
"accurate count of login failures, the replication is needed. On the other "
"hand, not replicating this data can save some performance. So if performance"
" is more important than accurate counts of login failures, the replication "
"can be avoided."
msgstr ""
"最後に、 `loginFailures` キャッシュは、ユーザー `john` "
"が不正なパスワードを入力した回数など、ログイン失敗に関するデータを追跡するために使用されます。詳細は、link:{adminguide_bruteforce_link}[こちら]を参照してください。このキャッシュをデータセンター間でレプリケートするかどうかは、管理者次第です。正確なログイン失敗の回数を取得するには、レプリケーションが必要です。一方、このデータをレプリケートしないことで、パフォーマンスをよくできます。したがって、パフォーマンスがログイン失敗の正確な回数よりも重要な場合は、レプリケーションを避けるという手もあります。"

msgid ""
"For more detail about how caches can be configured see <<tuningcache>>."
msgstr "キャッシュの設定方法の詳細については、<<tuningcache>>を参照してください。 "

msgid "Communication details"
msgstr "コミュニケーションの詳細"

msgid ""
"{project_name} uses multiple, separate clusters of Infinispan caches. Every "
"{project_name} node is in the cluster with the other {project_name} nodes in"
" same data center, but not with the {project_name} nodes in different data "
"centers. A {project_name} node does not communicate directly with the "
"{project_name} nodes from different data centers. {project_name} nodes use "
"external JDG (actually {jdgserver_name} servers) for communication across "
"data centers. This is done using the "
"link:https://infinispan.org/docs/10.1.x/titles/server/server.html#hot_rod[Infinispan"
" HotRod protocol]."
msgstr ""
"{project_name}は、Infinispanキャッシュの分割されたクラスターを複数使用します。各{project_name}ノードは、同じデータセンター内の他の{project_name}ノードと共にクラスター内にありますが、異なるデータセンターの{project_name}ノードはそのクラスター内にありません。{project_name}ノードは、異なるデータセンターの{project_name}ノードと直接通信できません。{project_name}ノードは、データセンター間の通信に外部JDG（実際には{jdgserver_name}サーバー）を使用します。これは、"
" "
"link:https://infinispan.org/docs/10.1.x/titles/server/server.html#hot_rod[Infinispan"
" HotRodプロトコル] を使用して行われます。"

msgid ""
"The Infinispan caches on the {project_name} side must be configured with the"
" "
"link:https://infinispan.org/docs/10.1.x/titles/configuring/configuring.html#remote_cache_store[remoteStore]"
" to ensure that data are saved to the remote cache. There is separate "
"Infinispan cluster between JDG servers, so the data saved on JDG1 on `site1`"
" are replicated to JDG2 on `site2` ."
msgstr ""
"{project_name}側のInfinispanキャッシュは、データがリモート・キャッシュに保存されていることを確認するために、 "
"link:https://infinispan.org/docs/10.1.x/titles/configuring/configuring.html#remote_cache_store[remoteStore]"
" を使用して設定する必要があります。JDGサーバー間に分割されたInfinispanクラスターがあるので、 `site1` "
"のJDG1に保存されていたデータは `site2` のJDG2にレプリケートされます。"

msgid ""
"The receiving {jdgserver_name} server notifies the {project_name} servers in"
" its cluster through Client Listeners, which are a feature of the Hot Rod "
"protocol. {project_name} nodes on `site2` then update their Infinispan "
"caches and the particular user session is also visible on {project_name} "
"nodes on `site2`."
msgstr ""
"受信{jdgserver_name}サーバーは、Hot "
"Rodプロトコルの機能であるクライアント・リスナーを介して、クラスター内の{project_name}サーバーに通知します。次に、 `site2` "
"の{project_name}ノードがInfinispanキャッシュを更新し、特定のユーザー・セッションが `site2` "
"の{project_name}ノードにも表示されます。 "

msgid "See the <<archdiagram>> for more details."
msgstr "詳細は、<<archdiagram>>を参照してください。"

msgid "Setting up cross-site replication"
msgstr ""

msgid ""
"Use the following procedures for {jdgserver_name} {jdgserver_version_latest}"
" to perform a basic setup of cross-site replication."
msgstr ""
"以下の手順で、{jdgserver_name} "
"{jdgserver_version_latest}のクロスサイト・レプリケーションの基本的な設定を行います。"

msgid ""
"The exact instructions for your version of {jdgserver_name} may be slightly "
"different from these instructions, which apply to {jdgserver_name} 8.1. "
"Check the {jdgserver_name} documentation for any steps that do not work as "
"described."
msgstr ""

msgid ""
"This example for {jdgserver_name} {jdgserver_version_latest} involves two "
"data centers, `site1` and `site2`. Each data center consists of 1 "
"{jdgserver_name} server and 2 {project_name} servers. We will end up with 2 "
"{jdgserver_name} servers and 4 {project_name} servers in total."
msgstr ""
"{jdgserver_name} {jdgserver_version_latest}のこの例には、 `site1` と `site2` "
"の2つのデータセンターが含まれます。各データセンターは、1つの{jdgserver_name}サーバーと2つの{project_name}サーバーで構成されています。合計すると、2つの{jdgserver_name}サーバーと4つの{project_name}サーバーになります。"

msgid ""
"`Site1` consists of {jdgserver_name} server, `server1`, and 2 {project_name}"
" servers, `node11` and `node12` ."
msgstr ""
"`Site1` は、{jdgserver_name}サーバーの `server1` と2つの{project_name}サーバーの `node11` "
"および `node12` で構成されています。"

msgid ""
"`Site2` consists of {jdgserver_name} server, `server2`, and 2 {project_name}"
" servers, `node21` and `node22` ."
msgstr ""
"`Site2` は、{jdgserver_name}サーバーの `server2` と2つの{project_name}サーバーの `node21` "
"および `node22` で構成されています。"

msgid ""
"{jdgserver_name} servers `server1` and `server2` are connected to each other"
" through the RELAY2 protocol and `backup` based {jdgserver_name} caches in a"
" similar way as described in the "
"link:{jdgserver_crossdcdocs_link}[{jdgserver_name} documentation]."
msgstr ""
"{jdgserver_name}サーバーである `server1` と `server2` は、 "
"link:{jdgserver_crossdcdocs_link}[ {jdgserver_name} のドキュメント] "
"で記載されているのと同様の方法で、RELAY2プロトコルと `backup` "
"ベースの{jdgserver_name}キャッシュを介して相互に接続されています。"

msgid ""
"{project_name} servers `node11` and `node12` form a cluster with each other,"
" but they do not communicate directly with any server in `site2`. They "
"communicate with the Infinispan server `server1` using the Hot Rod protocol "
"(Remote cache). See <<communication>> for more information."
msgstr ""
"{project_name}サーバーである `node11` と `node12` は、お互いにクラスターを形成しますが、 `site2` "
"内のサーバーとは直接通信はしません。それらはHot Rodプロトコル （リモート・キャッシュ）を使用して、Infinispanサーバー "
"`server1` と通信します。詳細については、<<communication>>を参照してください。"

msgid ""
"The same details apply for `node21` and `node22`. They cluster with each "
"other and communicate only with `server2` server using the Hot Rod protocol."
msgstr ""
"同じ説明が `node21` と `node22` にも当てはまります。それらはお互いにクラスター化し、Hot Rodプロトコルを使用して、 "
"`server2` サーバーとのみ通信します。"

msgid ""
"Our example setup assumes that the four {project_name} servers talk to the "
"same database. In production, we recommend that you use separate "
"synchronously replicated databases across data centers as described in "
"<<database>>."
msgstr ""
"この設定の例では、4つの{project_name}サーバーすべてが同じデータベースと通信することを前提としています。プロダクション環境では、<<database>>で説明されているとおり、データセンター間で別々の同期レプリケートされたデータベースを使用することをお勧めします。"

msgid "Setting Up {jdgserver_name} Servers"
msgstr "{jdgserver_name}サーバーのセットアップ"

msgid ""
"For cross-site replication, you start by creating remote {jdgserver_name} "
"clusters that can back up {project_name} data."
msgstr ""
"クロスサイト・レプリケーションの場合、{project_name}のデータをバックアップできるリモート{jdgserver_name}クラスターを作成することから始めます。"

msgid ""
"Download and install {jdgserver_name} Server {jdgserver_version_latest}."
msgstr "{jdgserver_name}サーバー{jdgserver_version_latest}をダウンロードしてインストールします。"

msgid "{jdgserver_name} Server {jdgserver_version_latest} requires Java 11."
msgstr "{jdgserver_name}サーバー{jdgserver_version_latest}にはJava 11が必要です。"

msgid ""
"Create a user to authenticate client connections from {jdgserver_name}, for "
"example:"
msgstr "{jdgserver_name}からのクライアント接続を認証するユーザーを作成します。次に例を示します。"

msgid "$ bin/cli.sh user create myuser -p \"qwer1234!\""
msgstr "$ bin/cli.sh user create myuser -p \"qwer1234!\""

msgid ""
"You specify these credentials in the Hot Rod client configuration when you "
"create remote caches on {project_name}."
msgstr "{project_name}にリモートキャッシュを作成するときに、HotRodクライアントの設定でこれらのクレデンシャルを指定します。"

msgid ""
"Create an SSL keystore and truststore to secure connections between "
"{jdgserver_name} and {project_name}, for example:"
msgstr ""
"{jdgserver_name}と{project_name}の間の接続を保護するために、SSLキーストアとトラストストアを作成します。次に例を示します。"

msgid ""
"Create a keystore to provide an SSL identity to your {jdgserver_name} "
"cluster"
msgstr "キーストアを作成して、{jdgserver_name}クラスターにSSLのIDを提供します"

msgid ""
"keytool -genkey -alias server -keyalg RSA -keystore server.jks -keysize 2048"
msgstr ""
"keytool -genkey -alias server -keyalg RSA -keystore server.jks -keysize 2048"

msgid "Export an SSL certificate from the keystore."
msgstr "キーストアからSSL証明書をエクスポートします。"

msgid ""
"keytool -exportcert -keystore server.jks -alias server -file server.crt"
msgstr ""
"keytool -exportcert -keystore server.jks -alias server -file server.crt"

msgid ""
"Import the SSL certificate into a truststore that {project_name} can use to "
"verify the SSL identity for {jdgserver_name}."
msgstr ""
"{project_name}が{jdgserver_name}のSSLのIDを確認するために使用できるトラストストアに、SSL証明書をインポートします。"

msgid ""
"keytool -importcert -keystore truststore.jks -alias server -file server.crt"
msgstr ""
"keytool -importcert -keystore truststore.jks -alias server -file server.crt"

msgid "Remove `server.crt`."
msgstr "`server.crt` を削除します。"

msgid "rm server.crt"
msgstr "rm server.crt"

msgid "Configuring {jdgserver_name} Clusters"
msgstr "{jdgserver_name}クラスターの設定"

msgid ""
"Configure {jdgserver_name} clusters to replicate {project_name} data across "
"data centers."
msgstr "データセンター間で{project_name}データを複製するように{jdgserver_name}クラスターを設定します。"

msgid "Install and set up {jdgserver_name} Server."
msgstr "{jdgserver_name}サーバーをインストールしてセットアップします。"

msgid "Open `infinispan.xml` for editing."
msgstr "編集のために `infinispan.xml` を開きます。"

msgid ""
"By default, {jdgserver_name} Server uses `server/conf/infinispan.xml` for "
"static configuration such as cluster transport and security mechanisms."
msgstr ""
"デフォルトでは、{jdgserver_name}サーバーはクラスター・トランスポートやセキュリティー機構などの静的設定に  "
"`server/conf/infinispan.xml` を使用します。"

msgid "Create a stack that uses TCPPING as the cluster discovery protocol."
msgstr "クラスター検出プロトコルとしてTCPPINGを使用するスタックを作成します。"

msgid ""
"<stack name=\"global-cluster\" extends=\"tcp\">\n"
"    <!-- Remove MPING protocol from the stack and add TCPPING -->\n"
"    <TCPPING initial_hosts=\"server1[7800],server2[7800]\" <1>\n"
"             stack.combine=\"REPLACE\" stack.position=\"MPING\"/>\n"
"</stack>"
msgstr ""
"<stack name=\"global-cluster\" extends=\"tcp\">\n"
"    <!-- Remove MPING protocol from the stack and add TCPPING -->\n"
"    <TCPPING initial_hosts=\"server1[7800],server2[7800]\" <1>\n"
"             stack.combine=\"REPLACE\" stack.position=\"MPING\"/>\n"
"</stack>"

msgid "Lists the host names for `server1` and `server2`."
msgstr "`server1` と `server2` のホスト名を一覧表示します。"

msgid ""
"Configure the {jdgserver_name} cluster transport to perform cross-site "
"replication."
msgstr "{jdgserver_name}のクラスター・トランスポートを設定して、クロスサイト・レプリケーションを実行します。"

msgid "Add the RELAY2 protocol to a JGroups stack."
msgstr "RELAY2プロトコルをJGroupsスタックに追加します。"

msgid ""
"<jgroups>\n"
"   <stack name=\"xsite\" extends=\"udp\"> <1>\n"
"      <relay.RELAY2 site=\"site1\" <2>\n"
"                    max_site_masters=\"1000\"/> <3>\n"
"      <remote-sites default-stack=\"global-cluster\"> <4>\n"
"         <remote-site name=\"site1\"/>\n"
"         <remote-site name=\"site2\"/>\n"
"      </remote-sites>\n"
"   </stack>\n"
"</jgroups>"
msgstr ""
"<jgroups>\n"
"   <stack name=\"xsite\" extends=\"udp\"> <1>\n"
"      <relay.RELAY2 site=\"site1\" <2>\n"
"                    max_site_masters=\"1000\"/> <3>\n"
"      <remote-sites default-stack=\"global-cluster\"> <4>\n"
"         <remote-site name=\"site1\"/>\n"
"         <remote-site name=\"site2\"/>\n"
"      </remote-sites>\n"
"   </stack>\n"
"</jgroups>"

msgid ""
"Creates a stack named `xsite` that extends the default UDP cluster "
"transport."
msgstr "デフォルトのUDPクラスター・トランスポートを拡張する `xsite` という名前のスタックを作成します。"

msgid ""
"Adds the RELAY2 protocol and names the cluster you are configuring as "
"`site1`. The site name must be unique to each {jdgserver_name} cluster."
msgstr ""
"RELAY2プロトコルを追加し、設定しているクラスターに `site1` "
"という名前を付けます。サイト名は、各{jdgserver_name}クラスターに固有である必要があります。"

msgid ""
"Sets 1000 as the number of relay nodes for the cluster. You should set a "
"value that is equal to or greater than the maximum number of nodes in your "
"{jdgserver_name} cluster."
msgstr ""
"クラスターのリレーノードの数として1000を設定します。{jdgserver_name}クラスター内のノードの最大数以上の値を設定する必要があります。"

msgid ""
"Names all {jdgserver_name} clusters that backup caches with {jdgserver_name}"
" data and uses the default TCP stack for inter-cluster transport."
msgstr ""
"{jdgserver_name}データでキャッシュをバックアップするすべての{jdgserver_name}クラスターに名前を付け、クラスター間転送にデフォルトのTCPスタックを使用します。"

msgid "Configure the {jdgserver_name} cluster transport to use the stack."
msgstr "スタックを使用するように{jdgserver_name}クラスター・トランスポートを設定します。"

msgid ""
"<cache-container name=\"default\" statistics=\"true\">\n"
"      <transport cluster=\"${infinispan.cluster.name:cluster}\"\n"
"                 stack=\"xsite\"/> <1>\n"
"</cache-container>"
msgstr ""
"<cache-container name=\"default\" statistics=\"true\">\n"
"      <transport cluster=\"${infinispan.cluster.name:cluster}\"\n"
"                 stack=\"xsite\"/> <1>\n"
"</cache-container>"

msgid "Uses the `xsite` stack for the cluster."
msgstr "クラスターに `xsite` スタックを使用します。"

msgid ""
"Configure the keystore as an SSL identity in the server security realm."
msgstr "サーバー・セキュリティー・レルムでキーストアをSSLのIDとして設定します。"

msgid ""
"<server-identities>\n"
"  <ssl>\n"
"    <keystore path=\"server.jks\" <1>\n"
"              relative-to=\"infinispan.server.config.path\"\n"
"              keystore-password=\"password\" <2>\n"
"              alias=\"server\" /> <3>\n"
"  </ssl>\n"
"</server-identities>"
msgstr ""
"<server-identities>\n"
"  <ssl>\n"
"    <keystore path=\"server.jks\" <1>\n"
"              relative-to=\"infinispan.server.config.path\"\n"
"              keystore-password=\"password\" <2>\n"
"              alias=\"server\" /> <3>\n"
"  </ssl>\n"
"</server-identities>"

msgid "Specifies the path of the keystore that contains the SSL identity."
msgstr "SSLのIDを含むキーストアのパスを指定します。"

msgid "Specifies the password to access the keystore."
msgstr "キーストアにアクセスするためのパスワードを指定します。"

msgid "Names the alias of the certificate in the keystore."
msgstr "キーストア内の証明書のエイリアスに名前を付けます。"

msgid "Configure the authentication mechanism for the Hot Rod endpoint."
msgstr "HotRodエンドポイントの認証機構を設定します。"

msgid ""
"<endpoints socket-binding=\"default\">\n"
"   <hotrod-connector name=\"hotrod\">\n"
"      <authentication>\n"
"         <sasl mechanisms=\"SCRAM-SHA-512\" <1>\n"
"               server-name=\"infinispan\" /> <2>\n"
"      </authentication>\n"
"   </hotrod-connector>\n"
"   <rest-connector name=\"rest\"/>\n"
"</endpoints>"
msgstr ""
"<endpoints socket-binding=\"default\">\n"
"   <hotrod-connector name=\"hotrod\">\n"
"      <authentication>\n"
"         <sasl mechanisms=\"SCRAM-SHA-512\" <1>\n"
"               server-name=\"infinispan\" /> <2>\n"
"      </authentication>\n"
"   </hotrod-connector>\n"
"   <rest-connector name=\"rest\"/>\n"
"</endpoints>"

msgid ""
"Configures the SASL authentication mechanism for the Hot Rod endpoint.  "
"SCRAM-SHA-512 is the default SASL mechanism for Hot Rod. However you can use"
" whatever is appropriate for your environment, such as GSSAPI."
msgstr ""
"Hot RodのエンドポイントのSASL認証メカニズムを設定します。SCRAM-SHA-512は、Hot "
"RodのデフォルトのSASLメカニズムです。ただし、GSSAPIなど、環境に応じて適切なものを使用できます。"

msgid ""
"Defines the name that {jdgserver_name} servers present to clients. You "
"specify this name in the Hot Rod client configuration when you set up "
"{project_name}."
msgstr ""
"{jdgserver_name}サーバーがクライアントに提示する名前を定義します。この名前は、{project_name}を設定するときにHotRodクライアントの設定で指定します。"

msgid "Create a cache template."
msgstr "キャッシュ・テンプレートを作成します。"

msgid ""
"Add the cache template to `infinispan.xml` on each node in the "
"{jdgserver_name} cluster."
msgstr "{jdgserver_name}クラスター内の各ノードの `infinispan.xml` にキャッシュ・テンプレートを追加します。"

msgid ""
"<cache-container ... >\n"
"  <replicated-cache-configuration name=\"sessions-cfg\" <1>\n"
"                                  mode=\"SYNC\"> <2>\n"
"    <locking acquire-timeout=\"0\" /> <3>\n"
"    <backups>\n"
"      <backup site=\"site2\" strategy=\"SYNC\" /> <4>\n"
"    </backups>\n"
"  </replicated-cache-configuration>\n"
"</cache-container>"
msgstr ""
"<cache-container ... >\n"
"  <replicated-cache-configuration name=\"sessions-cfg\" <1>\n"
"                                  mode=\"SYNC\"> <2>\n"
"    <locking acquire-timeout=\"0\" /> <3>\n"
"    <backups>\n"
"      <backup site=\"site2\" strategy=\"SYNC\" /> <4>\n"
"    </backups>\n"
"  </replicated-cache-configuration>\n"
"</cache-container>"

msgid "Creates a cache template named `sessions-cfg`."
msgstr "`sessions-cfg` という名前のキャッシュ・テンプレートを作成します。"

msgid "Defines a cache that synchronously replicates data across the cluster."
msgstr "クラスター全体でデータを同期的に複製するキャッシュを定義します。"

msgid "Disables timeout for lock acquisition."
msgstr "ロック獲得のタイムアウトを無効にします。"

msgid ""
"Names the backup site for the {jdgserver_name} cluster you are configuring."
msgstr "設定している{jdgserver_name}クラスターのバックアップ・サイトに名前を付けます。"

msgid "Start {jdgserver_name} server1."
msgstr "{jdgserver_name}のserver1を起動します。"

msgid ""
"./server.sh -c infinispan.xml -b PUBLIC_IP_ADDRESS -k PUBLIC_IP_ADDRESS "
"-Djgroups.mcast_addr=228.6.7.10"
msgstr ""
"./server.sh -c infinispan.xml -b PUBLIC_IP_ADDRESS -k PUBLIC_IP_ADDRESS "
"-Djgroups.mcast_addr=228.6.7.10"

msgid "Start {jdgserver_name} server2."
msgstr "{jdgserver_name}のserver2を起動します。"

msgid ""
"./server.sh -c infinispan.xml -b PUBLIC_IP_ADDRESS -k PUBLIC_IP_ADDRESS "
"-Djgroups.mcast_addr=228.6.7.11"
msgstr ""
"./server.sh -c infinispan.xml -b PUBLIC_IP_ADDRESS -k PUBLIC_IP_ADDRESS "
"-Djgroups.mcast_addr=228.6.7.11"

msgid ""
"Check {jdgserver_name} server logs to verify the clusters form cross-site "
"views."
msgstr "{jdgserver_name}サーバーログをチェックして、クラスターがクロスサイト・ビューを形成していることを確認します。"

msgid ""
"INFO  [org.infinispan.XSITE] (jgroups-5,${server.hostname}) ISPN000439: Received new x-site view: [site1]\n"
"INFO  [org.infinispan.XSITE] (jgroups-7,${server.hostname}) ISPN000439: Received new x-site view: [site1, site2]"
msgstr ""
"INFO  [org.infinispan.XSITE] (jgroups-5,${server.hostname}) ISPN000439: Received new x-site view: [site1]\n"
"INFO  [org.infinispan.XSITE] (jgroups-7,${server.hostname}) ISPN000439: Received new x-site view: [site1, site2]"

msgid "Creating Infinispan Caches"
msgstr "Infinispanキャッシュの生成"

msgid "Create the Infinispan caches that {project_name} requires."
msgstr "{project_name}が必要とするInfinispanキャッシュを生成します。"

msgid ""
"We recommend that you create caches on {jdgserver_name} clusters at runtime "
"rather than adding caches to `infinispan.xml`. This strategy ensures that "
"your caches are automatically synchronized across the cluster and "
"permanently stored."
msgstr ""
"`infinispan.xml` "
"にキャッシュを追加するのではなく、実行時に{jdgserver_name}クラスターにキャッシュを作成することをお勧めします。この戦略により、キャッシュがクラスター全体で自動的に同期され、永続的に保存されます。"

msgid ""
"The following procedure uses the {jdgserver_name} Command Line Interface "
"(CLI) to create all the required caches in a single batch command."
msgstr ""
"次の手順では、{jdgserver_name}コマンドライン・インターフェイス（CLI）を使用して、必要なすべてのキャッシュを1つのバッチコマンドで作成します。"

msgid "Configure your {jdgserver_name} clusters."
msgstr "{jdgserver_name}クラスターを設定します。"

msgid "Create a batch file that contains caches, for example:"
msgstr "たとえば、次にようにキャッシュを含むバッチファイルを作成します。"

msgid ""
"cat > /tmp/caches.batch<<EOF\n"
"echo \"creating caches...\"\n"
"create cache work --template=sessions-cfg\n"
"create cache sessions --template=sessions-cfg\n"
"create cache clientSessions --template=sessions-cfg\n"
"create cache offlineSessions --template=sessions-cfg\n"
"create cache offlineClientSessions --template=sessions-cfg\n"
"create cache actionTokens --template=sessions-cfg\n"
"create cache loginFailures --template=sessions-cfg\n"
"echo \"verifying caches\"\n"
"ls caches\n"
"EOF"
msgstr ""
"cat > /tmp/caches.batch<<EOF\n"
"echo \"creating caches...\"\n"
"create cache work --template=sessions-cfg\n"
"create cache sessions --template=sessions-cfg\n"
"create cache clientSessions --template=sessions-cfg\n"
"create cache offlineSessions --template=sessions-cfg\n"
"create cache offlineClientSessions --template=sessions-cfg\n"
"create cache actionTokens --template=sessions-cfg\n"
"create cache loginFailures --template=sessions-cfg\n"
"echo \"verifying caches\"\n"
"ls caches\n"
"EOF"

msgid "Create the caches with the CLI."
msgstr "CLIを使用してキャッシュを作成します。"

msgid "$ bin/cli.sh -c https://server1:11222 --trustall -f /tmp/caches.batch"
msgstr "$ bin/cli.sh -c https://server1:11222 --trustall -f /tmp/caches.batch"

msgid ""
"Instead of the `--trustall` argument you can specify the truststore with the"
" `-t` argument and the truststore password with the `-s` argument."
msgstr ""
"引数 `--trustall` の代わりに、引数 `-t` でトラストストアを指定し、 `-s` 引数でトラストストア・パスワードを指定できます。"

msgid "Create the caches on the other site."
msgstr "他のサイトにキャッシュを作成します。"

msgid "Configuring Remote Cache Stores on {project_name}"
msgstr "{project_name}でのリモート・キャッシュ・ストアの設定"

msgid ""
"After you set up remote {jdgserver_name} clusters, you configure the "
"Infinispan subsystem on {project_name} to externalize data to those clusters"
" through remote stores."
msgstr ""
"リモートの{jdgserver_name}クラスターをセットアップした後、{project_name}でInfinispanサブシステムを設定して、リモートストアを介してそれらのクラスターにデータを外部化します。"

msgid "Set up remote {jdgserver_name} clusters for cross-site configuration."
msgstr "クロスサイト設定用にリモート{jdgserver_name}クラスターをセットアップします。"

msgid ""
"Create a truststore that contains the SSL certificate with the "
"{jdgserver_name} Server identity."
msgstr "{jdgserver_name}ServerのIDを持つSSL証明書を含むトラストストアを作成します。"

msgid "Add the truststore to the {project_name} deployment."
msgstr "トラストストアを{project_name}の配備に追加します。"

msgid "Create a socket binding that points to your {jdgserver_name} cluster."
msgstr "{jdgserver_name}クラスターを指すソケット・バインディングを作成します。"

msgid ""
"<outbound-socket-binding name=\"remote-cache\"> <1>\n"
"  <remote-destination host=\"${remote.cache.host:server_hostname}\" <2>\n"
"                      port=\"${remote.cache.port:11222}\"/> <3>\n"
"</outbound-socket-binding>"
msgstr ""
"<outbound-socket-binding name=\"remote-cache\"> <1>\n"
"  <remote-destination host=\"${remote.cache.host:server_hostname}\" <2>\n"
"                      port=\"${remote.cache.port:11222}\"/> <3>\n"
"</outbound-socket-binding>"

msgid "Names the socket binding as `remote-cache`."
msgstr "ソケット・バインディングに `remote-cache` という名前を付けます。"

msgid "Specifies one or more hostnames for the {jdgserver_name} cluster."
msgstr "{jdgserver_name}クラスターに対して1つ以上のホスト名を指定します。"

msgid "Defines the port of `11222` where the Hot Rod endpoint listens."
msgstr "HotRodエンドポイントがリッスンする `11222` のポートを定義します。"

msgid ""
"Add the `org.keycloak.keycloak-model-infinispan` module to the `keycloak` "
"cache container in the Infinispan subsystem."
msgstr ""
"`org.keycloak.keycloak-model-infinispan` モジュールをInfinispanサブシステムの `keycloak` "
"キャッシュ・コンテナーに追加します。"

msgid ""
"<subsystem xmlns=\"urn:jboss:domain:infinispan:12.0\">\n"
"    <cache-container name=\"keycloak\"\n"
"                     modules=\"org.keycloak.keycloak-model-infinispan\"/>"
msgstr ""
"<subsystem xmlns=\"urn:jboss:domain:infinispan:12.0\">\n"
"    <cache-container name=\"keycloak\"\n"
"                     modules=\"org.keycloak.keycloak-model-infinispan\"/>"

msgid ""
"Update the `work` cache in the Infinispan subsystem so it has the following "
"configuration:"
msgstr "Infinispanサブシステムの `work` キャッシュを更新して、次の設定にします。"

msgid ""
"<replicated-cache name=\"work\"> <1>\n"
"    <remote-store cache=\"work\" <2>\n"
"                  remote-servers=\"remote-cache\" <3>\n"
"                  passivation=\"false\"\n"
"                  fetch-state=\"false\"\n"
"                  purge=\"false\"\n"
"                  preload=\"false\"\n"
"                  shared=\"true\">\n"
"        <property name=\"rawValues\">true</property>\n"
"        <property name=\"marshaller\">org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_username\">myuser</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_password\">qwer1234!</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_realm\">default</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_server_name\">infinispan</property>\n"
"        <property name=\"infinispan.client.hotrod.sasl_mechanism\">SCRAM-SHA-512</property>\n"
"        <property name=\"infinispan.client.hotrod.trust_store_file_name\">/path/to/truststore.jks</property>\n"
"        <property name=\"infinispan.client.hotrod.trust_store_type\">JKS</property>\n"
"        <property name=\"infinispan.client.hotrod.trust_store_password\">password</property>\n"
"    </remote-store>\n"
"</replicated-cache>"
msgstr ""
"<replicated-cache name=\"work\"> <1>\n"
"    <remote-store cache=\"work\" <2>\n"
"                  remote-servers=\"remote-cache\" <3>\n"
"                  passivation=\"false\"\n"
"                  fetch-state=\"false\"\n"
"                  purge=\"false\"\n"
"                  preload=\"false\"\n"
"                  shared=\"true\">\n"
"        <property name=\"rawValues\">true</property>\n"
"        <property name=\"marshaller\">org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_username\">myuser</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_password\">qwer1234!</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_realm\">default</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_server_name\">infinispan</property>\n"
"        <property name=\"infinispan.client.hotrod.sasl_mechanism\">SCRAM-SHA-512</property>\n"
"        <property name=\"infinispan.client.hotrod.trust_store_file_name\">/path/to/truststore.jks</property>\n"
"        <property name=\"infinispan.client.hotrod.trust_store_type\">JKS</property>\n"
"        <property name=\"infinispan.client.hotrod.trust_store_password\">password</property>\n"
"    </remote-store>\n"
"</replicated-cache>"

msgid "Names the cache in the {jdgserver_name} configuration."
msgstr "{jdgserver_name}の設定でキャッシュに名前を付けます。"

msgid "Names the corresponding cache on the remote {jdgserver_name} cluster."
msgstr "リモート{jdgserver_name}クラスター上の対応するキャッシュに名前を付けます。"

msgid "Specifies the `remote-cache` socket binding."
msgstr "`remote-cache` ソケット・バインディングを指定します。"

msgid ""
"The preceding cache configuration includes recommended settings for "
"{jdgserver_name} caches. Hot Rod client configuration properties specify the"
" {jdgserver_name} user credentials and SSL keystore and truststore details."
msgstr ""
"上記のキャッシュ設定には、{jdgserver_name}キャッシュの推奨設定が含まれています。Hot "
"Rodクライアント設定プロパティーは、{jdgserver_name}ユーザー・クレデンシャルとSSLのキーストアおよびトラストストアの詳細を指定します。"

msgid ""
"Refer to the "
"https://infinispan.org/docs/11.0.x/titles/xsite/xsite.html#configure_clients-"
"xsite[{jdgserver_name} documentation] for descriptions of each property."
msgstr ""
"各プロパティーの説明については、 "
"https://infinispan.org/docs/11.0.x/titles/xsite/xsite.html#configure_clients-"
"xsite[{jdgserver_name} ドキュメント] を参照してください。"

msgid ""
"Add distributed caches to the Infinispan subsystem for each of the following"
" caches:"
msgstr "次の各キャッシュに対する分散キャッシュをInfinispanサブシステムに追加します。"

msgid "sessions"
msgstr "sessions"

msgid "clientSessions"
msgstr "clientSessions"

msgid "offlineSessions"
msgstr "offlineSessions"

msgid "offlineClientSessions"
msgstr "offlineClientSessions"

msgid "actionTokens"
msgstr "actionTokens"

msgid "loginFailures"
msgstr "loginFailures"

msgid ""
"For example, add a cache named `sessions` with the following configuration:"
msgstr "たとえば、次の設定で `sessions` という名前のキャッシュを追加します。"

msgid ""
"<distributed-cache name=\"sessions\" <1>\n"
"                   owners=\"1\"> <2>\n"
"    <remote-store cache=\"sessions\" <3>\n"
"                  remote-servers=\"remote-cache\" <4>\n"
"                  passivation=\"false\"\n"
"                  fetch-state=\"false\"\n"
"                  purge=\"false\"\n"
"                  preload=\"false\"\n"
"                  shared=\"true\">\n"
"        <property name=\"rawValues\">true</property>\n"
"        <property name=\"marshaller\">org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_username\">myuser</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_password\">qwer1234!</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_realm\">default</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_server_name\">infinispan</property>\n"
"        <property name=\"infinispan.client.hotrod.sasl_mechanism\">SCRAM-SHA-512</property>\n"
"        <property name=\"infinispan.client.hotrod.trust_store_file_name\">/path/to/truststore.jks</property>\n"
"        <property name=\"infinispan.client.hotrod.trust_store_type\">JKS</property>\n"
"        <property name=\"infinispan.client.hotrod.trust_store_password\">password</property>\n"
"    </remote-store>\n"
"</distributed-cache>"
msgstr ""
"<distributed-cache name=\"sessions\" <1>\n"
"                   owners=\"1\"> <2>\n"
"    <remote-store cache=\"sessions\" <3>\n"
"                  remote-servers=\"remote-cache\" <4>\n"
"                  passivation=\"false\"\n"
"                  fetch-state=\"false\"\n"
"                  purge=\"false\"\n"
"                  preload=\"false\"\n"
"                  shared=\"true\">\n"
"        <property name=\"rawValues\">true</property>\n"
"        <property name=\"marshaller\">org.keycloak.cluster.infinispan.KeycloakHotRodMarshallerFactory</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_username\">myuser</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_password\">qwer1234!</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_realm\">default</property>\n"
"        <property name=\"infinispan.client.hotrod.auth_server_name\">infinispan</property>\n"
"        <property name=\"infinispan.client.hotrod.sasl_mechanism\">SCRAM-SHA-512</property>\n"
"        <property name=\"infinispan.client.hotrod.trust_store_file_name\">/path/to/truststore.jks</property>\n"
"        <property name=\"infinispan.client.hotrod.trust_store_type\">JKS</property>\n"
"        <property name=\"infinispan.client.hotrod.trust_store_password\">password</property>\n"
"    </remote-store>\n"
"</distributed-cache>"

msgid ""
"Configures one replica of each cache entry across the {jdgserver_name} "
"cluster."
msgstr "{jdgserver_name}クラスター全体で各キャッシュ・エントリーのレプリカを1つ設定します。"

msgid ""
"Copy the `NODE11` to 3 other directories referred later as `NODE12`, "
"`NODE21` and `NODE22`."
msgstr ""
"`NODE11` を後述する `NODE12` 、 `NODE21` 、 `NODE22` という3つのディレクトリーにコピーしてください。"

msgid "Start `NODE11` :"
msgstr "次のように、 `NODE11` を起動してください。"

msgid ""
"cd NODE11/bin\n"
"./standalone.sh -c standalone-ha.xml -Djboss.node.name=node11 -Djboss.site.name=site1 \\\n"
"  -Djboss.default.multicast.address=234.56.78.1 -Dremote.cache.host=server1 \\\n"
"  -Djava.net.preferIPv4Stack=true -b _PUBLIC_IP_ADDRESS_"
msgstr ""
"cd NODE11/bin\n"
"./standalone.sh -c standalone-ha.xml -Djboss.node.name=node11 -Djboss.site.name=site1 \\\n"
"  -Djboss.default.multicast.address=234.56.78.1 -Dremote.cache.host=server1 \\\n"
"  -Djava.net.preferIPv4Stack=true -b _PUBLIC_IP_ADDRESS_"

msgid ""
"If you notice the following warning messages in logs, you can safely ignore "
"them:"
msgstr "ログに次の警告メッセージが表示された場合は、無視しても問題ありません。"

msgid ""
"WARN  [org.infinispan.CONFIG] (MSC service thread 1-5) ISPN000292: Unrecognized attribute 'infinispan.client.hotrod.auth_password'. Please check your configuration. Ignoring!\n"
"WARN  [org.infinispan.CONFIG] (MSC service thread 1-5) ISPN000292: Unrecognized attribute 'infinispan.client.hotrod.auth_username'. Please check your configuration. Ignoring!"
msgstr ""
"WARN  [org.infinispan.CONFIG] (MSC service thread 1-5) ISPN000292: Unrecognized attribute 'infinispan.client.hotrod.auth_password'. Please check your configuration. Ignoring!\n"
"WARN  [org.infinispan.CONFIG] (MSC service thread 1-5) ISPN000292: Unrecognized attribute 'infinispan.client.hotrod.auth_username'. Please check your configuration. Ignoring!"

msgid "Start `NODE12` :"
msgstr "次のように、 `NODE12` を起動してください。"

msgid ""
"cd NODE12/bin\n"
"./standalone.sh -c standalone-ha.xml -Djboss.node.name=node12 -Djboss.site.name=site1 \\\n"
"  -Djboss.default.multicast.address=234.56.78.1 -Dremote.cache.host=server1 \\\n"
"  -Djava.net.preferIPv4Stack=true -b _PUBLIC_IP_ADDRESS_"
msgstr ""
"cd NODE12/bin\n"
"./standalone.sh -c standalone-ha.xml -Djboss.node.name=node12 -Djboss.site.name=site1 \\\n"
"  -Djboss.default.multicast.address=234.56.78.1 -Dremote.cache.host=server1 \\\n"
"  -Djava.net.preferIPv4Stack=true -b _PUBLIC_IP_ADDRESS_"

msgid ""
"The cluster nodes should be connected. Something like this should be in the "
"log of both NODE11 and NODE12:"
msgstr "クラスター・ノードを接続する必要があります。このようなものは、NODE11とNODE12のどちらのログにも残っていなければなりません。"

msgid ""
"Received new cluster view for channel keycloak: [node11|1] (2) [node11, "
"node12]"
msgstr ""
"Received new cluster view for channel keycloak: [node11|1] (2) [node11, "
"node12]"

msgid "The channel name in the log might be different."
msgstr "ログにあるチャネル名とは異なっている可能性があります。"

msgid "Start `NODE21` :"
msgstr "次のように、 `NODE21` を起動してください。"

msgid ""
"cd NODE21/bin\n"
"./standalone.sh -c standalone-ha.xml -Djboss.node.name=node21 -Djboss.site.name=site2 \\\n"
"  -Djboss.default.multicast.address=234.56.78.2 -Dremote.cache.host=server2 \\\n"
"  -Djava.net.preferIPv4Stack=true -b _PUBLIC_IP_ADDRESS_"
msgstr ""
"cd NODE21/bin\n"
"./standalone.sh -c standalone-ha.xml -Djboss.node.name=node21 -Djboss.site.name=site2 \\\n"
"  -Djboss.default.multicast.address=234.56.78.2 -Dremote.cache.host=server2 \\\n"
"  -Djava.net.preferIPv4Stack=true -b _PUBLIC_IP_ADDRESS_"

msgid ""
"It shouldn't be connected to the cluster with `NODE11` and `NODE12`, but to "
"a separate one:"
msgstr "`NODE11` と `NODE12` を使用してクラスターに接続するのではなく、別のクラスターに接続する必要があります。"

msgid ""
"Received new cluster view for channel keycloak: [node21|0] (1) [node21]"
msgstr ""
"Received new cluster view for channel keycloak: [node21|0] (1) [node21]"

msgid "Start `NODE22` :"
msgstr "次のように、 `NODE22` を起動してください。"

msgid ""
"cd NODE22/bin\n"
"./standalone.sh -c standalone-ha.xml -Djboss.node.name=node22 -Djboss.site.name=site2 \\\n"
"  -Djboss.default.multicast.address=234.56.78.2 -Dremote.cache.host=server2 \\\n"
"  -Djava.net.preferIPv4Stack=true -b _PUBLIC_IP_ADDRESS_"
msgstr ""
"cd NODE22/bin\n"
"./standalone.sh -c standalone-ha.xml -Djboss.node.name=node22 -Djboss.site.name=site2 \\\n"
"  -Djboss.default.multicast.address=234.56.78.2 -Dremote.cache.host=server2 \\\n"
"  -Djava.net.preferIPv4Stack=true -b _PUBLIC_IP_ADDRESS_"

msgid "It should be in cluster with `NODE21` :"
msgstr "`NODE21` をクラスター化する必要があります。"

msgid ""
"Received new cluster view for channel keycloak: [node21|1] (2) [node21, "
"node22]"
msgstr ""
"Received new cluster view for channel keycloak: [node21|1] (2) [node21, "
"node22]"

msgid "Test:"
msgstr "次のように、テストを行ってください。"

msgid "Go to `http://node11:8080/auth/` and create the initial admin user."
msgstr "`http://node11:8080/auth/` に移動し、最初の管理者ユーザーを作成します。"

msgid ""
"Go to `http://node11:8080/auth/admin` and login as admin to admin console."
msgstr "`http://node11:8080/auth/admin` に移動し、管理者として管理コンソールにログインします。"

msgid ""
"Open a second browser and go to any of nodes `http://node12:8080/auth/admin`"
" or `http://node21:8080/auth/admin` or `http://node22:8080/auth/admin`. "
"After login, you should be able to see the same sessions in tab `Sessions` "
"of particular user, client or realm on all 4 servers."
msgstr ""
"2つ目のブラウザーを開き、 `http://node12:8080/auth/admin` または "
"`http://node21:8080/auth/admin` もしくは `http://node22:8080/auth/admin` "
"のいずれかのノードに移動します。ログイン後、4つのすべてのサーバー上の特定のユーザー、クライアントまたはレルムの `Sessions` "
"タブで同じセッションを表示できます。"

msgid ""
"After making a change in the {project_name} Admin Console, such as modifying"
" a user or a realm, that change should be immediately visible on any of the "
"four nodes. Caches should be properly invalidated everywhere."
msgstr ""
"{project_name}の管理コンソールで変更を行った後、ユーザーやレルムの変更などを行います。管理者コンソールでユーザーやレルムの変更を行った後、その変更は4つのノードのいずれかですぐに表示されるはずです。キャッシュはすべての場所で適切に無効化されているはずです。"

msgid ""
"Check server.logs if needed. After login or logout, the message like this "
"should be on all the nodes `NODEXY/standalone/log/server.log` :"
msgstr ""
"必要に応じてserver.logsを確認してください。ログインまたはログアウト後、以下のようなメッセージがすべての "
"`NODEXY/standalone/log/server.log` ノードに表示される必要があります。"

msgid ""
"2017-08-25 17:35:17,737 DEBUG [org.keycloak.models.sessions.infinispan.remotestore.RemoteCacheSessionListener] (Client-Listener-sessions-30012a77422542f5) Received event from remote store.\n"
"Event 'CLIENT_CACHE_ENTRY_REMOVED', key '193489e7-e2bc-4069-afe8-f1dfa73084ea', skip 'false'"
msgstr ""
"2017-08-25 17:35:17,737 DEBUG [org.keycloak.models.sessions.infinispan.remotestore.RemoteCacheSessionListener] (Client-Listener-sessions-30012a77422542f5) Received event from remote store.\n"
"Event 'CLIENT_CACHE_ENTRY_REMOVED', key '193489e7-e2bc-4069-afe8-f1dfa73084ea', skip 'false'"

msgid "Administration of cross-site deployment"
msgstr "クロスサイト・デプロイメントの管理"

msgid ""
"This section contains some tips and options related to cross-site "
"replication."
msgstr "このセクションでは、クロスサイト・レプリケーションに関連するヒントやオプションをご紹介します。"

msgid ""
"When you run the {project_name} server inside a data center, it is required "
"that the database referenced in `KeycloakDS` datasource is already running "
"and available in that data center. It is also necessary that the "
"{jdgserver_name} server referenced by the `outbound-socket-binding`, which "
"is referenced from the Infinispan cache `remote-store` element, is already "
"running. Otherwise the {project_name} server will fail to start."
msgstr ""
"{project_name}サーバーをデータセンター内で実行する場合、 `KeycloakDS` "
"データソース内で参照されたデータベースがすでに実行され、そのデータセンター内で使用可能である必要があります。また、 Infinispanキャッシュの "
"`remote-store` 要素から参照される `outbound-socket-binding` "
"によって参照された{jdgserver_name}サーバーがすでに実行されてることが必要です。そうしないと、{project_name}サーバーは起動に失敗します。"

msgid ""
"Every data center can have more database nodes if you want to support "
"database failover and better reliability. Refer to the documentation of your"
" database and JDBC driver for the details how to set this up on the database"
" side and how the `KeycloakDS` datasource on Keycloak side needs to be "
"configured."
msgstr ""
"データベース・フェイルオーバーと高い信頼性をサポートする必要がある場合、すべてのデータセンターでより多くのデータベース・ノードを持たせます。データベース側での設定方法とKeycloak側の"
" `KeycloakDS` データソースで必要な設定方法の詳細については、JDBCドライバーのドキュメントを参照してください。"

msgid ""
"Every datacenter can have more {jdgserver_name} servers running in the "
"cluster. This is useful if you want some failover and better fault "
"tolerance. The Hot Rod protocol used for communication between "
"{jdgserver_name} servers and {project_name} servers has a feature that "
"{jdgserver_name} servers will automatically send new topology to the "
"{project_name} servers about the change in the {jdgserver_name} cluster, so "
"the remote store on {project_name} side will know to which {jdgserver_name} "
"servers it can connect. Read the {jdgserver_name} and WildFly documentation "
"for more details."
msgstr ""
"すべてのデータセンターで、より多くの{jdgserver_name}サーバーをクラスター内で実行することができます。これは、フェイルオーバーとフォールト・トレランスを強化する場合に便利です。{jdgserver_name}サーバーと{project_name}サーバー間の通信で使用されるHot"
" "
"Rodプロトコルには、{jdgserver_name}サーバーが{jdgserver_name}クラスターの変更について、{project_name}サーバーに新しいトポロジーを自動的に送信する機能を備えています。したがって、{project_name}側のリモートストアは、どの{jdgserver_name}サーバーに接続できるのかが分かります。詳細については、{jdgserver_name}とWildFlyドキュメントを参照してください。"

msgid ""
"It is highly recommended that a master {jdgserver_name} server is running in"
" every site before the {project_name} servers in **any** site are started. "
"As in our example, we started both `server1` and `server2` first, before all"
" {project_name} servers. If you still need to run the {project_name} server "
"and the backup site is offline, it is recommended to manually switch the "
"backup site offline on the {jdgserver_name} servers on your site, as "
"described in <<onoffline>>. If you do not manually switch the unavailable "
"site offline, the first startup may fail or they may be some exceptions "
"during startup until the backup site is taken offline automatically due the "
"configured count of failed operations."
msgstr ""
"**どんな** "
"サイトの{project_name}サーバーも起動する前に、すべてのサイトでマスター{jdgserver_name}サーバーを実行することを強くお勧めします。この例では、すべての{project_name}サーバーの前に、"
" `server1` と `server2` "
"の両方を最初に起動します。{project_name}サーバーをそれでも実行する必要があり、バックアップ・サイトがオフラインである場合は、<<onoffline>>での説明のとおり、サイトの{jdgserver_name}サーバー上のバックアップ・サイトを手動でオフラインに切り替えることをお勧めします。使用できない状態のサイトをオフラインに手動で切り替えることができない場合、初回起動に失敗するか、起動時にいくつか例外が発生する可能性があります。これは、失敗した操作の設定数によってバックアップ・サイトが自動的にオフラインになるまでです。"

msgid "Bringing sites offline and online"
msgstr "サイトをオフラインおよびオンラインにする"

msgid "For example, assume this scenario:"
msgstr "たとえば、以下のようなシナリオを想定します。"

msgid ""
"Site `site2` is entirely offline from the `site1` perspective. This means "
"that all {jdgserver_name} servers on `site2` are off *or* the network "
"between `site1` and `site2` is broken."
msgstr ""
"サイト `site1` から見たサイト `site2` は、完全にオフラインです。これは、`site2` "
"のすべての{jdgserver_name}サーバーがオフである、 *または* 、 `site1` と `site2` "
"の間のネットワークが切断されていることを意味します。"

msgid ""
"You run {project_name} servers and {jdgserver_name} server `server1` in site"
" `site1`"
msgstr ""
"サイト `site1` で{project_name}サーバーと{jdgserver_name}サーバー `server1` を実行します。"

msgid "Someone logs in on a {project_name} server on `site1`."
msgstr "いずれかのユーザーが `site1` の{project_name}サーバーにログインします。"

msgid ""
"The {project_name} server from `site1` will try to write the session to the "
"remote cache on `server1` server, which is supposed to backup data to the "
"`server2` server in the `site2`. See <<communication>> for more information."
msgstr ""
"`site1` の{project_name}サーバーは、`site2` の `server2` サーバーにデータをバックアップすることを想定し、 "
"`server1` "
"サーバー上のリモート・キャッシュにセッションを書き込もうとします。詳細については、<<communication>>を参照してください。"

msgid ""
"Server `server2` is offline or unreachable from `server1`. So the backup "
"from `server1` to `server2` will fail."
msgstr ""
"`server2` サーバーがオフラインであるか、 `server1` から到達できない状態なので、 `server1` から `server2` "
"へのバックアップは失敗します。"

msgid ""
"The exception is thrown in `server1` log and the failure will be propagated "
"from `server1` server to {project_name} servers as well because the default "
"`FAIL` backup failure policy is configured. See <<backupfailure>> for "
"details around the backup policies."
msgstr ""
"例外は `server1` のログにスローされます。デフォルトの `FAIL` バックアップ失敗ポリシーが設定されているため、その失敗は "
"`server1` "
"サーバーから{project_name}サーバーにも伝播されます。バックアップ・ポリシーの詳細については、<<backupfailure>>を参照してください。"

msgid ""
"The error will happen on {project_name} side too and user may not be able to"
" finish his login."
msgstr "このエラーは{project_name}側でも発生し、ユーザーはログインを完了できない可能性もあります。"

msgid ""
"According to your environment, it may be more or less probable that the "
"network between sites is unavailable or temporarily broken (split-brain). In"
" case this happens, it is good that {jdgserver_name} servers on `site1` are "
"aware of the fact that {jdgserver_name} servers on `site2` are unavailable, "
"so they will stop trying to reach the servers in the `server2` site and the "
"backup failures won't happen. This is called `Take site offline` ."
msgstr ""
"使用している環境に応じて、サイト間のネットワークが利用できないか、一時的に壊れている（スプリット・ブレイン）可能性があります。これが起こった場合、 "
"`site1` の{jdgserver_name}サーバーは、 `site2` の{jdgserver_name}サーバーが利用できないことに気付き、 "
"`server2` サイトのサーバーへアクセスしようとするのを止めるため、バックアップの失敗は発生しません。これは `サイトをオフラインにする` "
"と呼ばれています。"

msgid "Take site offline"
msgstr "サイトをオフラインにする"

msgid "There are 2 ways to take the site offline."
msgstr "サイトをオフラインにするには2つの方法があります。"

msgid ""
"**Manually by admin** - Admin can use the `jconsole` or other tool and run "
"some JMX operations to manually take the particular site offline. This is "
"useful especially if the outage is planned. With `jconsole` or CLI, you can "
"connect to the `server1` server and take the `site2` offline. More details "
"about this are available in the "
"link:{jdgserver_crossdcdocs_link}[{jdgserver_name} documentation]."
msgstr ""
"**管理者による手作業** - 管理者は `jconsole` "
"または他のツールを使用して、いくつかのJMX操作を実行することで、手動で特定のサイトをオフラインにすることができます。これは、特に停止が計画されている場合に役立ちます。"
" `jconsole` またはCLIを使用すると、 `server1` サーバーに接続し、 `site2` "
"をオフラインにすることができます。この詳細については、 "
"link:{jdgserver_crossdcdocs_link}[{jdgserver_name}ドキュメント] を参照してください。"

msgid ""
"These steps usually need to be done for all the {project_name} caches "
"mentioned in <<backups>>."
msgstr "<<backups>>で述べた他のすべての{project_name}キャッシュについても、通常はこれらの手順を実行する必要があります。"

msgid ""
"**Automatically** - After some number of failed backups, the `site2` will "
"usually be taken offline automatically. This is done due the configuration "
"of `take-offline` element inside the cache configuration."
msgstr ""

msgid "<take-offline min-wait=\"60000\" after-failures=\"3\" />"
msgstr "<take-offline min-wait=\"60000\" after-failures=\"3\" />"

msgid ""
"This example shows that the site will be taken offline automatically for the"
" particular single cache if there are at least 3 subsequent failed backups "
"and there is no any successful backup within 60 seconds."
msgstr ""
"この例では、少なくとも3回連続して失敗したバックアップがあり、60秒以内にバックアップが成功しなかった場合、特定のシングルキャッシュに対してサイトが自動的にオフラインになることを示しています。"

msgid ""
"Automatically taking a site offline is useful especially if the broken "
"network between sites is unplanned. The disadvantage is that there will be "
"some failed backups until the network outage is detected, which could also "
"mean  failures on the application side. For example, there will be failed "
"logins for some users or big login timeouts. Especially if `failure-policy` "
"with value `FAIL` is used."
msgstr ""
"自動的にサイトをオフラインにすることは、特に、サイト間の切断されたネットワークが計画外である場合に便利です。欠点は、ネットワークの停止が検出されるまで何らかのバックアップが失敗し、アプリケーション側で障害が起きてる可能性があります。たとえば、一部のユーザーのログインに失敗したり、大きなログインタイムアウトが発生したりします。"
" 特に、値が `FAIL` の `failure-policy` が使用されている場合です。"

msgid ""
"The tracking of whether a site is offline is tracked separately for every "
"cache."
msgstr "サイトがオフラインであるかどうかの追跡は、キャッシュごとに個別に行われます。"

msgid "Take site online"
msgstr "サイトをオンラインにする"

msgid ""
"Once your network is back and `site1` and `site2` can talk to each other, "
"you may need to put the site online. This needs to be done manually through "
"JMX or CLI in similar way as taking a site offline. Again, you may need to "
"check all the caches and bring them online."
msgstr ""
"一旦ネットワークが復旧し、 `site1` と `site2` "
"がお互いに通信することができたら、サイトをオンラインにする必要があります。これは、サイトをオフラインにするのと同じように、JMXまたはCLIを使用して手動で行う必要があります。再度キャッシュをすべてチェックし、オンラインにする必要があります。"

msgid "Once the sites are put online, it's usually good to:"
msgstr "サイトをオンラインにしたら、通常は次のようにするのが良いです。"

msgid "Do the <<statetransfer>>."
msgstr "<<statetransfer>>を行います。"

msgid "Manually <<clearcache>>."
msgstr "手動で<<clearcache>>を行います。"

msgid "State transfer"
msgstr "ステート・トランスファー"

msgid ""
"State transfer is a required, manual step. {jdgserver_name} server does not "
"do this automatically, for example during split-brain, it is only the admin "
"who may decide which site has preference and hence if state transfer needs "
"to be done bidirectionally between both sites or just unidirectionally, as "
"in only from `site1` to `site2`, but not from `site2` to `site1`."
msgstr ""
"ステート・トランスファーは、手動で行う必要があります。{jdgserver_name}サーバーはこれを自動的には行いません。たとえば、スプリット・ブレイン中は、誰がどのサイトを優先するかを管理者のみが決定することができます。したがって、ステート・トランスファーが両方のサイト間で双方向に、または"
" `site1` から `site2` へのみ単方向で行われる必要がありますが、`site2` から `site1` への単方向は行われません。"

msgid ""
"A bidirectional state transfer will ensure that entities which were created "
"*after* split-brain on `site1` will be transferred to `site2`. This is not "
"an issue as they do not yet exist on `site2`. Similarly, entities created "
"*after* split-brain on `site2` will be transferred to `site1`. Possibly "
"problematic parts are those entities which exist *before* split-brain on "
"both sites and which were updated during split-brain on both sites. When "
"this happens, one of the sites will *win* and will overwrite the updates "
"done during split-brain by the second site."
msgstr ""
"双方向のステート・トランスファーによって、スプリット・ブレインの *後に* `site1` で作成されたエンティティーが `site2` "
"に確実に転送されます。これは `site2` ではまだ発生していないので問題ありません。同じように、スプリット・ブレインの *後に* `site2` "
"で作成されたエンティティーは `site1` に転送されます。おそらく問題のある部分は、両方のサイトのスプリット・ブレインの *前に* "
"存在し、両方のサイトのスプリット・ブレイン中に更新されたエンティティーです。これが発生すると、サイトの1つが *勝ち* "
"、2番目のサイトがスプリット・ブレイン中に行った更新を上書きします。"

msgid ""
"Unfortunately, there is no any universal solution to this. Split-brains and "
"network outages are just state, which is usually impossible to be handled "
"100% correctly with 100% consistent data between sites. In the case of "
"{project_name}, it typically is not a critical issue. In the worst case, "
"users will need to re-login again to their clients, or have the improper "
"count of loginFailures tracked for brute force protection. See the "
"{jdgserver_name}/JGroups documentation for more tips how to deal with split-"
"brain."
msgstr ""
"残念ながら、これに対する広く一般的な解決方法はありません。スプリット・ブレインやネットワークの停止は状態に過ぎず、サイト間で100%の一貫性のあるデータで100%正確に処理することは通常不可能です。{project_name}の場合、これは特に重大な問題ではありません。最悪の場合、ユーザーがクライアントに再度ログインするか、loginFailuresの不正カウント数をブルートフォース保護のために追跡する必要があります。スプリット・ブレインに対処するためのヒントについては、{jdgserver_name}/JGroupsドキュメントを参照してください。"

msgid ""
"The state transfer can be also done on the {jdgserver_name} server side "
"through JMX. The operation name is `pushState`. There are few other "
"operations to monitor status, cancel push state, and so on. More info about "
"state transfer is available in the "
"link:{jdgserver_crossdcdocs_link}[{jdgserver_name} docs]."
msgstr ""
"ステート・トランスファーは、JMXを介して{jdgserver_name}サーバー側でも行われます。操作名は `pushState` "
"です。状態をモニタリングしたり、プッシュ状態をキャンセルしたりするその他の操作はほとんどありません。ステート・トランスファーの詳細については、 "
"link:{jdgserver_crossdcdocs_link}[{jdgserver_name} docs] を参照してください。"

msgid "Clear caches"
msgstr "キャッシュのクリア"

msgid ""
"After split-brain it is safe to manually clear caches in the {project_name} "
"admin console. This is because there might be some data changed in the "
"database on `site1` and because of the event, that the cache should be "
"invalidated wasn't transferred during split-brain to `site2`. Hence "
"{project_name} nodes on `site2` may still have some stale data in their "
"caches."
msgstr ""
"スプリット・ブレイン後は、{project_name}の管理コンソールで手動でキャッシュをクリアするのが安全です。これは、 `site1` "
"のデータベースで変更されたデータがあり、イベントのために無効にする必要のあるキャッシュが、スプリット・ブレイン中に `site2` "
"へ転送されなかった可能性があるためです。したがって、 `site2` "
"の{project_name}ノードでは、キャッシュ内に古いデータがまだ残っている可能性があります。"

msgid ""
"To clear the caches, see "
"{adminguide_clearcache_link}[{adminguide_clearcache_name}]."
msgstr ""
"キャッシュをクリアするには、 {adminguide_clearcache_link}[{adminguide_clearcache_name}] "
"を参照してください。"

msgid ""
"When the network is back, it is sufficient to clear the cache just on one "
"{project_name} node on any random site. The cache invalidation event will be"
" sent to all the other {project_name} nodes in all sites. However, it needs "
"to be done for all the caches (realms, users, keys). See "
"link:{adminguide_clearcache_link}[{adminguide_clearcache_name}] for more "
"information."
msgstr ""
"ネットワークが復旧したら、いずれかのサイトの1つの{project_name}ノードでキャッシュをクリアするだけで十分です。キャッシュの無効化イベントは、それぞれのサイトの他の{project_name}ノードすべてに送られます。ただし、すべてのキャッシュ（レルム、ユーザー、鍵）に対して実行する必要があります。詳しくは、link:{adminguide_clearcache_link}[{adminguide_clearcache_name}]を参照してください。"

msgid "Tuning the {jdgserver_name} cache configuration"
msgstr "{jdgserver_name}キャッシュ設定のチューニング"

msgid "This section contains tips and options for configuring your JDG cache."
msgstr "このセクションでは、JDGキャッシュを設定するためのヒントとオプションについて説明します。"

msgid "Backup failure policy"
msgstr "バックアップ失敗ポリシー"

msgid ""
"By default, the configuration of backup `failure-policy` in the Infinispan "
"cache configuration in the {jdgserver_name} `clustered.xml` file is "
"configured as `FAIL`. You may change it to `WARN` or `IGNORE`, as you "
"prefer."
msgstr ""
"デフォルトでは、{jdgserver_name}の `clustered.xml` "
"ファイル内にあるInfinispanキャッシュ設定のバックアップの設定 `failure-policy` が `FAIL` "
"に設定されています。必要に応じて `WARN` または `IGNORE` に変更できます。"

msgid ""
"The difference between `FAIL` and `WARN` is that when `FAIL` is used and the"
" {jdgserver_name} server tries to back data up to the other site and the "
"backup fails then the failure will be propagated back to the caller (the "
"{project_name} server). The backup might fail because the second site is "
"temporarily unreachable or there is a concurrent transaction which is trying"
" to update same entity. In this case, the {project_name} server will then "
"retry the operation a few times. However, if the retry fails, then the user "
"might see the error after a longer timeout."
msgstr ""
"`FAIL` と `WARN` の違いは、 `FAIL` "
"が使用され、{jdgserver_name}サーバーが別のサイトにデータのバックアップを試みたときに、バックアップが失敗すると、その失敗が呼び出し側（{project_name}サーバー）に伝播されるという点です。2番目のサイトが一時的に到達不能になったり、同じエンティティーの更新を試みる同時トランザクションが発生した場合は、バックアップが失敗する可能性があります。この場合、{project_name}サーバーは複数回再試行します。ただし、その再試行が失敗した場合、より長いタイムアウト後、ユーザーにはエラーが表示されます。"

msgid ""
"When using `WARN`, the failed backups are not propagated from the "
"{jdgserver_name} server to the {project_name} server. The user won't see the"
" error and the failed backup will be just ignored. There will be a shorter "
"timeout, typically 10 seconds as that's the default timeout for backup. It "
"can be changed by the attribute `timeout` of `backup` element. There won't "
"be retries. There will just be a WARNING message in the {jdgserver_name} "
"server log."
msgstr ""
"`WARN` "
"を使用すると、失敗したバックアップは、{jdgserver_name}サーバーから{project_name}サーバーに伝播されません。失敗したバックアップは無視され、ユーザーにはエラーが表示されません。バックアップのデフォルトのタイムアウトは10秒間であるため短いです。これは、"
" `backup` 要素の `timeout` "
"属性によって変更することができます。タイムアウトにおける再試行はありません。タイムアウト時は、{jdgserver_name}サーバーのログにWARNINGメッセージが表示されます。"

msgid ""
"The potential issue is, that in some cases, there may be just some a short "
"network outage between sites, where the retry (usage of the `FAIL` policy) "
"may help, so with `WARN` (without retry), there will be some data "
"inconsistencies across sites. This can also happen if there is an attempt to"
" update the same entity concurrently on both sites."
msgstr ""
"潜在的な課題としては、いくつかのケースで、再試行（ `FAIL` ポリシーの使用）が役に立つサイト間で短いネットワーク停止が発生する可能性があるため、 "
"`WARN` "
"（再試行なし）では、サイト間でデータの不整合が発生します。これは、両方のサイトで同時に同じエンティティーを更新しようとする際にも発生します。"

msgid ""
"How bad are these inconsistencies? Usually only means that a user will need "
"to re-authenticate."
msgstr "これらの不整合はどれほど悪いことなのでしょうか。通常は、ユーザーが再認証する必要があることだけを意味します。"

msgid ""
"When using the `WARN` policy, it may happen that the single-use cache, which"
" is provided by the `actionTokens` cache and which handles that particular "
"key is really single use, but may \"successfully\" write the same key twice."
" But, for example, the OAuth2 specification "
"link:https://datatracker.ietf.org/doc/html/rfc6749#section-10.5[mentions] "
"that code must be single-use. With the `WARN` policy, this may not be "
"strictly guaranteed and the same code could be written twice if there is an "
"attempt to write it concurrently in both sites."
msgstr ""
"`WARN` ポリシーを使用すると、 `actionTokens` "
"キャッシュにより提供され、その特定のキーを処理する、使い捨てのキャッシュが実際に1回使用されますが、同じキーが2回\"正常に\"書き込まれる可能性があります。しかし、たとえば、link:https://datatracker.ietf.org/doc/html/rfc6749#section-10.5[OAuth2"
" 仕様]では、コードは使い捨てでなければならないと言及されています。 `WARN` "
"ポリシーでは、これは厳密には保証されておらず、両方のサイトで同時に書き込まれる試みがあった場合、同じコードが2回書き込まれる可能性があります。"

msgid ""
"If there is a longer network outage or split-brain, then with both `FAIL` "
"and `WARN`, the other site will be taken offline after some time and "
"failures as described in <<onoffline>>. With the default 1 minute timeout, "
"it is usually 1-3 minutes until all the involved caches are taken offline. "
"After that, all the operations will work fine from an end user perspective. "
"You only need to manually restore the site when it is back online as "
"mentioned in <<onoffline>>."
msgstr ""
"より長いネットワーク停止またはスプリット・ブレインが起きた場合、 `FAIL` と `WARN` "
"を使用すると、<<onoffline>>で説明したとおり、少し時間を置いて失敗した後、他のサイトはオフラインになります。デフォルトの1分のタイムアウトでは、関連するキャッシュがすべてオフラインになるまで、通常は1～3分かかります。その後、エンドユーザーの観点から、動作はすべて問題なく進みます。<<onoffline>>で説明したとおり、オンラインに戻ったときに手動でサイトを復元する必要があります。"

msgid ""
"In summary, if you expect frequent, longer outages between sites and it is "
"acceptable for you to have some data inconsistencies and a not 100% accurate"
" single-use cache, but you never want end-users to see the errors and long "
"timeouts, then switch to `WARN`."
msgstr ""
"要約すると、サイト間で頻繁により長い停止が発生する可能性があり、データの不整合と100%正確ではない使い捨てのキャッシュについては許容されますが、エラーや長いタイムアウトがエンドユーザーに表示されないようにする場合には、"
" `WARN` に切り替えます。"

msgid ""
"The difference between `WARN` and `IGNORE` is, that with `IGNORE` warnings "
"are not written in the {jdgserver_name} log. See more details in the "
"Infinispan documentation."
msgstr ""
"`WARN` と `IGNORE` の違いは、 `IGNORE` "
"では警告が{jdgserver_name}ログに書き込まれていないことです。詳細については、Infinispanのドキュメントを参照してください。"

msgid "Lock acquisition timeout"
msgstr "ロックの取得タイムアウト"

msgid ""
"The default configuration is using transaction in NON_DURABLE_XA mode with "
"acquire timeout 0. This means that transaction will fail-fast if there is "
"another transaction in progress for the same key."
msgstr ""
"デフォルト設定では、NON_DURABLE_XAモードでトランザクションを取得タイムアウト0で使用しています。これは、同じキーに対して進行中の別のトランザクションがある場合、トランザクションはすぐに失敗することを意味します。"

msgid ""
"The reason to switch this to 0 instead of default 10 seconds was to avoid "
"possible deadlock issues. With {project_name}, it can happen that the same "
"entity (typically session entity or loginFailure) is updated concurrently "
"from both sites. This can cause deadlock under some circumstances, which "
"will cause the transaction to be blocked for 10 seconds. See "
"link:https://issues.redhat.com/browse/JDG-1318[this JIRA report] for "
"details."
msgstr ""
"デフォルトの10秒ではなく0に切り替えるのは、デッドロックの可能性を避けるためです。{project_name}では、同じエンティティー（通常はセッション・エンティティーまたはloginFailure）が両方のサイトから同時に更新されることがあります。これにより、状況によってはデッドロックが発生し、トランザクションが10秒間ブロックされる可能性があります。"
" 詳細については、 link:https://issues.redhat.com/browse/JDG-1318[このJIRAレポート] "
"を参照してください。"

msgid ""
"With timeout 0, the transaction will immediately fail and then will be "
"retried from {project_name} if backup `failure-policy` with the value `FAIL`"
" is configured. As long as the second concurrent transaction is finished, "
"the retry will usually be successful and the entity will have applied "
"updates from both concurrent transactions."
msgstr ""
"タイムアウト0の場合、トランザクションは直ちに失敗し、値 `FAIL` のバックアップ `failure-policy` "
"が設定されていれば、{project_name}から再試行されます。2番目の同時トランザクションが終了するまで、通常は再試行が成功し、エンティティーは両方の同時トランザクションから更新を適用します。"

msgid ""
"We see very good consistency and results for concurrent transaction with "
"this configuration, and it is recommended to keep it."
msgstr "この設定での同時トランザクションは、非常に良い一貫性と結果が得られるため、そのまま使用することをお勧めします。"

msgid ""
"The only (non-functional) problem is the exception in the {jdgserver_name} "
"server log, which happens every time when the lock is not immediately "
"available."
msgstr ""
"唯一の（機能しない）問題は、{jdgserver_name}サーバーログの例外です。これは、ロックがすぐに利用できなくなるたびに発生します。"

msgid "SYNC or ASYNC backups"
msgstr "SYNCまたはASYNCバックアップ"

msgid ""
"An important part of the `backup` element is the `strategy` attribute. You "
"must decide whether it needs to be `SYNC` or `ASYNC`. We have 7 caches which"
" might be cross-site replication aware, and these can be configured in 3 "
"different modes regarding cross-site:"
msgstr ""
"`backup` 要素の重要な部分は `strategy` 属性です。 `SYNC` と `ASYNC` "
"のどちらが必要かを決める必要があります。クロスサイト・レプリケーションを認識できる7つのキャッシュがあり、これらは、クロスサイトに対する次の3つの異なるモードで設定できます。"

msgid "SYNC backup"
msgstr "SYNCバックアップ"

msgid "ASYNC backup"
msgstr "ASYNCバックアップ"

msgid "No backup at all"
msgstr "バックアップを全くしない"

msgid ""
"If the `SYNC` backup is used, then the backup is synchronous and operation "
"is considered finished on the caller ({project_name} server) side once the "
"backup is processed on the second site. This has worse performance than "
"`ASYNC`, but on the other hand, you are sure that subsequent reads of the "
"particular entity, such as user session, on `site2` will see the updates "
"from `site1`. Also, it is needed if you want data consistency. As with "
"`ASYNC` the caller is not notified at all if backup to the other site "
"failed."
msgstr ""
"`SYNC` "
"バックアップが使用された場合、バックアップが同期され、バックアップが2番目のサイトで処理されると、呼び出し側（{project_name}サーバー）で操作が完了したとみなされます。これは"
" `ASYNC` よりもパフォーマンスが劣りますが、一方で、 `site2` のユーザー・セッションなど特定のエンティティーの後続の読み込みによって、 "
"`site1` からの更新が確実に確認されます。また、データの一貫性が必要な場合は、これは必須になります。 `ASYNC` "
"の場合と同様に、他のサイトへのバックアップが失敗した場合は、呼び出し側には全く通知されません。"

msgid ""
"For some caches, it is even possible to not backup at all and completely "
"skip writing data to the {jdgserver_name} server. To set this up, do not use"
" the `remote-store` element for the particular cache on the {project_name} "
"side (file `KEYCLOAK_HOME/standalone/configuration/standalone-ha.xml`) and "
"then the particular `replicated-cache` element is also not needed on the "
"{jdgserver_name} server side."
msgstr ""
"キャッシュによっては、バックアップをまったく取らず、{jdgserver_name}サーバーへのデータ書き込みを完全にスキップすることも可能です。これを設定するために、"
" {project_name}側（ `KEYCLOAK_HOME/standalone/configuration/standalone-ha.xml`"
" ファイル）の特定のキャッシュに `remote-store` 要素を使用しないでください。また、特定の `replicated-cache` "
"要素も{jdgserver_name}サーバー側では必要ありません。"

msgid ""
"By default, all 7 caches are configured with `SYNC` backup, which is the "
"safest option. Here are a few things to consider:"
msgstr ""
"デフォルトでは、7つのキャッシュすべてが最も安全なオプションである `SYNC` バックアップで設定されています。考慮すべき点は次のとおりです。"

msgid ""
"If you are using active/passive mode (all {project_name} servers are in "
"single site `site1` and the {jdgserver_name} server in `site2` is used "
"purely as backup. See <<modes>> for more details), then it is usually fine "
"to use `ASYNC` strategy for all the caches to save the performance."
msgstr ""
"アクティブ/パッシブモード（すべての{project_name}サーバーが単一のサイト `site1` にあり、 `site2` "
"にある{jdgserver_name}サーバーが純粋にバックアップとしてのみ使用されます。詳しくは "
"<<modes>>を参照してください）を使用している場合、パフォーマンスを低下させないよう、すべてのキャッシュに `ASYNC` "
"方式を使用するのが通常は望ましいです。"

msgid ""
"The `work` cache is used mainly to send some messages, such as cache "
"invalidation events, to the other site. It is also used to ensure that some "
"special events, such as userStorage synchronizations, happen only on single "
"site. It is recommended to keep this set to `SYNC`."
msgstr ""
"`work` "
"キャッシュは、主に、キャッシュ無効化イベントなどのいくつかのメッセージを他のサイトに送信するために使用されます。また、userStorageの同期化などの特別なイベントが単一のサイトでのみ発生するようにするためにも使用されます。これを"
" `SYNC` に設定することを推奨します。"

msgid ""
"The `actionTokens` cache is used as single-use cache to track that some "
"tokens/tickets were used just once. For example action tokens or OAuth2 "
"codes. It is possible to set this to `ASYNC` to slightly improved "
"performance, but then it is not guaranteed that particular ticket is really "
"single-use. For example, if there is concurrent request for same ticket in "
"both sites, then it is possible that both requests will be successful with "
"the `ASYNC` strategy. So what you set here will depend on whether you prefer"
" better security (`SYNC` strategy) or better performance (`ASYNC` strategy)."
msgstr ""
" `actionTokens` "
"キャッシュは、使い捨てのキャッシュとして使用され、トークンまたはチケットが1回だけ使用されたということを追跡します。たとえば、アクショントークンまたはOAuth2のコードです。これを"
" `ASYNC` "
"に設定して、パフォーマンスをわずかに向上させることは可能ですが、特定のチケットが実際に1回だけ使用され使い捨てになるかは保証されていません。たとえば、両方のサイトで同じチケットの同時リクエストがある場合、"
" `ASYNC` 方式によって両方のリクエストが成功する可能性があります。そのため、ここでの設定は、セキュリティー（ `SYNC` "
"方式）を優先するか、パフォーマンス（ `ASYNC` 方式）を優先するかによります。"

msgid ""
"The `loginFailures` cache may be used in any of the 3 modes. If there is no "
"backup at all, it means that count of login failures for a user will be "
"counted separately for every site (See <<cache>> for details). This has some"
" security implications, however it has some performance advantages. Also it "
"mitigates the possible risk of denial of service (DoS) attacks. For example,"
" if an attacker simulates 1000 concurrent requests using the username and "
"password of the user on both sites, it will mean lots of messages being "
"passed between the sites, which may result in network congestion. The "
"`ASYNC` strategy might be even worse as the attacker requests won't be "
"blocked by waiting for the backup to the other site, resulting in "
"potentially even more congested network traffic. The count of login failures"
" also will not be accurate with the `ASYNC` strategy."
msgstr ""
"`loginFailures` "
"キャッシュは、3つのモードのいずれかで使用できます。バックアップがまったくない場合、ユーザーのログイン失敗のカウントがサイトごとに個別にカウントされることを意味します（詳しくは<<cache>>を参照してください）。これにはいくつかのセキュリティー上の意味がありますが、パフォーマンス上の利点があります。また、サービス拒否（DoS）攻撃のリスクを軽減します。たとえば、攻撃者が両方のサイトでユーザーのユーザー名とパスワードを使用して1000件の同時リクエストをシミュレートすると、サイト間で多くのメッセージが渡され、ネットワークの混雑が発生する可能性があります。"
" `ASYNC` "
"方式は、攻撃者のリクエストが他のサイトへのバックアップを待つことによってブロックされず、潜在的にさらに混雑したネットワーク・トラフィックを招くため、状況は悪化する可能性があります。ログイン失敗のカウントも"
" `ASYNC` 方式では正確ではありません。"

msgid ""
"For the environments with slower network between data centers and "
"probability of DoS, it is recommended to not backup the `loginFailures` "
"cache at all."
msgstr ""
"データセンター間のネットワークが遅く、DoSの確率が高い環境では、 `loginFailures` "
"キャッシュをまったくバックアップしないことが推奨されます。"

msgid ""
"It is recommended to keep the `sessions` and `clientSessions` caches in "
"`SYNC`. Switching them to `ASYNC` is possible only if you are sure that user"
" requests and backchannel requests (requests from client applications to "
"{project_name} as described in <<requestprocessing>>) will be always "
"processed on same site. This is true, for example, if:"
msgstr ""
"`sessions` と `clientSessions` キャッシュを `SYNC` "
"で保持しておくことをお勧めします。ユーザーのリクエストとバックチャネル・リクエスト（<<requestprocessing>>で説明したクライアント・アプリケーションから{project_name}へのリクエスト）が常に同じサイトで処理されることが確かな場合にのみ、それらを"
" `ASYNC` へ切り替えることが可能になります。たとえば、次のような場合はこれが当てはまります。"

msgid "You use active/passive mode as described <<modes>>."
msgstr "<<modes>>で説明した通り、アクティブ/パッシブモードを使用しています。"

msgid ""
"All your client applications are using the {project_name} "
"{adapterguide_link_js_adapter}[JavaScript Adapter]. The JavaScript adapter "
"sends the backchannel requests within the browser and hence they participate"
" on the browser sticky session and will end on same cluster node (hence on "
"same site) as the other browser requests of this user."
msgstr ""
"クライアント・アプリケーションはすべて {project_name} "
"{adapterguide_link_js_adapter}[JavaScriptアダプター].を使用しています。JavaScriptアダプターは、ブラウザー内でバックチャネル・リクエストを送信するため、それらはブラウザーのスティッキー・セッションに参加し、このユーザーの別のブラウザー・リクエストと同じクラスターノード（したがって同じサイト）で終了します。"

msgid ""
"Your load balancer is able to serve the requests based on client IP address "
"(location) and the client applications are deployed on both sites."
msgstr ""
"ロードバランサーは、クライアントIPアドレス（ロケーション）に基づいてリクエストを処理でき、クライアント・アプリケーションは両方のサイトにデプロイされています。"

msgid ""
"For example you have 2 sites LON and NYC. As long as your applications are "
"deployed in both LON and NYC sites too, you can ensure that all the user "
"requests from London users will be redirected to the applications in LON "
"site and also to the {project_name} servers in LON site. Backchannel "
"requests from the LON site client deployments will end on {project_name} "
"servers in LON site too. On the other hand, for the American users, all the "
"{project_name} requests, application requests and backchannel requests will "
"be processed on NYC site."
msgstr ""
"たとえば、ロンドンとニューヨークの2つのサイトがあります。 "
"アプリケーションがロンドンサイトとニューヨークサイトの両方に配備されている場合は、ロンドンユーザーからのすべてのユーザー・リクエストがロンドンサイトのアプリケーションとロンドンサイトの{project_name}サーバーにリダイレクトされるようにすることができます。"
" ロンドンサイトのクライアント・デプロイメントからのバックチャネル・リクエストは、ロンドンサイトの{project_name}サーバーでも終了します。 "
"一方、米国のユーザーの場合、すべての{project_name}リクエスト、アプリケーション・リクエスト、バックチャネル・リクエストはニューヨークサイトで処理されます。"

msgid ""
"For `offlineSessions` and `offlineClientSessions` it is similar, with the "
"difference that you even don't need to backup them at all if you never plan "
"to use offline tokens for any of your client applications."
msgstr ""
"`offlineSessions` と `offlineClientSessions` "
"に対して、それは類似していますが、クライアント・アプリケーションのいずれに対してもオフライン・トークンを使用する予定ががない場合、それらをバックアップする必要はまったくありません。"

msgid ""
"Generally, if you are in doubt and performance is not a blocker for you, "
"it's safer to keep the caches in `SYNC` strategy."
msgstr "一般的に、懸念があり、パフォーマンスがブロッカーではない場合は、キャッシュを `SYNC` 方式に保持する方が安全です。"

msgid ""
"Regarding the switch to SYNC/ASYNC backup, make sure that you edit the "
"`strategy` attribute of the `backup` element. For example like this:"
msgstr ""
"SYNC/ASYNCバックアップへの切り替えに関しては、 `backup` 要素の `strategy` "
"属性を編集してください。たとえば、次のようになります。"

msgid "<backup site=\"site2\" failure-policy=\"FAIL\" strategy=\"ASYNC\" enabled=\"true\">"
msgstr "<backup site=\"site2\" failure-policy=\"FAIL\" strategy=\"ASYNC\" enabled=\"true\">"

msgid "Note the `mode` attribute of cache-configuration element."
msgstr "cache-configuration要素の `mode` 属性に注意してください。"

msgid "Troubleshooting"
msgstr "トラブルシューティング"

msgid ""
"The following tips are intended to assist you should you need to "
"troubleshoot:"
msgstr "以下のヒントは、トラブルシューティングが必要な場合に役立ちます。"

msgid ""
"We recommend that you go through the procedure for xref:assembly-setting-up-"
"crossdc[Setting up cross-site replication] and have this one working first, "
"so that you have some understanding of how things work. It is also wise to "
"read this entire document to have some understanding of things."
msgstr ""

msgid ""
"For the {project_name} servers, you should see a message such as this during"
" the server startup:"
msgstr ""

msgid ""
"18:09:30,156 INFO  [org.keycloak.connections.infinispan.DefaultInfinispanConnectionProviderFactory] (ServerService Thread Pool -- 54)\n"
"Node name: node11, Site name: site1"
msgstr ""
"18:09:30,156 INFO  [org.keycloak.connections.infinispan.DefaultInfinispanConnectionProviderFactory] (ServerService Thread Pool -- 54)\n"
"Node name: node11, Site name: site1"

msgid ""
"Check that the site name and the node name looks as expected during the "
"startup of {project_name} server."
msgstr "{project_name}サーバーの起動時に、サイト名とノード名が想定どおりに表示されていることを確認してください。"

msgid ""
"Check that {project_name} servers are in cluster as expected, including that"
" only the {project_name} servers from the same data center are in cluster "
"with each other. This can be also checked in JConsole through the GMS view."
msgstr ""

msgid ""
"If there are exceptions during startup of {project_name} server like this:"
msgstr "{project_name}サーバーの起動時に次のような例外が発生した場合、"

msgid ""
"17:33:58,605 ERROR [org.infinispan.client.hotrod.impl.operations.RetryOnFailureOperation] (ServerService Thread Pool -- 59) ISPN004007: Exception encountered. Retry 10 out of 10: org.infinispan.client.hotrod.exceptions.TransportException:: Could not fetch transport\n"
"...\n"
"Caused by: org.infinispan.client.hotrod.exceptions.TransportException:: Could not connect to server: 127.0.0.1:12232\n"
"\tat org.infinispan.client.hotrod.impl.transport.tcp.TcpTransport.<init>(TcpTransport.java:82)\n"
msgstr ""
"17:33:58,605 ERROR [org.infinispan.client.hotrod.impl.operations.RetryOnFailureOperation] (ServerService Thread Pool -- 59) ISPN004007: Exception encountered. Retry 10 out of 10: org.infinispan.client.hotrod.exceptions.TransportException:: Could not fetch transport\n"
"...\n"
"Caused by: org.infinispan.client.hotrod.exceptions.TransportException:: Could not connect to server: 127.0.0.1:12232\n"
"\tat org.infinispan.client.hotrod.impl.transport.tcp.TcpTransport.<init>(TcpTransport.java:82)\n"

msgid ""
"it usually means that {project_name} server is not able to reach the "
"{jdgserver_name} server in his own datacenter. Make sure that firewall is "
"set as expected and {jdgserver_name} server is possible to connect."
msgstr ""
"これは通常、{project_name}サーバーが自身のデータセンター内の{jdgserver_name}サーバーにアクセスできないことを意味します。ファイアウォールが期待どおりに設定され、{jdgserver_name}サーバーが接続可能であることを確認してください。"

msgid ""
"16:44:18,321 WARN  [org.infinispan.client.hotrod.impl.protocol.Codec21] (ServerService Thread Pool -- 57) ISPN004005: Error received from the server: javax.transaction.RollbackException: ARJUNA016053: Could not commit transaction.\n"
" ..."
msgstr ""
"16:44:18,321 WARN  [org.infinispan.client.hotrod.impl.protocol.Codec21] (ServerService Thread Pool -- 57) ISPN004005: Error received from the server: javax.transaction.RollbackException: ARJUNA016053: Could not commit transaction.\n"
" ..."

msgid ""
"then check the log of corresponding {jdgserver_name} server of your site and"
" check if has failed to backup to the other site. If the backup site is "
"unavailable, then it is recommended to switch it offline, so that "
"{jdgserver_name} server won't try to backup to the offline site causing the "
"operations to pass successfully on {project_name} server side as well. See "
"<<administration>> for more information."
msgstr ""
"サイトの該当する{jdgserver_name}サーバーのログをチェックし、他のサイトへのバックアップに失敗したかどうかを確認します。バックアップ・サイトが利用できない場合は、{jdgserver_name}サーバーがオフラインサイトにバックアップしようとしないようにオフラインに切り替えて、{project_name}サーバー側で正常に操作が成功するようにすることをお勧めします。詳細については、"
" <<administration>> を参照してください。"

msgid ""
"Check the Infinispan statistics, which are available through JMX. For "
"example, try to login and then see if the new session was successfully "
"written to both {jdgserver_name} servers and is available in the `sessions` "
"cache there. This can be done indirectly by checking the count of elements "
"in the `sessions` cache for the MBean `jboss.datagrid-"
"infinispan:type=Cache,name=\"sessions(repl_sync)\",manager=\"clustered\",component=Statistics`"
" and attribute `numberOfEntries`. After login, there should be one more "
"entry for `numberOfEntries` on both {jdgserver_name} servers on both sites."
msgstr ""
"JMXを介して利用可能なInfinispanの統計を確認してください。たとえば、ログインして、新しいセッションが{jdgserver_name}サーバーの両方に正常に書き込まれたかどうかを確認し、そこの"
" `sessions` キャッシュで利用可能かどうかを確認します。これは、MBean `jboss.datagrid-"
"infinispan:type=Cache,name=\"sessions(repl_sync)\",manager=\"clustered\",component=Statistics`"
" と `numberOfEntries` 属性の `sessions` "
"キャッシュ内の要素の数をチェックすることによって間接的に行うことができます。ログイン後、両方のサイトのそれぞれの{jdgserver_name}サーバーに"
" `numberOfEntries` の1つ以上のエントリーが存在するはずです。"

msgid ""
"If you updated the entity, such as `user`, on {project_name} server on "
"`site1` and you do not see that entity updated on the {project_name} server "
"on `site2`, then the issue can be either in the replication of the "
"synchronous database itself or that {project_name} caches are not properly "
"invalidated. You may try to temporarily disable the {project_name} caches as"
" described link:{installguide_disablingcaching_link}[here] to nail down if "
"the issue is at the database replication level. Also it may help to manually"
" connect to the database and check if data are updated as expected. This is "
"specific to every database, so you will need to consult the documentation "
"for your database."
msgstr ""
"`site1` の{project_name}サーバーで `user` などのエンティティーを更新しても、 `site2` "
"の{project_name}サーバーで更新したエンティティーが表示されない場合は、同期したデータベース自体のレプリケーションか、{project_name}キャッシュが適切に無効化されなかったかのどちらかに問題があります。問題がデータベースのレプリケーション・レベルにある場合は、link:{installguide_disablingcaching_link}[ここ]で説明するように一時的に{project_name}キャッシュを無効化してください。また、データベースに手動で接続し、データが期待どおりに更新されるかどうかを確認するのに役立ちます。これはすべてのデータベースに固有のものなので、データベースのドキュメントを参照する必要があります。"

msgid ""
"Sometimes you may see the exceptions related to locks like this in "
"{jdgserver_name} server log:"
msgstr "場合によっては、{jdgserver_name}サーバーログに次のようなロックに関する例外が表示されることがあります。"

msgid ""
"(HotRodServerHandler-6-35) ISPN000136: Error executing command ReplaceCommand,\n"
"writing keys [[B0x033E243034396234..[39]]: org.infinispan.util.concurrent.TimeoutException: ISPN000299: Unable to acquire lock after\n"
"0 milliseconds for key [B0x033E243034396234..[39] and requestor GlobalTx:server1:4353. Lock is held by GlobalTx:server1:4352"
msgstr ""
"(HotRodServerHandler-6-35) ISPN000136: Error executing command ReplaceCommand,\n"
"writing keys [[B0x033E243034396234..[39]]: org.infinispan.util.concurrent.TimeoutException: ISPN000299: Unable to acquire lock after\n"
"0 milliseconds for key [B0x033E243034396234..[39] and requestor GlobalTx:server1:4353. Lock is held by GlobalTx:server1:4352"

msgid ""
"Those exceptions are not necessarily an issue. They may happen anytime when "
"a concurrent edit of the same entity is triggered on both DCs. This is "
"common in a deployment. Usually the {project_name} server is notified about "
"the failed operation and will retry it, so from the user's point of view, "
"there is usually not any issue."
msgstr ""
"これらの例外は必ずしも問題ではありません。両方のデータセンターで同じエンティティーの同時編集がトリガーされると、いつでも発生する可能性があります。これは、デプロイメントの多くの場合に当てはまります。たいてい、{project_name}サーバーは、失敗した操作について通知を受けて再試行するため、ユーザーの観点からは通常問題はありません。"

msgid ""
"If you try to authenticate with {project_name} to your application, but "
"authentication fails with an infinite number of redirects in your browser "
"and you see the errors like this in the {project_name} server log:"
msgstr ""
"{project_name}でアプリケーションに認証しようとすると、ブラウザーの無限のリダイレクトで認証に失敗し、{project_name}サーバーログに次のようなエラーが表示されます。"

msgid ""
"2017-11-27 14:50:31,587 WARN  [org.keycloak.events] (default task-17) "
"type=LOGIN_ERROR, realmId=master, clientId=null, userId=null, "
"ipAddress=aa.bb.cc.dd, error=expired_code, restart_after_timeout=true"
msgstr ""
"2017-11-27 14:50:31,587 WARN  [org.keycloak.events] (default task-17) "
"type=LOGIN_ERROR, realmId=master, clientId=null, userId=null, "
"ipAddress=aa.bb.cc.dd, error=expired_code, restart_after_timeout=true"

msgid ""
"it probably means that your load balancer needs to be set to support sticky "
"sessions. Make sure that the provided route name used during startup of "
"{project_name} server (Property `jboss.node.name`) contains the correct name"
" used by the load balancer server to identify the current server."
msgstr ""
"おそらく、スティッキー・セッションをサポートするようにロードバランサーを設定する必要があることを意味します。{project_name}サーバー起動中に使用される指定されたルート名（プロパティー"
" `jboss.node.name` ）に、 "
"ロードバランサー・サーバーが現在のサーバーを識別するために使用する正しい名前が含まれていることを確認してください。"

msgid ""
"If the {jdgserver_name} `work` cache grows indefinitely, you may be "
"experiencing https://issues.redhat.com/browse/JDG-987[this {jdgserver_name} "
"issue], which is caused by cache items not being properly expired. In that "
"case, update the cache declaration with an empty `<expiration />` tag like "
"this:"
msgstr ""
"{jdgserver_name}の `work` キャッシュが無期限に増加した場合、 "
"https://issues.redhat.com/browse/JDG-987[この{jdgserver_name}の問題] "
"が発生している可能性があります（キャッシュが正しく期限切れになっていないことに起因する問題）。その場合、キャッシュ宣言を次のような空の "
"`<expiration />` タグで更新してください。"

msgid ""
"    <replicated-cache name=\"work\" configuration=\"sessions-cfg\">\n"
"        <expiration />\n"
"    </replicated-cache>"
msgstr ""
"    <replicated-cache name=\"work\" configuration=\"sessions-cfg\">\n"
"        <expiration />\n"
"    </replicated-cache>"

msgid "If you see Warnings in the {jdgserver_name} server log like:"
msgstr "{jdgserver_name}サーバーのログに次のような警告が表示された場合は、"

msgid ""
"18:06:19,687 WARN  [org.infinispan.server.hotrod.Decoder2x] (HotRod-ServerWorker-7-12) ISPN006011: Operation 'PUT_IF_ABSENT' forced to\n"
"  return previous value should be used on transactional caches, otherwise data inconsistency issues could arise under failure situations\n"
"18:06:19,700 WARN  [org.infinispan.server.hotrod.Decoder2x] (HotRod-ServerWorker-7-10) ISPN006010: Conditional operation 'REPLACE_IF_UNMODIFIED' should\n"
"  be used with transactional caches, otherwise data inconsistency issues could arise under failure situations"
msgstr ""
"18:06:19,687 WARN  [org.infinispan.server.hotrod.Decoder2x] (HotRod-ServerWorker-7-12) ISPN006011: Operation 'PUT_IF_ABSENT' forced to\n"
"  return previous value should be used on transactional caches, otherwise data inconsistency issues could arise under failure situations\n"
"18:06:19,700 WARN  [org.infinispan.server.hotrod.Decoder2x] (HotRod-ServerWorker-7-10) ISPN006010: Conditional operation 'REPLACE_IF_UNMODIFIED' should\n"
"  be used with transactional caches, otherwise data inconsistency issues could arise under failure situations"

msgid ""
"you can just ignore them. To avoid the warning, the caches on "
"{jdgserver_name} server side could be changed to transactional caches, but "
"this is not recommended as it can cause some other issues caused by the bug "
"https://issues.redhat.com/browse/ISPN-9323. So for now, the warnings just "
"need to be ignored."
msgstr ""
"それらを無視することができます。この警告を回避するために、{jdgserver_name}サーバー側のキャッシュをトランザクション・キャッシュに変更することができますが、バグ"
" https://issues.redhat.com/browse/ISPN-9323 "
"によって引き起こされるいくつかの他の問題が発生する可能性があるため、これはお勧めしません。したがって、今のところこの警告は無視する必要があります。"

msgid "If you see errors in the {jdgserver_name} server log like:"
msgstr "{jdgserver_name}サーバーのログに次のようなエラーが表示された場合は、"

msgid ""
"12:08:32,921 ERROR [org.infinispan.server.hotrod.CacheDecodeContext] (HotRod-ServerWorker-7-11) ISPN005003: Exception reported: org.infinispan.server.hotrod.InvalidMagicIdException: Error reading magic byte or message id: 7\n"
"\tat org.infinispan.server.hotrod.HotRodDecoder.readHeader(HotRodDecoder.java:184)\n"
"\tat org.infinispan.server.hotrod.HotRodDecoder.decodeHeader(HotRodDecoder.java:133)\n"
"\tat org.infinispan.server.hotrod.HotRodDecoder.decode(HotRodDecoder.java:92)\n"
"\tat io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:411)\n"
"\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248)"
msgstr ""
"12:08:32,921 ERROR [org.infinispan.server.hotrod.CacheDecodeContext] (HotRod-ServerWorker-7-11) ISPN005003: Exception reported: org.infinispan.server.hotrod.InvalidMagicIdException: Error reading magic byte or message id: 7\n"
"\tat org.infinispan.server.hotrod.HotRodDecoder.readHeader(HotRodDecoder.java:184)\n"
"\tat org.infinispan.server.hotrod.HotRodDecoder.decodeHeader(HotRodDecoder.java:133)\n"
"\tat org.infinispan.server.hotrod.HotRodDecoder.decode(HotRodDecoder.java:92)\n"
"\tat io.netty.handler.codec.ByteToMessageDecoder.callDecode(ByteToMessageDecoder.java:411)\n"
"\tat io.netty.handler.codec.ByteToMessageDecoder.channelRead(ByteToMessageDecoder.java:248)"

msgid ""
"and you see some similar errors in the {project_name} log, it can indicate "
"that there are incompatible versions of the Hot Rod protocol being used. "
"This is likely happen when you try to use {project_name} with an old version"
" of the Infinispan server. It will help if you add the `protocolVersion` "
"property as an additional property to the `remote-store` element in the "
"{project_name} configuration file. For example:"
msgstr ""
"また、{project_name}ログに類似のエラーが表示された場合は、互換性のないバージョンのHot "
"Rodプロトコルが使用されていることを示しています。これは、{project_name}を古いバージョンのInfinispanサーバーで使用しようとした場合に発生する可能性があります。{project_name}設定ファイルの"
" `remote-store` 要素に、追加のプロパティーとして `protocolVersion` "
"プロパティーを追加すると役に立ちます。たとえば次のように設定します。"

msgid "<property name=\"protocolVersion\">2.6</property>"
msgstr "<property name=\"protocolVersion\">2.6</property>"

msgid "Managing the subsystem configuration"
msgstr "サブシステム設定の管理"

msgid ""
"Low-level configuration of {project_name} is done by editing the  "
"`standalone.xml`, `standalone-ha.xml`, or `domain.xml` file in your "
"distribution.  The location of this file depends on your <<_operating-mode, "
"operating mode>>."
msgstr ""
"{project_name}の低レベルな設定は、配布物に含まれている `standalone.xml` 、 `standalone-ha.xml` "
"、または `domain.xml` ファイルを編集して行います。このファイルの場所は<<_operating-mode, "
"動作モード>>によって異なります。"

msgid ""
"While there are endless settings you can configure here, this section will "
"focus on configuration of the _keycloak-server_ subsystem.  No matter which "
"configuration file you are using, configuration of the _keycloak-server_ "
"subsystem is the same."
msgstr ""
"ここで設定可能な設定は無限にありますが、このセクションでは  _keycloak-server_ "
"サブシステムの設定について説明します。どの設定ファイルを使用していても、 _keycloak-server_ サブシステムの設定は同じです。"

msgid ""
"The keycloak-server subsystem is typically declared toward the end of the "
"file like this:"
msgstr "keycloak-serverサブシステムは通常、以下のようにファイルの末尾で宣言されています。"

msgid ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:1.1\">\n"
"   <web-context>auth</web-context>\n"
"   ...\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:1.1\">\n"
"   <web-context>auth</web-context>\n"
"   ...\n"
"</subsystem>"

msgid ""
"Note that anything changed in this subsystem will not take effect until the "
"server is rebooted."
msgstr "このサブシステム内での変更はサーバーが再起動されるまで有効になりませんので、注意してください。"

msgid "Configure SPI providers"
msgstr "SPIプロバイダーの設定"

msgid ""
"The specifics of each configuration setting is discussed elsewhere in "
"context with that setting.  However, it is useful to understand the format "
"used to declare settings on SPI providers."
msgstr ""
"各設定の詳細については、その設定と関連する別の箇所で説明します。ただし、SPIプロバイダー設定の宣言に使用される形式について学ぶことをお勧めします。"

msgid ""
"{project_name} is a highly modular system that allows great flexibility.  "
"There are more than 50 service provider interfaces (SPIs), and you are "
"allowed to swap out implementations of each SPI.  An implementation of an "
"SPI is known as a _provider_."
msgstr ""
"{project_name}は、柔軟性に優れた、高度なモジュールシステムです。50以上のサービス・プロバイダー・インターフェイス（いわゆるSPI）があり、各SPIの実装を交換することができます。SPIの実装は"
" _provider_ によって行われます。"

msgid ""
"All elements in an SPI declaration are optional, but a full SPI declaration"
"  looks like this:"
msgstr "SPI宣言のすべての要素は任意で選択できるものですが、完全なSPI宣言は以下のようになります。"

msgid ""
"<spi name=\"myspi\">\n"
"    <default-provider>myprovider</default-provider>\n"
"    <provider name=\"myprovider\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"foo\" value=\"bar\"/>\n"
"        </properties>\n"
"    </provider>\n"
"    <provider name=\"mysecondprovider\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"foo\" value=\"foo\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"myspi\">\n"
"    <default-provider>myprovider</default-provider>\n"
"    <provider name=\"myprovider\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"foo\" value=\"bar\"/>\n"
"        </properties>\n"
"    </provider>\n"
"    <provider name=\"mysecondprovider\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"foo\" value=\"foo\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid ""
"Here we have two providers defined for the SPI `myspi`.  The `default-"
"provider` is listed as `myprovider`.  However it is up to the SPI to decide "
"how it will treat this setting.  Some SPIs allow more than one provider and "
"some do not.  So `default-provider` can help the SPI to choose."
msgstr ""
"ここでは、 `myspi` というSPIに2つのプロバイダーが定義されています。 `default-provider` は `myprovider` "
"と表示されています。しかし、この設定をどのように処理するかはSPIが決定します。SPIによって複数のプロバイダーを許可するものもあれば、そうでないものもあります。そのため、"
" `default-provider` はSPIの選択の手助けになります。"

msgid ""
"Also notice that each provider defines its own set of configuration "
"properties. The fact that both providers above have a property called `foo` "
"is just a coincidence."
msgstr ""
"また、各プロバイダーが独自の設定プロパティーを定義することについても注意してください。上記の両方のプロバイダーが `foo` "
"というプロパティーを持っている点は単なる偶然です。"

msgid ""
"The type of each property value is interpreted by the provider.  However, "
"there is one exception.  Consider the `jpa` provider for the `eventsStore` "
"SPI:"
msgstr ""
"プロパティー値のタイプはそれぞれプロバイダーによって解釈されます。ただし、1つ例外があります。 `eventsStore` のSPIの `jpa` "
"プロバイダーについて確認してみましょう。"

msgid ""
"<spi name=\"eventsStore\">\n"
"    <provider name=\"jpa\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"exclude-events\" value=\"[&quot;EVENT1&quot;,\n"
"                                                    &quot;EVENT2&quot;]\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"eventsStore\">\n"
"    <provider name=\"jpa\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"exclude-events\" value=\"[&quot;EVENT1&quot;,\n"
"                                                    &quot;EVENT2&quot;]\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid ""
"We see that the value begins and ends with square brackets.  That means that"
" the value will be passed to the provider as a list.  In this example, the "
"system will pass the provider a list with two element values _EVENT1_ and "
"_EVENT2_. To add more values to the list, just separate each list element "
"with a comma. Unfortunately, you do need to escape the quotes surrounding "
"each list element with `\\&quot;`."
msgstr ""
"この値は角括弧で始まり、角括弧で終わることが分かります。これは、値がリストとしてプロバイダーに渡されることを意味します。このサンプルでは、2つの要素値 "
"_EVENT1_ と _EVENT2_ "
"のリストはシステムからプロバイダーに渡されます。リストに値を追加するには、各リスト要素をカンマで区切ります。残念ながら、各リスト要素を囲む引用符を "
"`\\&quot;` にエスケープする必要があります。"

msgid ""
"Follow the steps in "
"link:{developerguide_link}#_providers[{developerguide_name}] for more "
"details on custom providers and the configuration of providers."
msgstr ""
"カスタム・プロバイダーとプロバイダーの設定の詳細については、link:{developerguide_link}#_providers[{developerguide_name}]"
" の手順に従ってください。"

msgid "Starting the {appserver_name} CLI"
msgstr "{appserver_name} CLIの起動"

msgid ""
"Besides editing the configuration by hand, you also have the option of "
"changing the configuration by issuing commands via the _jboss-cli_ tool.  "
"CLI allows you to configure servers locally or remotely.  And it is "
"especially useful when combined with scripting."
msgstr ""
"設定変更は、手作業で編集するだけでなく、 _jboss-cli_ "
"ツールでコマンドを発行して行うこともできます。CLIを使用すると、サーバーをローカルでもリモートでも設定することができます。スクリプティングと組み合わせると特に便利です。"

msgid "To start the {appserver_name} CLI, you need to run `jboss-cli`."
msgstr "{appserver_name}CLIを起動するには、 `jboss-cli` を実行する必要があります。"

msgid "$ .../bin/jboss-cli.sh"
msgstr "$ .../bin/jboss-cli.sh"

msgid "> ...\\bin\\jboss-cli.bat"
msgstr "> ...\\bin\\jboss-cli.bat"

msgid "This will bring you to a prompt like this:"
msgstr "これを実行すると、以下のようにプロンプトが表示されます。"

msgid "Prompt"
msgstr "Prompt"

msgid "[disconnected /]"
msgstr "[disconnected /]"

msgid ""
"If you wish to execute commands on a running server, you will first execute "
"the `connect` command."
msgstr "実行中のサーバーでコマンドを実行する場合、まず `connect` コマンドを実行します。"

msgid "connect"
msgstr "接続"

msgid ""
"[disconnected /] connect\n"
"connect\n"
"[standalone@localhost:9990 /]"
msgstr ""
"[disconnected /] connect\n"
"connect\n"
"[standalone@localhost:9990 /]"

msgid ""
"You may be thinking to yourself, \"I didn't enter in any username or "
"password!\".  If you run `jboss-cli` on the same machine as your running "
"standalone server or domain controller and your account has appropriate file"
" permissions, you do not have to setup or enter in an admin username and "
"password.  See the "
"link:{appserver_admindoc_link}[_{appserver_admindoc_name}_] for more details"
" on how to make things more secure if you are uncomfortable with that setup."
msgstr ""
"ここでユーザー名もパスワードも入力していないと思うかもしれませんが、 `jboss-cli` "
"を実行中のスタンドアローン・サーバーまたはドメイン・コントローラーと同じマシンで実行し、アカウントに適切なファイル・アクセス権限がある場合は、管理者のユーザー名とパスワードを設定または入力する必要はありません。この設定では心配で、よりセキュアにしたい場合の詳細は、link:{appserver_admindoc_link}[_{appserver_admindoc_name}_]を参照してください。"

msgid "CLI embedded mode"
msgstr "CLI組み込みモード"

msgid ""
"If you do happen to be on the same machine as your standalone server and you"
" want to issue commands while the server is not active, you can embed the "
"server into CLI and make changes in a special mode that disallows incoming "
"requests.  To do this, first execute the `embed-server` command with the "
"config file you wish to change."
msgstr ""
"サーバーがアクティブではない間にスタンドアローン・サーバーと同じマシン上にコマンドが発行された場合は、サーバーをCLIに組み込み、受信要求を許可しない特殊モードに変更することができます。これを行うには、まず、変更したい設定ファイルで"
" `embed-server` コマンドを実行します。"

msgid "embed-server"
msgstr "embed-server"

msgid ""
"[disconnected /] embed-server --server-config=standalone.xml\n"
"[standalone@embedded /]"
msgstr ""
"[disconnected /] embed-server --server-config=standalone.xml\n"
"[standalone@embedded /]"

msgid "Using CLI GUI mode"
msgstr "CLI GUIモードの使用"

msgid ""
"The CLI can also run in GUI mode.  GUI mode launches a Swing application "
"that allows you to graphically view and edit the entire management model of "
"a _running_ server. GUI mode is especially useful when you need help "
"formatting your CLI commands and learning about the options available.  The "
"GUI can also retrieve server logs from a local or remote server."
msgstr ""
"CLIはGUIモードでも実行できます。GUIモードでは、実行中のサーバーの管理モデル全体をグラフィカルに表示および編集できるSwingアプリケーションが起動します。GUIモードは、CLIコマンドの書式を設定したり、オプションを調べる際のヘルプとして特に便利です。GUIは、ローカルまたはリモートサーバーからサーバーログを取得することもできます。"

msgid "Start the CLI in GUI mode"
msgstr "GUIモードでのCLIの起動"

msgid "$ .../bin/jboss-cli.sh --gui"
msgstr "$ .../bin/jboss-cli.sh --gui"

msgid ""
"Note: to connect to a remote server, you pass the `--connect` option as "
"well. Use the --help option for more details."
msgstr ""
"注意: リモートサーバーに接続するには、 `--connect` オプションも渡します。詳しくは、 --helpオプションを参照してください。"

msgid "Scroll down to find the node `subsystem=keycloak-server`."
msgstr "スクロールダウンして、 `subsystem=keycloak-server` というノードを見つけます。"

msgid "Right-click the node and select `Explore subsystem=keycloak-server`."
msgstr "ノードを右クリックして、 `Explore subsystem=keycloak-server` を選択します。"

msgid "A new tab displays only the keycloak-server subsystem."
msgstr "新しいタブには、keycloak-serverサブシステムのみが表示されます。"

msgid "keycloak-server subsystem"
msgstr "keycloak-serverサブシステム"

msgid "image:images/cli-gui.png[keycloak-server subsystem]"
msgstr "image:images/cli-gui.png[keycloak-server subsystem]"

msgid "CLI scripting"
msgstr "CLIスクリプティング"

msgid ""
"The CLI has extensive scripting capabilities.  A script is just a text file "
"with CLI commands in it.  Consider a simple script that turns off theme and "
"template caching."
msgstr ""
"CLIには、さまざまなスクリプト機能があります。スクリプトはCLIコマンドを含む単なるテキストファイルです。テーマとテンプレートのキャッシュをオフにする簡単なスクリプトを見ていきましょう。"

msgid "turn-off-caching.cli"
msgstr "turn-off-caching.cli"

msgid ""
"/subsystem=keycloak-server/theme=defaults/:write-attribute(name=cacheThemes,value=false)\n"
"/subsystem=keycloak-server/theme=defaults/:write-attribute(name=cacheTemplates,value=false)"
msgstr ""
"/subsystem=keycloak-server/theme=defaults/:write-attribute(name=cacheThemes,value=false)\n"
"/subsystem=keycloak-server/theme=defaults/:write-attribute(name=cacheTemplates,value=false)"

msgid ""
"To execute the script, you can follow the `Scripts` menu in CLI GUI, or "
"execute the script from the command line as follows:"
msgstr ""
"スクリプトを実行するには、CLI GUIの `Scripts` メニューに従うか、または以下のようにコマンドラインからスクリプトを実行します。"

msgid "$ .../bin/jboss-cli.sh --file=turn-off-caching.cli"
msgstr "$ .../bin/jboss-cli.sh --file=turn-off-caching.cli"

msgid "CLI recipes"
msgstr "CLIレシピ"

msgid ""
"Here are some configuration tasks and how to perform them with CLI commands."
" Note that in all but the first example, we use the wildcard path `**` to "
"mean you should substitute or the path to the keycloak-server subsystem."
msgstr ""
"ここでは、設定タスクおよびそれらをCLIコマンドで実行する方法について説明します。代入すべきという意味で、またはkeycloak-"
"serverサブシステムという意味でワイルドカード・パス `**` を使用しています。その点は注意してください。"

msgid "For standalone, this just means:"
msgstr "スタンドアローンの場合、これは単に以下の意味になります。"

msgid "`**` = `/subsystem=keycloak-server`"
msgstr "`**` = `/subsystem=keycloak-server`"

msgid "For domain mode, this would mean something like:"
msgstr "ドメインモードの場合、これは以下のような意味になります。"

msgid "`**` = `/profile=auth-server-clustered/subsystem=keycloak-server`"
msgstr "`**` = `/profile=auth-server-clustered/subsystem=keycloak-server`"

msgid "Changing the web context of the server"
msgstr "サーバーのwebコンテキストの変更"

msgid ""
"/subsystem=keycloak-server/:write-attribute(name=web-"
"context,value=myContext)"
msgstr ""
"/subsystem=keycloak-server/:write-attribute(name=web-"
"context,value=myContext)"

msgid "Setting the global default theme"
msgstr "グローバルなデフォルトテーマの設定"

msgid "**/theme=defaults/:write-attribute(name=default,value=myTheme)"
msgstr "**/theme=defaults/:write-attribute(name=default,value=myTheme)"

msgid "Adding a new SPI and a provider"
msgstr "新しいSPIとプロバイダーの追加"

msgid ""
"**/spi=mySPI/:add\n"
"**/spi=mySPI/provider=myProvider/:add(enabled=true)"
msgstr ""
"**/spi=mySPI/:add\n"
"**/spi=mySPI/provider=myProvider/:add(enabled=true)"

msgid "Disabling a provider"
msgstr "プロバイダーの無効化"

msgid ""
"**/spi=mySPI/provider=myProvider/:write-attribute(name=enabled,value=false)"
msgstr ""
"**/spi=mySPI/provider=myProvider/:write-attribute(name=enabled,value=false)"

msgid "Changing the default provider for an SPI"
msgstr "SPIのデフォルトプロバイダーの変更"

msgid "**/spi=mySPI/:write-attribute(name=default-provider,value=myProvider)"
msgstr "**/spi=mySPI/:write-attribute(name=default-provider,value=myProvider)"

msgid "Configuring the dblock SPI"
msgstr "dblock SPIの設定"

msgid ""
"**/spi=dblock/:add(default-provider=jpa)\n"
"**/spi=dblock/provider=jpa/:add(properties={lockWaitTimeout => \"900\"},enabled=true)"
msgstr ""
"**/spi=dblock/:add(default-provider=jpa)\n"
"**/spi=dblock/provider=jpa/:add(properties={lockWaitTimeout => \"900\"},enabled=true)"

msgid "Adding or changing a single property value for a provider"
msgstr "プロバイダーのシングル・プロパティー値の追加または変更"

msgid ""
"**/spi=dblock/provider=jpa/:map-"
"put(name=properties,key=lockWaitTimeout,value=3)"
msgstr ""
"**/spi=dblock/provider=jpa/:map-"
"put(name=properties,key=lockWaitTimeout,value=3)"

msgid "Remove a single property from a provider"
msgstr "プロバイダーからのシングル・プロパティーの削除"

msgid ""
"**/spi=dblock/provider=jpa/:map-remove(name=properties,key=lockRecheckTime)"
msgstr ""
"**/spi=dblock/provider=jpa/:map-remove(name=properties,key=lockRecheckTime)"

msgid "Setting values on a provider property of type `List`"
msgstr "`List` 型のプロバイダー・プロパティー値の設定"

msgid ""
"**/spi=eventsStore/provider=jpa/:map-put(name=properties,key=exclude-"
"events,value=[EVENT1,EVENT2])"
msgstr ""
"**/spi=eventsStore/provider=jpa/:map-put(name=properties,key=exclude-"
"events,value=[EVENT1,EVENT2])"

msgid "Profiles"
msgstr "プロファイル"

msgid ""
"There are features in {project_name} that are not enabled by default, these "
"include features that are not fully supported. In addition there are some "
"features that are enabled by default, but that can be disabled."
msgstr ""
"{project_name}には、デフォルトでは有効とされていない機能があり、完全にはサポートされていないものがあります。さらに、デフォルトで有効とされている機能を無効にすることもできます。"

msgid "The features that can be enabled and disabled are:"
msgstr "有効および無効にできる機能は、以下のとおりです。"

msgid "Name"
msgstr "名前"

msgid "Description"
msgstr "説明"

msgid "Enabled by default"
msgstr "デフォルトで有効"

msgid "Support level"
msgstr "サポートレベル"

msgid "account2"
msgstr "account2"

msgid "New Account Management Console"
msgstr "新しいアカウント管理コンソール"

msgid "Yes"
msgstr "Yes"

msgid "Supported"
msgstr "Supported"

msgid "account_api"
msgstr "account_api"

msgid "Account Management REST API"
msgstr "アカウント管理REST API"

msgid "admin_fine_grained_authz"
msgstr "admin_fine_grained_authz"

msgid "Fine-Grained Admin Permissions"
msgstr "きめ細かい管理権限"

msgid "No"
msgstr "No"

msgid "Preview"
msgstr "Preview"

msgid "ciba"
msgstr "ciba"

msgid "OpenID Connect Client Initiated Backchannel Authentication (CIBA)"
msgstr "OpenID Connect Client Initiated Backchannel Authentication (CIBA)"

msgid "client_policies"
msgstr "client_policies"

msgid "Add client configuration policies"
msgstr "クライアント設定ポリシーの追加"

msgid "client_secret_rotation"
msgstr "client_secret_rotation"

msgid "Enables client secret rotation for confidential clients"
msgstr "コンフィデンシャル・クライアントのクライアント・シークレットのローテーションの有効化"

msgid "par"
msgstr "par"

msgid "OAuth 2.0 Pushed Authorization Requests (PAR)"
msgstr "OAuth 2.0 Pushed Authorization Requests（PAR）"

msgid "declarative_user_profile"
msgstr "declarative_user_profile"

msgid "Configure user profiles using a declarative style"
msgstr "宣言型スタイルによるユーザー・プロファイルの設定"

msgid "docker"
msgstr "docker"

msgid "Docker Registry protocol"
msgstr "Dockerレジストリーのプロトコル"

msgid "impersonation"
msgstr "impersonation"

msgid "Ability for admins to impersonate users"
msgstr "管理者がユーザーに成り代わる機能"

msgid "openshift_integration"
msgstr "openshift_integration"

msgid "Extension to enable securing OpenShift"
msgstr "OpenShiftを保護するための拡張"

msgid "recovery_codes"
msgstr "recovery_codes"

msgid "Recovery codes for authentication"
msgstr "認証のリカバリーコード"

msgid "scripts"
msgstr "scripts"

msgid "Write custom authenticators using JavaScript"
msgstr "JavaScriptを使用したカスタム認証の記述"

msgid "step_up_authentication"
msgstr "step_up_authentication"

msgid "Step-up authentication"
msgstr "ステップアップ認証"

msgid "token_exchange"
msgstr "token_exchange"

msgid "Token Exchange Service"
msgstr "Token Exchangサービス"

msgid "upload_scripts"
msgstr "upload_scripts"

msgid "Upload scripts"
msgstr "スクリプトのアップロード"

msgid "Deprecated"
msgstr "非推奨"

msgid "web_authn"
msgstr "web_authn"

msgid "W3C Web Authentication (WebAuthn)"
msgstr "W3C Web Authentication（WebAuthn）"

msgid "update_email"
msgstr ""

msgid "Update Email Workflow"
msgstr ""

msgid "To enable all preview features start the server with:"
msgstr "すべてのプレビュー機能を有効にするには、次のようにサーバーを起動します。"

msgid "bin/standalone.sh|bat -Dkeycloak.profile=preview"
msgstr "bin/standalone.sh|bat -Dkeycloak.profile=preview"

msgid ""
"You can set this permanently by creating the file "
"`standalone/configuration/profile.properties` (or `domain/servers/server-"
"one/configuration/profile.properties` for `server-one` in domain mode). Add "
"the following to the file:"
msgstr ""
"`standalone/configuration/profile.properties` （またはドメインモード内の `server-one` 用の "
"`domain/servers/server-one/configuration/profile.properties` "
"）ファイルを作成することにより、これを永続的に設定することができます。以下をファイルに追加します。"

msgid "profile=preview"
msgstr "profile=preview"

msgid "To enable a specific feature start the server with:"
msgstr "特定の機能を有効にするには、以下のようにサーバーを起動します。"

msgid ""
"bin/standalone.sh|bat -Dkeycloak.profile.feature.<feature name>=enabled"
msgstr ""
"bin/standalone.sh|bat -Dkeycloak.profile.feature.<feature name>=enabled"

msgid ""
"For example to enable Docker use "
"`-Dkeycloak.profile.feature.docker=enabled`."
msgstr ""
"サンプルとして、Dockerを有効にするには `-Dkeycloak.profile.feature.docker=enabled` を使用します。"

msgid ""
"You can set this permanently in the `profile.properties` file by adding:"
msgstr "`profile.properties` ファイルに以下を追加することにより、永続的に設定することができます。"

msgid "feature.docker=enabled"
msgstr "feature.docker=enabled"

msgid "To disable a specific feature start the server with:"
msgstr "特定の機能を無効にするには、以下のようにサーバーを起動します。"

msgid ""
"bin/standalone.sh|bat -Dkeycloak.profile.feature.<feature name>=disabled"
msgstr ""
"bin/standalone.sh|bat -Dkeycloak.profile.feature.<feature name>=disabled"

msgid ""
"For example to disable Impersonation use "
"`-Dkeycloak.profile.feature.impersonation=disabled`."
msgstr ""
"サンプルとして、代理ログイン機能を無効にするには `-Dkeycloak.profile.feature.impersonation=disabled`"
" を使用します。"

msgid "feature.impersonation=disabled"
msgstr "feature.impersonation=disabled"

msgid "Setting up the relational database"
msgstr "リレーショナル・データベースの設定"

msgid ""
"{project_name} comes with its own embedded Java-based relational database "
"called H2. This is the default database that {project_name} will use to "
"persist data and really only exists so that you can run the authentication "
"server out of the box.  We highly recommend that you replace it with a more "
"production ready external database.  The H2 database is not very viable in "
"high concurrency situations and should not be used in a cluster either.  The"
" purpose of this chapter is to show you how to connect {project_name} to a "
"more mature database."
msgstr ""
"{project_name}には、H2というJavaベースのリレーショナル・データベースが組み込まれています。これは、{project_name}がデータを保存するために使用するデフォルトのデータベースで、単に認証サーバーをそのまま実行できるように組み込まれただけのものです。そのため、プロダクション用の外部データベースに置き換えることを強くお勧めします。H2データベースは並行性の高いシチュエーションではあまり実用的ではないので、クラスター内でも使用しないでください。この章では、{project_name}をより成熟度の高いデータベースに接続する方法を説明します。"

msgid ""
"{project_name} uses two layered technologies to persist its relational data."
"  The bottom layered technology is JDBC.  JDBC is a Java API that is used to"
" connect to a RDBMS.  There are different JDBC drivers per database type "
"that are provided by your database vendor.  This chapter discusses how to "
"configure {project_name} to use one of these vendor-specific drivers."
msgstr ""
"{project_name}では、リレーショナル・データを保存するために2つの階層化技術が使用されます。最下層の技術はJDBCです。JDBCは、RDBMSへの接続に使用されるJavaAPIです。データベース・ベンダーによって提供されるデータベース・タイプ毎に、さまざまなJDBCドライバーがあります。この章では、これらのベンダー固有のドライバーのいずれかを使用するように{project_name}を設定する方法について説明します。"

msgid ""
"The top layered technology for persistence is Hibernate JPA.  This is an "
"object to relational mapping API that maps Java Objects to relational data."
"  Most deployments of {project_name} will never have to touch the "
"configuration aspects of Hibernate, but we will discuss how that is done if "
"you run into that rare circumstance."
msgstr ""
"データを保存するための最上層の技術は、Hibernate "
"JPAです。これは、Javaオブジェクトをリレーショナル・データにマップするORマッピングAPIの1つです。{project_name}のデプロイメントで、Hibernateの設定に触れる必要はほとんどありませんが、そのまれなケースに遭遇した場合どうなるかを説明します。"

msgid ""
"Datasource configuration is covered much more thoroughly in "
"link:{appserver_datasource_link}[the datasource configuration chapter]"
"        in the _{appserver_admindoc_name}_."
msgstr ""
"データソースの設定については、 _{appserver_admindoc_name}_ "
"の中のデータソース設定の章link:{appserver_datasource_link}[the datasource configuration "
"chapter]で詳しく説明しています。"

msgid "Database setup checklist"
msgstr "データベース設定のチェックリスト"

msgid ""
"Following are the steps you perform to get an RDBMS configured for "
"{project_name}."
msgstr "以下は、{project_name}にRDBMSを設定するために行う手順です。"

msgid "Locate and download a JDBC driver for your database"
msgstr "データベース用のJDBCドライバーの検索とダウンロード"

msgid ""
"Package the driver JAR into a module and install this module into the server"
msgstr "ドライバーのJARをモジュールにパッケージ化し、このモジュールをサーバーにインストール"

msgid "Declare the JDBC driver in the configuration profile of the server"
msgstr "サーバーの設定プロファイルでJDBCドライバーを宣言"

msgid "Modify the datasource configuration to use your database's JDBC driver"
msgstr "データベースのJDBCドライバーを使用するようにデータソース設定を変更"

msgid ""
"Modify the datasource configuration to define the connection parameters to "
"your database"
msgstr "データベースへの接続パラメーターを定義するようにデータソース設定を変更"

msgid ""
"This chapter will use PostgresSQL for all its examples.  Other databases "
"follow the same steps for installation."
msgstr "この章では、すべてのサンプルにおいてPostgreSQLを使用します。他のデータベースも同じ手順でインストールできます。"

msgid "Packaging the JDBC driver"
msgstr "JDBCドライバーのパッケージ化"

msgid ""
"Find and download the JDBC driver JAR for your RDBMS. Before you can use "
"this driver, you must package it up into a module and install it into the "
"server. Modules define JARs that are loaded into the {project_name} "
"classpath and the dependencies those JARs have on other modules."
msgstr ""
"RDBMS用のJDBCドライバーのJARを検索してダウンロードします。このドライバーを使用する前に、モジュールにパッケージ化してサーバーにインストールする必要があります。モジュールによって、{project_name}のクラスパスにロードされるJAR、およびこれらのJARが他のモジュールに持つ依存関係が定義されます。"

msgid ""
"Create a directory structure to hold your module definition within the "
"_.../modules/_ directory of your {project_name} distribution."
msgstr ""
" {project_name}配布ファイルの _.../modules/_ "
"ディレクトリー内に、モジュールの定義を格納するディレクトリー構造を作成してください。"

msgid ""
"The convention is use the Java package name of the JDBC driver for the name "
"of the directory structure. For PostgreSQL, create the directory "
"_org/postgresql/main_."
msgstr ""
"ディレクトリー構造の名前には、JDBCドライバーのJavaパッケージ名を使うのが一般的です。PostgreSQLの場合は、 "
"_org/postgresql/main_ というディレクトリーを作成します。"

msgid ""
"Copy your database driver JAR into this directory and create an empty "
"_module.xml_ file within it too."
msgstr "データベース・ドライバーのJARをこのディレクトリーにコピーし、その中に空の _module.xml_ ファイルを作成します。"

msgid "Module Directory"
msgstr "モジュール・ディレクトリー"

msgid "image:{project_images}/db-module.png[Module Directory]"
msgstr "image:{project_images}/db-module.png[Module Directory]"

msgid "Open up the _module.xml_ file and create the following XML:"
msgstr "_module.xml_ ファイルを開き、以下のようなXMLを作成します。"

msgid "Module XML"
msgstr "モジュールXML"

msgid ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<module xmlns=\"urn:jboss:module:1.3\" name=\"org.postgresql\">\n"
"\n"
"    <resources>\n"
"        <resource-root path=\"postgresql-VERSION.jar\"/>\n"
"    </resources>\n"
"\n"
"    <dependencies>\n"
"        <module name=\"javax.api\"/>\n"
"        <module name=\"javax.transaction.api\"/>\n"
"    </dependencies>\n"
"</module>"
msgstr ""
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n"
"<module xmlns=\"urn:jboss:module:1.3\" name=\"org.postgresql\">\n"
"\n"
"    <resources>\n"
"        <resource-root path=\"postgresql-VERSION.jar\"/>\n"
"    </resources>\n"
"\n"
"    <dependencies>\n"
"        <module name=\"javax.api\"/>\n"
"        <module name=\"javax.transaction.api\"/>\n"
"    </dependencies>\n"
"</module>"

msgid ""
"The module name should match the directory structure of your module. So, "
"_org/postgresql_ maps to `org.postgresql`."
msgstr ""
"モジュール名は、モジュールのディレクトリー構造と一致していなければなりません。たとえば、 _org/postgresql_ は "
"`org.postgresql` に対応します。"

msgid ""
"The `resource-root path` attribute should specify the JAR filename of the "
"driver."
msgstr "`resource-root path` 属性は、ドライバーのJARファイル名を指定します。"

msgid ""
"The rest are just the normal dependencies that any JDBC driver JAR would "
"have."
msgstr "残りの部分は、JDBCドライバーのJARが持っている通常の依存関係です。"

msgid "Declaring and loading the JDBC driver"
msgstr "JDBCドライバーの宣言とロード"

msgid ""
"You declare your JDBC into your deployment profile so that it loads and "
"becomes available when the server boots up."
msgstr "JDBCをデプロイメント・プロファイルに宣言し、サーバー起動時にロードして利用できるようにします。"

msgid "You have packaged the JDBC driver."
msgstr "JDBCドライバーをパッケージ化しました。"

msgid ""
"Declare your JDBC driver by editing one of these files based on your "
"deployment mode:"
msgstr "デプロイメント・モードに応じて、これらのファイルのいずれかを編集し、JDBCドライバーを宣言します。"

msgid ""
"For standalone mode, edit _.../standalone/configuration/standalone.xml_."
msgstr ""
"スタンドアローン・モードでは、  _.../standalone/configuration/standalone.xml_ を編集します。"

msgid ""
"For standalone clustering mode, edit "
"_.../standalone/configuration/standalone-ha.xml_."
msgstr ""
"スタンドアローン・クラスタリング・モードの場合は、 _.../standalone/configuration/standalone-ha.xml_ "
"を編集してください。"

msgid "For domain mode, edit _.../domain/configuration/domain.xml_."
msgstr "ドメインモードの場合は、 _.../domain/configuration/domain.xml_ を編集します。"

msgid ""
"In domain mode, make sure you edit the profile you are using: either `auth-"
"server-standalone` or `auth-server-clustered`"
msgstr ""
"ドメインモードでは、使用しているプロファイル（ `auth-server-standalone` または `auth-server-clustered`"
" のいずれか）を編集することを確認してください。"

msgid ""
"Within the profile, search for the `drivers` XML block within the "
"`datasources` subsystem."
msgstr "プロファイル内で、 `datasources` サブシステム内の `drivers` XMLブロックを検索します。"

msgid ""
"You should see a pre-defined driver declared for the H2 JDBC driver. This is"
" where you'll declare the JDBC driver for your external database."
msgstr "H2 JDBCドライバーの定義済みのドライバーが宣言されているはずです。ここでは、外部データベースのJDBCドライバーを宣言します。"

msgid "JDBC Drivers"
msgstr "JDBCドライバー"

msgid ""
"  <subsystem xmlns=\"{subsystem_datasources_xml_urn}\">\n"
"     <datasources>\n"
"       ...\n"
"       <drivers>\n"
"          <driver name=\"h2\" module=\"com.h2database.h2\">\n"
"              <xa-datasource-class>org.h2.jdbcx.JdbcDataSource</xa-datasource-class>\n"
"          </driver>\n"
"       </drivers>\n"
"     </datasources>\n"
"  </subsystem>"
msgstr ""
"  <subsystem xmlns=\"{subsystem_datasources_xml_urn}\">\n"
"     <datasources>\n"
"       ...\n"
"       <drivers>\n"
"          <driver name=\"h2\" module=\"com.h2database.h2\">\n"
"              <xa-datasource-class>org.h2.jdbcx.JdbcDataSource</xa-datasource-class>\n"
"          </driver>\n"
"       </drivers>\n"
"     </datasources>\n"
"  </subsystem>"

msgid "Within the `drivers` XML block, declare an additional JDBC driver."
msgstr "`drivers` のXMLブロック内で、追加のJDBCドライバーを宣言します。"

msgid "Assign any `name` to this driver."
msgstr "このドライバーに任意の `name` を付けます。"

msgid ""
"Specify the `module` attribute which points to the `module` package that you"
" created earlier for the driver JAR."
msgstr "`module` 属性を指定します。この属性は、ドライバーJAR用に以前作成した `module` パッケージを指します。"

msgid "Specify the driver's Java class."
msgstr "ドライバーのJavaクラスを指定します。"

msgid ""
"Here's an example of installing a PostgreSQL driver that lives in the module"
" example defined earlier in this chapter."
msgstr "ここでは、本章の前半で定義したモジュールのサンプルに含まれるPostgreSQLドライバーをインストールする例を紹介します。"

msgid "Declare Your JDBC Drivers"
msgstr "JDBCドライバーの宣言"

msgid ""
"  <subsystem xmlns=\"{subsystem_datasources_xml_urn}\">\n"
"     <datasources>\n"
"       ...\n"
"       <drivers>\n"
"          <driver name=\"postgresql\" module=\"org.postgresql\">\n"
"              <xa-datasource-class>org.postgresql.xa.PGXADataSource</xa-datasource-class>\n"
"          </driver>\n"
"          <driver name=\"h2\" module=\"com.h2database.h2\">\n"
"              <xa-datasource-class>org.h2.jdbcx.JdbcDataSource</xa-datasource-class>\n"
"          </driver>\n"
"       </drivers>\n"
"     </datasources>\n"
"  </subsystem>"
msgstr ""
"  <subsystem xmlns=\"{subsystem_datasources_xml_urn}\">\n"
"     <datasources>\n"
"       ...\n"
"       <drivers>\n"
"          <driver name=\"postgresql\" module=\"org.postgresql\">\n"
"              <xa-datasource-class>org.postgresql.xa.PGXADataSource</xa-datasource-class>\n"
"          </driver>\n"
"          <driver name=\"h2\" module=\"com.h2database.h2\">\n"
"              <xa-datasource-class>org.h2.jdbcx.JdbcDataSource</xa-datasource-class>\n"
"          </driver>\n"
"       </drivers>\n"
"     </datasources>\n"
"  </subsystem>"

msgid "Modifying the {project_name} datasource"
msgstr "{project_name}データソースの変更"

msgid ""
"You modify the existing datasource configuration that {project_name} uses to"
" connect it to your new external database.  You'll do this within the same "
"configuration file and XML block that you registered your JDBC driver in.  "
"Here's an example that sets up the connection to your new database:"
msgstr ""
"{project_name}が新しい外部データベースに接続するために使用する既存のデータソース設定を変更します。これは、JDBCドライバーを登録したのと同じ設定ファイルとXMLブロック内で行います。サンプルとして、新しいデータベースへの接続を設定すると以下のとおりになります。"

msgid ""
"  <subsystem xmlns=\"{subsystem_datasources_xml_urn}\">\n"
"     <datasources>\n"
"       ...\n"
"       <datasource jndi-name=\"java:jboss/datasources/KeycloakDS\" pool-name=\"KeycloakDS\" enabled=\"true\" use-java-context=\"true\">\n"
"           <connection-url>jdbc:postgresql://localhost/keycloak</connection-url>\n"
"           <driver>postgresql</driver>\n"
"           <pool>\n"
"               <max-pool-size>20</max-pool-size>\n"
"           </pool>\n"
"           <security>\n"
"               <user-name>William</user-name>\n"
"               <password>password</password>\n"
"           </security>\n"
"       </datasource>\n"
"        ...\n"
"     </datasources>\n"
"  </subsystem>"
msgstr ""
"  <subsystem xmlns=\"{subsystem_datasources_xml_urn}\">\n"
"     <datasources>\n"
"       ...\n"
"       <datasource jndi-name=\"java:jboss/datasources/KeycloakDS\" pool-name=\"KeycloakDS\" enabled=\"true\" use-java-context=\"true\">\n"
"           <connection-url>jdbc:postgresql://localhost/keycloak</connection-url>\n"
"           <driver>postgresql</driver>\n"
"           <pool>\n"
"               <max-pool-size>20</max-pool-size>\n"
"           </pool>\n"
"           <security>\n"
"               <user-name>William</user-name>\n"
"               <password>password</password>\n"
"           </security>\n"
"       </datasource>\n"
"        ...\n"
"     </datasources>\n"
"  </subsystem>"

msgid "You have already declared your JDBC driver."
msgstr "JDBCドライバーはすでに宣言しています。"

msgid "Search for the `datasource` definition for `KeycloakDS`."
msgstr "`KeycloakDS` の `datasource` 定義を検索します。"

msgid ""
"You'll first need to modify the `connection-url`.  The documentation for "
"your vendor's JDBC implementation should specify the format for this "
"connection URL value."
msgstr ""
"まず `connection-url` を変更する必要があります。この接続URL値の形式は、ベンダーのJDBC実装のドキュメントで指定されています。"

msgid "Define the `driver` you will use."
msgstr "次に、使用する `driver` を定義します。"

msgid ""
"This is the logical name of the JDBC driver you declared in the previous "
"section of this chapter."
msgstr "これは、この章の前のセクションで宣言したJDBCドライバーの論理名になります。"

msgid ""
"It is expensive to open a new connection to a database every time you want "
"to perform a transaction.  To compensate, the datasource implementation "
"maintains a pool of open connections.  The `max-pool-size` specifies the "
"maximum number of connections it will pool. You may want to change the value"
" of this depending on the load of your system."
msgstr ""
"トランザクションを実行するたびにデータベースへの新しい接続を開くのは処理コストがかかります。これを補うために、データソース実装は開いた接続のプールを維持します。"
" `max-pool-size` によって、プールする接続の最大数が指定されます。システムの負荷に応じて、この値を変更することができます。"

msgid ""
"Define the database username and password that is needed to connect to the "
"database.  This step is necessary for at least PostgreSQL. You may be "
"concerned that these credentials are in clear text in the example. Methods "
"exist to obfuscate these credentials, but these methods are beyond the scope"
" of this guide."
msgstr ""
"データベースへの接続に必要なデータベースのユーザー名とパスワードを定義します。このステップは少なくともPostgreSQLでは必要です。この例では、これらのクレデンシャルが平文で表示されていることが気になるかもしれません。これらのクレデンシャルを難読化する方法がありますが、その方法はこのガイドの範囲外です。"

msgid ""
"For more information about datasource features, see "
"link:{appserver_datasource_link}[the datasource configuration chapter] in "
"the _{appserver_admindoc_name}_."
msgstr ""
"データソース機能について、詳しくは _{appserver_admindoc_name}_ "
"内のlink:{appserver_datasource_link}[the datasource configuration "
"chapter]を参照してください。"

msgid "Database Configuration"
msgstr "データベース設定"

msgid ""
"The configuration for this component is found in the `standalone.xml`, "
"`standalone-ha.xml`, or `domain.xml` file in your distribution. The location"
" of this file depends on your <<_operating-mode, operating mode>>."
msgstr ""
"配布物内の `standalone.xml` 、 `standalone-ha.xml` 、 `domain.xml` "
"のいずれかの中にこのコンポーネント用の設定があります。このファイルの場所は<<_operating-mode, 動作モード>>によって異なります。"

msgid "Database Config"
msgstr "データベース設定"

msgid ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:1.1\">\n"
"    ...\n"
"    <spi name=\"connectionsJpa\">\n"
"     <provider name=\"default\" enabled=\"true\">\n"
"         <properties>\n"
"             <property name=\"dataSource\" value=\"java:jboss/datasources/KeycloakDS\"/>\n"
"             <property name=\"initializeEmpty\" value=\"false\"/>\n"
"             <property name=\"migrationStrategy\" value=\"manual\"/>\n"
"             <property name=\"migrationExport\" value=\"${jboss.home.dir}/keycloak-database-update.sql\"/>\n"
"         </properties>\n"
"     </provider>\n"
"    </spi>\n"
"    ...\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:1.1\">\n"
"    ...\n"
"    <spi name=\"connectionsJpa\">\n"
"     <provider name=\"default\" enabled=\"true\">\n"
"         <properties>\n"
"             <property name=\"dataSource\" value=\"java:jboss/datasources/KeycloakDS\"/>\n"
"             <property name=\"initializeEmpty\" value=\"false\"/>\n"
"             <property name=\"migrationStrategy\" value=\"manual\"/>\n"
"             <property name=\"migrationExport\" value=\"${jboss.home.dir}/keycloak-database-update.sql\"/>\n"
"         </properties>\n"
"     </provider>\n"
"    </spi>\n"
"    ...\n"
"</subsystem>"

msgid "Possible configuration options are:"
msgstr "設定可能なオプションは、以下のとおりです。"

msgid "dataSource"
msgstr "dataSource"

msgid "JNDI name of the dataSource"
msgstr "データソースのJNDI名"

msgid "jta"
msgstr "jta"

msgid "boolean property to specify if datasource is JTA capable"
msgstr "データソースがJTA対応かどうか指定するbooleanプロパティー"

msgid "driverDialect"
msgstr "driverDialect"

msgid ""
"Value of database dialect. In most cases you don't need to specify this "
"property as dialect will be autodetected by Hibernate."
msgstr ""
"データベース・ダイアレクトの値。ほとんどの場合、ダイアレクトはHibernateによって自動検出されるため、このプロパティーを指定する必要はありません。"

msgid "initializeEmpty"
msgstr "initializeEmpty"

msgid ""
"Initialize database if empty. If set to false the database has to be "
"manually initialized. If you want to manually initialize the database set "
"migrationStrategy to `manual` which will create a file with SQL commands to "
"initialize the database. Defaults to true."
msgstr ""
"空の場合はデータベースを初期化します。falseに設定する場合、データベースを手動で初期化する必要があります。データベースを手動で初期化するには、migrationStrategyを"
" `manual` に設定し、データベース初期化用のSQLコマンドが書かれたファイルを作成します。デフォルトはtrueになっています。"

msgid "migrationStrategy"
msgstr "migrationStrategy"

msgid ""
"Strategy to use to migrate database. Valid values are `update`, `manual` and"
" `validate`. Update will automatically migrate the database schema. Manual "
"will export the required changes to a file with SQL commands that you can "
"manually execute on the database. Validate will simply check if the database"
" is up-to-date."
msgstr ""
"データベースの移行に使用する戦略。有効な値は `update` 、 `manual` 、 `validate` "
"です。updateは、自動的にデータベース・スキーマを移行します。manualは、データベースに対して手動実行可能な、必要な変更のSQLコマンドが書かれたファイルをエクスポートします。validateは、データベースが最新であるかどうかを単にチェックするものです。"

msgid "migrationExport"
msgstr "migrationExport"

msgid "Path for where to write manual database initialization/migration file."
msgstr "手動によるデータベース初期化または移行用ファイルを書き込む場所のパス。"

msgid "showSql"
msgstr "showSql"

msgid ""
"Specify whether Hibernate should show all SQL commands in the console (false"
" by default).  This is very verbose!"
msgstr ""
"Hibernateがコンソール内にすべてのSQLコマンドを表示するかどうかを指定します（デフォルトはfalse）。これは非常に冗長な出力となります。"

msgid "formatSql"
msgstr "formatSql"

msgid "Specify whether Hibernate should format SQL commands (true by default)"
msgstr "HibernateがSQLコマンドをフォーマットするかどうかを指定します（デフォルトはtrue）。 "

msgid "globalStatsInterval"
msgstr "globalStatsInterval"

msgid ""
"Will log global statistics from Hibernate about executed DB queries and "
"other things. Statistics are always reported to server log at specified "
"interval (in seconds) and are cleared after each report."
msgstr ""
"実行されたDBクエリーなどに関する、Hibernateのグローバル統計情報をログに出力します。統計情報は、秒単位で指定された間隔でサーバーログに常にレポートされ、各レポート後にクリアされます。"

msgid "schema"
msgstr "schema"

msgid "Specify the database schema to use"
msgstr "使用するデータベース・スキーマを指定します。"

msgid ""
"These configuration switches and more are described in the "
"link:{appserver_jpa_link}[_{appserver_jpa_name}_]."
msgstr ""
"これらの設定スイッチなどについては、link:{appserver_jpa_link}[_{appserver_jpa_name}_]で説明します。"

msgid "Unicode considerations for databases"
msgstr "データベースのユニコードに関する考慮事項"

msgid ""
"Database schema in {project_name} only accounts for Unicode strings in the "
"following special fields:"
msgstr "{project_name}のデータベース・スキーマは、以下の特別なフィールドにだけユニコード文字列の使用を許可します。"

msgid ""
"Realms: display name, HTML display name, localization texts (keys and "
"values)"
msgstr "レルム：表示名、HTML表示名、ローカライズテキスト（キーと値）"

msgid "Federation Providers: display name"
msgstr "フェデレーション・プロバイダー：表示名"

msgid "Users: username, given name, last name, attribute names and values"
msgstr "ユーザー：ユーザー名、氏名、属性名、値"

msgid "Groups: name, attribute names and values"
msgstr "グループ：名前、属性名、値"

msgid "Roles: name"
msgstr "ロール：名前"

msgid "Descriptions of objects"
msgstr "オブジェクトの説明"

msgid ""
"Otherwise, characters are limited to those contained in database encoding "
"which is often 8-bit. However, for some database systems, it is possible to "
"enable UTF-8 encoding of Unicode characters and use full Unicode character "
"set in all text fields. Often, this is counterbalanced by shorter maximum "
"length of the strings than in case of 8-bit encodings."
msgstr ""
"上記以外の場合は、8ビットのデータベース・エンコーディングに含まれる文字に制限されます。ただし、データベース・システムによっては、ユニコード文字のUTF-8エンコーディングを有効にし、すべてのテキストフィールド内で完全なユニコード文字セットを使用することができます。これは8ビットエンコーディングの場合よりも文字列の最大長を短くすることによって相殺されます。"

msgid ""
"Some of the databases require special settings to database and/or JDBC "
"driver to be able to handle Unicode characters. Please find the settings for"
" your database below. Note that if a database is listed here, it can still "
"work properly provided it handles UTF-8 encoding properly both on the level "
"of database and JDBC driver."
msgstr ""
"データベースによっては、ユニコード文字を処理できるようにデータベースとJDBCドライバーの両方、またはいずれかに特別な設定をする必要があります。以下のデータベースの設定を確認してください。データベースがここにリストされている場合、データベースとJDBCドライバーの両方のレベルでUTF-8エンコーディングが適切に処理されていれば、正常に動きます。この点には注意してください。"

msgid ""
"Technically, the key criterion for Unicode support for all fields is whether"
" the database allows setting of Unicode character set for `VARCHAR` and "
"`CHAR` fields. If yes, there is a high chance that Unicode will be "
"plausible, usually at the expense of field length. If it only supports "
"Unicode in `NVARCHAR` and `NCHAR` fields, Unicode support for all text "
"fields is unlikely as Keycloak schema uses `VARCHAR` and `CHAR` fields "
"extensively."
msgstr ""
"技術的には、すべてのフィールド内のユニコード・サポートの重要な基準は、データベースによって `VARCHAR` フィールドと `CHAR` "
"フィールドにユニコード文字セットが設定できるかどうかになります。設定できる場合は、通常はフィールド長を犠牲にすることで、ユニコードは妥当となります。 "
"`NVARCHAR` フィールドと `NCHAR` フィールド内のユニコードしかサポートされていない場合は、Keycloakスキーマは "
"`VARCHAR` フィールドと `CHAR` "
"フィールドを広範囲にわたって使用するため、すべてのテキストフィールドのユニコード・サポートはほとんどありません。"

msgid "Oracle database"
msgstr "Oracleデータベース"

msgid ""
"Unicode characters are properly handled provided the database was created "
"with Unicode support in `VARCHAR` and `CHAR` fields (e.g. by using "
"`AL32UTF8` character set as the database character set). No special settings"
" is needed for JDBC driver."
msgstr ""
"`VARCHAR` フィールドと `CHAR` "
"フィールド内でユニコード・サポートを使用してデータベースを作成した場合は、ユニコード文字は適切に処理されます（例： `AL32UTF8` "
"文字セットがデータベース文字セットとして使用された場合）。JDBCドライバーに特別な設定は必要ありません。"

msgid ""
"If the database character set is not Unicode, then to use Unicode characters"
" in the special fields, the JDBC driver needs to be configured with the "
"connection property `oracle.jdbc.defaultNChar` set to `true`. It might be "
"wise, though not strictly necessary, to also set the "
"`oracle.jdbc.convertNcharLiterals` connection property to `true`. These "
"properties can be set either as system properties or as connection "
"properties. Please note that setting `oracle.jdbc.defaultNChar` may have "
"negative impact on performance. For details, please refer to Oracle JDBC "
"driver configuration documentation."
msgstr ""
"データベース文字セットがユニコードではない場合、ユニコード文字を特別なフィールド内で使用するために、JDBCドライバーを設定して接続プロパティー "
"`oracle.jdbc.defaultNChar` を `true` に設定する必要があります。厳密には必須ではないのですが、 "
"`oracle.jdbc.convertNcharLiterals` 接続プロパティーも `true` "
"にしておいた方が賢明です。これらのプロパティーは、システム・プロパティーまたは接続プロパティーとして設定することができます。しかし "
"`oracle.jdbc.defaultNChar` "
"の設定はパフォーマンスに悪影響を与える可能性がありますので、この点は注意してください。詳しくは、Oracle "
"JDBCドライバーの設定ドキュメントを参照してください。"

msgid "Microsoft SQL Server database"
msgstr "Microsoft SQL Serverデータベース"

msgid ""
"Unicode characters are properly handled only for the special fields. No "
"special settings of JDBC driver or database is necessary."
msgstr "ユニコード文字は、特別なフィールドに対してのみ適切に処理されます。JDBCドライバーやデータベースの特別な設定は必要ありません。"

msgid "MySQL database"
msgstr "MySQLデータベース"

msgid ""
"Unicode characters are properly handled provided the database was created "
"with Unicode support in `VARCHAR` and `CHAR` fields in the `CREATE DATABASE`"
" command (e.g. by using `utf8` character set as the default database "
"character set in MySQL 5.5. Please note that `utf8mb4` character set does "
"not work due to different storage requirements to `utf8` character set "
"footnote:[Tracked as https://issues.redhat.com/browse/KEYCLOAK-3873]). Note "
"that in this case, length restriction to non-special fields does not apply "
"because columns are created to accommodate given amount of characters, not "
"bytes. If the database default character set does not allow storing Unicode,"
" only the special fields allow storing Unicode values."
msgstr ""
"`CREATE DATABASE` コマンドで、 `VARCHAR` と `CHAR` "
"のフィールド内のユニコード・サポートを使用してデータベースが作成される場合は、ユニコード文字は適切に処理されます（例：MySQL "
"5.5でデフォルトのデータベース文字セットとして `utf8` 文字セットを使用する場合。 `utf8` "
"文字セットに求められるさまざまなストレージ要件により、 `utf8mb4` 文字セットは動作しませんので注意してください "
"footnote:[https://issues.redhat.com/browse/KEYCLOAK-3873として追跡] "
"）。この場合、バイト数ではなく文字数に合わせて列が作成されるため、通常のフィールドには長さ制限は適用されないことに注意が必要です。データベースのデフォルト文字セットでユニコードの保存が許可されていない場合、特別なフィールドでのみユニコード値の保存が許可されることになります。"

msgid ""
"At the side of JDBC driver settings, it is necessary to add a connection "
"property `characterEncoding=UTF-8` to the JDBC connection settings."
msgstr ""
"JDBCドライバー設定については、JDBC接続設定に接続プロパティー `characterEncoding=UTF-8` を追加する必要があります。"

msgid "PostgreSQL database"
msgstr "PostgreSQLデータベース"

msgid ""
"Unicode is supported when the database character set is `UTF8`. In that "
"case, Unicode characters can be used in any field, there is no reduction of "
"field length for non-special fields. No special settings of JDBC driver is "
"necessary."
msgstr ""
"データベース文字セットが `UTF8` "
"である場合、ユニコードはサポートされます。この場合、ユニコード文字はどのフィールドでも使用することができますが、通常フィールドではフィールド長は短縮されません。JDBCドライバーの特別な設定は必要ありません。"

msgid ""
"The character set of a PostgreSQL database is determined at the time it is "
"created. You can determine the default character set for a PostgreSQL "
"cluster with the SQL command"
msgstr ""
"PostgreSQL "
"Databaseの文字セットは作成時に決定されます。PostgreSQLクラスターのデフォルトの文字セットは以下のSQLコマンドで特定できます。"

msgid "show server_encoding;"
msgstr "show server_encoding;"

msgid ""
"If the default character set is not UTF 8, then you can create the database "
"with UTF8 as its character set like this:"
msgstr "デフォルトの文字セットがUTF-8でない場合は、次のように文字セットとしてUTF-8を使用してデータベースを作成することができます。"

msgid "create database keycloak with encoding 'UTF8';"
msgstr "create database keycloak with encoding 'UTF8';"

msgid "Use of the public hostname"
msgstr "パブリックホスト名の使用"

msgid ""
"{project_name} uses the public hostname for a number of things. For example,"
" in the token issuer fields and URLs sent in password reset emails."
msgstr ""
"{project_name}は、パブリックホスト名をさまざまな用途に使用します。たとえば、トークン発行者のフィールドやパスワードリセットの電子メールで送信されたURLなどです。"

msgid ""
"The Hostname SPI provides a way to configure the hostname for a request. The"
" default provider allows setting a fixed URL for frontend requests, while "
"allowing backend requests to be based on the request URI. It is also "
"possible to develop your own provider in the case the built-in provider does"
" not provide the functionality needed."
msgstr ""
"Hostname "
"SPIは、リクエストのホスト名を設定する方法を提供します。デフォルト・プロバイダーでは、フロントエンドのリクエストに固定のURLを設定でき、バックエンドのリクエストはリクエストURIに基づくことができます。ビルトイン・プロバイダーが必要な機能を提供しない場合、独自のプロバイダーを開発することもできます。"

msgid "Default provider"
msgstr "デフォルト・プロバイダー"

msgid ""
"The default hostname provider uses the configured `frontendUrl` as the base "
"URL for frontend requests (requests from user-agents) and uses the request "
"URL as the basis for backend requests (direct requests from clients)."
msgstr ""
"デフォルトのHostnameプロバイダーは、設定済みの `frontendUrl` "
"をフロントエンド・リクエスト（ユーザー・エージェントからのリクエスト）をベースURLとして使用し、リクエストURLをバックエンド・リクエスト（クライアントからの直接リクエスト）のベースとして使用します。"

msgid ""
"Frontend request do not have to have the same context-path as the Keycloak "
"server. This means you can expose Keycloak on for example "
"`https://auth.example.org` or `https://example.org/keycloak` while "
"internally its URL could be `https://10.0.0.10:8080/auth`."
msgstr ""
"フロントエンド・リクエストは、Keycloakサーバーと同じコンテキストパスを持つ必要はありません。これは、たとえば "
"`https://auth.example.org` または `https://example.org/keycloak` "
"でKeycloakを公開できる一方で、内部的にはURLが `https://10.0.0.10:8080/auth` "
"である可能性があることを意味します。"

msgid ""
"This makes it possible to have user-agents (browsers) send requests to "
"{project_name} through the public domain name, while internal clients can "
"use an internal domain name or IP address."
msgstr ""
"これにより、ユーザー・エージェント（ブラウザー）がパブリック・ドメイン名を介して{project_name}にリクエストを送信し、内部クライアントが内部ドメイン名またはIPアドレスを使用できるようになります。"

msgid ""
"This is reflected in the OpenID Connect Discovery endpoint for example where"
" the `authorization_endpoint` uses the frontend URL, while `token_endpoint` "
"uses the backend URL. As a note here a public client for instance would "
"contact Keycloak through the public endpoint, which would result in the base"
" of `authorization_endpoint` and `token_endpoint` being the same."
msgstr ""
"これは、たとえば、 `authorization_endpoint` がフロントエンドURLを使用し、 `token_endpoint` "
"がバックエンドURLを使用するOpenID Connect "
"Discoveryエンドポイントに反映されます。ここでの注意点は、たとえば、パブリック・クライアントはパブリック・エンドポイントを介してKeycloakにアクセスし、その結果、"
" `authorization_endpoint` と `token_endpoint` のベースが同じになるということです。"

msgid ""
"To set the frontendUrl for Keycloak you can either pass add "
"`-Dkeycloak.frontendUrl=https://auth.example.org` to the startup or you can "
"configure it in `standalone.xml`. See the example below:"
msgstr ""
"KeycloakのfrontendUrlを設定するには、追加の "
"`-Dkeycloak.frontendUrl=https://auth.example.org` を起動時に渡すか、 `standalone.xml`"
" で設定します。以下の例を参照してください。"

msgid ""
"<spi name=\"hostname\">\n"
"    <default-provider>default</default-provider>\n"
"    <provider name=\"default\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"frontendUrl\" value=\"https://auth.example.com\"/>\n"
"            <property name=\"forceBackendUrlToFrontendUrl\" value=\"false\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"hostname\">\n"
"    <default-provider>default</default-provider>\n"
"    <provider name=\"default\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"frontendUrl\" value=\"https://auth.example.com\"/>\n"
"            <property name=\"forceBackendUrlToFrontendUrl\" value=\"false\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid "To update the `frontendUrl` with jboss-cli use the following command:"
msgstr "jboss-cliで `frontendUrl` を更新するには、次のコマンドを使用します。"

msgid ""
"/subsystem=keycloak-server/spi=hostname/provider=default:write-"
"attribute(name=properties.frontendUrl,value=\"https://auth.example.com\")"
msgstr ""
"/subsystem=keycloak-server/spi=hostname/provider=default:write-"
"attribute(name=properties.frontendUrl,value=\"https://auth.example.com\")"

msgid ""
"If you want all requests to go through the public domain name you can force "
"backend requests to use the frontend URL as well by setting "
"`forceBackendUrlToFrontendUrl` to `true`."
msgstr ""
"すべてのリクエストがパブリック・ドメイン名を通過するようにしたい場合は、 `forceBackendUrlToFrontendUrl` を `true`"
" に設定することで、バックエンド・リクエストにもフロントエンドURLを使用させることができます。"

msgid ""
"It is also possible to override the default frontend URL for individual "
"realms. This can be done in the admin console."
msgstr "個々のレルムのデフォルトのフロントエンドURLをオーバーライドすることもできます。これは管理コンソールで実施できます。"

msgid ""
"If you do not want to expose the admin endpoints and console on the public "
"domain use the property `adminUrl` to set a fixed URL for the admin console,"
" which is different to the `frontendUrl`. It is also required to block "
"access to `/auth/admin` externally, for details on how to do that refer to "
"the link:{adminguide_link}[{adminguide_name}]."
msgstr ""
"パブリック・ドメインで管理エンドポイントとコンソールを公開したくない場合は、プロパティー `adminUrl` "
"を使用して、管理コンソールの固定URLを設定します。これは `frontendUrl` とは異なります。また、外部から `/auth/admin` "
"へのアクセスをブロックする必要があります。その方法の詳細については、link:{adminguide_link}[{adminguide_name}]を参照してください。"

msgid "Custom provider"
msgstr "カスタム・プロバイダー"

msgid ""
"To develop a custom hostname provider you need to implement "
"`org.keycloak.urls.HostnameProviderFactory` and "
"`org.keycloak.urls.HostnameProvider`."
msgstr ""
"カスタムのホスト名プロバイダーを開発するには、 `org.keycloak.urls.HostnameProviderFactory` と "
"`org.keycloak.urls.HostnameProvider` を実装する必要があります。"

msgid ""
"Follow the instructions in the Service Provider Interfaces section in "
"link:{developerguide_link}[{developerguide_name}] for more information on "
"how to develop a custom provider."
msgstr ""
"カスタム・プロバイダーの開発方法の詳細については、 link:{developerguide_link}[{developerguide_name}] "
"のサービス・プロバイダー・インターフェイスのセクションの指示に従ってください。"

msgid "Setting up the network"
msgstr "ネットワークの設定"

msgid ""
"The default installation of {project_name} can run with some networking "
"limitations.  For one, all network endpoints bind to `localhost` so the auth"
" server is really only usable on one local machine.  For HTTP based "
"connections, it does not use default ports like 80 and 443.  HTTPS/SSL is "
"not configured out of the box and without it, {project_name} has many "
"security vulnerabilities. Finally, {project_name} may often need to make "
"secure SSL and HTTPS connections to external servers and thus need a trust "
"store set up so that endpoints can be validated correctly.  This chapter "
"discusses all of these things."
msgstr ""
"デフォルトでインストールされている{project_name}には、いくつかのネットワーク上の制限があります。たとえば、すべてのネットワーク・エンドポイントは"
" `localhost` "
"にバインドされるので、認証サーバーは実際には1つのローカルマシンでしか使用できません。HTTPベースの接続では、80や443といったデフォルトのポートは使用しません。HTTPS/SSLは最初から設定されておらず、設定しなければ{project_name}には多くのセキュリティー上の脆弱性があります。最後に、{project_name}はしばしば外部のサーバーと安全なSSLやHTTPS接続を行う必要があるため、エンドポイントが正しく検証されるようにトラスト・ストアを設定する必要があります。本章では、これらすべてについて説明します。"

msgid "Bind addresses"
msgstr "バインドアドレス"

msgid ""
"By default {project_name} binds to the localhost loopback address "
"`127.0.0.1`.  That's not a very useful default if you want the "
"authentication server available on your network.  Generally, what we "
"recommend is that you deploy a reverse proxy or load balancer on a public "
"network and route traffic to individual {project_name} server instances on a"
" private network. In either case though, you still need to set up your "
"network interfaces to bind to something other than `localhost`."
msgstr ""
"デフォルトでは、{project_name}はローカルホストのループバック・アドレス `127.0.0.1` "
"にバインドされています。しかし、利用中のネットワーク上で認証サーバーを使用するには、これはあまり便利なデフォルトではありません。通常は、リバース・プロキシーまたはロードバランサーをパブリック・ネットワークにデプロイし、トラフィックをプライベート・ネットワーク上の個々の{project_name}サーバー・インスタンスにルーティングすることをお勧めします。どちらの場合でも、ネットワーク・インターフェイスを設定して"
" `localhost` 以外のものにバインドする必要があります。"

msgid ""
"Setting the bind address is quite easy and can be done on the command line "
"with either the _standalone.sh_ or _domain.sh_ boot scripts discussed in the"
" <<_operating-mode, Choosing an Operating Mode>> chapter."
msgstr ""
"バインドアドレスの設定は簡単です。<<_operating-mode, 動作モードの選択>>の章で説明した _standalone.sh_ または "
"_domain.sh_ 起動スクリプトを使用して、コマンドライン上で設定することができます。"

msgid "$ standalone.sh -b 192.168.0.5"
msgstr "$ standalone.sh -b 192.168.0.5"

msgid "The `-b` switch sets the IP bind address for any public interfaces."
msgstr "`-b` スイッチにより、パブリック・インターフェイス用のIPバインドアドレスは設定されます。"

msgid ""
"Alternatively, if you don't want to set the bind address at the command "
"line, you can edit the profile configuration of your deployment. Open up the"
" profile configuration file (_standalone.xml_ or _domain.xml_ depending on "
"your <<_operating-mode, operating mode>>) and look for the `interfaces` XML "
"block."
msgstr ""
"また、コマンドラインでバインドアドレスを設定したくない場合はその代わりの方法として、プロファイル設定を編集することもできます。<<_operating-"
"mode, 動作モード>>に応じて _standalone.xml_ または _domain.xml_ "
"になりますが、そのいずれかのプロファイル設定ファイルを開き、XMLブロックの `interfaces` を検索します。"

msgid ""
"    <interfaces>\n"
"        <interface name=\"management\">\n"
"            <inet-address value=\"${jboss.bind.address.management:127.0.0.1}\"/>\n"
"        </interface>\n"
"        <interface name=\"public\">\n"
"            <inet-address value=\"${jboss.bind.address:127.0.0.1}\"/>\n"
"        </interface>\n"
"    </interfaces>"
msgstr ""
"    <interfaces>\n"
"        <interface name=\"management\">\n"
"            <inet-address value=\"${jboss.bind.address.management:127.0.0.1}\"/>\n"
"        </interface>\n"
"        <interface name=\"public\">\n"
"            <inet-address value=\"${jboss.bind.address:127.0.0.1}\"/>\n"
"        </interface>\n"
"    </interfaces>"

msgid ""
"The `public` interface corresponds to subsystems creating sockets that are "
"available publicly.  An example of one of these subsystems is the web layer "
"which serves up the authentication endpoints of {project_name}.  The "
"`management` interface corresponds to sockets opened up by the management "
"layer of the {appserver_name}.  Specifically the sockets which allow you to "
"use the `jboss-cli.sh` command line interface and the {appserver_name} web "
"console."
msgstr ""
"`public` "
"インターフェイスは、公開用ソケットを作成するサブシステムに対応しています。これらのサブシステムのサンプルとしては、{project_name}の認証エンドポイントを提供するwebレイヤーというものがあります。一方、"
" `management` "
"インターフェイスは、{appserver_name}のmanagementレイヤーによって開かれたソケットに対応しています。具体的には、 `jboss-"
"cli.sh` コマンドライン・インターフェイスと{appserver_name}のwebコンソールを使用できるソケットになります。"

msgid ""
"In looking at the `public` interface you see that it has a special string "
"`${jboss.bind.address:127.0.0.1}`.  This string denotes a value `127.0.0.1` "
"that can be overridden on the command line by setting a Java system "
"property, i.e.:"
msgstr ""
"`public` インターフェイスを確認すると、特別な文字列 `${jboss.bind.address:127.0.0.1}` "
"が表示されています。この文字列は、 `127.0.0.1` "
"という値を示していますが、コマンドラインでJavaシステム・プロパティーを設定して上書きすることができます。"

msgid "$ domain.sh -Djboss.bind.address=192.168.0.5"
msgstr "$ domain.sh -Djboss.bind.address=192.168.0.5"

msgid ""
"The `-b` is just a shorthand notation for this command.  So, you can either "
"change the bind address value directly in the profile config, or change it "
"on the command line when you boot up."
msgstr ""
"`-b` "
"は、このコマンドの簡略表記です。したがって、このバインドアドレス値は、プロファイル設定で直接変更、または起動時にコマンドラインで変更することができます。"

msgid ""
"There are many more options available when setting up `interface` "
"definitions. For more information, see link:{appserver_network_link}[the "
"network interface] in the _{appserver_network_name}_."
msgstr ""
"`interface` 定義を設定すると、さらに多くのオプションを使用できます。詳しくは、 _{appserver_network_name}_ 内の "
"link:{appserver_network_link}[network interface] を参照してください。"

msgid "Socket port bindings"
msgstr "ソケット・ポート・バインディング"

msgid ""
"The ports opened for each socket have a pre-defined default that can be "
"overridden at the command line or within configuration. To illustrate this "
"configuration, let's pretend you are running in <<_standalone-"
"mode,standalone mode>> and open up the "
"_.../standalone/configuration/standalone.xml_.  Search for `socket-binding-"
"group`."
msgstr ""
"各ソケット用に開けられたポートには、コマンドラインまたは設定内で上書きできるデフォルト値があらかじめ定義されています。この設定方法を学ぶために、<<_standalone-"
"mode,スタンドアローン・モード>>で実行していると仮定し、 "
"_.../standalone/configuration/standalone.xml_ を開いてみましょう。そして `socket-binding-"
"group` を検索します。"

msgid ""
"    <socket-binding-group name=\"standard-sockets\" default-interface=\"public\" port-offset=\"${jboss.socket.binding.port-offset:0}\">\n"
"        <socket-binding name=\"management-http\" interface=\"management\" port=\"${jboss.management.http.port:9990}\"/>\n"
"        <socket-binding name=\"management-https\" interface=\"management\" port=\"${jboss.management.https.port:9993}\"/>\n"
"        <socket-binding name=\"ajp\" port=\"${jboss.ajp.port:8009}\"/>\n"
"        <socket-binding name=\"http\" port=\"${jboss.http.port:8080}\"/>\n"
"        <socket-binding name=\"https\" port=\"${jboss.https.port:8443}\"/>\n"
"        <socket-binding name=\"txn-recovery-environment\" port=\"4712\"/>\n"
"        <socket-binding name=\"txn-status-manager\" port=\"4713\"/>\n"
"        <outbound-socket-binding name=\"mail-smtp\">\n"
"            <remote-destination host=\"localhost\" port=\"25\"/>\n"
"        </outbound-socket-binding>\n"
"    </socket-binding-group>"
msgstr ""
"    <socket-binding-group name=\"standard-sockets\" default-interface=\"public\" port-offset=\"${jboss.socket.binding.port-offset:0}\">\n"
"        <socket-binding name=\"management-http\" interface=\"management\" port=\"${jboss.management.http.port:9990}\"/>\n"
"        <socket-binding name=\"management-https\" interface=\"management\" port=\"${jboss.management.https.port:9993}\"/>\n"
"        <socket-binding name=\"ajp\" port=\"${jboss.ajp.port:8009}\"/>\n"
"        <socket-binding name=\"http\" port=\"${jboss.http.port:8080}\"/>\n"
"        <socket-binding name=\"https\" port=\"${jboss.https.port:8443}\"/>\n"
"        <socket-binding name=\"txn-recovery-environment\" port=\"4712\"/>\n"
"        <socket-binding name=\"txn-status-manager\" port=\"4713\"/>\n"
"        <outbound-socket-binding name=\"mail-smtp\">\n"
"            <remote-destination host=\"localhost\" port=\"25\"/>\n"
"        </outbound-socket-binding>\n"
"    </socket-binding-group>"

msgid ""
"`socket-bindings` define socket connections that will be opened by the "
"server.  These bindings specify the `interface` (bind address) they use as "
"well as what port number they will open.   The ones you will be most "
"interested in are:"
msgstr ""
"`socket-bindings` によってソケット接続が定義され、サーバーで開かれます。これらのバインディングは、 `interface` "
"のバインドアドレスとポート番号を指定します。最も重要な項目は、以下のとおりです。"

msgid "http"
msgstr "http"

msgid "Defines the port used for {project_name} HTTP connections"
msgstr "{project_name}のHTTP接続に使用されるポートの定義"

msgid "https"
msgstr "https"

msgid "Defines the port used for {project_name} HTTPS connections"
msgstr "{project_name}のHTTPS接続に使用されるポートの定義"

msgid "ajp"
msgstr "ajp"

msgid ""
"This socket binding defines the port used for the AJP protocol.  This "
"protocol is used by Apache HTTPD server in conjunction `mod-cluster` when "
"you are using Apache HTTPD as a load balancer."
msgstr ""
"このソケット・バインディングは、AJPプロトコルに使用されるポートを定義します。このプロトコルは、Apache "
"HTTPDサーバーをロードバランサーとして使用している場合、ApacheHTTPDサーバーによって `mod-cluster` と共に使用されます。"

msgid "management-http"
msgstr "management-http"

msgid ""
"Defines the HTTP connection used by {appserver_name} CLI and web console."
msgstr "{appserver_name} CLIとwebコンソールで使用されるHTTP接続を定義します。"

msgid ""
"When running in <<_domain-mode,domain mode>> setting the socket "
"configurations is a bit trickier as the example _domain.xml_ file has "
"multiple `socket-binding-groups` defined.  If you scroll down to the "
"`server-group` definitions you can see what `socket-binding-group` is used "
"for each `server-group`."
msgstr ""
"<<_domain-mode,ドメインモード>>で実行する場合、 _domain.xml_ ファイルに複数の `socket-binding-"
"groups` が定義されているサンプルと同様に、ソケット設定は少し難しくなります。 `server-group` の定義までスクロールダウンすると、各"
" `server-group` にどの `socket-binding-group` が使用されているのか確認することができます。"

msgid "domain socket bindings"
msgstr "ドメイン・ソケット・バインディング"

msgid ""
"    <server-groups>\n"
"        <server-group name=\"load-balancer-group\" profile=\"load-balancer\">\n"
"            ...\n"
"            <socket-binding-group ref=\"load-balancer-sockets\"/>\n"
"        </server-group>\n"
"        <server-group name=\"auth-server-group\" profile=\"auth-server-clustered\">\n"
"            ...\n"
"            <socket-binding-group ref=\"ha-sockets\"/>\n"
"        </server-group>\n"
"    </server-groups>"
msgstr ""
"    <server-groups>\n"
"        <server-group name=\"load-balancer-group\" profile=\"load-balancer\">\n"
"            ...\n"
"            <socket-binding-group ref=\"load-balancer-sockets\"/>\n"
"        </server-group>\n"
"        <server-group name=\"auth-server-group\" profile=\"auth-server-clustered\">\n"
"            ...\n"
"            <socket-binding-group ref=\"ha-sockets\"/>\n"
"        </server-group>\n"
"    </server-groups>"

msgid ""
"There are many more options available when setting up `socket-binding-group`"
" definitions.  For more information, see link:{appserver_socket_link}[the "
"socket binding group] in the _{appserver_socket_name}_."
msgstr ""
"`socket-binding-group` を定義すると、さらに多くのオプションを使用できるようになります。詳しくは、 "
"_{appserver_socket_name}_ 内の link:{appserver_socket_link}[socket binding "
"group] を参照してください。"

msgid "Setting up HTTPS/SSL"
msgstr "HTTPS/SSLの設定"

msgid ""
"{project_name} is not set up by default to handle SSL/HTTPS.           It is"
" highly recommended that you either enable SSL on the {project_name} server "
"itself or on a reverse proxy in front of the {project_name} server."
msgstr ""
"{project_name}は、デフォルトではSSL/HTTPSを処理するように設定されていません。{project_name}サーバー上、または{project_name}サーバーのフロントにあるリバース・プロキシー上のいずれかでSSLを有効にすることを強くお勧めします。"

msgid ""
"This default behavior is defined by the SSL/HTTPS mode of each "
"{project_name} realm.  This is discussed in more detail in the "
"link:{adminguide_link}[{adminguide_name}], but let's give some context and a"
" brief overview of these modes."
msgstr ""
"このデフォルトの動作は、各{project_name}レルムのSSL/HTTPSモードによって定義されています。これについて詳しくはlink:{adminguide_link}[{adminguide_name}]で説明しますが、これらのモードの関連事項と簡単な概要についてはここで示します。"

msgid "external requests"
msgstr "external requests"

msgid ""
"{project_name} can run out of the box without SSL so long as you stick to "
"private IP addresses like `localhost`, `127.0.0.1`, `10.x.x.x`, "
"`192.168.x.x`, and `172.16.x.x`. If you don't have SSL/HTTPS configured on "
"the server or you try to access {project_name} over HTTP from a non-private "
"IP adress you will get an error."
msgstr ""
"SSLが無効でも、 `localhost` 、 `127.0.0.1` 、 `10.x.x.x` 、 `192.168.x.x` 、 "
"`172.16.x.x` "
"のようなプライベートIPアドレスであれば、{project_name}をそのまま実行することは可能です。サーバーにSSL/HTTPSが設定されていない場合、またはプライベートIPアドレス以外からHTTP経由で{project_name}にアクセスする場合はエラーになります。"

msgid "none"
msgstr "none"

msgid ""
"{project_name} does not require SSL.  This should really only be used in "
"development when you are playing around with things."
msgstr "{project_name}はSSLを要求しません。この設定は、開発段階でいろいろと検証している時にのみ使用すべきです。"

msgid "all requests"
msgstr "all requests"

msgid "{project_name} requires SSL for all IP addresses."
msgstr "{project_name}はすべてのIPアドレスに対してSSLを要求します。"

msgid ""
"The SSL mode for each realm can be configured in the {project_name} admin "
"console."
msgstr "各レルム用のSSLモードは、{project_name}管理コンソール内で設定できます。"

msgid "Enabling SSL/HTTPS for the {project_name} server"
msgstr "{project_name}サーバー用SSL/HTTPSの有効化"

msgid ""
"If you are not using a reverse proxy or load balancer to handle HTTPS "
"traffic for you, you'll need to enable HTTPS for the {project_name} server."
"  This involves"
msgstr ""
"HTTPSトラフィックを処理するためにリバース・プロキシーまたはロードバランサーを使用していない場合、{project_name}サーバー用にHTTPSを有効にする必要があります。これには下記が含まれます。"

msgid ""
"Obtaining or generating a keystore that contains the private key and "
"certificate for SSL/HTTP traffic"
msgstr "SSL/HTTPトラフィック用の秘密鍵と証明書を含むキーストアの取得または生成"

msgid ""
"Configuring the {project_name} server to use this keypair and certificate."
msgstr "このキーペアと証明書を使用するための{project_name}サーバー設定"

msgid "Creating the Certificate and Java Keystore"
msgstr "証明書とJavaキーストアの作成"

msgid ""
"In order to allow HTTPS connections, you need to obtain a self signed or "
"third-party signed certificate and import it into a Java keystore before you"
" can enable HTTPS in the web container where you are deploying the "
"{project_name} Server."
msgstr ""
"HTTPS接続が許可されるには、{project_name}サーバーがデプロイされているWebコンテナー内でHTTPSを有効にする前に、自己署名証明書または第三者署名証明書を取得してJavaキーストアにインポートする必要があります。"

msgid "Self Signed Certificate"
msgstr "自己署名証明書"

msgid ""
"In development, you will probably not have a third party signed certificate "
"available to test a {project_name} deployment so you'll need to generate a "
"self-signed one using the `keytool` utility that comes with the Java JDK."
msgstr ""
"開発段階で、{project_name}の配備をテストするための第三者署名証明書を用意していない場合、Java JDKに付属する `keytool` "
"ユーティリティーを使用して自己署名証明書を生成する必要があります。"

msgid ""
"\n"
"$ keytool -genkey -alias localhost -keyalg RSA -keystore keycloak.jks -validity 10950\n"
"    Enter keystore password: secret\n"
"    Re-enter new password: secret\n"
"    What is your first and last name?\n"
"    [Unknown]:  localhost\n"
"    What is the name of your organizational unit?\n"
"    [Unknown]:  Keycloak\n"
"    What is the name of your organization?\n"
"    [Unknown]:  Red Hat\n"
"    What is the name of your City or Locality?\n"
"    [Unknown]:  Westford\n"
"    What is the name of your State or Province?\n"
"    [Unknown]:  MA\n"
"    What is the two-letter country code for this unit?\n"
"    [Unknown]:  US\n"
"    Is CN=localhost, OU=Keycloak, O=Test, L=Westford, ST=MA, C=US correct?\n"
"    [no]:  yes"
msgstr ""
"\n"
"$ keytool -genkey -alias localhost -keyalg RSA -keystore keycloak.jks -validity 10950\n"
"    Enter keystore password: secret\n"
"    Re-enter new password: secret\n"
"    What is your first and last name?\n"
"    [Unknown]:  localhost\n"
"    What is the name of your organizational unit?\n"
"    [Unknown]:  Keycloak\n"
"    What is the name of your organization?\n"
"    [Unknown]:  Red Hat\n"
"    What is the name of your City or Locality?\n"
"    [Unknown]:  Westford\n"
"    What is the name of your State or Province?\n"
"    [Unknown]:  MA\n"
"    What is the two-letter country code for this unit?\n"
"    [Unknown]:  US\n"
"    Is CN=localhost, OU=Keycloak, O=Test, L=Westford, ST=MA, C=US correct?\n"
"    [no]:  yes"

msgid ""
"When you see the question `What is your first and last name ?`, supply the "
"DNS name of the machine where you are installing the server. For testing "
"purposes, `localhost` should be used. After executing this command, the "
"`keycloak.jks` file will be generated in the same directory as you executed "
"the `keytool` command in."
msgstr ""
"`What is your first and last name ?` という質問には、サーバーをインストールしたマシンのDNS名を答えてください。 "
"テスト目的なので、 `localhost` を使用します。このコマンドを実行すると、 `keytool` コマンドが実行されたのと同じディレクトリー内で"
" `keycloak.jks` ファイルが生成されます。"

msgid ""
"If you want a third-party signed certificate, but don't have one, you can "
"obtain one for free at http://www.cacert.org[cacert.org].  However, you "
"first need to use the following procedure."
msgstr ""
"第三者署名証明書が必要だが用意していない場合、 http://www.cacert.org[cacert.org] "
"から無料で取得することができます。ただし、その前に以下の手順が必要となります。"

msgid "Generate a Certificate Request:"
msgstr "証明書要求の生成"

msgid ""
"$ keytool -certreq -alias yourdomain -keystore keycloak.jks > keycloak.careq"
msgstr ""
"$ keytool -certreq -alias yourdomain -keystore keycloak.jks > keycloak.careq"

msgid ""
"Where `yourdomain` is a DNS name for which this certificate is generated. "
"Keytool generates the request:"
msgstr "`yourdomain` はこの証明書が生成されるDNS名になります。Keytoolにより以下のように生成されます。"

msgid ""
"-----BEGIN NEW CERTIFICATE REQUEST-----\n"
"MIIC2jCCAcICAQAwZTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAk1BMREwDwYDVQQHEwhXZXN0Zm9y\n"
"ZDEQMA4GA1UEChMHUmVkIEhhdDEQMA4GA1UECxMHUmVkIEhhdDESMBAGA1UEAxMJbG9jYWxob3N0\n"
"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAr7kck2TaavlEOGbcpi9c0rncY4HhdzmY\n"
"Ax2nZfq1eZEaIPqI5aTxwQZzzLDK9qbeAd8Ji79HzSqnRDxNYaZu7mAYhFKHgixsolE3o5Yfzbw1\n"
"29RvyeUVe+WZxv5oo9wolVVpdSINIMEL2LaFhtX/c1dqiqYVpfnvFshZQaIg2nL8juzZcBjj4as\n"
"H98gIS7khql/dkZKsw9NLvyxgJvp7PaXurX29fNf3ihG+oFrL22oFyV54BWWxXCKU/GPn61EGZGw\n"
"Ft2qSIGLdctpMD1aJR2bcnlhEjZKDksjQZoQ5YMXaAGkcYkG6QkgrocDE2YXDbi7GIdf9MegVJ35\n"
"2DQMpwIDAQABoDAwLgYJKoZIhvcNAQkOMSEwHzAdBgNVHQ4EFgQUQwlZJBA+fjiDdiVzaO9vrE/i\n"
"n2swDQYJKoZIhvcNAQELBQADggEBAC5FRvMkhal3q86tHPBYWBuTtmcSjs4qUm6V6f63frhveWHf\n"
"PzRrI1xH272XUIeBk0gtzWo0nNZnf0mMCtUBbHhhDcG82xolikfqibZijoQZCiGiedVjHJFtniDQ\n"
"9bMDUOXEMQ7gHZg5q6mJfNG9MbMpQaUVEEFvfGEQQxbiFK7hRWU8S23/d80e8nExgQxdJWJ6vd0X\n"
"MzzFK6j4Dj55bJVuM7GFmfdNC52pNOD5vYe47Aqh8oajHX9XTycVtPXl45rrWAH33ftbrS8SrZ2S\n"
"vqIFQeuLL3BaHwpl3t7j2lMWcK1p80laAxEASib/fAwrRHpLHBXRcq6uALUOZl4Alt8=\n"
"-----END NEW CERTIFICATE REQUEST-----"
msgstr ""
"-----BEGIN NEW CERTIFICATE REQUEST-----\n"
"MIIC2jCCAcICAQAwZTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAk1BMREwDwYDVQQHEwhXZXN0Zm9y\n"
"ZDEQMA4GA1UEChMHUmVkIEhhdDEQMA4GA1UECxMHUmVkIEhhdDESMBAGA1UEAxMJbG9jYWxob3N0\n"
"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAr7kck2TaavlEOGbcpi9c0rncY4HhdzmY\n"
"Ax2nZfq1eZEaIPqI5aTxwQZzzLDK9qbeAd8Ji79HzSqnRDxNYaZu7mAYhFKHgixsolE3o5Yfzbw1\n"
"29RvyeUVe+WZxv5oo9wolVVpdSINIMEL2LaFhtX/c1dqiqYVpfnvFshZQaIg2nL8juzZcBjj4as\n"
"H98gIS7khql/dkZKsw9NLvyxgJvp7PaXurX29fNf3ihG+oFrL22oFyV54BWWxXCKU/GPn61EGZGw\n"
"Ft2qSIGLdctpMD1aJR2bcnlhEjZKDksjQZoQ5YMXaAGkcYkG6QkgrocDE2YXDbi7GIdf9MegVJ35\n"
"2DQMpwIDAQABoDAwLgYJKoZIhvcNAQkOMSEwHzAdBgNVHQ4EFgQUQwlZJBA+fjiDdiVzaO9vrE/i\n"
"n2swDQYJKoZIhvcNAQELBQADggEBAC5FRvMkhal3q86tHPBYWBuTtmcSjs4qUm6V6f63frhveWHf\n"
"PzRrI1xH272XUIeBk0gtzWo0nNZnf0mMCtUBbHhhDcG82xolikfqibZijoQZCiGiedVjHJFtniDQ\n"
"9bMDUOXEMQ7gHZg5q6mJfNG9MbMpQaUVEEFvfGEQQxbiFK7hRWU8S23/d80e8nExgQxdJWJ6vd0X\n"
"MzzFK6j4Dj55bJVuM7GFmfdNC52pNOD5vYe47Aqh8oajHX9XTycVtPXl45rrWAH33ftbrS8SrZ2S\n"
"vqIFQeuLL3BaHwpl3t7j2lMWcK1p80laAxEASib/fAwrRHpLHBXRcq6uALUOZl4Alt8=\n"
"-----END NEW CERTIFICATE REQUEST-----"

msgid "Send this CA request to your Certificate Authority (CA)."
msgstr "このCAリクエストを認証局（CA）に送信します。"

msgid "The CA will issue you a signed certificate and send it to you."
msgstr "CAは署名入りの証明書を発行し、あなたに送ります。"

msgid "Obtain and import the root certificate of the CA."
msgstr "CAのルート証明書を入手してインポートする。"

msgid ""
"You can download the cert from CA (in other words: root.crt) and import as "
"follows:"
msgstr "CAから証明書をダウンロードして（つまり、root.crt）、以下のようにインポートすることができます。"

msgid "$ keytool -import -keystore keycloak.jks -file root.crt -alias root"
msgstr "$ keytool -import -keystore keycloak.jks -file root.crt -alias root"

msgid "Import your new CA generated certificate to your keystore:"
msgstr "新しいCAが生成した証明書をキーストアにインポートします。"

msgid ""
"$ keytool -import -alias yourdomain -keystore keycloak.jks -file your-"
"certificate.cer"
msgstr ""
"$ keytool -import -alias yourdomain -keystore keycloak.jks -file your-"
"certificate.cer"

msgid "Configure {project_name} to Use the Keystore"
msgstr "キーストアを使用するための{project_name}設定"

msgid ""
"Now that you have a Java keystore with the appropriate certificates, you "
"need to configure your {project_name} installation to use it."
msgstr ""
"適切な証明書を含むJavaキーストアができたので、それを使用するために{project_name}のインストール環境を設定する必要があります。"

msgid ""
"Edit the _standalone.xml_, _standalone-ha.xml_, or _host.xml_ file to use "
"the keystore and enable HTTPS."
msgstr ""
"キーストアを使用し、HTTPSを有効にするために、_standalone.xml_ 、 _standalone-ha.xml_ 、 _host.xml_"
" のいずれかのファイルを編集します。"

msgid ""
"Either move the keystore file to the _configuration/_ directory of your "
"deployment or the file in a location you choose and provide an absolute path"
" to it."
msgstr ""
"キーストアファイルをデプロイメントの _configuration/_ "
"ディレクトリーに移動するか、またはファイルを任意の場所に移動し、そこへの絶対パスを指定してください。"

msgid ""
"If you are using absolute paths, remove the optional `relative-to` parameter"
" from your configuration (See <<_operating-mode, operating mode>>)."
msgstr ""
"絶対パスを使用する場合は、オプションの `relative-to` パラメーターを設定から削除してください（<<_operating-mode, "
"operating mode>>を参照してください）。"

msgid "Configure the keystore using the CLI:"
msgstr "次のようにCLIを使用して、キーストアを設定します。"

msgid ""
"$ /subsystem=elytron/key-store=httpsKS:add(relative-to=jboss.server.config.dir,path=keycloak.jks,credential-reference={clear-text=secret},type=JKS)\n"
"$ /subsystem=elytron/key-manager=httpsKM:add(key-store=httpsKS,credential-reference={clear-text=secret})\n"
"$ /subsystem=elytron/server-ssl-context=httpsSSC:add(key-manager=httpsKM,protocols=[\\\"TLSv1.3\\\"])"
msgstr ""
"$ /subsystem=elytron/key-store=httpsKS:add(relative-to=jboss.server.config.dir,path=keycloak.jks,credential-reference={clear-text=secret},type=JKS)\n"
"$ /subsystem=elytron/key-manager=httpsKM:add(key-store=httpsKS,credential-reference={clear-text=secret})\n"
"$ /subsystem=elytron/server-ssl-context=httpsSSC:add(key-manager=httpsKM,protocols=[\\\"TLSv1.3\\\"])"

msgid ""
"If using domain mode, the commands should be executed in every host using "
"the `/host=<host_name>/` prefix (in order to create the `security-realm` in "
"all of them). Here is an example, which you would repeat for each host:"
msgstr ""
"ドメインモードを使用している場合は、コマンドはすべてのホストで `/host=<host_name>/` "
"プレフィックスを使用して実行します（すべてのホストで `security-realm` を作成するために）。次の例のように、各ホスト分繰り返します。"

msgid ""
"$ /host=<host_name>/subsystem=elytron/key-store=httpsKS:add(relative-"
"to=jboss.server.config.dir,path=keycloak.jks,credential-reference={clear-"
"text=secret},type=JKS)"
msgstr ""
"$ /host=<host_name>/subsystem=elytron/key-store=httpsKS:add(relative-"
"to=jboss.server.config.dir,path=keycloak.jks,credential-reference={clear-"
"text=secret},type=JKS)"

msgid ""
"Modify the `https-listener` to use the `server-ssl-context`previously "
"created:"
msgstr "作成した `server-ssl-context` を使用するように `https-listener` を変更します。"

msgid ""
"$ /subsystem=undertow/server=default-server/https-listener=https:write-"
"attribute(name=ssl-context, value=httpsSSC)"
msgstr ""
"$ /subsystem=undertow/server=default-server/https-listener=https:write-"
"attribute(name=ssl-context, value=httpsSSC)"

msgid ""
"If using domain mode, prefix the command with the profile that is being used"
" with: `/profile=<profile_name>/`."
msgstr ""
"ドメインモードを使用している場合は、使用されているプロファイルをコマンドの先頭に `/profile=<profile_name>/` "
"のように付けます。"

msgid ""
"The resulting element, `server name=\"default-server\"`, which is a child "
"element of `subsystem xmlns=\"{subsystem_undertow_xml_urn}\"`, should "
"contain the following stanza:"
msgstr ""
"結果として得られる要素 `server name=\"default-server\"` は、これは `subsystem "
"xmlns=\"{subsystem_undertow_xml_urn}\"` の子要素であり、次のような内容を含みます。"

msgid ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"   <buffer-cache name=\"default\"/>\n"
"   <server name=\"default-server\">\n"
"      <https-listener name=\"https\" socket-binding=\"https\" ssl-context=\"httpsSSC\"/>\n"
"   ...\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"   <buffer-cache name=\"default\"/>\n"
"   <server name=\"default-server\">\n"
"      <https-listener name=\"https\" socket-binding=\"https\" ssl-context=\"httpsSSC\"/>\n"
"   ...\n"
"</subsystem>"

msgid ""
"For more information on configuring TLS refer to the "
"https://docs.wildfly.org/25/WildFly_Elytron_Security.html#configure-"
"ssltls[WildFly documentation]."
msgstr ""
"TLSの設定に関する詳細については、 "
"https://docs.wildfly.org/25/WildFly_Elytron_Security.html#configure-"
"ssltls[WildFlyドキュメント] を参照してください。"

msgid "Outgoing HTTP requests"
msgstr "外部へのHTTPリクエスト"

msgid ""
"The {project_name} server often needs to make non-browser HTTP requests to "
"the applications and services it secures. The auth server manages these "
"outgoing connections by maintaining an HTTP client connection pool.  There "
"are some things you'll need to configure in `standalone.xml`, `standalone-"
"ha.xml`, or `domain.xml`.  The location of this file depends on your "
"<<_operating-mode, operating mode>>."
msgstr ""
"{project_name}サーバーは、ブラウザーを介さないHTTPリクエストを、セキュリティー保護されたアプリケーションやサービスに送信する必要が多々あります。{project_name}サーバーは、HTTPクライアント接続プールを維持することによって、これらの外部接続を管理します。"
" `standalone.xml` 、 `standalone-ha.xml` または `domain.xml` "
"内で少し設定する必要があります。このファイルの場所は、<<_operating-mode, 動作モード>>によって異なります。"

msgid "HTTP client Config example"
msgstr "HTTPクライアント設定のサンプル"

msgid ""
"<spi name=\"connectionsHttpClient\">\n"
"    <provider name=\"default\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"connection-pool-size\" value=\"256\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"connectionsHttpClient\">\n"
"    <provider name=\"default\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"connection-pool-size\" value=\"256\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid "establish-connection-timeout-millis"
msgstr "establish-connection-timeout-millis"

msgid "Timeout for establishing a socket connection."
msgstr "ソケット接続を確立する際のタイムアウトです。"

msgid "socket-timeout-millis"
msgstr "socket-timeout-millis"

msgid ""
"If an outgoing request does not receive data for this amount of time, "
"timeout the connection."
msgstr "外部へのリクエストがこの時間の間にデータを受信しない場合、接続をタイムアウトします。"

msgid "connection-pool-size"
msgstr "connection-pool-size"

msgid "How many connections can be in the pool (128 by default)."
msgstr "プールされる接続数です（デフォルトでは128）。"

msgid "max-pooled-per-route"
msgstr "max-pooled-per-route"

msgid "How many connections can be pooled per host (64 by default)."
msgstr "ホストごとにプールされる接続数です（デフォルトでは64）。"

msgid "connection-ttl-millis"
msgstr "connection-ttl-millis"

msgid "Maximum connection time to live in milliseconds. Not set by default."
msgstr "ミリ秒単位での最大接続時間です。デフォルトでは設定されていません。"

msgid "max-connection-idle-time-millis"
msgstr "max-connection-idle-time-millis"

msgid ""
"Maximum time the connection might stay idle in the connection pool (900 "
"seconds by default). Will start background cleaner thread of Apache HTTP "
"client. Set to `-1` to disable this checking and the background thread."
msgstr ""
"接続プール内でアイドル状態を維持する最大時間です（デフォルトでは900秒）。Apache "
"HTTPクライアントのバックグラウンド・クリーナー・スレッドを開始します。 `-1` "
"にセットすると、このチェックとバックグラウンド・スレッドは無効になります。"

msgid "disable-cookies"
msgstr "disable-cookies"

msgid ""
"`true` by default. When set to true, this will disable any cookie caching."
msgstr "デフォルトでは `true` です。trueを設定した場合、Cookieキャッシュは無効になります。"

msgid "client-keystore"
msgstr "client-keystore"

msgid ""
"This is the file path to a Java keystore file. This keystore contains client"
" certificate for two-way SSL."
msgstr "これはJavaキーストア・ファイルへのファイルパスです。このキーストアには、双方向SSL用のクライアント証明書を含めます。"

msgid "client-keystore-password"
msgstr "client-keystore-password"

msgid ""
"Password for the client keystore. This is _REQUIRED_ if `client-keystore` is"
" set."
msgstr ""
"クライアント・キーストア用のパスワードです。 `client-keystore` が設定されている場合、これは _REQUIRED_ です。"

msgid "client-key-password"
msgstr "client-key-password"

msgid ""
"Password for the client's key. This is _REQUIRED_ if `client-keystore` is "
"set."
msgstr "クライアントキー用のパスワードです。 `client-keystore` が設定されている場合、これは _REQUIRED_ です。"

msgid "proxy-mappings"
msgstr "proxy-mappings"

msgid ""
"Denotes proxy configurations for outgoing HTTP requests. See the section on "
"<<_proxymappings, Proxy Mappings for Outgoing HTTP Requests>> for more "
"details."
msgstr ""
"送信するHTTPリクエストのプロキシー設定を示します。詳細については、<<_proxymappings, "
"送信HTTPリクエストのプロキシー・マッピング>>のセクションを参照してください。"

msgid "disable-trust-manager"
msgstr "disable-trust-manager"

msgid ""
"If an outgoing request requires HTTPS and this config option is set to "
"`true` you do not have to specify a truststore. This setting should only be "
"used during development and *never* in production as it will disable "
"verification of SSL certificates. This is _OPTIONAL_. The default value is "
"`false`."
msgstr ""
"外部へのリクエストがHTTPSを必要とし、この設定オプションを `true` "
"に設定する場合は、トラストストアを指定する必要はありません。この設定は、SSL証明書の検証を無効とするため、開発時にのみ使用すべきで、プロダクション環境では"
" *決して使用してはいけません* 。これは _OPTIONAL_ です。デフォルトは `false` です。"

msgid "Proxy mappings for outgoing HTTP requests"
msgstr "送信HTTPリクエストのプロキシー・マッピング"

msgid ""
"Outgoing HTTP requests sent by {project_name} can optionally use a proxy "
"server based on a comma delimited list of proxy-mappings. A proxy-mapping "
"denotes the combination of a regex based hostname pattern and a proxy-uri in"
" the form of `hostnamePattern;proxyUri`, e.g.:"
msgstr ""
"{project_name}によって送信された送信HTTPリクエストは、プロキシー・マッピングのカンマで区切られたリストに基づいて、オプションでプロキシー・サーバーを使用できます。プロキシー・マッピングは、正規表現ベースのホスト名パターンと"
" `hostnamePattern;proxyUri` 形式のproxy-uriの組み合わせを示します。例："

msgid ".*\\.(google|googleapis)\\.com;http://www-proxy.acme.com:8080"
msgstr ".*\\.(google|googleapis)\\.com;http://www-proxy.acme.com:8080"

msgid ""
"To determine the proxy for an outgoing HTTP request the target hostname is "
"matched against the configured hostname patterns. The first matching pattern"
" determines the proxy-uri to use. If none of the configured patterns match "
"for the given hostname then no proxy is used."
msgstr ""
"送信するHTTPリクエストのプロキシーを判別するために、ターゲットホスト名が、設定されたホスト名パターンと照合されます。最初に一致するパターンで、使用するproxy-"
"uriが決定します。指定されたホスト名と一致する設定済みのパターンが無い場合、プロキシーは使用されません。"

msgid ""
"If the proxy server requires authentication, include the proxy user's "
"credentials in this format `username:password@`. For example:"
msgstr ""
"プロキシー・サーバーが認証を必要とする場合、プロキシーユーザのクレデンシャルを `username:password@` "
"という形式で含めてください。たとえば、以下のようになります。"

msgid ""
".*\\.(google|googleapis)\\.com;http://user01:pas2w0rd@www-"
"proxy.acme.com:8080"
msgstr ""
".*\\.(google|googleapis)\\.com;http://user01:pas2w0rd@www-"
"proxy.acme.com:8080"

msgid ""
"The special value `NO_PROXY` for the proxy-uri can be used to indicate that "
"no proxy should be used for hosts matching the associated hostname pattern. "
"It is possible to specify a catch-all pattern at the end of the proxy-"
"mappings to define a default proxy for all outgoing requests."
msgstr ""
"proxy-uriに対する特別な値 `NO_PROXY` "
"は、関連するホスト名パターンと一致するホストに対して、プロキシーを使用しないことを示すために使用できます。プロキシー・マッピングの終わりにcatch-"
"allパターンを指定して、送信するすべてのリクエストのデフォルト・プロキシーを定義することが可能です。"

msgid "The following example demonstrates the proxy-mapping configuration."
msgstr "次の例は、プロキシー・マッピングの設定を示しています。"

msgid ""
"# All requests to Google APIs should use http://www-proxy.acme.com:8080 as proxy\n"
".*\\.(google|googleapis)\\.com;http://www-proxy.acme.com:8080\n"
"\n"
"# All requests to internal systems should use no proxy\n"
".*\\.acme\\.com;NO_PROXY\n"
"\n"
"# All other requests should use http://fallback:8080 as proxy\n"
".*;http://fallback:8080"
msgstr ""
"# All requests to Google APIs should use http://www-proxy.acme.com:8080 as proxy\n"
".*\\.(google|googleapis)\\.com;http://www-proxy.acme.com:8080\n"
"\n"
"# All requests to internal systems should use no proxy\n"
".*\\.acme\\.com;NO_PROXY\n"
"\n"
"# All other requests should use http://fallback:8080 as proxy\n"
".*;http://fallback:8080"

msgid ""
"This can be configured via the following `jboss-cli` command. Note that you "
"need to properly escape the regex-pattern as shown below."
msgstr ""
"これは、以下の `jboss-cli` コマンドで設定できます。以下に示す正規表現パターンを適切にエスケープする必要があることに注意してください。"

msgid ""
"echo SETUP: Configure proxy routes for HttpClient SPI\n"
"\n"
"# In case there is no connectionsHttpClient definition yet\n"
"/subsystem=keycloak-server/spi=connectionsHttpClient/provider=default:add(enabled=true)\n"
"\n"
"# Configure the proxy-mappings\n"
"/subsystem=keycloak-server/spi=connectionsHttpClient/provider=default:write-attribute(name=properties.proxy-mappings,value=[\".*\\\\.(google|googleapis)\\\\.com;http://www-proxy.acme.com:8080\",\".*\\\\.acme\\\\.com;NO_PROXY\",\".*;http://fallback:8080\"])"
msgstr ""
"echo SETUP: Configure proxy routes for HttpClient SPI\n"
"\n"
"# In case there is no connectionsHttpClient definition yet\n"
"/subsystem=keycloak-server/spi=connectionsHttpClient/provider=default:add(enabled=true)\n"
"\n"
"# Configure the proxy-mappings\n"
"/subsystem=keycloak-server/spi=connectionsHttpClient/provider=default:write-attribute(name=properties.proxy-mappings,value=[\".*\\\\.(google|googleapis)\\\\.com;http://www-proxy.acme.com:8080\",\".*\\\\.acme\\\\.com;NO_PROXY\",\".*;http://fallback:8080\"])"

msgid ""
"The `jboss-cli` command results in the following subsystem configuration. "
"Note that one needs to encode `\"` characters with `\\&quot;`."
msgstr ""
"`jboss-cli` コマンドの結果、以下のサブシステム設定になります。 `\\&quot;` で `\"` "
"文字をエンコードする必要があることに注意してください。"

msgid ""
"<spi name=\"connectionsHttpClient\">\n"
"    <provider name=\"default\" enabled=\"true\">\n"
"        <properties>\n"
"            <property\n"
"            name=\"proxy-mappings\"\n"
"            value=\"[&quot;.*\\\\.(google|googleapis)\\\\.com;http://www-proxy.acme.com:8080&quot;,&quot;.*\\\\.acme\\\\.com;NO_PROXY&quot;,&quot;.*;http://fallback:8080&quot;]\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"connectionsHttpClient\">\n"
"    <provider name=\"default\" enabled=\"true\">\n"
"        <properties>\n"
"            <property\n"
"            name=\"proxy-mappings\"\n"
"            value=\"[&quot;.*\\\\.(google|googleapis)\\\\.com;http://www-proxy.acme.com:8080&quot;,&quot;.*\\\\.acme\\\\.com;NO_PROXY&quot;,&quot;.*;http://fallback:8080&quot;]\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid "Using standard environment variables"
msgstr "標準的な環境変数の使用"

msgid ""
"Alternatively, it is possible to use standard environment variables to "
"configure the proxy mappings, that is `HTTP_PROXY`, `HTTPS_PROXY` and "
"`NO_PROXY` variables."
msgstr ""
"代わりに，標準的な環境変数を使ってプロキシー・マッピングを設定することも可能です（ `HTTP_PROXY` 、 `HTTPS_PROXY` 、 "
"`NO_PROXY` ）。"

msgid ""
"The `HTTP_PROXY` and `HTTPS_PROXY` variables represent the proxy server that"
" should be used for all outgoing HTTP requests. {project_name} does not "
"differ between the two. If both are specified, `HTTPS_PROXY` takes the "
"precedence regardless of the actual scheme the proxy server uses."
msgstr ""
"変数 `HTTP_PROXY` と `HTTPS_PROXY` は、すべての送信HTTPリクエストに使用されるべきプロキシーサーバーを表しています。 "
"{project_name}は、両者の間に違いはありません。両方が指定された場合は、プロキシーサーバーが実際に使用するスキームに関わらず、`HTTPS_PROXY`"
" が優先されます。"

msgid ""
"The `NO_PROXY` variable is used to define a comma separated list of "
"hostnames that should not use the proxy. If a hostname is specified, all its"
" prefixes (subdomains) are also excluded from using proxy."
msgstr ""
"`NO_PROXY` "
"変数は、プロキシーを使用してはいけないホスト名のリストをカンマ区切りで定義するのに使われます。ホスト名が指定された場合、そのすべてのプレフィックス（サブドメイン）もプロキシーの使用から除外されます。"

msgid "Take the following example:"
msgstr "次のような例があります。"

msgid ""
"HTTPS_PROXY=https://www-proxy.acme.com:8080\n"
"NO_PROXY=google.com,login.facebook.com"
msgstr ""
"HTTPS_PROXY=https://www-proxy.acme.com:8080\n"
"NO_PROXY=google.com,login.facebook.com"

msgid ""
"In this example, all outgoing HTTP requests will use `\\https://www-"
"proxy.acme.com:8080` proxy server except for requests to for example "
"`login.google.com`, `google.com`, `auth.login.facebook.com`. However, for "
"example `groups.facebook.com` will be routed through the proxy."
msgstr ""
"この例では、たとえば `login.google.com` 、 `google.com` 、 `auth.login.facebook.com` "
"へのリクエストを除き、すべての送信HTTPリクエストが `https://www-proxy.acme.com:8080` "
"プロキシー・サーバーを使用します。ただし、たとえば `groups.facebook.com` などのリクエストはプロキシーを経由します。"

msgid ""
"The environment variables can be lowercase or uppercase. Lowercase takes "
"precedence. For example if both `HTTP_PROXY` and        `http_proxy` are "
"defined, `http_proxy` will be used."
msgstr ""
"環境変数は、小文字でも大文字でもOKです。小文字の方が優先されます。たとえば、 `HTTP_PROXY` と `http_proxy` "
"の両方が定義されている場合、  `http_proxy` が使用されます。"

msgid ""
"If proxy mappings are defined using the subsystem configuration (as "
"described above), the environment variables are not considered by "
"{project_name}. This scenario applies in case no proxy server should be used"
" despite having for example `HTTP_PROXY` environment variable defined. To do"
" so, you can specify a generic no proxy route as follows:"
msgstr ""
"サブシステム設定を使用してプロキシー・マッピングを定義する場合 "
"（上記のとおり）、環境変数は{project_name}では考慮されません。このシナリオは、たとえば `HTTP_PROXY` "
"環境変数が定義されているにもかかわらず、プロキシー・サーバーを使用しない場合に適用されます。これを行うには、以下のように一般的なプロキシーのないルートを指定します。"

msgid ""
"<spi name=\"connectionsHttpClient\">\n"
"    <provider name=\"default\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"proxy-mappings\" value=\".*;NO_PROXY\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"connectionsHttpClient\">\n"
"    <provider name=\"default\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"proxy-mappings\" value=\".*;NO_PROXY\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid "Outgoing HTTPS request truststore"
msgstr "発信するHTTPSリクエスト truststore"

msgid ""
"When {project_name} invokes on remote HTTPS endpoints, it has to validate "
"the remote server's certificate in order to ensure it is connecting to a "
"trusted server. This is necessary in order to prevent man-in-the-middle "
"attacks.  The certificates of these remote server's or the CA that signed "
"these certificates must be put in a truststore.  This truststore is managed "
"by the {project_name} server."
msgstr ""
"{project_name}がリモートのHTTPSエンドポイントを呼び出す場合、信頼できるサーバーへの接続かどうかを確認するために、リモートサーバーの証明書を検証する必要があります。これは、中間者攻撃を防ぐために必要です。リモートサーバーや署名した認証局の証明書は、トラストストアに保存されている必要があります。このトラストストアは、{project_name}サーバーによって管理されます。"

msgid ""
"The truststore is used when connecting securely to identity brokers, LDAP "
"identity providers, when sending emails, and for backchannel communication "
"with client applications."
msgstr ""
"トラストストアは、アイデンティティー・ブローカーやLDAPアイデンティティー・プロバイダーに安全に接続する場合、電子メールを送信する場合、およびクライアント・アプリケーションとのバックチャネル通信をする場合に使用されます。"

msgid ""
"By default, a truststore provider is not configured, and any https "
"connections fall back to standard java truststore configuration as described"
" in           "
"https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html[Java's"
" JSSE Reference Guide].  If there is no trust           established, then "
"these outgoing HTTPS requests will fail."
msgstr ""
"デフォルトでは、トラストストア・プロバイダーは設定されておらず、https接続は "
"https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html[Javaの"
" JSSE Reference "
"Guide]で説明されている標準のJavaトラストストア設定にフォールバックします。信頼が確立されていない場合、これらの送信するHTTPSリクエストはエラーになります。"

msgid ""
"You can use _keytool_ to create a new truststore file or add trusted host "
"certificates to an existing one:"
msgstr ""
"_keytool_ "
"を使用し、新しいトラストストア・ファイルを作成、または信頼できるホスト証明書を既存のトラストストア・ファイルに追加することができます。"

msgid ""
"\n"
"$ keytool -import -alias HOSTDOMAIN -keystore truststore.jks -file host-certificate.cer"
msgstr ""
"\n"
"$ keytool -import -alias HOSTDOMAIN -keystore truststore.jks -file host-certificate.cer"

msgid ""
"The truststore is configured within the `standalone.xml`, `standalone-"
"ha.xml`, or `domain.xml` file in your distribution.  The location of this "
"file depends on your <<_operating-mode, operating mode>>. You can add your "
"truststore configuration by using the following template:"
msgstr ""
"トラストストアは、配布物内の `standalone.xml` 、 `standalone-ha.xml` または `domain.xml` "
"で設定されます。このファイルの場所は、<<_operating-mode, "
"動作モード>>によって異なります。以下のテンプレートを使用して、トラストストア設定を追加することができます。"

msgid ""
"<spi name=\"truststore\">\n"
"    <provider name=\"file\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"file\" value=\"path to your .jks file containing public certificates\"/>\n"
"            <property name=\"password\" value=\"password\"/>\n"
"            <property name=\"hostname-verification-policy\" value=\"WILDCARD\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>\n"
msgstr ""
"<spi name=\"truststore\">\n"
"    <provider name=\"file\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"file\" value=\"path to your .jks file containing public certificates\"/>\n"
"            <property name=\"password\" value=\"password\"/>\n"
"            <property name=\"hostname-verification-policy\" value=\"WILDCARD\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>\n"

msgid "Possible configuration options for this setting are:"
msgstr "設定可能なオプションは以下のとおりです。"

msgid "file"
msgstr "file"

msgid ""
"The path to a Java keystore file. HTTPS requests need a way to verify the "
"host of the server they are talking to. This is what the trustore does. The "
"keystore contains one or more trusted host certificates or certificate "
"authorities. This truststore file should only contain public certificates of"
" your secured hosts. This is _REQUIRED_ if any of these properties are "
"defined."
msgstr ""
"Javaキーストア・ファイルへのパスです。HTTPSリクエストでは、通信を行うサーバーのホストを検証する必要があります。これはトラストストアの役割です。キーストアには、1つ以上の信頼できるホスト証明書または認証局が含まれています。このトラストストア・ファイルには、セキュリティー保護されたホストのパブリック証明書のみを含めるべきです。"
" これらのプロパティーのいずれかが定義されている場合、これは _REQUIRED_ です。"

msgid "password"
msgstr "password"

msgid ""
"Password of the keystore. This is _REQUIRED_ if any of these properties are "
"defined."
msgstr "キーストアのパスワード。これらのプロパティーのいずれかが定義されている場合、これは _REQUIRED_ です。"

msgid "hostname-verification-policy"
msgstr "hostname-verification-policy"

msgid ""
"`WILDCARD` by default. For HTTPS requests, this verifies the hostname of the"
" server's certificate.  `ANY` means that the hostname is not verified. "
"`WILDCARD` Allows wildcards in subdomain names i.e. *.foo.com. `STRICT` CN "
"must match hostname exactly."
msgstr ""
"デフォルトでは `WILDCARD` です。HTTPSリクエストを行うために、サーバー証明書のホスト名を検証します。 `ANY` "
"はホスト名が検証されないことを意味します。 `WILDCARD` によって、サブドメイン名にワイルドカード（つまり "
"*.foo.com）が使用できるようになります。 `STRICT` の場合、CNはホスト名と正確に一致する必要があります。"

msgid "Configuring {project_name} to run in a cluster"
msgstr "{project_name}をクラスターで実行させるための設定"

msgid ""
"To configure {project_name} to run in a cluster, you perform these actions:"
msgstr "{project_name}をクラスターで実行するように設定するには、以下の操作を行います。"

msgid "<<_operating-mode,Pick an operation mode>>"
msgstr "<<_operating-mode,動作モードの選択>>"

msgid "<<_database,Configure a shared external database>>"
msgstr "<<_database,外部共有データベースの設定>>"

msgid "Set up a load balancer"
msgstr "ロードバランサーの設定"

msgid "Supplying a private network that supports IP multicast"
msgstr "IPマルチキャストをサポートするプライベート・ネットワークの提供"

msgid ""
"Picking an operation mode and configuring a shared database have been "
"discussed earlier in this guide.  This chapter describes setting up a load "
"balancer and supplying a private network as well as booting up a host in the"
" cluster."
msgstr ""
"動作モードの選択と共有データベースの設定については、本ガイドの前半で説明しました。本章では、ロードバランサーの設定、プライベート・ネットワークの提供、クラスター内のホストの起動について説明します。"

msgid ""
"It is possible to cluster {project_name} without IP Multicast, but this "
"topic is beyond the scope of this guide.  For more information, see "
"link:{appserver_jgroups_link}[JGroups] chapter of the "
"_{appserver_jgroups_name}_."
msgstr ""
"IPマルチキャストなしでも{project_name}をクラスター構成にすることは可能ですが、このトピックについてはこのガイドの範囲を超えています。詳しくは、"
" _{appserver_jgroups_name}_ "
"のlink:{appserver_jgroups_link}[JGroups]を参照してください。"

msgid "Recommended network architecture"
msgstr "推奨ネットワーク・アーキテクチャー"

msgid ""
"The recommended network architecture for deploying {project_name} is to set "
"up an HTTP/HTTPS load balancer on a public IP address that routes requests "
"to {project_name} servers sitting on a private network.  This isolates all "
"clustering connections and provides a nice means of protecting the servers."
msgstr ""
"{project_name}をデプロイするための推奨ネットワーク・アーキテクチャーは、パブリックIPアドレスを持つHTTP/HTTPSロードバランサーを配置し、プライベート・ネットワーク上の{project_name}サーバーへのリクエストをルーティングさせます。これにより、クラスタリング接続はすべて分離され、サーバーを保護する優れた手段が提供されます。"

msgid ""
"By default, there is nothing to prevent unauthorized nodes from joining the "
"cluster and broadcasting multicast messages.       This is why cluster nodes"
" should be in a private network, with a firewall protecting them from "
"outside attacks."
msgstr ""
"デフォルトでは、許可されていないノードがクラスターに加わり、マルチキャスト・メッセージをブロードキャストするのを防ぐものは何もありません。このため、クラスター・ノードはプライベート・ネットワーク内に置かれ、ファイアウォールによって外部の攻撃から保護される必要があります。"

msgid "Clustering example"
msgstr "クラスタリングの例"

msgid ""
"{project_name} does come with an out of the box clustering demo that "
"leverages domain mode.  Review the <<_clustered-domain-example, Clustered "
"Domain Example>> chapter for more details."
msgstr ""
"{project_name}には、ドメインモードでそのまま利用できるクラスタリングのデモが付属しています。詳しくは<<_clustered-"
"domain-example, クラスター構成ドメインのサンプル>>の章を参照してください。"

msgid "Setting Up a load balancer or proxy"
msgstr "ロードバランサーまたはプロキシーの設定"

msgid ""
"This section discusses a number of things you need to configure before you "
"can put a reverse proxy or load balancer in front of your clustered "
"{project_name} deployment.  It also covers configuring the built-in load "
"balancer that was <<_clustered-domain-example, Clustered Domain Example>>."
msgstr ""
"このセクションでは、クラスター構成の{project_name}の前にリバース・プロキシーまたはロードバランサーを配置するにあたって、設定が必要な項目について説明します。また、組み込みのロードバランサーの設定についても説明します。これは<<_clustered-"
"domain-example, クラスター構成ドメインのサンプル>>でも確認できます。"

msgid ""
"The following diagram illustrates the use of a load balancer. In this "
"example, the load balancer serves as a reverse proxy between three clients "
"and a cluster of three {project_name} servers."
msgstr ""
"次の図は、ロードバランサーの使用方法を示しています。この例では、ロードバランサーは、3つのクライアントと3つの{project_name}サーバーのクラスター間のリバースプロキシーとして機能します。"

msgid "Example Load Balancer Diagram"
msgstr "ロードバランサーの例の図"

msgid "image:{project_images}/load_balancer.png[]"
msgstr "image:{project_images}/load_balancer.png[]"

msgid "Identifying client IP addresses"
msgstr "クライアントIPアドレスの特定"

msgid ""
"A few features in {project_name} rely on the fact that the remote address of"
" the HTTP client connecting to the authentication server is the real IP "
"address of the client machine. Examples include:"
msgstr ""
"{project_name}のいくつかの機能は、認証サーバーに接続するHTTPクライアントのリモート・アドレスがクライアント・マシンの実際のIPアドレスであることを前提としています。例は、以下のとおりです。"

msgid ""
"Event logs - a failed login attempt would be logged with the wrong source IP"
" address"
msgstr "イベントログ - 間違ったソースIPアドレスでログインエラーが記録されます"

msgid ""
"SSL required - if the SSL required is set to external (the default) it "
"should require SSL for all external requests"
msgstr "SSLの要求 - SSLの要求がexternal（デフォルト）に設定されている場合、すべての外部リクエストに対してSSLを要求します"

msgid ""
"Authentication flows - a custom authentication flow that uses the IP address"
" to for example show OTP only for external requests"
msgstr "認証フロー - IPアドレスを使用して、たとえば外部リクエストに対してのみOTPを表示するようなカスタム認証フロー"

msgid "Dynamic Client Registration"
msgstr "動的クライアント登録"

msgid ""
"This can be problematic when you have a reverse proxy or loadbalancer in "
"front of your {project_name} authentication server. The usual setup is that "
"you have a frontend proxy sitting on a public network that load balances and"
" forwards requests to backend {project_name} server instances located in a "
"private network.  There is some extra configuration you have to do in this "
"scenario so that the actual client IP address is forwarded to and processed "
"by the {project_name} server instances.  Specifically:"
msgstr ""
"{project_name}認証サーバーの前にリバース・プロキシーまたはロードバランサーが置いてある場合、問題になる可能性があります。通常の設定では、パブリック・ネットワーク上にフロントエンドのプロキシーを置いています。このプロキシーはプライベート・ネットワーク内のバックエンドの{project_name}サーバー・インスタンスに負荷を分散してリクエストを転送するものです。実際のクライアントIPアドレスが転送され、{project_name}サーバー・インスタンスによって処理されるように、追加設定する必要があります。具体的には以下のとおりです。"

msgid ""
"Configure your reverse proxy or loadbalancer to properly set `X-Forwarded-"
"For` and `X-Forwarded-Proto` HTTP headers."
msgstr ""
"`X-Forwarded-For` 、 `X-Forwarded-Proto` "
"HTTPヘッダーを適切にセットするように、リバース・プロキシーまたはロードバランサーを設定します。"

msgid ""
"Configure your reverse proxy or loadbalancer to preserve the original 'Host'"
" HTTP header."
msgstr "オリジナルの 'Host' HTTPヘッダーを保持するように、リバース・プロキシーまたはロードバランサーを設定します。"

msgid ""
"Configure the authentication server to read the client's IP address from "
"`X-Forwarded-For` header."
msgstr "`X-Forwarded-For` ヘッダーからクライアントのIPアドレスを読み取るように、認証サーバーを設定します。"

msgid ""
"Configuring your proxy to generate the `X-Forwarded-For` and `X-Forwarded-"
"Proto` HTTP headers and preserving the  original `Host` HTTP header is "
"beyond the scope of this guide.  Take extra precautions to ensure that the "
"`X-Forwarded-For` header is set by your proxy.  If your proxy isn't "
"configured correctly, then _rogue_ clients can set this header themselves "
"and trick {project_name} into thinking the client is connecting from a "
"different IP address than it actually is.  This becomes really important if "
"you are doing any black or white listing of IP addresses."
msgstr ""
"`X-Forwarded-For` 、 `X-Forwarded-Proto` HTTPヘッダーを生成するためにプロキシーを設定し、オリジナルの "
"`Host` HTTPヘッダーを保持する方法については、このガイドの説明範囲を超えています。 `X-Forwarded-For` "
"ヘッダーがプロキシーによって設定されているか、特に注意して確認してください。プロキシーが正しく設定されていない場合、_不正な_ "
"クライアントがこのヘッダーを自身で設定して、クライアントが実際とは異なるIPアドレスから接続していると{project_name}に認識させることができてしまいます。IPアドレスのブラックリストまたはホワイトリストを作成している場合、この設定は非常に重要です。"

msgid ""
"Beyond the proxy itself, there are a few things you need to configure on the"
" {project_name} side of things. If your proxy is forwarding requests via the"
" HTTP protocol, then you need to configure {project_name} to pull the "
"client's IP address from the `X-Forwarded-For` header rather than from the "
"network packet. To do this, open up the profile configuration file "
"(_standalone.xml_, _standalone-ha.xml_, or _domain.xml_ depending on your "
"<<_operating-mode, operating mode>>) and look for the "
"`{subsystem_undertow_xml_urn}` XML block."
msgstr ""
"プロキシーの他にも、いくつか{project_name}側で設定する必要があります。プロキシーがHTTPプロトコル経由でリクエストを転送している場合、クライアントのIPアドレスをネットワーク・パケットからではなく"
" `X-Forwarded-For` "
"ヘッダーから取得するように、{project_name}を設定する必要があります。これを行うには、プロファイル設定ファイル（<<_operating-"
"mode, 動作モード>>に応じて _standalone.xml_ 、 _standalone-ha.xml_ または _domain.xml_ "
"）を開き、 `{subsystem_undertow_xml_urn}` XMLブロックを検索します。"

msgid "`X-Forwarded-For` HTTP Config"
msgstr "`X-Forwarded-For` HTTP設定"

msgid ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"   <buffer-cache name=\"default\"/>\n"
"   <server name=\"default-server\">\n"
"      <ajp-listener name=\"ajp\" socket-binding=\"ajp\"/>\n"
"      <http-listener name=\"default\" socket-binding=\"http\" redirect-socket=\"https\"\n"
"          proxy-address-forwarding=\"true\"/>\n"
"      ...\n"
"   </server>\n"
"   ...\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"   <buffer-cache name=\"default\"/>\n"
"   <server name=\"default-server\">\n"
"      <ajp-listener name=\"ajp\" socket-binding=\"ajp\"/>\n"
"      <http-listener name=\"default\" socket-binding=\"http\" redirect-socket=\"https\"\n"
"          proxy-address-forwarding=\"true\"/>\n"
"      ...\n"
"   </server>\n"
"   ...\n"
"</subsystem>"

msgid ""
"Add the `proxy-address-forwarding` attribute to the `http-listener` element."
"  Set the value to `true`."
msgstr ""
"`http-listener` 要素に `proxy-address-forwarding` 属性を追加します。値を `true` に設定します。"

msgid ""
"If your proxy is using the AJP protocol instead of HTTP to forward requests "
"(i.e. Apache HTTPD + mod-cluster), then you have to configure things a "
"little differently.  Instead of modifying the `http-listener`, you need to "
"add a filter to pull this information from the AJP packets."
msgstr ""
"プロキシーがリクエストを転送するためにHTTPの代わりにAJPプロトコルを使用している場合（サンプルとしては、Apache HTTPD + mod-"
"clusterなど）、少し異なる設定が必要になります。 `http-listener` "
"を変更する代わりに、AJPパケットからこの情報を取得するフィルターを追加する必要があります。"

msgid "`X-Forwarded-For` AJP Config"
msgstr "`X-Forwarded-For` AJP設定"

msgid ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"     <buffer-cache name=\"default\"/>\n"
"     <server name=\"default-server\">\n"
"         <ajp-listener name=\"ajp\" socket-binding=\"ajp\"/>\n"
"         <http-listener name=\"default\" socket-binding=\"http\" redirect-socket=\"https\"/>\n"
"         <host name=\"default-host\" alias=\"localhost\">\n"
"             ...\n"
"             <filter-ref name=\"proxy-peer\"/>\n"
"         </host>\n"
"     </server>\n"
"        ...\n"
"     <filters>\n"
"         ...\n"
"         <filter name=\"proxy-peer\"\n"
"                 class-name=\"io.undertow.server.handlers.ProxyPeerAddressHandler\"\n"
"                 module=\"io.undertow.core\" />\n"
"     </filters>\n"
" </subsystem>"
msgstr ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"     <buffer-cache name=\"default\"/>\n"
"     <server name=\"default-server\">\n"
"         <ajp-listener name=\"ajp\" socket-binding=\"ajp\"/>\n"
"         <http-listener name=\"default\" socket-binding=\"http\" redirect-socket=\"https\"/>\n"
"         <host name=\"default-host\" alias=\"localhost\">\n"
"             ...\n"
"             <filter-ref name=\"proxy-peer\"/>\n"
"         </host>\n"
"     </server>\n"
"        ...\n"
"     <filters>\n"
"         ...\n"
"         <filter name=\"proxy-peer\"\n"
"                 class-name=\"io.undertow.server.handlers.ProxyPeerAddressHandler\"\n"
"                 module=\"io.undertow.core\" />\n"
"     </filters>\n"
" </subsystem>"

msgid "Enabling HTTPS/SSL with a reverse proxy"
msgstr "リバース・プロキシーでのHTTPS/SSLの有効化"

msgid ""
"Assuming that your reverse proxy doesn't use port 8443 for SSL you also need"
" to configure to what port the HTTPS traffic is redirected."
msgstr ""
"リバース・プロキシーがSSL用にポート8443を使用しない場合、HTTPSトラフィックのどのポートをリダイレクトするか設定する必要があります。"

msgid ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"    ...\n"
"    <http-listener name=\"default\" socket-binding=\"http\"\n"
"        proxy-address-forwarding=\"true\" redirect-socket=\"proxy-https\"/>\n"
"    ...\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"    ...\n"
"    <http-listener name=\"default\" socket-binding=\"http\"\n"
"        proxy-address-forwarding=\"true\" redirect-socket=\"proxy-https\"/>\n"
"    ...\n"
"</subsystem>"

msgid ""
"Add the `redirect-socket` attribute to the `http-listener` element.  The "
"value should be `proxy-https` which points to a socket binding you also need"
" to define."
msgstr ""
"`http-listener` 要素に `redirect-socket` 属性を追加します。値には `proxy-https` "
"を設定しますが、これは定義が必要なソケット・バインディングを指しています。"

msgid ""
"Add a new `socket-binding` element to the `socket-binding-group` element:"
msgstr "新しい `socket-binding` 要素を `socket-binding-group` 要素に追加します。以下のようになります。"

msgid ""
"<socket-binding-group name=\"standard-sockets\" default-interface=\"public\"\n"
"    port-offset=\"${jboss.socket.binding.port-offset:0}\">\n"
"    ...\n"
"    <socket-binding name=\"proxy-https\" port=\"443\"/>\n"
"    ...\n"
"</socket-binding-group>"
msgstr ""
"<socket-binding-group name=\"standard-sockets\" default-interface=\"public\"\n"
"    port-offset=\"${jboss.socket.binding.port-offset:0}\">\n"
"    ...\n"
"    <socket-binding name=\"proxy-https\" port=\"443\"/>\n"
"    ...\n"
"</socket-binding-group>"

msgid "Verifying the configuration"
msgstr "設定内容の確認"

msgid "You can verify the reverse proxy or load balancer configuration"
msgstr "リバース・プロキシーやロードバランサーの設定を確認することができます。"

msgid ""
"Open the path `/auth/realms/master/.well-known/openid-configuration` through"
" the reverse proxy."
msgstr ""
"リバース・プロキシー経由でパス `/auth/realms/master/.well-known/openid-configuration` "
"を開きます。"

msgid ""
"For example if the reverse proxy address is `\\https://acme.com/` then open "
"the URL `\\https://acme.com/auth/realms/master/.well-known/openid-"
"configuration`. This will show a JSON document listing a number of endpoints"
" for {project_name}."
msgstr ""
"たとえば、リバース・プロキシーのアドレスが `https://acme.com/` であれば、 "
"`https://acme.com/auth/realms/master/.well-known/openid-configuration` "
"を開きます。そうすると、{project_name}のエンドポイントをいくつかリストアップしたJSONドキュメントが表示されます。"

msgid ""
"Make sure the endpoints starts with the address (scheme, domain and port) of"
" your reverse proxy or load balancer. By doing this you make sure that "
"{project_name} is using the correct endpoint."
msgstr ""
"エンドポイントが、リバース・プロキシーやロードバランサーのアドレス（スキーム、ドメイン、ポート）で始まっていることを確認してください。これにより、{project_name}"
" が正しいエンドポイントを使用していることが確認できます。"

msgid ""
"Verify that {project_name} sees the correct source IP address for requests."
msgstr "{project_name}がリクエストに対して正しいソースIPアドレスを見ていることを確認します。"

msgid ""
"To check this, you can try to login to the Admin Console with an invalid "
"username and/or password. This should show a warning in the server log "
"something like this:"
msgstr ""
"これを確認するには、無効なユーザー名やパスワードを使って管理者コンソールにログインしてみてください。この場合、サーバーログに次のような警告が表示されます。"

msgid ""
"08:14:21,287 WARN  XNIO-1 task-45 [org.keycloak.events] type=LOGIN_ERROR, "
"realmId=master, clientId=security-admin-console, "
"userId=8f20d7ba-4974-4811-a695-242c8fbd1bf8, ipAddress=X.X.X.X, "
"error=invalid_user_credentials, auth_method=openid-connect, auth_type=code, "
"redirect_uri=http://localhost:8080/auth/admin/master/console/?redirect_fragment=%2Frealms%2Fmaster%2Fevents-"
"settings, code_id=a3d48b67-a439-4546-b992-e93311d6493e, username=admin"
msgstr ""
"08:14:21,287 WARN  XNIO-1 task-45 [org.keycloak.events] type=LOGIN_ERROR, "
"realmId=master, clientId=security-admin-console, "
"userId=8f20d7ba-4974-4811-a695-242c8fbd1bf8, ipAddress=X.X.X.X, "
"error=invalid_user_credentials, auth_method=openid-connect, auth_type=code, "
"redirect_uri=http://localhost:8080/auth/admin/master/console/?redirect_fragment=%2Frealms%2Fmaster%2Fevents-"
"settings, code_id=a3d48b67-a439-4546-b992-e93311d6493e, username=admin"

msgid ""
"Check that the value of `ipAddress` is the IP address of the machine you "
"tried to login with and not the IP address  of the reverse proxy or load "
"balancer."
msgstr ""
"`ipAddress` "
"の値が、リバース・プロキシーやロードバランサーのIPアドレスではなく、ログインしようとしたマシンのIPアドレスであることを確認してください。"

msgid "Using the built-in load balancer"
msgstr "組み込みロードバランサーの使用"

msgid ""
"This section covers configuring the built-in load balancer that is discussed"
" in the <<_clustered-domain-example, Clustered Domain Example>>."
msgstr ""
"このセクションでは、<<_clustered-domain-example, "
"クラスター構成ドメインのサンプル>>で説明している組み込みのロードバランサーの設定方法について説明します。"

msgid ""
"The <<_clustered-domain-example, Clustered Domain Example>> is only designed"
" to run on one machine.  To bring up a slave on another host, you'll need to"
msgstr ""
"<<_clustered-domain-example, "
"クラスター構成ドメインのサンプル>>は1台のマシンで実行するためにのみ作られています。他のホストでスレーブを起動するには、次の操作が必要です。"

msgid "Edit the _domain.xml_ file to point to your new host slave"
msgstr "新しいホスト・スレーブを指し示すように、 _domain.xml_ ファイルを編集します。"

msgid ""
"Copy the server distribution.  You don't need the _domain.xml_, _host.xml_, "
"or _host-master.xml_ files.  Nor do you need the _standalone/_ directory."
msgstr ""
"サーバー配布物をコピーします。 _domain.xml_ 、 _host.xml_ または _host-master.xml_ は必要ありません。 "
"_standalone/_ ディレクトリーも必要ありません。"

msgid ""
"Edit the _host-slave.xml_ file to change the bind addresses used or override"
" them on the command line"
msgstr ""
"使用しているバインドアドレスを変更、またはコマンドラインでそのアドレスを上書きするように、 _host-slave.xml_ ファイルを編集します。"

msgid ""
"Open  _domain.xml_ so you can registering the new host slave with the load "
"balancer configuration."
msgstr "_domain.xml_ を開き、新しいホストスレーブをロードバランサーの設定に登録できるようにします。"

msgid ""
"Go to the undertow configuration in the `load-balancer` profile.  Add a new "
"`host` definition called `remote-host3` within the `reverse-proxy` XML "
"block."
msgstr ""
"`load-balancer` プロファイル内のundertow設定に移動します。 `reverse-proxy` のXMLブロックの中に、 "
"`remote-host3` という新しい `host` の定義を追加します。"

msgid "domain.xml reverse-proxy config"
msgstr "domain.xmlのreverse-proxy設定 "

msgid ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"  ...\n"
"  <handlers>\n"
"      <reverse-proxy name=\"lb-handler\">\n"
"         <host name=\"host1\" outbound-socket-binding=\"remote-host1\" scheme=\"ajp\" path=\"/\" instance-id=\"myroute1\"/>\n"
"         <host name=\"host2\" outbound-socket-binding=\"remote-host2\" scheme=\"ajp\" path=\"/\" instance-id=\"myroute2\"/>\n"
"         <host name=\"remote-host3\" outbound-socket-binding=\"remote-host3\" scheme=\"ajp\" path=\"/\" instance-id=\"myroute3\"/>\n"
"      </reverse-proxy>\n"
"  </handlers>\n"
"  ...\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"{subsystem_undertow_xml_urn}\">\n"
"  ...\n"
"  <handlers>\n"
"      <reverse-proxy name=\"lb-handler\">\n"
"         <host name=\"host1\" outbound-socket-binding=\"remote-host1\" scheme=\"ajp\" path=\"/\" instance-id=\"myroute1\"/>\n"
"         <host name=\"host2\" outbound-socket-binding=\"remote-host2\" scheme=\"ajp\" path=\"/\" instance-id=\"myroute2\"/>\n"
"         <host name=\"remote-host3\" outbound-socket-binding=\"remote-host3\" scheme=\"ajp\" path=\"/\" instance-id=\"myroute3\"/>\n"
"      </reverse-proxy>\n"
"  </handlers>\n"
"  ...\n"
"</subsystem>"

msgid ""
"The `output-socket-binding` is a logical name pointing to a `socket-binding`"
" configured later in the _domain.xml_ file. The `instance-id` attribute must"
" also be unique to the new host as this value is used by a cookie to enable "
"sticky sessions when load balancing."
msgstr ""
"`output-socket-binding` は _domain.xml_ 内で後ほど設定する `socket-binding` を指す論理名です。 "
"`instance-id` "
"属性の値は、負荷を分散する時にスティッキー・セッションを有効にできるようにCookieで使用されるため、新しいホスト固有のものでなければなりません。"

msgid ""
"Go down to the `load-balancer-sockets` `socket-binding-group` and add the "
"`outbound-socket-binding` for `remote-host3`."
msgstr ""
" `load-balancer-sockets` `socket-binding-group` に進み、 `remote-host3` "
"の`outbound-socket-binding` を追加します。"

msgid "This new binding needs to point to the host and port of the new host."
msgstr "この新しいバインディングは、新しいホストのホストとポートを指す必要があります。"

msgid "domain.xml outbound-socket-binding"
msgstr "domain.xmlのoutbound-socket-binding"

msgid ""
"<socket-binding-group name=\"load-balancer-sockets\" default-interface=\"public\">\n"
"    ...\n"
"    <outbound-socket-binding name=\"remote-host1\">\n"
"        <remote-destination host=\"localhost\" port=\"8159\"/>\n"
"    </outbound-socket-binding>\n"
"    <outbound-socket-binding name=\"remote-host2\">\n"
"        <remote-destination host=\"localhost\" port=\"8259\"/>\n"
"    </outbound-socket-binding>\n"
"    <outbound-socket-binding name=\"remote-host3\">\n"
"        <remote-destination host=\"192.168.0.5\" port=\"8259\"/>\n"
"    </outbound-socket-binding>\n"
"</socket-binding-group>"
msgstr ""
"<socket-binding-group name=\"load-balancer-sockets\" default-interface=\"public\">\n"
"    ...\n"
"    <outbound-socket-binding name=\"remote-host1\">\n"
"        <remote-destination host=\"localhost\" port=\"8159\"/>\n"
"    </outbound-socket-binding>\n"
"    <outbound-socket-binding name=\"remote-host2\">\n"
"        <remote-destination host=\"localhost\" port=\"8259\"/>\n"
"    </outbound-socket-binding>\n"
"    <outbound-socket-binding name=\"remote-host3\">\n"
"        <remote-destination host=\"192.168.0.5\" port=\"8259\"/>\n"
"    </outbound-socket-binding>\n"
"</socket-binding-group>"

msgid "Master bind addresses"
msgstr "マスターバインドアドレス"

msgid ""
"Next thing you'll have to do is to change the `public` and `management` bind"
" addresses for the master host.  Either edit the _domain.xml_ file as "
"discussed in the <<_bind-address, Bind Addresses>> chapter or specify these "
"bind addresses on the command line as follows:"
msgstr ""
"次に、マスターホスト用の `public` と `management` バインドアドレスを変更する必要があります。<<_bind-address, "
"バインドアドレス>>内で説明した _domain.xml_ ファイルを編集するか、以下のとおりコマンドライン上でこれらのバインドアドレスを指定します。"

msgid ""
"$ domain.sh --host-config=host-master.xml -Djboss.bind.address=192.168.0.2 "
"-Djboss.bind.address.management=192.168.0.2"
msgstr ""
"$ domain.sh --host-config=host-master.xml -Djboss.bind.address=192.168.0.2 "
"-Djboss.bind.address.management=192.168.0.2"

msgid "Host slave bind addresses"
msgstr "ホスト・スレーブ・バインドアドレス"

msgid ""
"Next you'll have to change the `public`, `management`, and domain controller"
" bind addresses (`jboss.domain.master-address`).  Either edit the _host-"
"slave.xml_ file or specify them on the command line as follows:"
msgstr ""
"次は、 `public` 、 `management` 、ドメイン・コントローラー・バインドアドレス（ `jboss.domain.master-"
"address` ）を変更する必要があります 。 _host-slave.xml_ "
"ファイルを編集するか、以下のとおりコマンドラインでこれらを指定します。"

msgid ""
"$ domain.sh --host-config=host-slave.xml\n"
"     -Djboss.bind.address=192.168.0.5\n"
"      -Djboss.bind.address.management=192.168.0.5\n"
"       -Djboss.domain.master.address=192.168.0.2"
msgstr ""
"$ domain.sh --host-config=host-slave.xml\n"
"     -Djboss.bind.address=192.168.0.5\n"
"      -Djboss.bind.address.management=192.168.0.5\n"
"       -Djboss.domain.master.address=192.168.0.2"

msgid ""
"The values of `jboss.bind.address` and `jboss.bind.address.management` "
"pertain to the host slave's IP address. The value of "
"`jboss.domain.master.address` needs to be the IP address of the domain "
"controller, which is the management address of the master host."
msgstr ""
"`jboss.bind.address` と `jboss.bind.address.management` "
"の値はホストスレーブのIPアドレスに関係します。 `jboss.domain.master.address` "
"の値は、マスターホストの管理アドレスであるドメイン・コントローラーのIPアドレスとする必要があります。"

msgid "Additional resources"
msgstr "追加のリソース"

msgid ""
"See link:{appserver_loadbalancer_link}[the load balancing] section in the "
"_{appserver_loadbalancer_name}_ for information how to use other software-"
"based load balancers."
msgstr ""
"その他のソフトウェア・ベースのロードバランサーの使用方法については、 _{appserver_loadbalancer_name}_ "
"内のlink:{appserver_loadbalancer_link}[ロードバランシング]のセクションを参照してください。"

msgid "Sticky sessions"
msgstr "スティッキー・セッション"

msgid ""
"Typical cluster deployment consists of the load balancer (reverse proxy) and"
" 2 or more {project_name} servers on private network. For performance "
"purposes, it may be useful if load balancer forwards all requests related to"
" particular browser session to the same {project_name} backend node."
msgstr ""
"典型的なクラスター構成は、ロードバランサー（リバース・プロキシー）とプライベート・ネットワーク上の2つ以上の{project_name}サーバーで構成されています。パフォーマンスのために、ロードバランサーが特定のブラウザー・セッションに関するリクエストをすべて同じ{project_name}バックエンド・ノードに転送することは有用かもしれません。"

msgid ""
"The reason is, that {project_name} is using Infinispan distributed cache "
"under the covers for save data related to current authentication session and"
" user session. The Infinispan distributed caches are configured with one "
"owner by default. That means that particular session is saved just on one "
"cluster node and the other nodes need to lookup the session remotely if they"
" want to access it."
msgstr ""
"なぜなら、{project_name}が現在の認証セッションとユーザー・セッションに関するデータを保存するために、Infinispanの分散キャッシュを使用しているためです。Infinispanの分散キャッシュは、デフォルトで所有者は1つと設定されています。つまり、特定のセッションは1つのクラスター・ノードに保存され、他のノードがこのセッションにアクセスする場合は、リモートで検索する必要があります。"

msgid ""
"For example if authentication session with ID `123` is saved in the "
"Infinispan cache on `node1`, and then `node2` needs to lookup this session, "
"it needs to send the request to `node1` over the network to return the "
"particular session entity."
msgstr ""
"たとえば、ID `123` を持つ認証セッションが `node1` 上のInfinispanキャッシュに保存されていて、 `node2` "
"はこのセッションを検索する必要がある場合は、特定のセッション・エンティティーを返すためにネットワーク経由で `node1` "
"へリクエストを送信する必要があります。"

msgid ""
"It is beneficial if particular session entity is always available locally, "
"which can be done with the help of sticky sessions. The workflow in the "
"cluster environment with the public frontend load balancer and two backend "
"{project_name} nodes can be like this:"
msgstr ""
"特定のセッション・エンティティーが常にローカルで使用できる場合は、スティッキー・セッションに助けを借りることができます。パブリック・フロントエンド・ロードバランサーと2つのバックエンド{project_name}ノードを持つクラスター環境内のワークフローは、以下のようになります。"

msgid "User sends initial request to see the {project_name} login screen"
msgstr "ユーザーは{project_name}のログイン画面を表示するため初回リクエストを送信します。"

msgid ""
"This request is served by the frontend load balancer, which forwards it to "
"some random node (eg. node1). Strictly said, the node doesn't need to be "
"random, but can be chosen according to some other criterias (client IP "
"address etc). It all depends on the implementation and configuration of "
"underlying load balancer (reverse proxy)."
msgstr ""
"このリクエストは、フロントエンド・ロードバランサーによって処理され、このフロントエンド・ロードバランサーがランダムにノード（たとえばnode1）に転送します。厳密には、ノードはランダムである必要はなく、他のいくつかの基準（クライアントIPアドレスなど）によって選択することができます。それらはすべて、ロードバランサー（リバース・プロキシー）の実装と設定に依存します。"

msgid ""
"{project_name} creates authentication session with random ID (eg. 123) and "
"saves it to the Infinispan cache."
msgstr "{project_name}は認証セッションを任意のID（たとえば123）で作成し、Infinispanキャッシュに保存します。"

msgid ""
"Infinispan distributed cache assigns the primary owner of the session based "
"on the hash of session ID. See "
"link:https://infinispan.org/docs/10.1.x/titles/configuring/configuring.html#clustered_caches[Infinispan"
" documentation] for more details around this. Let's assume that Infinispan "
"assigned `node2` to be the owner of this session."
msgstr ""
"Infinispanの分散キャッシュは、セッションIDのハッシュに基づいてセッションの主な所有者を割り当てます。これに関する詳細は、link:https://infinispan.org/docs/10.1.x/titles/configuring/configuring.html#clustered_caches[Infinispanのドキュメント]を参照してください。Infinispanがこのセッションの所有者として"
" `node2` を割り当てたとしましょう。"

msgid ""
"{project_name} creates the cookie `AUTH_SESSION_ID` with the format like "
"`<session-id>.<owner-node-id>` . In our example case, it will be `123.node2`"
" ."
msgstr ""
"{project_name}は `<session-id>.<owner-node-id>` のような形式のCookie "
"`AUTH_SESSION_ID` を作成します。この例では `123.node2` となります。"

msgid ""
"Response is returned to the user with the {project_name} login screen and "
"the AUTH_SESSION_ID cookie in the browser"
msgstr ""
"レスポンスは、{project_name}のログイン画面とブラウザーの `AUTH_SESSION_ID` Cookieでユーザーに返されます。"

msgid ""
"From this point, it is beneficial if load balancer forwards all the next "
"requests to the `node2` as this is the node, who is owner of the "
"authentication session with ID `123` and hence Infinispan can lookup this "
"session locally. After authentication is finished, the authentication "
"session is converted to user session, which will be also saved on `node2` "
"because it has same ID `123` ."
msgstr ""
"以上の点から、ID `123` "
"を持つ認証セッションの所有者はこのノードであり、それゆえにInfinispanはローカルでこのセッションを検索できるため、ロードバランサーが "
"`node2` に対して以降のリクエストすべてを転送するなら有益なのです。認証セッションは、認証されるとユーザー・セッションに変換され、同じID "
"`123` を持っているため `node2` に保存されます。"

msgid ""
"The sticky session is not mandatory for the cluster setup, however it is "
"good for performance for the reasons mentioned above. You need to configure "
"your loadbalancer to sticky over the `AUTH_SESSION_ID` cookie. How exactly "
"do this is dependent on your loadbalancer."
msgstr ""
"スティッキー・セッションはクラスターの設定のために必須ではありませんが、上記の理由からパフォーマンスをあげるために有効です。 "
"`AUTH_SESSION_ID` Cookieで固定するようロードバランサーを設定する必要があります。どのように行うかはロードバランサーによります。"

msgid ""
"It is recommended on the {project_name} side to use the system property "
"`jboss.node.name` during startup, with the value corresponding to the name "
"of your route. For example, `-Djboss.node.name=node1` will use `node1` to "
"identify the route. This route will be used by Infinispan caches and will be"
" attached to the AUTH_SESSION_ID cookie when the node is the owner of the "
"particular key. Here is an example of the start up command using this system"
" property:"
msgstr ""
"{project_name}側では、起動時にシステム・プロパティー `jboss.node.name` "
"を使用し、経路名に対応する値を使用することをお勧めします。たとえば、 `-Djboss.node.name=node1` は経路を識別するために "
"`node1` "
"を使います。この経路はInfinispanのキャッシュで使用され、ノードが特定のキーの所有者である場合は、`AUTH_SESSION_ID` "
"Cookieに関連付けられます。このシステム・プロパティーを使用した起動コマンドの例を以下に示します。"

msgid ""
"cd $RHSSO_NODE1\n"
"./standalone.sh -c standalone-ha.xml -Djboss.socket.binding.port-offset=100 -Djboss.node.name=node1"
msgstr ""
"cd $RHSSO_NODE1\n"
"./standalone.sh -c standalone-ha.xml -Djboss.socket.binding.port-offset=100 -Djboss.node.name=node1"

msgid ""
"Typically in production environment the route name should use the same name "
"as your backend host, but it is not required. You can use a different route "
"name. For example, if you want to hide the host name of your {project_name} "
"server inside your private network."
msgstr ""
"通常、プロダクション環境では経路名はバックエンド・ホストと同じ名前を使うべきですが、必要ではありません。たとえば、プライベート・ネットワーク内の{project_name}サーバーのホスト名を隠す場合などに、別の経路名を使用できます。"

msgid "Disable adding the route"
msgstr "経路の追加を無効にする"

msgid ""
"Some load balancers can be configured to add the route information by "
"themselves instead of relying on the back end {project_name} node. However, "
"as described above, adding the route by the {project_name} is recommended. "
"This is because when done this way performance improves, since "
"{project_name} is aware of the entity that is the owner of particular "
"session and can route to that node, which is not necessarily the local node."
msgstr ""
"いくつかのロードバランサーは、バックエンドの{project_name}ノードに頼るのではなく、経路情報を自身で追加するように設定できます。ただし、前述のとおり、{project_name}による経路の追加が推奨されます。これは、{project_name}が特定のセッションの所有者であり、必ずしもローカルノードではないノードにルーティングできるエンティティーを認識しているため、このようにパフォーマンスが向上するためです。"

msgid ""
"You are permitted to disable adding route information to the AUTH_SESSION_ID"
" cookie by {project_name}, if you prefer, by adding the following into your "
"`RHSSO_HOME/standalone/configuration/standalone-ha.xml` file in the "
"{project_name} subsystem configuration:"
msgstr ""
"必要に応じて、{project_name}サブシステム設定の "
"`RHSSO_HOME/standalone/configuration/standalone-ha.xml` "
"ファイルに以下を追加することにより、`AUTH_SESSION_ID` Cookieへの経路情報の追加を無効にすることができます。"

msgid ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:1.1\">\n"
"  ...\n"
"    <spi name=\"stickySessionEncoder\">\n"
"        <provider name=\"infinispan\" enabled=\"true\">\n"
"            <properties>\n"
"                <property name=\"shouldAttachRoute\" value=\"false\"/>\n"
"            </properties>\n"
"        </provider>\n"
"    </spi>\n"
"\n"
"</subsystem>"
msgstr ""
"<subsystem xmlns=\"urn:jboss:domain:keycloak-server:1.1\">\n"
"  ...\n"
"    <spi name=\"stickySessionEncoder\">\n"
"        <provider name=\"infinispan\" enabled=\"true\">\n"
"            <properties>\n"
"                <property name=\"shouldAttachRoute\" value=\"false\"/>\n"
"            </properties>\n"
"        </provider>\n"
"    </spi>\n"
"\n"
"</subsystem>"

msgid "Setting up multicast networking"
msgstr "マルチキャストネットワークの設定"

msgid ""
"The default clustering support needs IP Multicast. Multicast is a network "
"broadcast protocol. This protocol is used at boot time to discover and join "
"the cluster. It is also used to broadcast messages for the replication and "
"invalidation of distributed caches used by {project_name}."
msgstr ""
"デフォルトのクラスタリング・サポートには、IPマルチキャストが必要です。マルチキャストは、ネットワークのブロードキャスト・プロトコルです。このプロトコルは、起動時にクラスターの検出と参加に使用されます。また、{project_name}が使用する分散キャッシュのレプリケーションや無効化のためのメッセージをブロードキャストするためにも使用されます。"

msgid ""
"The clustering subsystem for {project_name} runs on the JGroups stack. Out "
"of the box, the bind addresses for clustering are bound to a private network"
" interface with 127.0.0.1 as default IP address."
msgstr ""
"{project_name} "
"のクラスタリング・サブシステムはJGroupsスタックで動作しています。クラスタリング用のバインドアドレスは、デフォルトIPアドレスとして127.0.0.1を持つプライベート・ネットワーク・インターフェースにバインドされています。"

msgid ""
"Edit your the _standalone-ha.xml_ or _domain.xml_ sections discussed in the "
"<<_bind-address,Bind Address>> chapter."
msgstr ""
"<<_bind-address,Bind Address>>の章で説明した _standalone-ha.xml_ または _domain.xml_ "
"のセクションを編集してください。"

msgid "private network config"
msgstr "プライベート・ネットワーク設定"

msgid ""
"    <interfaces>\n"
"        ...\n"
"        <interface name=\"private\">\n"
"            <inet-address value=\"${jboss.bind.address.private:127.0.0.1}\"/>\n"
"        </interface>\n"
"    </interfaces>\n"
"    <socket-binding-group name=\"standard-sockets\" default-interface=\"public\" port-offset=\"${jboss.socket.binding.port-offset:0}\">\n"
"        ...\n"
"        <socket-binding name=\"jgroups-mping\" interface=\"private\" port=\"0\" multicast-address=\"${jboss.default.multicast.address:230.0.0.4}\" multicast-port=\"45700\"/>\n"
"        <socket-binding name=\"jgroups-tcp\" interface=\"private\" port=\"7600\"/>\n"
"        <socket-binding name=\"jgroups-tcp-fd\" interface=\"private\" port=\"57600\"/>\n"
"        <socket-binding name=\"jgroups-udp\" interface=\"private\" port=\"55200\" multicast-address=\"${jboss.default.multicast.address:230.0.0.4}\" multicast-port=\"45688\"/>\n"
"        <socket-binding name=\"jgroups-udp-fd\" interface=\"private\" port=\"54200\"/>\n"
"        <socket-binding name=\"modcluster\" port=\"0\" multicast-address=\"224.0.1.105\" multicast-port=\"23364\"/>\n"
"        ...\n"
"    </socket-binding-group>"
msgstr ""
"    <interfaces>\n"
"        ...\n"
"        <interface name=\"private\">\n"
"            <inet-address value=\"${jboss.bind.address.private:127.0.0.1}\"/>\n"
"        </interface>\n"
"    </interfaces>\n"
"    <socket-binding-group name=\"standard-sockets\" default-interface=\"public\" port-offset=\"${jboss.socket.binding.port-offset:0}\">\n"
"        ...\n"
"        <socket-binding name=\"jgroups-mping\" interface=\"private\" port=\"0\" multicast-address=\"${jboss.default.multicast.address:230.0.0.4}\" multicast-port=\"45700\"/>\n"
"        <socket-binding name=\"jgroups-tcp\" interface=\"private\" port=\"7600\"/>\n"
"        <socket-binding name=\"jgroups-tcp-fd\" interface=\"private\" port=\"57600\"/>\n"
"        <socket-binding name=\"jgroups-udp\" interface=\"private\" port=\"55200\" multicast-address=\"${jboss.default.multicast.address:230.0.0.4}\" multicast-port=\"45688\"/>\n"
"        <socket-binding name=\"jgroups-udp-fd\" interface=\"private\" port=\"54200\"/>\n"
"        <socket-binding name=\"modcluster\" port=\"0\" multicast-address=\"224.0.1.105\" multicast-port=\"23364\"/>\n"
"        ...\n"
"    </socket-binding-group>"

msgid ""
"Configure the `jboss.bind.address.private` and "
"`jboss.default.multicast.address` as well as the ports of the services on "
"the clustering stack."
msgstr ""
"クラスタリングスタック上のサービスのポートと同様に、 `jboss.bind.address.private` と  "
"`jboss.default.multicast.address`  を設定します。"

msgid ""
"It is possible to cluster {project_name} without IP Multicast, but this "
"topic is beyond the scope of this guide. For more information, see "
"link:{appserver_jgroups_link}[JGroups] in the _{appserver_jgroups_name}_."
msgstr ""
"IPマルチキャストなしで{project_name}をクラスタリングすることは可能ですが、このトピックはこのガイドの説明範囲を超えています。詳しくは、 "
"_{appserver_jgroups_name}_ 内の link:{appserver_jgroups_link}[JGroups] "
"を参照してください。"

msgid "Secure cluster communication"
msgstr "クラスター通信のセキュリティー保護"

msgid ""
"When cluster nodes are isolated on a private network it requires access to "
"the private network to be able to join a cluster or to view communication in"
" the cluster. In addition you can also enable authentication and encryption "
"for cluster communication. As long as your private network is secure it is "
"not necessary to enable authentication and encryption. {project_name} does "
"not send very sensitive information on the cluster in either case."
msgstr ""
"クラスター・ノードがプライベート・ネットワークで隔離されている場合は、クラスターに参加したり、クラスター内の通信を表示したりするために、プライベート・ネットワークへのアクセスが必要です。また、クラスター通信の認証と暗号化を有効にすることもできます。プライベート・ネットワークが安全である限り、認証と暗号化を有効にする必要はありません。どちらの場合も、{project_name}はクラスター上で機密情報を送信しません。"

msgid ""
"If you want to enable authentication and encryption for clustering "
"communication, see the 'High Availability Guide' in the "
"link:{appserver_doc_base_url}/High_Availability_Guide.html[WildFly "
"documentation]."
msgstr ""
"クラスタリング通信の認証と暗号化を有効にする場合は、 "
"link:{appserver_doc_base_url}/High_Availability_Guide.html[WildFly "
"documentation] にある'High Availability Guide'を参照してください。"

msgid "Serialized cluster startup"
msgstr "シリアライズされたクラスターの起動"

msgid ""
"{project_name} cluster nodes are allowed to boot concurrently. When "
"{project_name} server instance boots up it may do some database migration, "
"importing, or first time initializations. A DB lock is used to prevent start"
" actions from conflicting with one another when cluster nodes boot up "
"concurrently."
msgstr ""
"{project_name}クラスター・ノードは並行して起動することができます。{project_name}サーバー・インスタンスが起動すると、データベースの移行、インポート、初回の初期化を行います。DBロックは、クラスター・ノードが同時に起動した場合、起動アクションが競合するのを防ぐために使用されます。"

msgid ""
"By default, the maximum timeout for this lock is 900 seconds.  If a node is "
"waiting on this lock for more than the timeout it will fail to boot. "
"Typically you won't need to increase/decrease the default value, but just in"
" case it's possible to configure it in `standalone.xml`, `standalone-"
"ha.xml`, or `domain.xml` file in your distribution.  The location of this "
"file depends on your <<_operating-mode, operating mode>>."
msgstr ""
"デフォルトでは、このロックの最大タイムアウトは900秒です。ノードがこのタイムアウト時間を超えてロック状態のままだった場合、起動は失敗します。通常は、デフォルト値を増減する必要はありません。しかし、配布物内の"
" `standalone.xml` 、 `standalone-ha.xml` または `domain.xml` "
"ファイルで、念のためこの増減を設定することができます。このファイルの場所は、<<_operating-mode, 動作モード>>に依存します。"

msgid ""
"<spi name=\"dblock\">\n"
"    <provider name=\"jpa\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"lockWaitTimeout\" value=\"900\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"
msgstr ""
"<spi name=\"dblock\">\n"
"    <provider name=\"jpa\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"lockWaitTimeout\" value=\"900\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>"

msgid "Booting the cluster"
msgstr "クラスターの起動"

msgid ""
"Booting {project_name} in a cluster depends on your <<_operating-mode, "
"operating mode>>"
msgstr "クラスター内での{project_name}の起動は<<_operating-mode, 動作モード>>によって異なります。"

msgid "Standalone Mode"
msgstr "スタンドアローン・モード"

msgid "$ bin/standalone.sh --server-config=standalone-ha.xml"
msgstr "$ bin/standalone.sh --server-config=standalone-ha.xml"

msgid "Domain Mode"
msgstr "ドメインモード"

msgid ""
"$ bin/domain.sh --host-config=host-master.xml\n"
"$ bin/domain.sh --host-config=host-slave.xml"
msgstr ""
"$ bin/domain.sh --host-config=host-master.xml\n"
"$ bin/domain.sh --host-config=host-slave.xml"

msgid ""
"You may need to use additional parameters or system properties. For example,"
" the parameter `-b` for the binding host or the system property "
"`jboss.node.name` to specify the name of the route, as described in "
"<<sticky-sessions,Sticky Sessions >> section."
msgstr ""
"追加のパラメーターまたはシステム・プロパティーを使用する必要があります。たとえば、バインディング・ホストの場合は `-b` "
"パラメーターで、ルートの名前を指定する場合は `jboss.node.name` システム・プロパティーです（<<sticky-"
"sessions,スティッキー・セッション>>のセクションで説明しています）。"

msgid ""
"Note that when you run a cluster, you should see message similar to this in "
"the log of both cluster nodes:"
msgstr "クラスターを実行すると、両方のクラスターノードのログに以下のようなメッセージが表示されます。"

msgid ""
"INFO  [org.infinispan.remoting.transport.jgroups.JGroupsTransport] (Incoming-10,shared=udp)\n"
"ISPN000094: Received new cluster view: [node1/keycloak|1] (2) [node1/keycloak, node2/keycloak]"
msgstr ""
"INFO  [org.infinispan.remoting.transport.jgroups.JGroupsTransport] (Incoming-10,shared=udp)\n"
"ISPN000094: Received new cluster view: [node1/keycloak|1] (2) [node1/keycloak, node2/keycloak]"

msgid ""
"If you see just one node mentioned, it's possible that your cluster hosts "
"are not joined together."
msgstr "ノードが1つだけ表示されている場合、クラスターホストが同じクラスターに参加していない可能性があります。"

msgid ""
"Usually it's best practice to have your cluster nodes on private network "
"without firewall for communication among them. Firewall could be enabled "
"just on public access point to your network instead. If for some reason you "
"still need to have firewall enabled on cluster nodes, you will need to open "
"some ports. Default values are UDP port 55200 and multicast port 45688 with "
"multicast address 230.0.0.4. Note that you may need more ports opened if you"
" want to enable additional features like diagnostics for your JGroups stack."
" {project_name} delegates most of the clustering work to Infinispan/JGroups."
" For more information, see link:{appserver_jgroups_link}[JGroups] in the "
"_{appserver_jgroups_name}_."
msgstr ""
"通常、プライベート・ネットワーク上にクラスターノードを置き、ファイアウォールは置かずに通信するのがベスト・プラクティスです。その代わり、ネットワークへのパブリック・アクセス・ポイントでは、ファイアウォールを有効にすることができます。何らかの理由によりクラスターノードでファイアウォールを有効にする場合、ポートをいくつか開く必要があります。デフォルト値は、マルチキャスト・アドレス230.0.0.4のUDPポート55200とマルチキャスト・ポート45688です。JGroupsスタックの診断機能などの追加機能を有効にするには、ポートをさらに開く必要がありますので、その点は注意してください。{project_name}は、InfinispanまたはJGroupsにクラスタリング作業のほとんどを委譲します。詳しくは、"
" _{appserver_jgroups_name}_ "
"のlink:{appserver_jgroups_link}[JGroups]を参照してください。"

msgid ""
"If you are interested in failover support (high availability), evictions, "
"expiration and cache tuning, see <<cache-configuration>>."
msgstr ""
"フェイルオーバーのサポート（高可用性）、エビクション、有効期限およびキャッシュ・チューニングに関心がある場合は、<<cache-"
"configuration>>を参照してください。"

msgid "Server cache configuration"
msgstr "サーバー・キャッシュ設定"

msgid ""
"{project_name} has two types of caches.  One type of cache sits in front of "
"the database to decrease load on the DB and to decrease overall response "
"times by keeping data in memory.  Realm, client, role, and user metadata is "
"kept in this type of cache. This cache is a local cache.  Local caches do "
"not use replication even if you are in the cluster with more {project_name} "
"servers. Instead, they only keep copies locally and if the entry is updated "
"an invalidation message is sent to the rest of the cluster and the entry is "
"evicted. There is separate replicated cache `work`, which task is to send "
"the invalidation messages to the whole cluster about what entries  should be"
" evicted from local caches. This greatly reduces network traffic, makes "
"things efficient, and avoids transmitting sensitive metadata over the wire."
msgstr ""
"{project_name}には、2つのタイプのキャッシュがあります。1つ目のキャッシュは、データベースの前に置かれていて、DBの負荷を減らし、データをメモリーに保持することで全体の応答時間を短縮します。レルム、クライアント、ロール、およびユーザー・メタデータは、このタイプのキャッシュに保持されます。このキャッシュはローカル・キャッシュです。クラスターにより多くの{project_name}サーバーがある場合でも、ローカル・キャッシュはレプリケーションを使用しません。その代わり、ローカル・キャッシュはローカルにのみコピーを保持し、エントリーが更新された場合は無効化メッセージが残りのクラスターに送られてエントリーは追い出されます。これとは別にレプリケーションされるキャッシュ"
" `work` "
"があります。これは、どのエントリーがローカル・キャッシュから取り除かれるかについて、クラスター全体に無効化メッセージを送信するタスクになります。これによって、ネットワーク・トラフィックが大幅に減少し、効率化され、機密なメタデータのネットワーク経由での送信が回避されます。"

msgid ""
"The second type of cache handles managing user sessions, offline tokens, and"
" keeping track of login failures so that the server can detect password "
"phishing and other attacks.  The data held in these caches is temporary, in "
"memory only, but is possibly replicated across the cluster."
msgstr ""
"2つ目のキャッシュは、ユーザー・セッション、オフライン・トークン、ログイン・エラーの履歴保持の管理を担当し、サーバーがパスワード・フィッシングやその他の攻撃を検出できるようにします。これらのキャッシュ内のデータは一時的で、メモリーにのみ保持されるものですが、クラスター全体にレプリケーションされる可能性があります。"

msgid ""
"This chapter discusses some configuration options for these caches for both "
"clustered and non-clustered deployments."
msgstr "この章では、クラスター構成と非クラスター構成の両方のためのキャッシュ用設定オプションについて説明します。"

msgid ""
"More advanced configuration of these caches can be found in the  "
"link:{appserver_caching_link}[Infinispan] section of the "
"_{appserver_caching_name}_."
msgstr ""
"これらのキャッシュのより高度な設定については、　_{appserver_caching_name}_ "
"のlink:{appserver_caching_link}[Infinispan]のセクションを参照してください。"

msgid "Eviction and expiration"
msgstr "退避と有効期限"

msgid ""
"There are multiple different caches configured for {project_name}. There is "
"a realm cache that holds information about secured applications, general "
"security data, and configuration options. There is also a user cache that "
"contains user metadata.  Both caches default to a maximum of 10000 entries "
"and use a least recently used eviction strategy. Each of them is also tied "
"to an object revisions cache that controls eviction in a clustered setup. "
"This cache is created implicitly and has twice the configured size. The same"
" applies for the `authorization` cache, which holds the authorization data. "
"The `keys` cache holds data about external keys and does not need to have "
"dedicated revisions cache. Rather it has `expiration` explicitly declared on"
" it, so the keys are periodically expired and forced to be periodically "
"downloaded from external clients or identity providers."
msgstr ""
"{project_name}には、さまざまなキャッシュの設定があります。その一つにレルムキャッシュというものがあり、セキュリティー保護されたアプリケーション、一般的なセキュリティー・データおよび設定オプションに関する情報を保持しています。また、ユーザー・メタデータを含むユーザー・キャッシュがあります。このキャッシュのデフォルト値は最大10000エントリーで、最近最も使われなかったものを退避する戦略が使用されます。また、これらのキャッシュはそれぞれ、クラスター構成内での退避を制御するオブジェクト・リビジョン・キャッシュにも関連付けられています。このキャッシュは暗黙的に作成され、設定されたサイズの2倍のサイズがあります。認可データを保持する"
" `authorization` キャッシュについても同様です。 `keys` "
"キャッシュは外部キーに関するデータを保持し、専用のリビジョン・キャッシュを保持する必要はありません。それはむしろ明示的に `expiration` "
"が宣言されているので、キーは定期的に期限切れとなり、外部のクライアントやアイデンティティー・プロバイダーから定期的にダウンロードされます。"

msgid ""
"The eviction policy and max entries for these caches can be configured in "
"the _standalone.xml_, _standalone-ha.xml_, or _domain.xml_ depending on your"
" <<_operating-mode, operating mode>>. In the configuration file, there is "
"the part with infinispan subsystem, which looks similar to this:"
msgstr ""
"これらのキャッシュの退避ポリシーと最大エントリーは、<<_operating-mode, 動作モード>>に応じて _standalone.xml_ 、 "
"_standalone-ha.xml_ または _domain.xml_ "
"内で設定することができます。設定ファイルには、infinispanサブシステムの次のような部分があります。"

msgid ""
"<subsystem xmlns=\"{subsystem_infinispan_xml_urn}\">\n"
"    <cache-container name=\"keycloak\">\n"
"        <local-cache name=\"realms\">\n"
"            <object-memory size=\"10000\"/>\n"
"        </local-cache>\n"
"        <local-cache name=\"users\">\n"
"            <object-memory size=\"10000\"/>\n"
"        </local-cache>\n"
"        ...\n"
"        <local-cache name=\"keys\">\n"
"            <object-memory size=\"1000\"/>\n"
"            <expiration max-idle=\"3600000\"/>\n"
"        </local-cache>\n"
"        ...\n"
"    </cache-container>"
msgstr ""
"<subsystem xmlns=\"{subsystem_infinispan_xml_urn}\">\n"
"    <cache-container name=\"keycloak\">\n"
"        <local-cache name=\"realms\">\n"
"            <object-memory size=\"10000\"/>\n"
"        </local-cache>\n"
"        <local-cache name=\"users\">\n"
"            <object-memory size=\"10000\"/>\n"
"        </local-cache>\n"
"        ...\n"
"        <local-cache name=\"keys\">\n"
"            <object-memory size=\"1000\"/>\n"
"            <expiration max-idle=\"3600000\"/>\n"
"        </local-cache>\n"
"        ...\n"
"    </cache-container>"

msgid ""
"To limit or expand the number of allowed entries simply add or edit the "
"`object` element or the `expiration` element of particular cache "
"configuration."
msgstr ""
"許可されたエントリーの数を制限したり拡張したりするには、特定のキャッシュ設定の `object` 要素または `expiration` "
"要素を追加または編集するだけでできます。"

msgid ""
"In addition, there are also separate caches `sessions`, `clientSessions`, "
"`offlineSessions`, `offlineClientSessions`, `loginFailures` and "
"`actionTokens`. These caches are distributed in cluster environment and they"
" are unbounded in size by default. If they are bounded, it would then be "
"possible that some sessions will be lost. Expired sessions are cleared "
"internally by {project_name} itself to avoid growing the size of these "
"caches without limit. If you see memory issues due to a large number of "
"sessions, you can try to:"
msgstr ""
"さらに、 `sessions` 、 `clientSessions` 、 `offlineSessions` 、 "
"`offlineClientSessions` 、 `loginFailures` 、 `actionTokens` "
"といったキャッシュもあります。これらのキャッシュはクラスター環境で分散され、デフォルトではサイズが制限されていません。制限がある場合、一部のセッションが失われる可能性があります。制限なしにこれらのキャッシュサイズが増大することを避けるために、期限切れのセッションは{project_name}自身によって内部的にクリアされます。多数のセッションが原因でメモリーの問題が発生した場合は、次の操作を試すことができます。"

msgid ""
"Increase the size of cluster (more nodes in cluster means that sessions are "
"spread more equally among nodes)"
msgstr "クラスターのサイズを大きくします（クラスター内のノードが多いほど、セッションはノード間でより均等に分散されます）"

msgid "Increase the memory for {project_name} server process"
msgstr "{project_name}サーバープロセスのメモリーを増やします"

msgid ""
"Decrease the number of owners to ensure that caches are saved in one single "
"place. See <<_replication>> for more details"
msgstr "キャッシュが1つの場所に保存されるように、所有者の数を減らします。詳細は<<_replication>>を参照してください"

msgid ""
"Disable l1-lifespan for distributed caches. See Infinispan documentation for"
" more details"
msgstr "分散キャッシュのl1-lifespanを無効にします。詳細については、Infinispanのマニュアルを参照してください。"

msgid ""
"Decrease session timeouts, which could be done individually for each realm "
"in {project_name} admin console. But this could affect usability for end "
"users. See link:{adminguide_timeouts_link}[{adminguide_timeouts_name}] for "
"more details."
msgstr ""
"セッション・タイムアウトを減らします。これは{project_name}管理コンソールの各レルムで個別に実行できます。しかし、これはエンドユーザーのユーザビリティーに影響する可能性があります。詳細については、"
" link:{adminguide_timeouts_link}[{adminguide_timeouts_name}] を参照してください。"

msgid ""
"There is an additional replicated cache, `work`, which is mostly used to "
"send messages among cluster nodes; it is also unbounded by default. However,"
" this cache should not cause any memory issues as entries in this cache are "
"very short-lived."
msgstr ""
"クラスターノード間でメッセージを送信するために主に使用される追加のレプリケーション・キャッシュ `work` "
"があります。デフォルトでは無制限です。ただし、このキャッシュ内のエントリーは非常に短期間であるため、このキャッシュがメモリーの問題を引き起こすことはありません。"

msgid "Replication and failover"
msgstr "レプリケーションとフェイルオーバー"

msgid ""
"There are caches like `sessions`, `authenticationSessions`, "
"`offlineSessions`, `loginFailures` and a few others (See <<_eviction>> for "
"more details), which are configured as distributed caches when using a "
"clustered setup. Entries are not replicated to every single node, but "
"instead one or more nodes is chosen as an owner of that data.  If a node is "
"not the owner of a specific cache entry it queries the cluster to obtain it."
"  What this means for failover is that if all the nodes that own a piece of "
"data go down, that data is lost forever.  By default, {project_name} only "
"specifies one owner for data.  So if that one node goes down that data is "
"lost.  This usually means that users will be logged out and will have to "
"login again."
msgstr ""
"`sessions` 、 `authenticationSessions` 、 `offlineSessions`  、 `loginFailures`"
" "
"などのキャッシュがあります（詳細は<<_eviction>>を参照）。クラスター化された設定を使用するときは分散キャッシュとして設定されます。エントリーはすべてのノードにひとつひとつレプリケーションされるわけではありませんが、1つ以上のノードがそのデータの所有者として選ばれます。ノードが特定のキャッシュ・エントリーの所有者ではない場合は、そのキャッシュ・エントリーを取得するためにクラスターに問い合わせをします。これがフェイルオーバーに対して何を意味するかというと、データを保持しているノードがすべてダウンした場合は、そのデータは永遠に失われてしまうということです。デフォルトでは、{project_name}が指定するデータの所有者は1つだけです。そのため、その1つのノードがダウンした場合は、そのデータは失われることになります。このことは通常、ユーザーはログアウトされ、再度ログインし直さなければならないということを意味します。"

msgid ""
"You can change the number of nodes that replicate a piece of data by change "
"the `owners` attribute in the `distributed-cache` declaration."
msgstr ""
"`distributed-cache` の宣言で `owners` 属性を変更すると、データをレプリケートするノードの数を変更することができます。"

msgid "owners"
msgstr "owners"

msgid ""
"<subsystem xmlns=\"{subsystem_infinispan_xml_urn}\">\n"
"   <cache-container name=\"keycloak\">\n"
"       <distributed-cache name=\"sessions\" owners=\"2\"/>\n"
"..."
msgstr ""
"<subsystem xmlns=\"{subsystem_infinispan_xml_urn}\">\n"
"   <cache-container name=\"keycloak\">\n"
"       <distributed-cache name=\"sessions\" owners=\"2\"/>\n"
"..."

msgid ""
"Here we've changed it so at least two nodes will replicate one specific user"
" login session."
msgstr "ここで上記のとおりに変更すると、少なくとも2つのノードが1つの特定のユーザー・ログイン・セッションをレプリケーションします。"

msgid ""
"The number of owners recommended is really dependent on your deployment.  If"
" you do not care if users are logged       out when a node goes down, then "
"one owner is good enough and you will avoid replication."
msgstr ""
"推奨される所有者数は、構成によって異なります。ノードがダウンした時にユーザーがログアウトされてもされなくても良い場合は、所有者は1つで十分であり、レプリケーションを避けることができます。"

msgid ""
"It is generally wise to configure your environment to use loadbalancer with "
"sticky sessions. It is beneficial for performance      as {project_name} "
"server, where the particular request is served, will be usually the owner of"
" the data from the distributed cache      and will therefore be able to look"
" up the data locally. See <<sticky-sessions>> for more details."
msgstr ""
"スティッキー・セッションでロードバランサーを使用するように環境を設定することは、一般的には賢明です。通常は、特定のリクエストが処理される{project_name}サーバーが分散キャッシュデータの所有者であるため、ローカルでデータをルックアップできますので、パフォーマンスを向上させるために有益です。詳細は<<sticky-"
"sessions>>を参照してください。"

msgid "Disabling caching"
msgstr "キャッシングの無効化"

msgid "You can disable the realm or user cache."
msgstr "レルムキャッシュやユーザーキャッシュを無効にすることができます。"

msgid ""
"Edit the `standalone.xml`, `standalone-ha.xml`,  or `domain.xml` file in "
"your distribution."
msgstr ""
"配布物内の `standalone.xml` 、 `standalone-ha.xml` 、  `domain.xml` ファイルを編集します。"

msgid ""
"The location of this file depends on your <<_operating-mode, operating "
"mode>>. Here is a sample config file."
msgstr "このファイルの場所は、<<_operating-mode, 動作モード>>に依存します。以下に設定ファイルのサンプルを示します。"

msgid ""
"\n"
"    <spi name=\"userCache\">\n"
"        <provider name=\"default\" enabled=\"true\"/>\n"
"    </spi>\n"
"\n"
"    <spi name=\"realmCache\">\n"
"        <provider name=\"default\" enabled=\"true\"/>\n"
"    </spi>\n"
msgstr ""
"\n"
"    <spi name=\"userCache\">\n"
"        <provider name=\"default\" enabled=\"true\"/>\n"
"    </spi>\n"
"\n"
"    <spi name=\"realmCache\">\n"
"        <provider name=\"default\" enabled=\"true\"/>\n"
"    </spi>\n"

msgid ""
"Set the `enabled` attribute to false for the cache you want to disable."
msgstr "無効にしたいキャッシュの `enabled` 属性をfalseに設定します。"

msgid "Reboot your server for this change to take effect."
msgstr "この変更を有効にするには、サーバーを再起動してください。"

msgid "Clearing cache at runtime"
msgstr "実行時のキャッシュクリア"

msgid ""
"You can clear the realm cache, user cache, or the external public keys."
msgstr "レルムキャッシュ、ユーザーキャッシュ、外部の公開鍵のいずれかをクリアすることができます。"

msgid "Log into the Admin Console."
msgstr "管理コンソールにログインします。"

msgid "Click *Realm Settings*."
msgstr "*Realm Settings* をクリックします。"

msgid "Click the *Cache* tab."
msgstr "*Cache* タブをクリックします。"

msgid ""
"Clear the realm cache, the user cache or cache of external public keys."
msgstr "レルムキャッシュ、ユーザーキャッシュ、外部の公開鍵のキャッシュをクリアします。"

msgid "The cache will be cleared for all realms!"
msgstr "すべてのレルムのキャッシュがクリアされます。"

msgid "{project_operator}"
msgstr "{project_operator}"

msgid ""
"The {project_operator} automates {project_name} administration in Kubernetes"
" or Openshift. You use this Operator to create custom resources (CRs), which"
" automate administrative tasks. For example, instead of creating a client or"
" a user in the {project_name} admin console, you can create custom resources"
" to perform those tasks. A custom resource is a YAML file that defines the "
"parameters for the administrative task."
msgstr ""
"Openshift。このオペレーターを使用して、管理タスクを自動化するカスタムリソース（CR）を作成します。たとえば、{project_name}管理コンソールでクライアントまたはユーザーを作成する代わりに、これらのタスクを実行するカスタムリソースを作成できます。カスタムリソースは、管理タスクのパラメーターを定義するYAMLファイルです。"

msgid "You can create custom resources to perform the following tasks:"
msgstr "カスタムリソースを作成して、次のタスクを実行できます。"

msgid "xref:_keycloak_cr[Install {project_name}]"
msgstr "xref:_keycloak_cr[Install {project_name}]"

msgid "xref:_realm-cr[Create realms]"
msgstr "xref:_realm-cr[Create realms]"

msgid "xref:_client-cr[Create clients]"
msgstr "xref:_client-cr[Create clients]"

msgid "xref:_user-cr[Create users]"
msgstr "xref:_user-cr[Create users]"

msgid "xref:_external_database[Connect to an external database]"
msgstr "xref:_external_database[Connect to an external database]"

msgid "xref:_backup-cr[Schedule database backups]"
msgstr "xref:_backup-cr[Schedule database backups]"

msgid "xref:_operator-extensions[Install extensions and themes]"
msgstr "xref:_operator-extensions[Install extensions and themes]"

msgid ""
"After you create custom resources for realms, clients, and users, you can "
"manage them by using the {project_name} admin console or as custom resources"
" using the `{create_cmd_brief}` command.  However, you cannot use both "
"methods, because the Operator performs a one way sync for custom resources "
"that you modify.  For example, if you modify a realm custom resource, the "
"changes show up in the admin console. However, if you modify the realm using"
" the admin console, those changes have no effect on the custom resource."
msgstr ""
"レルム、クライアント、ユーザーのカスタムリソースを作成したら、{project_name}管理コンソールを使用するか、 "
"`{create_cmd_brief}` "
"コマンドを使用してカスタムリソースとして管理できます。ただし、オペレーターは変更したカスタムリソースに対して一方向の同期を実行するため、両方の方法を使用することはできません。たとえば、レルムのカスタムリソースを変更すると、その変更が管理コンソールに表示されます。ただし、管理コンソールを使用してレルムを変更した場合、それらの変更はカスタムリソースには影響しません。"

msgid ""
"Begin using the Operator by xref:_installing-operator[Installing the "
"{project_operator} on a cluster]."
msgstr ""
"xref:_installing-operator[{project_operator}のインストール] でオペレーターの使用を開始します。"

msgid "Installing the {project_operator} on a cluster"
msgstr "クラスターに{project_operator}をインストールする"

msgid "To install the {project_operator}, you can use:"
msgstr "{project_operator}をインストールするには、以下を使用できます。"

msgid "xref:_install_by_olm[The Operator Lifecycle Manager (OLM)]"
msgstr "xref:_install_by_olm[Operator Lifecycle Manager（OLM）]"

msgid "xref:_install_by_command[Command line installation]"
msgstr "xref:_install_by_command[コマンドライン・インストール]"

msgid "Installing using the Operator Lifecycle Manager"
msgstr "Operator Lifecycle Managerを使用したインストール"

msgid ""
"You can install the Operator on an xref:_openshift-olm[OpenShift] or "
"xref:_kubernetes-olm[Kubernetes] cluster."
msgstr ""
"Operatorは、 xref:_openshift-olm[OpenShift] または xref:_kubernetes-"
"olm[Kubernetes] クラスターにインストールできます。"

msgid "Installation on an OpenShift cluster"
msgstr "OpenShiftクラスターへのインストール"

msgid ""
"You have cluster-admin permission or an equivalent level of permissions "
"granted by an administrator."
msgstr "cluster-adminパーミッションまたは同等のレベルのパーミッションが管理者によって付与されていること。"

msgid "Perform this procedure on an OpenShift cluster."
msgstr "OpenShiftクラスターでこの手順を実行します。"

msgid "Open the OpenShift Container Platform web console."
msgstr "OpenShift Container Platform Webコンソールを開きます。"

msgid "In the left column, click `Operators, OperatorHub`."
msgstr "左側の列で、 `Operators, OperatorHub` をクリックします。"

msgid "Search for {project_name} Operator."
msgstr "{project_name} Operatorを検索します。"

msgid "OperatorHub tab in OpenShift"
msgstr "OpenShiftのOperatorHubタブ"

msgid "image:{project_images}/operator-openshift-operatorhub.png[]"
msgstr "image:{project_images}/operator-openshift-operatorhub.png[]"

msgid "Click the {project_name} Operator icon."
msgstr "{project_name}オペレーター・アイコンをクリックします。"

msgid "An Install page opens."
msgstr "インストール・ページが開きます。"

msgid "Operator Install page on OpenShift"
msgstr "OpenShiftのOperatorインストール・ページ"

msgid "image:{project_images}/operator-olm-installation.png[]"
msgstr "image:{project_images}/operator-olm-installation.png[]"

msgid "Click `Install`."
msgstr "`Install` をクリックします。"

msgid "Select a namespace and click Subscribe."
msgstr "ネームスペースを選択し、Subscribeをクリックします。"

msgid "Namespace selection in OpenShift"
msgstr "OpenShiftでのネームスペースの選択"

msgid "image:images/installed-namespace.png[]"
msgstr "image:images/installed-namespace.png[]"

msgid "The Operator starts installing."
msgstr "Operatorがインストールを開始します。"

msgid ""
"When the Operator installation completes, you are ready to create your first"
" custom resource. See xref:_keycloak_cr[{project_name} installation using a "
"custom resource]. However, if you want to start tracking all Operator "
"activities before creating custom resources, see the xref:_monitoring-"
"operator[Application Monitoring Operator]."
msgstr ""
"Operatorのインストールが完了すると、最初のカスタムリソースを作成する準備が整います。 "
"xref:_keycloak_cr[{project_name} カスタムリソースを使用したインストール] "
"を参照してください。ただし、カスタムリソースを作成する前にすべてのOperatorアクティビティーの追跡を開始する場合は、 "
"xref:_monitoring-operator[Application Monitoring Operator] を参照してください。"

msgid ""
"For more information on OpenShift Operators, see the "
"link:https://docs.openshift.com/container-platform/4.4/operators/olm-what-"
"operators-are.html[OpenShift Operators guide]."
msgstr ""
"OpenShiftオペレーターの詳細については、 link:https://docs.openshift.com/container-"
"platform/4.4/operators/olm-what-operators-are.html[OpenShift Operators "
"guide] を参照してください。"

msgid "Installation on a Kubernetes cluster"
msgstr "Kubernetesクラスターへのインストール"

msgid "For a Kubernetes cluster, perform these steps."
msgstr "Kubernetesクラスターの場合、次の手順を実行します。"

msgid ""
"Go to link:https://operatorhub.io/operator/keycloak-operator[Keycloak "
"Operator on OperatorHub.io]."
msgstr ""
"link:https://operatorhub.io/operator/keycloak-operator[Keycloak Operator on "
"OperatorHub.io] に移動します。"

msgid "Follow the instructions on the screen."
msgstr "画面の指示に従ってください。"

msgid "Operator Install page on Kubernetes"
msgstr "KubernetesのOperatorインストール・ページ"

msgid "image:{project_images}/operator-operatorhub-install.png[]"
msgstr "image:{project_images}/operator-operatorhub-install.png[]"

msgid ""
"For more information on a Kubernetes installation, see "
"link:https://operatorhub.io/how-to-install-an-operator[How to install an "
"Operator from OperatorHub.io]."
msgstr ""
"Kubernetesのインストールの詳細については、 link:https://operatorhub.io/how-to-install-an-"
"operator[How to install an Operator from OperatorHub.io] を参照してください。"

msgid "Installing from the command line"
msgstr "コマンドラインからのインストール"

msgid "You can install the {project_operator} from the command line."
msgstr "コマンドラインから{project_operator}をインストールできます。"

msgid ""
"Obtain the software to install from this location: "
"link:{operatorRepo_link}[Github repo]."
msgstr "次の場所からインストールするソフトウェアを入手してください。link:{operatorRepo_link}[Github repo]"

msgid "Install all required custom resource definitions:"
msgstr "必要なすべてのカスタムリソース定義をインストールします。"

msgid "$ {create_cmd} -f deploy/crds/"
msgstr "$ {create_cmd} -f deploy/crds/"

msgid ""
"Create a new namespace (or reuse an existing one) such as the namespace "
"`myproject`:"
msgstr "ネームスペース `myproject` などの新しいネームスペースを作成（または既存のネームスペースを再利用）します。"

msgid "$ {create_cmd_brief} create namespace myproject"
msgstr "$ {create_cmd_brief} create namespace myproject"

msgid "Deploy a role, role binding, and service account for the Operator:"
msgstr "Operatorのロール、ロール・バインディング、およびサービス・アカウントをデプロイします。"

msgid ""
"$ {create_cmd} -f deploy/role.yaml -n myproject\n"
"$ {create_cmd} -f deploy/role_binding.yaml -n myproject\n"
"$ {create_cmd} -f deploy/service_account.yaml -n myproject"
msgstr ""
"$ {create_cmd} -f deploy/role.yaml -n myproject\n"
"$ {create_cmd} -f deploy/role_binding.yaml -n myproject\n"
"$ {create_cmd} -f deploy/service_account.yaml -n myproject"

msgid "Deploy the Operator:"
msgstr "Operatorを配置します。"

msgid "$ {create_cmd} -f deploy/operator.yaml -n myproject"
msgstr "$ {create_cmd} -f deploy/operator.yaml -n myproject"

msgid "Confirm that the Operator is running:"
msgstr "Operatorが実行されていることを確認します。"

msgid ""
"$ {create_cmd_brief} get deployment keycloak-operator -n myproject\n"
"NAME                READY   UP-TO-DATE   AVAILABLE   AGE\n"
"keycloak-operator   1/1     1            1           41s"
msgstr ""
"$ {create_cmd_brief} get deployment keycloak-operator -n myproject\n"
"NAME                READY   UP-TO-DATE   AVAILABLE   AGE\n"
"keycloak-operator   1/1     1            1           41s"

msgid "Using the {project_operator} in production environment"
msgstr "プロダクション環境での{project_operator}の使用"

msgid "The usage of embedded DB is not supported in a production environment."
msgstr "プロダクション環境では、組み込みDBの使用はサポートされていません。"

msgid ""
"Backup CRD is deprecated and not supported in a production environment."
msgstr "バックアップCRDは非推奨で、プロダクション環境ではサポートされていません。"

msgid ""
"The `podDisruptionBudget` field in the Keycloak CR is deprecated and will be"
" ignored when the Operator is deployed on Kubernetes version 1.25 and "
"higher."
msgstr ""

msgid ""
"We fully support using the rest of the CRDs in production, despite the "
"`v1alpha1` version. We do not plan to make any breaking changes in this CRDs"
" version."
msgstr ""
"我々は、 `v1alpha1` "
"バージョンにもかかわらず、残りのCRDをプロダクション環境で使用することを完全にサポートします。このCRDのバージョンでは、破壊的な変更を行う予定はありません。"

msgid "The {application_monitoring_operator}"
msgstr "{application_monitoring_operator}"

msgid ""
"Before using the Operator to install {project_name} or create components, we"
" recommend that you install the {application_monitoring_operator}, which "
"tracks Operator activity. To view metrics for the Operator, you can use the "
"Grafana Dashboard and Prometheus Alerts from the "
"{application_monitoring_operator}. For example, you can view metrics such as"
" the number of controller runtime reconciliation loops, the reconcile loop "
"time, and errors."
msgstr ""
"Operatorを使用して{project_name}をインストールまたはコンポーネントを作成する前に、Operatorのアクティビティーを追跡する{application_monitoring_operator}をインストールすることをお勧めします。Operatorのメトリクスを表示するには、{application_monitoring_operator}からGrafanaダッシュボードとPrometheusアラートを使用できます。たとえば、コントローラーのランタイム・リコンシリエーション・ループの数、リコンシリエーション・ループ時間、エラーなどのメトリクスを表示できます。"

msgid ""
"The {project_operator} integration with the "
"{application_monitoring_operator} requires no action. You only need to "
"install the {application_monitoring_operator} in the cluster."
msgstr ""
"{project_operator}と{application_monitoring_operator}の統合に、アクションは必要ありません。クラスターに{application_monitoring_operator}をインストールするだけです。"

msgid "Installing the {application_monitoring_operator}"
msgstr "{application_monitoring_operator}のインストール"

msgid "The {project_operator} is installed."
msgstr "{project_operator}がインストールされていること。"

msgid ""
"Install the {application_monitoring_operator} by using the "
"link:{application_monitoring_operator_installation_link}[documentation]."
msgstr ""
"link:{application_monitoring_operator_installation_link}[documentation] "
"を使用して{application_monitoring_operator}をインストールします。"

msgid ""
"Annotate the namespace used for the {project_operator} installation. For "
"example:"
msgstr "{project_operator}のインストールに使用されるネームスペースに注釈を付けます。例："

msgid ""
"{create_cmd_brief} label namespace <namespace> monitoring-key=middleware"
msgstr ""
"{create_cmd_brief} label namespace <namespace> monitoring-key=middleware"

msgid "Log into the OpenShift web console."
msgstr "OpenShift Webコンソールにログインします。"

msgid ""
"Confirm monitoring is working by searching for Prometheus and Grafana route "
"in the `application-monitoring` namespace."
msgstr ""
"`application-monitoring` "
"ネームスペースの中のPrometheusおよびGrafanaルートを検索して、モニタリングが機能していることを確認します。"

msgid "Routes in OpenShift web console"
msgstr "OpenShift Webコンソールでのルート"

msgid "image:{project_images}/operator-application-monitoring-routes.png[]"
msgstr "image:{project_images}/operator-application-monitoring-routes.png[]"

msgid "Viewing Operator Metrics"
msgstr "Operatorメトリクスの表示"

msgid ""
"Grafana and Promotheus each provide graphical information about Operator "
"activities."
msgstr "GrafanaとPrometheusはそれぞれ、Operatorアクティビティーに関するグラフィカルな情報を提供します。"

msgid "The Operator installs a pre-defined Grafana Dashboard as shown here:"
msgstr "Operatorは、次のような事前定義されたGrafanaダッシュボードをインストールします。"

msgid "Grafana Dashboard"
msgstr "Grafanaダッシュボード"

msgid "image:{project_images}/operator-graphana-dashboard.png[]"
msgstr "image:{project_images}/operator-graphana-dashboard.png[]"

msgid ""
"If you make customizations, we recommend that you clone the Grafana "
"Dashboard so that your changes are not overwritten during an upgrade."
msgstr "カスタマイズを行う場合は、アップグレード中に変更が上書きされないように、Grafanaダッシュボードを複製することをお勧めします。"

msgid ""
"The Operator installs a set of pre-defined Prometheus Alerts as shown here:"
msgstr "Operatorは、以下に示すように、事前定義されたPrometheusアラートのセットをインストールします。"

msgid "Prometheus Alerts"
msgstr "Prometheusアラート"

msgid "image:{project_images}/operator-prometheus-alerts.png[]"
msgstr "image:{project_images}/operator-prometheus-alerts.png[]"

msgid ""
"For more information, see link:https://docs.openshift.com/container-"
"platform/latest/monitoring/cluster_monitoring/prometheus-alertmanager-and-"
"grafana.html[Accessing Prometheus, Alertmanager, and Grafana]."
msgstr ""
"詳細については、 link:https://docs.openshift.com/container-"
"platform/latest/monitoring/cluster_monitoring/prometheus-alertmanager-and-"
"grafana.html[Accessing Prometheus, Alertmanager, and Grafana] を参照してください。"

msgid "Installing {project_name} using a custom resource"
msgstr "カスタムリソースを使用した{project_name}のインストール "

msgid ""
"You can use the Operator to automate the installation of {project_name} by "
"creating a Keycloak custom resource. When you use a custom resource to "
"install {project_name}, you create the components and services that are "
"described here and illustrated in the graphic that follows."
msgstr ""
"Operatorを使用して、Keycloakカスタムリソースを作成することにより、{project_name}のインストールを自動化できます。カスタムリソースを使用して{project_name}をインストールする場合、ここで説明し、次の図に示すコンポーネントとサービスを作成します。"

msgid ""
"`keycloak-db-secret` - Stores properties such as the database username, "
"password, and external address (if you connect to an external database)"
msgstr ""
"`keycloak-db-secret` - "
"データベースのユーザー名、パスワード、外部アドレス（外部データベースに接続している場合）などのプロパティーを保存します"

msgid ""
"`credentials-<CR-Name>` - Admin username and password to log into the "
"{project_name} admin console (the `<CR-Name>` is based on the `Keycloak` "
"custom resource name)"
msgstr ""
"`credentials-<CR-Name>` - 管理コンソールにログインするための管理者ユーザー名とパスワード（ `<CR-Name>` は "
"`Keycloak` カスタムリソース名に基づいています）"

msgid ""
"`keycloak` - Keycloak deployment specification that is implemented as a "
"StatefulSet with high availability support"
msgstr "`keycloak` - 高可用性サポートを備えたStatefulSetとして実装されるKeycloakデプロイメント仕様"

msgid "`keycloak-postgresql` - Starts a PostgreSQL database installation"
msgstr "`keycloak-postgresql` - PostgreSQLデータベースのインストールを開始します"

msgid "`keycloak-discovery` Service - Performs `JDBC_PING` discovery"
msgstr "`keycloak-discovery` Service - `JDBC_PING` 検出を実行します"

msgid ""
"`keycloak` Service - Connects to {project_name} through HTTPS (HTTP is not "
"supported)"
msgstr "`keycloak` サービス - HTTPSを介して{project_name}に接続します（HTTPはサポートされていません）"

msgid ""
"`keycloak-postgresql` Service - Connects an internal and external, if used, "
"database instance"
msgstr "`keycloak-postgresql` サービス - 内部と外部（使用されている場合）のデータベース・インスタンスを接続します"

msgid ""
"`keycloak` Route - The URL for accessing the {project_name} admin console "
"from OpenShift"
msgstr "`keycloak` ルート - OpenShiftから{project_name}管理コンソールにアクセスするためのURL"

msgid ""
"`keycloak` Ingress - The URL for accessing the {project_name} admin console "
"from Kubernetes"
msgstr "`keycloak` Ingress - Kubernetesから{project_name}管理コンソールにアクセスするためのURL"

msgid "How Operator components and services interact"
msgstr "Operatorコンポーネントとサービスの相互作用"

msgid "image:{project_images}/operator-components.png[]"
msgstr "image:{project_images}/operator-components.png[]"

msgid "The Keycloak custom resource"
msgstr "Keycloakカスタムリソース"

msgid ""
"The Keycloak custom resource is a YAML file that defines the parameters for "
"installation.  This file contains three properties."
msgstr ""
"Keycloakカスタムリソースは、インストール用のパラメーターを定義するYAMLファイルです。このファイルには3つのプロパティーが含まれています。"

msgid ""
"`instances` - controls the number of instances running in high availability "
"mode."
msgstr "`instances` - 高可用性モードで実行されているインスタンスの数を制御します。"

msgid ""
"`externalAccess` - if the `enabled` is `True`, the Operator creates a route "
"for OpenShift or an Ingress for Kubernetes for the {project_name} cluster. "
"You can set `host` to override the automatically chosen host name for Route "
"or default value `keycloak.local` set for Ingress."
msgstr ""
"`externalAccess` - `enabled` が `True` "
"の場合、OperatorはOpenShiftのルートまたは{project_name}クラスターのKubernetesのIngressを作成します。Routeに自動的に選択されたホスト名を上書きするように"
" `host` を設定するか、Ingressにデフォルト値の `keycloak.local` を設定できます。"

msgid ""
"`externalDatabase` - in order to connect to an externally hosted database. "
"That topic is covered in the xref:_external_database[external database] "
"section of this guide. Setting it to false should be used only for testing "
"purposes and will install an embedded PostgreSQL database. Be aware that "
"externalDatabase:false is *NOT* supported in production environments."
msgstr ""
"externalDatabase` - 外部でホストされているデータベースに接続するために使用します。これについては、このガイドの "
"xref:_external_database[外部データベース] "
"の項で説明します。これをfalseに設定すると、組み込み式のPostgreSQLデータベースがインストールされますので、テスト目的でのみ使用してください。externalDatabase:falseは本番環境ではサポートされていないことに注意してください。"

msgid "Example YAML file for a Keycloak custom resource"
msgstr "Keycloakカスタム・リソースのYAMLファイルの例"

msgid ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: Keycloak\n"
"metadata:\n"
"  name: example-keycloak\n"
"  labels:\n"
"   app: example-keycloak\n"
"spec:\n"
"  instances: 1\n"
"  externalAccess:\n"
"    enabled: True"
msgstr ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: Keycloak\n"
"metadata:\n"
"  name: example-keycloak\n"
"  labels:\n"
"   app: example-keycloak\n"
"spec:\n"
"  instances: 1\n"
"  externalAccess:\n"
"    enabled: True"

msgid ""
"You can update the YAML file and the changes appear in the {project_name} "
"admin console, however changes to the admin console do not update the custom"
" resource."
msgstr ""
"YAMLファイルを更新すると、{project_name}管理コンソールに変更が表示されますが、管理コンソールで変更しても、カスタムリソースは更新されません。"

msgid "Creating a Keycloak custom resource on OpenShift"
msgstr "OpenShiftでのKeycloakカスタムリソースの作成"

msgid ""
"On OpenShift, you use the custom resource to create a route, which is the "
"URL of the admin console, and find the secret, which holds the username and "
"password for the admin console."
msgstr ""
"OpenShiftでは、カスタムリソースを使用してルート（管理コンソールのURL）を作成し、（管理コンソールのユーザー名とパスワードを保持する）シークレットを見つけます。"

msgid "You have a YAML file for this custom resource."
msgstr "このカスタムリソース用のYAMLファイルがあること。"

msgid ""
"If you want to start tracking all Operator activities now, install the "
"monitoring application before you create this custom resource. See "
"xref:_monitoring-operator[The Application Monitoring Operator]."
msgstr ""
"ここですべてのOperatorアクティビティの追跡を開始する場合は、このカスタムリソースを作成する前に監視アプリケーションをインストールしてください。 "
"xref:_monitoring-operator[アプリケーション監視Operator] を参照してください。"

msgid ""
"Create a route using your YAML file: `{create_cmd} -f <filename>.yaml -n "
"<namespace>`. For example:"
msgstr ""
"`{create_cmd} -f <filename>.yaml -n <namespace>` "
"のようにYAMLファイルを使用してルートを作成します。たとえば、"

msgid ""
"$ {create_cmd} -f keycloak.yaml -n keycloak\n"
"keycloak.keycloak.org/example-keycloak created"
msgstr ""
"$ {create_cmd} -f keycloak.yaml -n keycloak\n"
"keycloak.keycloak.org/example-keycloak created"

msgid "A route is created in OpenShift."
msgstr "OpenShiftにルートが作成されます。"

msgid "Select `Networking`, `Routes` and search for Keycloak."
msgstr "`Networking` 、 `Routes` を選択し、Keycloakを検索します。"

msgid "Routes screen in OpenShift web console"
msgstr "OpenShift Webコンソールのルーティング画面"

msgid "image:images/route-ocp.png[]"
msgstr "image:images/route-ocp.png[]"

msgid "On the screen with the Keycloak route, click the URL under `Location`."
msgstr "Keycloakルートのある画面で、 `Location` の下のURLをクリックします。"

msgid "The {project_name} admin console login screen appears."
msgstr "{project_name}管理コンソールのログイン画面が表示されます。"

msgid "Admin console login screen"
msgstr "管理コンソールのログイン画面"

msgid "image:images/login-empty.png[]"
msgstr "image:images/login-empty.png[]"

msgid ""
"Locate the username and password for the admin console in the OpenShift web "
"console; under `Workloads`, click `Secrets` and search for Keycloak."
msgstr ""
"OpenShift Webコンソールで管理コンソールのユーザー名とパスワードを見つけます。 `Workloads` で `Secrets` "
"をクリックし、Keycloakを検索します。"

msgid "Secrets screen in OpenShift web console"
msgstr "OpenShift Webコンソールのシークレット画面"

msgid "image:images/secrets-ocp.png[]"
msgstr "image:images/secrets-ocp.png[]"

msgid "Enter the username and password into the admin console login screen."
msgstr "ユーザー名とパスワードを管理コンソールのログイン画面に入力します。"

msgid "image:images/login-complete.png[]"
msgstr "image:images/login-complete.png[]"

msgid ""
"You are now logged into an instance of {project_name} that was installed by "
"a Keycloak custom resource. You are ready to create custom resources for "
"realms, clients, and users."
msgstr ""
"これで、Keycloakカスタムリソースによってインストールされた{project_name}のインスタンスにログインしました。レルム、クライアント、およびユーザー用のカスタムリソースを作成する準備が整いました。"

msgid "{project_name} master realm"
msgstr "{project_name} masterレルム"

msgid "image:images/new_install_cr.png[]"
msgstr "image:images/new_install_cr.png[]"

msgid "Check the status of the custom resource:"
msgstr "カスタムリソースのステータスを確認します。"

msgid "$ {create_cmd_brief} describe keycloak <CR-name>"
msgstr "$ {create_cmd_brief} describe keycloak <CR-name>"

msgid "Creating a Keycloak custom resource on Kubernetes"
msgstr "KubernetesでKeycloakカスタムリソースを作成する"

msgid ""
"On Kubernetes, you use the custom resource to create an ingress, which is "
"the IP address of the admin console, and find the secret, which holds the "
"username and password for that console."
msgstr ""
"Kubernetesでは、カスタムリソースを使用して、管理コンソールのIPアドレスであるingressを作成し、そのコンソールのユーザー名とパスワードを保持するシークレットを見つけます。"

msgid ""
"Create the ingress using your YAML file. `{create_cmd} -f <filename>.yaml -n"
" <namespace>`.  For example:"
msgstr ""
"`{create_cmd} -f <filename>.yaml -n <namespace>` "
"のようにYAMLファイルを使用してingressを作成します。たとえば、"

msgid ""
"Find the ingress: `{create_cmd_brief} get ingress -n <CR-name>`. For "
"example:"
msgstr "`{create_cmd_brief} get ingress -n <CR-name>` のようにingressを見つけます。たとえば"

msgid ""
"$ {create_cmd_brief} get ingress -n example-keycloak\n"
"NAME       HOSTS                 ADDRESS     PORTS   AGE\n"
"keycloak   keycloak.redhat.com   192.0.2.0   80      3m"
msgstr ""
"$ {create_cmd_brief} get ingress -n example-keycloak\n"
"NAME       HOSTS                 ADDRESS     PORTS   AGE\n"
"keycloak   keycloak.redhat.com   192.0.2.0   80      3m"

msgid "Copy and paste the ADDRESS (the ingress) into a web browser."
msgstr "ADDRESS（ingress）をコピーしてWebブラウザーに貼り付けます。"

msgid "Locate the username and password."
msgstr "ユーザー名とパスワードを見つけます。"

msgid ""
"$ {create_cmd_brief} get secret credential-<CR-Name> -o go-template='{{range"
" $k,$v := .data}}{{printf \"%s: \" $k}}{{if not $v}}{{$v}}{{else}}{{$v | "
"base64decode}}{{end}}{{\"\\n\"}}{{end}}'"
msgstr ""
"$ {create_cmd_brief} get secret credential-<CR-Name> -o go-template='{{range"
" $k,$v := .data}}{{printf \"%s: \" $k}}{{if not $v}}{{$v}}{{else}}{{$v | "
"base64decode}}{{end}}{{\"\\n\"}}{{end}}'"

msgid "Enter the username and password in the admin console login screen."
msgstr "ユーザー名とパスワードを管理コンソールのログイン画面に入力します。"

msgid ""
"You are now logged into an instance of {project_name} that was installed by "
"a Keycloak custom resource.  You are ready to create custom resources for "
"realms, clients, and users."
msgstr ""
"これで、Keycloakカスタムリソースによってインストールされた{project_name}のインスタンスにログインしました。レルム、クライアント、およびユーザー用のカスタムリソースを作成する準備が整いました。"

msgid "Admin console master realm"
msgstr "管理コンソールmasterレルム"

msgid "Results"
msgstr "結果"

msgid ""
"After the Operator processes the custom resource, view the status with this "
"command:"
msgstr "Operatorがカスタムリソースを処理したら、次のコマンドでステータスを表示します。"

msgid "Keycloak custom resource Status"
msgstr "Keycloakカスタムリソースのステータス"

msgid ""
"Name:         example-keycloak\n"
"Namespace:    keycloak\n"
"Labels:       app=example-keycloak\n"
"Annotations:  <none>\n"
"API Version:  keycloak.org/v1alpha1\n"
"Kind:         Keycloak\n"
"Spec:\n"
"  External Access:\n"
"    Enabled:  true\n"
"  Instances:  1\n"
"Status:\n"
"  Credential Secret:  credential-example-keycloak\n"
"  Internal URL:       https://<External URL to the deployed instance>\n"
"  Message:\n"
"  Phase:              reconciling\n"
"  Ready:              true\n"
"  Secondary Resources:\n"
"    Deployment:\n"
"      keycloak-postgresql\n"
"    Persistent Volume Claim:\n"
"      keycloak-postgresql-claim\n"
"    Prometheus Rule:\n"
"      keycloak\n"
"    Route:\n"
"      keycloak\n"
"    Secret:\n"
"      credential-example-keycloak\n"
"      keycloak-db-secret\n"
"    Service:\n"
"      keycloak-postgresql\n"
"      keycloak\n"
"      keycloak-discovery\n"
"    Service Monitor:\n"
"      keycloak\n"
"    Stateful Set:\n"
"      keycloak\n"
"  Version:\n"
"Events:"
msgstr ""
"Name:         example-keycloak\n"
"Namespace:    keycloak\n"
"Labels:       app=example-keycloak\n"
"Annotations:  <none>\n"
"API Version:  keycloak.org/v1alpha1\n"
"Kind:         Keycloak\n"
"Spec:\n"
"  External Access:\n"
"    Enabled:  true\n"
"  Instances:  1\n"
"Status:\n"
"  Credential Secret:  credential-example-keycloak\n"
"  Internal URL:       https://<External URL to the deployed instance>\n"
"  Message:\n"
"  Phase:              reconciling\n"
"  Ready:              true\n"
"  Secondary Resources:\n"
"    Deployment:\n"
"      keycloak-postgresql\n"
"    Persistent Volume Claim:\n"
"      keycloak-postgresql-claim\n"
"    Prometheus Rule:\n"
"      keycloak\n"
"    Route:\n"
"      keycloak\n"
"    Secret:\n"
"      credential-example-keycloak\n"
"      keycloak-db-secret\n"
"    Service:\n"
"      keycloak-postgresql\n"
"      keycloak\n"
"      keycloak-discovery\n"
"    Service Monitor:\n"
"      keycloak\n"
"    Stateful Set:\n"
"      keycloak\n"
"  Version:\n"
"Events:"

msgid ""
"Once the installation of {project_name} completes, you are ready to "
"xref:_realm-cr[create a realm custom resource]."
msgstr ""
"{project_name}のインストールが完了すると、 xref:_realm-cr[レルム・カスタムリソースを作成] する準備が整います。"

msgid ""
"An external database is the supported option and needs to be enabled in the "
"Keycloak custom resource. You can disable this option only for testing and "
"enable it when you switch to a production environment. See "
"xref:_external_database[Connecting to an external database]."
msgstr ""
"外部データベースは、サポートされているオプションで、Keycloakのカスタムリソースで有効にする必要があります。テスト時のみこのオプションを無効にして、プロダクション環境に切り替えたときに有効にすることができます。xref:_external_database[Connecting"
" to an external database]を参照してください。"

msgid "Creating a realm custom resource"
msgstr "レルム・カスタム・リソースの作成"

msgid ""
"You can use the Operator to create realms in {project_name} as defined by a "
"custom resource. You define the properties of the realm custom resource in a"
" YAML file."
msgstr ""
"Operatorを使用して、カスタムリソースで定義されているように{project_name}にレルムを作成できます。レルム・カスタム・リソースのプロパティーをYAMLファイルで定義します。"

msgid ""
"You can only create or delete realms by creating or deleting the YAML file, "
"and changes appear in the {project_name} admin console. However changes to "
"the admin console are not reflected back and updates of the CR after the "
"realm is created are not supported."
msgstr ""
"YAMLファイルの作成または削除により、レルムの作成または削除のみ可能で、{project_name}管理コンソールで確認できます。ただし、レルム作成後の管理コンソールへの変更を、CRに更新として戻すことはサポートされません。"

msgid "Example YAML file for a `Realm` custom resource"
msgstr "`Realm` カスタム・リソースのYAMLファイルの例"

msgid ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: KeycloakRealm\n"
"metadata:\n"
"  name: test\n"
"  labels:\n"
"    app: example-keycloak\n"
"spec:\n"
"  realm:\n"
"    id: \"basic\"\n"
"    realm: \"basic\"\n"
"    enabled: True\n"
"    displayName: \"Basic Realm\"\n"
"  instanceSelector:\n"
"    matchLabels:\n"
"      app: example-keycloak\n"
msgstr ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: KeycloakRealm\n"
"metadata:\n"
"  name: test\n"
"  labels:\n"
"    app: example-keycloak\n"
"spec:\n"
"  realm:\n"
"    id: \"basic\"\n"
"    realm: \"basic\"\n"
"    enabled: True\n"
"    displayName: \"Basic Realm\"\n"
"  instanceSelector:\n"
"    matchLabels:\n"
"      app: example-keycloak\n"

msgid ""
"In the YAML file,  the `app` under `instanceSelector` matches the label of a"
" Keycloak custom resource. Matching these values ensures that you create the"
" realm in the right instance of {project_name}."
msgstr ""
"YAMLファイルでは、 `instanceSelector` の下の `app` "
"はKeycloakカスタムリソースのラベルと一致します。これらの値を一致させることで、{project_name}の正しいインスタンスにレルムを確実に作成できます。"

msgid ""
"Use this command on the YAML file that you created: `{create_cmd} -f <realm-"
"name>.yaml`. For example:"
msgstr "作成したYAMLファイルで `{create_cmd} -f <realm-name>.yaml` のコマンドを使用します。たとえば、"

msgid ""
"$ {create_cmd} -f initial_realm.yaml\n"
"keycloak.keycloak.org/test created"
msgstr ""
"$ {create_cmd} -f initial_realm.yaml\n"
"keycloak.keycloak.org/test created"

msgid "Log into the admin console for the related instance of {project_name}."
msgstr "{project_name}の関連インスタンスの管理コンソールにログインします。"

msgid "Click Select Realm and locate the realm that you created."
msgstr "Select Realmをクリックして、作成したレルムを見つけます。"

msgid "The new realm opens."
msgstr "新規レルムが開きます。"

msgid "image:images/test-realm-cr.png[]"
msgstr "image:images/test-realm-cr.png[]"

msgid "Realm custom resource status"
msgstr "レルム・カスタム・リソースのステータス"

msgid ""
"Name:         example-keycloakrealm\n"
"Namespace:    keycloak\n"
"Labels:       app=example-keycloak\n"
"Annotations:  <none>\n"
"API Version:  keycloak.org/v1alpha1\n"
"Kind:         KeycloakRealm\n"
"Metadata:\n"
"  Creation Timestamp:  2019-12-03T09:46:02Z\n"
"  Finalizers:\n"
"    realm.cleanup\n"
"  Generation:        1\n"
"  Resource Version:  804596\n"
"  Self Link:         /apis/keycloak.org/v1alpha1/namespaces/keycloak/keycloakrealms/example-keycloakrealm\n"
"  UID:               b7b2f883-15b1-11ea-91e6-02cb885627a6\n"
"Spec:\n"
"  Instance Selector:\n"
"    Match Labels:\n"
"      App: example-keycloak\n"
"  Realm:\n"
"    Display Name:  Basic Realm\n"
"    Enabled:       true\n"
"    Id:            basic\n"
"    Realm:         basic\n"
"Status:\n"
"  Login URL:\n"
"  Message:\n"
"  Phase:      reconciling\n"
"  Ready:      true\n"
"Events:       <none>\n"
msgstr ""
"Name:         example-keycloakrealm\n"
"Namespace:    keycloak\n"
"Labels:       app=example-keycloak\n"
"Annotations:  <none>\n"
"API Version:  keycloak.org/v1alpha1\n"
"Kind:         KeycloakRealm\n"
"Metadata:\n"
"  Creation Timestamp:  2019-12-03T09:46:02Z\n"
"  Finalizers:\n"
"    realm.cleanup\n"
"  Generation:        1\n"
"  Resource Version:  804596\n"
"  Self Link:         /apis/keycloak.org/v1alpha1/namespaces/keycloak/keycloakrealms/example-keycloakrealm\n"
"  UID:               b7b2f883-15b1-11ea-91e6-02cb885627a6\n"
"Spec:\n"
"  Instance Selector:\n"
"    Match Labels:\n"
"      App: example-keycloak\n"
"  Realm:\n"
"    Display Name:  Basic Realm\n"
"    Enabled:       true\n"
"    Id:            basic\n"
"    Realm:         basic\n"
"Status:\n"
"  Login URL:\n"
"  Message:\n"
"  Phase:      reconciling\n"
"  Ready:      true\n"
"Events:       <none>\n"

msgid ""
"When the realm creation completes, you are ready to xref:_client-cr[create a"
" client custom resource]."
msgstr "レルムの作成が完了すると、 xref:_client-cr[クライアント・カスタム・リソースを作成する] 準備が整います。"

msgid "Creating a client custom resource"
msgstr "クライアント・カスタム・リソースの作成"

msgid ""
"You can use the Operator to create clients in {project_name} as defined by a"
" custom resource.  You define the properties of the realm in a YAML file."
msgstr ""
"Operatorを使用して、カスタムリソースで定義されているように{project_name}にクライアントを作成できます。レルムのプロパティーをYAMLファイルで定義します。"

msgid ""
"You can update the YAML file and changes appear in the {project_name} admin "
"console, however changes to the admin console do not update the custom "
"resource."
msgstr ""
"YAMLファイルを更新すると、{project_name}管理コンソールに変更が表示されますが、管理コンソールで変更しても、カスタムリソースは更新されません。"

msgid "Example YAML file for a Client custom resource"
msgstr "クライアント・カスタム・リソースのYAMLファイルの例"

msgid ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: KeycloakClient\n"
"metadata:\n"
"  name: example-client\n"
"  labels:\n"
"    app: app=example-keycloak\n"
"spec:\n"
"  realmSelector:\n"
"     matchLabels:\n"
"      app: <matching labels for KeycloakRealm custom resource>\n"
"  client:\n"
"    # auto-generated if not supplied\n"
"    #id: 123\n"
"    clientId: client-secret\n"
"    secret: client-secret\n"
"    # ...\n"
"    # other properties of Keycloak Client"
msgstr ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: KeycloakClient\n"
"metadata:\n"
"  name: example-client\n"
"  labels:\n"
"    app: app=example-keycloak\n"
"spec:\n"
"  realmSelector:\n"
"     matchLabels:\n"
"      app: <matching labels for KeycloakRealm custom resource>\n"
"  client:\n"
"    # auto-generated if not supplied\n"
"    #id: 123\n"
"    clientId: client-secret\n"
"    secret: client-secret\n"
"    # ...\n"
"    # other properties of Keycloak Client"

msgid ""
"Use this command on the YAML file that you created: `{create_cmd} -f "
"<client-name>.yaml`. For example:"
msgstr "作成したYAMLファイルで `{create_cmd} -f <client-name>.yaml` のコマンドを使用します。たとえば、"

msgid ""
"$ {create_cmd} -f initial_client.yaml\n"
"keycloak.keycloak.org/example-client created"
msgstr ""
"$ {create_cmd} -f initial_client.yaml\n"
"keycloak.keycloak.org/example-client created"

msgid ""
"Log into the {project_name} admin console for the related instance of "
"{project_name}."
msgstr "{project_name}の関連インスタンスの{project_name}管理コンソールにログインします。"

msgid "Click Clients."
msgstr "Clientsをクリックします。"

msgid "The new client appears in the list of clients."
msgstr "新しいクライアントがクライアントの一覧に表示されます。"

msgid "image:images/clients.png[]"
msgstr "image:images/clients.png[]"

msgid ""
"After a client is created, the Operator creates a Secret containing the "
"`Client ID` and the client's secret using the following naming pattern: "
"`keycloak-client-secret-<custom resource name>`. For example:"
msgstr ""
"クライアントが作成された後、オペレーターは `keycloak-client-secret-<custom resource name>` "
"の命名パターンを使用して `Client ID` とクライアントのシークレットを含むシークレットを作成します。次に例を示します。"

msgid "Client's Secret"
msgstr "クライアントのシークレット"

msgid ""
"apiVersion: v1\n"
"data:\n"
"  CLIENT_ID: <base64 encoded Client ID>\n"
"  CLIENT_SECRET: <base64 encoded Client Secret>\n"
"kind: Secret"
msgstr ""
"apiVersion: v1\n"
"data:\n"
"  CLIENT_ID: <base64 encoded Client ID>\n"
"  CLIENT_SECRET: <base64 encoded Client Secret>\n"
"kind: Secret"

msgid "Client custom resource Status"
msgstr "クライアント・カスタム・リソースのステータス"

msgid ""
"Name:         client-secret\n"
"Namespace:    keycloak\n"
"Labels:       app=example-keycloak\n"
"API Version:  keycloak.org/v1alpha1\n"
"Kind:         KeycloakClient\n"
"Spec:\n"
"  Client:\n"
"    Client Authenticator Type:     client-secret\n"
"    Client Id:                     client-secret\n"
"    Id:                            keycloak-client-secret\n"
"  Realm Selector:\n"
"    Match Labels:\n"
"      App:  keycloak\n"
"Status:\n"
"  Message:\n"
"  Phase:    reconciling\n"
"  Ready:    true\n"
"  Secondary Resources:\n"
"    Secret:\n"
"      keycloak-client-secret-client-secret\n"
"Events:  <none>"
msgstr ""
"Name:         client-secret\n"
"Namespace:    keycloak\n"
"Labels:       app=example-keycloak\n"
"API Version:  keycloak.org/v1alpha1\n"
"Kind:         KeycloakClient\n"
"Spec:\n"
"  Client:\n"
"    Client Authenticator Type:     client-secret\n"
"    Client Id:                     client-secret\n"
"    Id:                            keycloak-client-secret\n"
"  Realm Selector:\n"
"    Match Labels:\n"
"      App:  keycloak\n"
"Status:\n"
"  Message:\n"
"  Phase:    reconciling\n"
"  Ready:    true\n"
"  Secondary Resources:\n"
"    Secret:\n"
"      keycloak-client-secret-client-secret\n"
"Events:  <none>"

msgid ""
"When the client creation completes, you are ready to xref:_user-cr[create a "
"user custom resource]."
msgstr "クライアントの作成が完了すると、 xref:_user-cr[ユーザーカスタムリソースの作成] の準備が整います。"

msgid "Creating a user custom resource"
msgstr "ユーザー・カスタム・リソースの作成"

msgid ""
"You can use the Operator to create users in {project_name} as defined by a "
"custom resource. You define the properties of the user custom resource in a "
"YAML file."
msgstr ""
"Operatorを使用して、カスタムリソースで定義されているように{project_name}にユーザーを作成できます。ユーザー・カスタム・リソースのプロパティーをYAMLファイルで定義します。"

msgid ""
"You can update properties, except for the password, in the YAML file and "
"changes appear in the {project_name} admin console, however changes to the "
"admin console do not update the custom resource."
msgstr ""
"YAMLファイルでパスワード以外のプロパティーを更新できます。変更は{project_name}管理コンソールに表示されますが、管理コンソールを変更してもカスタムリソースは更新されません。"

msgid "Example YAML file for a user custom resource"
msgstr "ユーザー・カスタム・リソースのYAMLファイルの例"

msgid ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: KeycloakUser\n"
"metadata:\n"
"  name: example-user\n"
"spec:\n"
"  user:\n"
"    username: \"realm_user\"\n"
"    firstName: \"John\"\n"
"    lastName: \"Doe\"\n"
"    email: \"user@example.com\"\n"
"    enabled: True\n"
"    emailVerified: False\n"
"    credentials:\n"
"      - type: \"password\"\n"
"        value: \"12345\"\n"
"    realmRoles:\n"
"      - \"offline_access\"\n"
"    clientRoles:\n"
"      account:\n"
"        - \"manage-account\"\n"
"      realm-management:\n"
"        - \"manage-users\"\n"
"  realmSelector:\n"
"    matchLabels:\n"
"      app: example-keycloak"
msgstr ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: KeycloakUser\n"
"metadata:\n"
"  name: example-user\n"
"spec:\n"
"  user:\n"
"    username: \"realm_user\"\n"
"    firstName: \"John\"\n"
"    lastName: \"Doe\"\n"
"    email: \"user@example.com\"\n"
"    enabled: True\n"
"    emailVerified: False\n"
"    credentials:\n"
"      - type: \"password\"\n"
"        value: \"12345\"\n"
"    realmRoles:\n"
"      - \"offline_access\"\n"
"    clientRoles:\n"
"      account:\n"
"        - \"manage-account\"\n"
"      realm-management:\n"
"        - \"manage-users\"\n"
"  realmSelector:\n"
"    matchLabels:\n"
"      app: example-keycloak"

msgid ""
"The `realmSelector` matches the labels of an existing realm custom resource."
msgstr "`realmSelector` は既存のレルム・カスタム・リソースのラベルと一致します。"

msgid ""
"Use this command on the YAML file that you created: `{create_cmd} -f "
"<user_cr>.yaml`. For example:"
msgstr "作成したYAMLファイルで `{create_cmd} -f 1.yaml` のコマンドを使用します。たとえば、"

msgid ""
"$ {create_cmd} -f initial_user.yaml\n"
"keycloak.keycloak.org/example-user created"
msgstr ""
"$ {create_cmd} -f initial_user.yaml\n"
"keycloak.keycloak.org/example-user created"

msgid "Click Users."
msgstr "Usersをクリックします。"

msgid "Search for the user that you defined in the YAML file."
msgstr "YAMLファイルで定義したユーザーを検索します。"

msgid "You may need to switch to a different realm to find the user."
msgstr "ユーザーを見つけるには、別のレルムに切り替える必要があるかもしれません。"

msgid "image:images/realm_user.png[]"
msgstr "image:images/realm_user.png[]."

msgid ""
"After a user is created, the Operator creates a Secret using the following "
"naming pattern: `credential-<realm name>-<username>-<namespace>`, containing"
" the username and, if it has been specified in the CR `credentials` "
"attribute, the password."
msgstr ""
"ユーザーが作成されると、Operatorは: `credential-<realm name>-<username>-<namespace>` "
"のネーミングパターンでシークレットを作成します。これには、ユーザー名と、CRの `credential` "
"属性で指定されている場合はパスワードを含みます。"

msgid "Here's an example:"
msgstr "以下は例です。"

msgid "`KeycloakUser` Secret"
msgstr "`KeycloakUser` シークレット"

msgid ""
"kind: Secret\n"
"apiVersion: v1\n"
"data:\n"
"  password: <base64 encoded password>\n"
"  username: <base64 encoded username>\n"
"type: Opaque"
msgstr ""
"kind: Secret\n"
"apiVersion: v1\n"
"data:\n"
"  password: <base64 encoded password>\n"
"  username: <base64 encoded username>\n"
"type: Opaque"

msgid ""
"Once the Operator processes the custom resource, view the status with this "
"command:"
msgstr "Operatorがカスタムリソースを処理したら、次のコマンドでステータスを表示します。"

msgid "User custom resource Status"
msgstr "ユーザー・カスタム・リソースのステータス"

msgid ""
"Name:         example-realm-user\n"
"Namespace:    keycloak\n"
"Labels:       app=example-keycloak\n"
"API Version:  keycloak.org/v1alpha1\n"
"Kind:         KeycloakUser\n"
"Spec:\n"
"  Realm Selector:\n"
"    Match Labels:\n"
"      App: example-keycloak\n"
"  User:\n"
"    Email:           realm_user@redhat.com\n"
"    Credentials:\n"
"      Type:          password\n"
"      Value:         <user password>\n"
"    Email Verified:  false\n"
"    Enabled:         true\n"
"    First Name:      John\n"
"    Last Name:       Doe\n"
"    Username:        realm_user\n"
"Status:\n"
"  Message:\n"
"  Phase:    reconciled\n"
"Events:     <none>"
msgstr ""
"Name:         example-realm-user\n"
"Namespace:    keycloak\n"
"Labels:       app=example-keycloak\n"
"API Version:  keycloak.org/v1alpha1\n"
"Kind:         KeycloakUser\n"
"Spec:\n"
"  Realm Selector:\n"
"    Match Labels:\n"
"      App: example-keycloak\n"
"  User:\n"
"    Email:           realm_user@redhat.com\n"
"    Credentials:\n"
"      Type:          password\n"
"      Value:         <user password>\n"
"    Email Verified:  false\n"
"    Enabled:         true\n"
"    First Name:      John\n"
"    Last Name:       Doe\n"
"    Username:        realm_user\n"
"Status:\n"
"  Message:\n"
"  Phase:    reconciled\n"
"Events:     <none>"

msgid ""
"If you have an external database, you can modify the Keycloak custom "
"resource to support it. See xref:_external_database[Connecting to an "
"external database]."
msgstr ""
"外部データベースがある場合は、Keycloakカスタムリソースを変更してそれをサポートできます。 "
"xref:_external_database[外部データベースへの接続] を参照してください。"

msgid ""
"To back up your database using custom resources, see xref:_backup-"
"cr[schedule database backups]."
msgstr ""
"カスタムリソースを使用してデータベースをバックアップするには、 xref:_backup-cr[データベースのバックアップをスケジュールする] "
"を参照してください。"

msgid "Connecting to an external database"
msgstr "外部データベースへの接続"

msgid ""
"You can use the Operator to connect to an external PostgreSQL database by "
"creating a `keycloak-db-secret` YAML file and setting Keycloak CR "
"externalDatabase property to enabled. Note that values are Base64 encoded."
msgstr ""
"Operatorを使って外部のPostgreSQLデータベースに接続するには、 `keycloak-db-secret` "
"というYAMLファイルを作成し、Keycloak CR "
"externalDatabaseプロパティーをenabledに設定します。値はBase64エンコードされることに注意してください。"

msgid "Example YAML file for `keycloak-db-secret`"
msgstr "`keycloak-db-secret` のYAMLファイルの例"

msgid ""
"apiVersion: v1\n"
"kind: Secret\n"
"metadata:\n"
"    name: keycloak-db-secret\n"
"    namespace: keycloak\n"
"stringData:\n"
"    POSTGRES_DATABASE: <Database Name>\n"
"    POSTGRES_EXTERNAL_ADDRESS: <External Database IP or URL (resolvable by K8s)>\n"
"    POSTGRES_EXTERNAL_PORT: <External Database Port>\n"
"    POSTGRES_PASSWORD: <Database Password>\n"
"    # Required for AWS Backup functionality\n"
"    POSTGRES_SUPERUSER: \"true\"\n"
"    POSTGRES_USERNAME: <Database Username>\n"
"    SSLMODE: <TLS configuration for the Database connection>\n"
"type: Opaque"
msgstr ""
"apiVersion: v1\n"
"kind: Secret\n"
"metadata:\n"
"    name: keycloak-db-secret\n"
"    namespace: keycloak\n"
"stringData:\n"
"    POSTGRES_DATABASE: <Database Name>\n"
"    POSTGRES_EXTERNAL_ADDRESS: <External Database IP or URL (resolvable by K8s)>\n"
"    POSTGRES_EXTERNAL_PORT: <External Database Port>\n"
"    POSTGRES_PASSWORD: <Database Password>\n"
"    # Required for AWS Backup functionality\n"
"    POSTGRES_SUPERUSER: \"true\"\n"
"    POSTGRES_USERNAME: <Database Username>\n"
"    SSLMODE: <TLS configuration for the Database connection>\n"
"type: Opaque"

msgid ""
"The following properties set the hostname or IP address and port of the "
"database."
msgstr "次のプロパティーには、データベースのホスト名またはIPアドレスとポートを設定します。"

msgid ""
"`POSTGRES_EXTERNAL_ADDRESS` - an IP address or a hostname of the external "
"database. This address needs be resolvable in a Kubernetes cluster."
msgstr ""
"`POSTGRES_EXTERNAL_ADDRESS` - "
"外部データベースのIPアドレスまたはホスト名。このアドレスは、Kubernetesクラスターで解決可能である必要があります。"

msgid "`POSTGRES_EXTERNAL_PORT` - (Optional) A database port."
msgstr "`POSTGRES_EXTERNAL_PORT` - （任意）データベースのポート。"

msgid ""
"The other properties work in the same way for a hosted or external database."
" Set them as follows:"
msgstr "他のプロパティーは、ホストされたデータベースまたは外部データベースの場合と同じように機能します。次のように設定します。"

msgid "`POSTGRES_DATABASE` - Database name to be used."
msgstr "`POSTGRES_DATABASE` - 使用するデータベース名。"

msgid "`POSTGRES_USERNAME` - Database username"
msgstr "`POSTGRES_USERNAME` - データベースのユーザー名"

msgid "`POSTGRES_PASSWORD` - Database password"
msgstr "`POSTGRES_PASSWORD` - データベースのパスワード"

msgid ""
"`POSTGRES_SUPERUSER` - Indicates whether backups should run as super user. "
"Typically `true`."
msgstr "`POSTGRES_SUPERUSER` - バックアップをスーパーユーザーとして実行するかどうかを示します。通常は `true` です。"

msgid ""
"`SSL_MODE` - Indicates whether to use TLS on the connection to the external "
"PostgreSQL database. Check the possible "
"https://www.postgresql.org/docs/current/libpq-ssl.html[values]"
msgstr ""
"`SSL_MODE` - 外部のPostgreSQLデータベースへの接続でTLSを使用するかどうかを示します。可能な "
"https://www.postgresql.org/docs/current/libpq-ssl.html[値] を確認してください。"

msgid ""
"When `SSL_MODE` is enabled, the operator searches for a secret called "
"`keycloak-db-ssl-cert-secret` containing the `root.crt` that has been used "
"by the PostgreSQL database. Creating the secret is optional and the secret "
"is used only when you want to verify the Database's certificate (for example"
" `SSLMODE: verify-ca`). Here is an example :"
msgstr ""
"`SSL_MODE` を有効にすると、OperatorはPostgreSQLデータベースで使用されている `root.crt` を含む "
"`keycloak-db-ssl-cert-secret` "
"というシークレットを検索します。シークレットの作成はオプションで、データベースの証明書を検証したい場合（例： `SSLMODE: verify-ca` "
"）にのみシークレットが使用されます。以下に例を示します。"

msgid "Example YAML file for `TLS Secret` to be used by the operator."
msgstr "オペレーターが使用する `TLS Secret` のYAMLファイルの例。"

msgid ""
"apiVersion: v1\n"
"kind: Secret\n"
"metadata:\n"
"  name: keycloak-db-ssl-cert-secret\n"
"  namespace: keycloak\n"
"type: Opaque\n"
"data:\n"
"  root.crt: {root.crt base64}"
msgstr ""
"apiVersion: v1\n"
"kind: Secret\n"
"metadata:\n"
"  name: keycloak-db-ssl-cert-secret\n"
"  namespace: keycloak\n"
"type: Opaque\n"
"data:\n"
"  root.crt: {root.crt base64}"

msgid ""
"The Operator will create a Service named `keycloak-postgresql`. This Service"
" is configured by the Operator to expose the external database based on the "
"content of `POSTGRES_EXTERNAL_ADDRESS`. {project_name} uses this Service to "
"connect to the Database, which means it does not connect to the Database "
"directly but rather through this Service."
msgstr ""
"Operatorは `keycloak-postgresql` という名前のサービスを作成します。このサービスは、 "
"`POSTGRES_EXTERNAL_ADDRESS` "
"の内容に基づいて外部データベースを公開するようにOperatorが設定します。{project_name}はこのサービスを使ってデータベースに接続しますが、これはデータベースに直接接続するのではなく、このサービスを介して接続することを意味します。"

msgid ""
"The Keycloak custom resource requires updates to enable external database "
"support."
msgstr "Keycloakカスタムリソースは、外部データベースのサポートを有効にするために更新が必要です。"

msgid ""
"Example YAML file for `Keycloak` custom resource that supports an external "
"database"
msgstr "外部データベースをサポートする `Keycloak` カスタムリソースのYAMLファイルの例"

msgid ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: Keycloak\n"
"metadata:\n"
"  labels:\n"
"      app: example-keycloak\n"
"  name: example-keycloak\n"
"  namespace: keycloak\n"
"spec:\n"
"  externalDatabase:\n"
"    enabled: true\n"
"  instances: 1"
msgstr ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: Keycloak\n"
"metadata:\n"
"  labels:\n"
"      app: example-keycloak\n"
"  name: example-keycloak\n"
"  namespace: keycloak\n"
"spec:\n"
"  externalDatabase:\n"
"    enabled: true\n"
"  instances: 1"

msgid "You have a YAML file for `keycloak-db-secret`."
msgstr "`keycloak-db-secret` のYAMLファイルがあること。"

msgid ""
"You have modified the Keycloak custom resource to set `externalDatabase` to "
"`true`."
msgstr "Keycloakカスタムリソースを変更して、 `externalDatabase` を `true` に設定しました。"

msgid ""
"Locate the secret for your PostgreSQL database: `{create_cmd_brief} get "
"secret <secret_for_db> -o yaml`. For example:"
msgstr ""
"`{create_cmd_brief} get secret <secret_for_db> -o yaml` "
"のようにPostgreSQLデータベースのシークレットを見つけます。たとえば、"

msgid ""
"$ {create_cmd_brief} get secret keycloak-db-secret -o yaml\n"
"apiVersion: v1\n"
"data\n"
"  POSTGRES_DATABASE: cm9vdA==\n"
"  POSTGRES_EXTERNAL_ADDRESS: MTcyLjE3LjAuMw==\n"
"  POSTGRES_EXTERNAL_PORT: NTQzMg=="
msgstr ""
"$ {create_cmd_brief} get secret keycloak-db-secret -o yaml\n"
"apiVersion: v1\n"
"data\n"
"  POSTGRES_DATABASE: cm9vdA==\n"
"  POSTGRES_EXTERNAL_ADDRESS: MTcyLjE3LjAuMw==\n"
"  POSTGRES_EXTERNAL_PORT: NTQzMg=="

msgid "The `POSTGRES_EXTERNAL_ADDRESS` is in Base64 format."
msgstr "`POSTGRES_EXTERNAL_ADDRESS` はBase64形式です。"

msgid ""
"Decode the value for the secret: `echo \"<encoded_secret>\" | base64 "
"-decode`. For example:"
msgstr "`echo \"<encoded_secret>\" | base64 -decode` のようにシークレットの値をデコードします。たとえば、"

msgid ""
"$ echo \"MTcyLjE3LjAuMw==\" | base64 -decode\n"
"192.0.2.3"
msgstr ""
"$ echo \"MTcyLjE3LjAuMw==\" | base64 -decode\n"
"192.0.2.3"

msgid ""
"Confirm that the decoded value matches the IP address for your database:"
msgstr "デコードされた値がデータベースのIPアドレスと一致することを確認します。"

msgid ""
"$ {create_cmd_brief} get pods -o wide\n"
"NAME                        READY  STATUS    RESTARTS   AGE   IP\n"
"keycloak-0                  1/1    Running   0          13m   192.0.2.0\n"
"keycloak-postgresql-c8vv27m 1/1    Running   0          24m   192.0.2.3"
msgstr ""
"$ {create_cmd_brief} get pods -o wide\n"
"NAME                        READY  STATUS    RESTARTS   AGE   IP\n"
"keycloak-0                  1/1    Running   0          13m   192.0.2.0\n"
"keycloak-postgresql-c8vv27m 1/1    Running   0          24m   192.0.2.3"

msgid ""
"Confirm that `keycloak-postgresql` appears in a list of running services:"
msgstr "実行中のサービスのリストに `keycloak-postgresql` が表示されていることを確認します。"

msgid ""
"$ {create_cmd_brief} get svc\n"
"NAME                 TYPE       CLUSTER-IP     EXTERNAL-IP  PORT(S)   AGE\n"
"keycloak             ClusterIP  203.0.113.0    <none>       8443/TCP  27m\n"
"keycloak-discovery   ClusterIP  None           <none>       8080/TCP  27m\n"
"keycloak-postgresql  ClusterIP  203.0.113.1    <none>       5432/TCP  27m"
msgstr ""
"$ {create_cmd_brief} get svc\n"
"NAME                 TYPE       CLUSTER-IP     EXTERNAL-IP  PORT(S)   AGE\n"
"keycloak             ClusterIP  203.0.113.0    <none>       8443/TCP  27m\n"
"keycloak-discovery   ClusterIP  None           <none>       8080/TCP  27m\n"
"keycloak-postgresql  ClusterIP  203.0.113.1    <none>       5432/TCP  27m"

msgid ""
"The `keycloak-postgresql` service sends requests to a set of IP addresses in"
" the backend.  These IP addresses are called endpoints."
msgstr ""
"`keycloak-postgresql` "
"サービスは、バックエンドの一連のIPアドレスにリクエストを送信します。これらのIPアドレスはエンドポイントと呼ばれます。"

msgid ""
"View the endpoints used by the `keycloak-postgresql` service to confirm that"
" they use the IP addresses for your database:"
msgstr ""
"`keycloak-postgresql` サービスで使用されるエンドポイントを表示して、データベースのIPアドレスを使用していることを確認します。"

msgid ""
"$ {create_cmd_brief} get endpoints keycloak-postgresql\n"
"NAME                  ENDPOINTS         AGE\n"
"keycloak-postgresql   192.0.2.3.5432    27m"
msgstr ""
"$ {create_cmd_brief} get endpoints keycloak-postgresql\n"
"NAME                  ENDPOINTS         AGE\n"
"keycloak-postgresql   192.0.2.3.5432    27m"

msgid ""
"Confirm that {project_name} is running with the external database. This "
"example shows that everything is running:"
msgstr "{project_name}が外部データベースとともに実行されていることを確認します。この例は、すべてが実行中であることを示しています。"

msgid ""
"$ {create_cmd_brief} get pods\n"
"NAME                        READY  STATUS    RESTARTS   AGE   IP\n"
"keycloak-0                  1/1    Running   0          26m   192.0.2.0\n"
"keycloak-postgresql-c8vv27m 1/1    Running   0          36m   192.0.2.3"
msgstr ""
"$ {create_cmd_brief} get pods\n"
"NAME                        READY  STATUS    RESTARTS   AGE   IP\n"
"keycloak-0                  1/1    Running   0          26m   192.0.2.0\n"
"keycloak-postgresql-c8vv27m 1/1    Running   0          36m   192.0.2.3"

msgid "Additional Resources"
msgstr "追加のリソース"

msgid ""
"To back up your database using custom resources, see xref:_backup-"
"cr[Scheduling database backups]."
msgstr ""
"カスタムリソースを使用してデータベースをバックアップするには、 xref:_backup-cr[データベースのバックアップをスケジュールする] "
"を参照してください。"

msgid ""
"For more information on Base64 encoding, see the "
"https://kubernetes.io/docs/concepts/configuration/secret/[Kubernetes Secrets"
" manual]."
msgstr ""
"Base64エンコードの詳細については、 "
"https://kubernetes.io/docs/concepts/configuration/secret/[Kubernetes Secrets"
" manual] をご覧ください。"

msgid "Connecting to an external {project_name}"
msgstr "外部{project_name}への接続"

msgid ""
"This operator can also be used to partially manage an external "
"{project_name} instance. In it's current state, it will only be able to "
"create clients."
msgstr ""
"このオペレーターは、外部の{project_name}インスタンスを部分的に管理するためにも使用できます。現在の状態では、クライアントを作成することしかできません。"

msgid ""
"To do this, you'll need to create unmanaged versions of the `Keycloak` and "
"`KeycloakRealm` CRDs to use for targeting and configuration."
msgstr ""
"そのためには、ターゲティングや設定に使用するアンマネージド版の `Keycloak` と `KeycloakRealm` "
"のCRDを作成する必要があります。"

msgid "Example YAML file for `external-keycloak`"
msgstr "`external-keycloak` のYAMLファイルの例"

msgid ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: Keycloak\n"
"metadata:\n"
"  name: external-ref\n"
"  labels:\n"
"    app: external-keycloak\n"
"spec:\n"
"  unmanaged: true\n"
"  external:\n"
"    enabled: true\n"
"    url: https://some.external.url"
msgstr ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: Keycloak\n"
"metadata:\n"
"  name: external-ref\n"
"  labels:\n"
"    app: external-keycloak\n"
"spec:\n"
"  unmanaged: true\n"
"  external:\n"
"    enabled: true\n"
"    url: https://some.external.url"

msgid ""
"In order to authenticate against this keycloak, the operator infers the "
"secret name from the CRD by prefixing the CRD name with `credential-`."
msgstr ""
"このKeycloakに対して認証を行うために、オペレーターはCRD名の前に `credential-` "
"を付けることで、CRDからシークレット名を推測します。"

msgid "Example YAML file for `credential-external-ref`"
msgstr "`credential-external-ref` のYAMLファイルの例"

msgid ""
"apiVersion: v1\n"
"kind: Secret\n"
"metadata:\n"
"  name: credential-external-ref\n"
"type: Opaque\n"
"data:\n"
"  ADMIN_USERNAME: YWRtaW4=\n"
"  ADMIN_PASSWORD: cGFzcw=="
msgstr ""
"apiVersion: v1\n"
"kind: Secret\n"
"metadata:\n"
"  name: credential-external-ref\n"
"type: Opaque\n"
"data:\n"
"  ADMIN_USERNAME: YWRtaW4=\n"
"  ADMIN_PASSWORD: cGFzcw=="

msgid "Example YAML file for `external-realm`"
msgstr "`EXTERNAL-REALM` のYAMLファイルの例"

msgid ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: KeycloakRealm\n"
"metadata:\n"
"  name: external-realm\n"
"  labels:\n"
"    app: external-keycloak\n"
"spec:\n"
"  unmanaged: true\n"
"  realm:\n"
"    id: \"basic\"\n"
"    realm: \"basic\"\n"
"  instanceSelector:\n"
"    matchLabels:\n"
"      app: external-keycloak"
msgstr ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: KeycloakRealm\n"
"metadata:\n"
"  name: external-realm\n"
"  labels:\n"
"    app: external-keycloak\n"
"spec:\n"
"  unmanaged: true\n"
"  realm:\n"
"    id: \"basic\"\n"
"    realm: \"basic\"\n"
"  instanceSelector:\n"
"    matchLabels:\n"
"      app: external-keycloak"

msgid ""
"You can now use the realm reference in your client as usual, and it will "
"create the client on the external {project_name} instance."
msgstr ""
"これで、通常通りクライアントでレルムの参照を使用することができ、外部の{project_name}インスタンスにクライアントが作成されます。"

msgid "Scheduling database backups"
msgstr "データベース・バックアップのスケジュール"

msgid "Backup CR is *deprecated* and could be removed in future releases."
msgstr "バックアップCRは *非推奨* であり、将来のリリースでは削除される可能性があります。"

msgid ""
"You can use the Operator to schedule automatic backups of the database as "
"defined by custom resources. The custom resource triggers a backup job (or a"
" `CronJob` in the case of Periodic Backups) and reports back its status."
msgstr ""
"Operatorを使用して、カスタムリソースで定義されているデータベースの自動バックアップをスケジュールできます。カスタムリソースはバックアップ・ジョブ（または定期バックアップの場合は"
" `CronJob` ）をトリガーし、そのステータスをレポートします。"

msgid "Two options exist to schedule backups:"
msgstr "バックアップをスケジュールするには、次の2つのオプションがあります。"

msgid "xref:_backups-cr-aws[Backing up to AWS S3 storage]"
msgstr "xref:_backups-cr-aws[AWS S3ストレージへのバックアップ]"

msgid "xref:_backups-local-cr[Backing up to local storage]"
msgstr "xref:_backups-local-cr[ローカル・ストレージへのバックアップ]"

msgid ""
"If you have AWS S3 storage, you can perform a one-time backup or periodic "
"backups. If you do not have AWS S3 storage, you can back up to local "
"storage."
msgstr ""
"AWS S3ストレージがある場合は、1回限りのバックアップまたは定期的なバックアップを実行できます。AWS "
"S3ストレージがない場合は、ローカル・ストレージにバックアップできます。"

msgid "Backing up to AWS S3 storage"
msgstr "AWS S3ストレージへのバックアップ"

msgid ""
"You can back up your database to AWS S3 storage one time or periodically. To"
" back up your data periodically, enter a valid `CronJob` into the "
"`schedule`."
msgstr ""
"データベースをAWS S3ストレージに1回または定期的にバックアップできます。データを定期的にバックアップするには、有効な `CronJob` を "
"`schedule` に入力してください。"

msgid ""
"For AWS S3 storage, you create a YAML file for the backup custom resource "
"and a YAML file for the AWS secret. The backup custom resource requires a "
"YAML file with the following structure:"
msgstr ""
"AWS "
"S3ストレージの場合、バックアップ・カスタムリソース用のYAMLファイルとAWSシークレット用のYAMLファイルを作成します。バックアップ・カスタムリソースには、次の構造のYAMLファイルが必要です。"

msgid ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: KeycloakBackup\n"
"metadata:\n"
"  name: <CR Name>\n"
"spec:\n"
"  aws:\n"
"    # Optional - used only for Periodic Backups.\n"
"    # Follows usual crond syntax (for example, use \"0 1 * * *\" to perform the backup every day at 1 AM.)\n"
"    schedule: <Cron Job Schedule>\n"
"    # Required - the name of the secret containing the credentials to access the S3 storage\n"
"    credentialsSecretName: <A Secret containing S3 credentials>"
msgstr ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: KeycloakBackup\n"
"metadata:\n"
"  name: <CR Name>\n"
"spec:\n"
"  aws:\n"
"    # Optional - used only for Periodic Backups.\n"
"    # Follows usual crond syntax (for example, use \"0 1 * * *\" to perform the backup every day at 1 AM.)\n"
"    schedule: <Cron Job Schedule>\n"
"    # Required - the name of the secret containing the credentials to access the S3 storage\n"
"    credentialsSecretName: <A Secret containing S3 credentials>"

msgid "The AWS secret requires a YAML file with the following structure:"
msgstr "AWSシークレットには、次の構造のYAMLファイルが必要です。"

msgid "AWS S3 `Secret`"
msgstr "AWS S3 `Secret`"

msgid ""
"apiVersion: v1\n"
"kind: Secret\n"
"metadata:\n"
"  name: <Secret Name>\n"
"type: Opaque\n"
"stringData:\n"
"  AWS_S3_BUCKET_NAME: <S3 Bucket Name>\n"
"  AWS_ACCESS_KEY_ID: <AWS Access Key ID>\n"
"  AWS_SECRET_ACCESS_KEY: <AWS Secret Key>"
msgstr ""
"apiVersion: v1\n"
"kind: Secret\n"
"metadata:\n"
"  name: <Secret Name>\n"
"type: Opaque\n"
"stringData:\n"
"  AWS_S3_BUCKET_NAME: <S3 Bucket Name>\n"
"  AWS_ACCESS_KEY_ID: <AWS Access Key ID>\n"
"  AWS_SECRET_ACCESS_KEY: <AWS Secret Key>"

msgid ""
"Your Backup custom resource YAML file includes a `credentialsSecretName` "
"that references a `Secret` containing AWS S3 credentials."
msgstr ""
"BackupカスタムリソースYAMLファイルには、AWS S3の認証情報を含む `Secret` を参照する "
"`credentialsSecretName` が含まれています。"

msgid "Your `KeycloakBackup` custom resource has `aws` sub-properties."
msgstr "`KeycloakBackup` カスタムリソースには `aws` サブプロパティーがあります。"

msgid ""
"You have a YAML file for the AWS S3 Secret that includes a `<Secret Name>` "
"that matches the one identified in the backup custom resource."
msgstr ""
"AWS S3シークレットのYAMLファイルがあり、バックアップ・カスタムリソースで識別されたものと一致する `<Secret Name>` "
"が含まれています。"

msgid ""
"Create the secret with credentials: `{create_cmd} -f <secret_for_aws>.yaml`."
" For example:"
msgstr ""
"`{create_cmd} -f <secret_for_aws>.yaml` のようにクレデンシャルを使用してシークレットを作成します。たとえば、"

msgid ""
"$ {create_cmd} -f secret.yaml\n"
"keycloak.keycloak.org/aws_s3_secret created"
msgstr ""
"$ {create_cmd} -f secret.yaml\n"
"keycloak.keycloak.org/aws_s3_secret created"

msgid ""
"Create a backup job: `{create_cmd} -f <backup_crname>.yaml`. For example:"
msgstr "`{create_cmd} -f <secret_for_aws>.yaml` のようにバックアップジョブを作成します。たとえば、"

msgid ""
"$ {create_cmd} -f aws_one-time-backup.yaml\n"
"keycloak.keycloak.org/aws_s3_backup created"
msgstr ""
"$ {create_cmd} -f aws_one-time-backup.yaml\n"
"keycloak.keycloak.org/aws_s3_backup created"

msgid "View a list of backup jobs:"
msgstr "次のようにバックアップジョブの一覧を表示します。"

msgid ""
"$ {create_cmd_brief} get jobs\n"
"NAME                   COMPLETIONS     DURATION     AGE\n"
"aws_s3_backup    0/1             6s           6s"
msgstr ""
"$ {create_cmd_brief} get jobs\n"
"NAME                   COMPLETIONS     DURATION     AGE\n"
"aws_s3_backup    0/1             6s           6s"

msgid "View the list of executed backup jobs."
msgstr "実行されたバックアップ・ジョブの一覧を表示します。"

msgid ""
"$ {create_cmd_brief} get pods\n"
"NAME                               READY    STATUS       RESTARTS    AGE\n"
"aws_s3_backup-5b4rfdd              0/1      Completed    0           24s\n"
"keycloak-0                         1/1      Running      0           52m\n"
"keycloak-postgresql-c824c6-vv27m   1/1      Running      0           71m"
msgstr ""
"$ {create_cmd_brief} get pods\n"
"NAME                               READY    STATUS       RESTARTS    AGE\n"
"aws_s3_backup-5b4rfdd              0/1      Completed    0           24s\n"
"keycloak-0                         1/1      Running      0           52m\n"
"keycloak-postgresql-c824c6-vv27m   1/1      Running      0           71m"

msgid "View the log of your completed backup job:"
msgstr "次のように完了したバックアップ・ジョブのログを表示します。"

msgid ""
"$ {create_cmd_brief} logs aws_s3_backup-5b4rf\n"
"==> Component data dump completed\n"
".\n"
".\n"
".\n"
".\n"
"[source,bash,subs=+attributes]"
msgstr ""
"$ {create_cmd_brief} logs aws_s3_backup-5b4rf\n"
"==> Component data dump completed\n"
".\n"
".\n"
".\n"
".\n"
"[source,bash,subs=+attributes]"

msgid "The status of the backup job also appears in the AWS console."
msgstr "バックアップ・ジョブのステータスは、AWSコンソールにも表示されます。"

msgid "Backing up to Local Storage"
msgstr "ローカル・ストレージへのバックアップ"

msgid ""
"You can use Operator to create a backup job that performs a one-time backup "
"to a local Persistent Volume."
msgstr ""
"Operatorを使用して、ローカルのPersistent Volumeへの1回限りのバックアップを実行するバックアップ・ジョブを作成できます。"

msgid "Example YAML file for a Backup custom resource"
msgstr "Backupカスタム・リソースのYAMLファイルの例"

msgid ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: KeycloakBackup\n"
"metadata:\n"
"  name: test-backup"
msgstr ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: KeycloakBackup\n"
"metadata:\n"
"  name: test-backup"

msgid ""
"You have a YAML file for this custom resource. Be sure to omit the `aws` "
"sub-properties from this file."
msgstr "このカスタムリソース用のYAMLファイルがあること。このファイルから `aws` サブプロパティーを省略するようにしてください。"

msgid ""
"You have a `PersistentVolume` with a `claimRef` to reserve it only for a "
"`PersistentVolumeClaim` created by the {project_name} Operator."
msgstr ""
"{project_name} Operatorによって作成された `PersistentVolumeClaim` に対してのみ予約するために、 "
"`claimRef` とともに `PersistentVolume` があります。"

msgid "Create a backup job: `{create_cmd} -f <backup_crname>`. For example:"
msgstr "`{create_cmd} -f <backup_crname>` のようにバックアップジョブを作成します。たとえば、"

msgid ""
"$ {create_cmd} -f one-time-backup.yaml\n"
"keycloak.keycloak.org/test-backup"
msgstr ""
"$ {create_cmd} -f one-time-backup.yaml\n"
"keycloak.keycloak.org/test-backup"

msgid ""
"The Operator creates a `PersistentVolumeClaim` with the following naming "
"scheme:  `Keycloak-backup-<CR-name>`."
msgstr ""
"Operatorは `Keycloak-backup-<CR-name>` の命名スキームで `PersistentVolumeClaim` "
"を作成します。"

msgid "View a list of volumes:"
msgstr "ボリュームの一覧を表示します。"

msgid ""
"$ {create_cmd_brief} get pvc\n"
"NAME                          STATUS   VOLUME\n"
"keycloak-backup-test-backup   Bound    pvc-e242-ew022d5-093q-3134n-41-adff\n"
"keycloak-postresql-claim      Bound    pvc-e242-vs29202-9bcd7-093q-31-zadj"
msgstr ""
"$ {create_cmd_brief} get pvc\n"
"NAME                          STATUS   VOLUME\n"
"keycloak-backup-test-backup   Bound    pvc-e242-ew022d5-093q-3134n-41-adff\n"
"keycloak-postresql-claim      Bound    pvc-e242-vs29202-9bcd7-093q-31-zadj"

msgid ""
"$ {create_cmd_brief} get jobs\n"
"NAME           COMPLETIONS     DURATION     AGE\n"
"test-backup    0/1             6s           6s"
msgstr ""
"$ {create_cmd_brief} get jobs\n"
"NAME           COMPLETIONS     DURATION     AGE\n"
"test-backup    0/1             6s           6s"

msgid "View the list of executed backup jobs:"
msgstr "実行されたバックアップ・ジョブの一覧を表示します。"

msgid ""
"$ {create_cmd_brief} get pods\n"
"NAME                               READY    STATUS       RESTARTS    AGE\n"
"test-backup-5b4rf                  0/1      Completed    0           24s\n"
"keycloak-0                         1/1      Running      0           52m\n"
"keycloak-postgresql-c824c6-vv27m   1/1      Running      0           71m"
msgstr ""
"$ {create_cmd_brief} get pods\n"
"NAME                               READY    STATUS       RESTARTS    AGE\n"
"test-backup-5b4rf                  0/1      Completed    0           24s\n"
"keycloak-0                         1/1      Running      0           52m\n"
"keycloak-postgresql-c824c6-vv27m   1/1      Running      0           71m"

msgid ""
"$ {create_cmd_brief} logs test-backup-5b4rf\n"
"==> Component data dump completed\n"
".\n"
".\n"
".\n"
"."
msgstr ""
"$ {create_cmd_brief} logs test-backup-5b4rf\n"
"==> Component data dump completed\n"
".\n"
".\n"
".\n"
"."

msgid ""
"For more details on persistent volumes, see "
"link:https://docs.openshift.com/container-"
"platform/4.4/storage/understanding-persistent-storage.html[Understanding "
"persistent storage]."
msgstr ""
"永続ボリュームの詳細については、 link:https://docs.openshift.com/container-"
"platform/4.4/storage/understanding-persistent-storage.html[永続ストレージについて理解する] "
"を参照してください。"

msgid "Installing extensions and themes"
msgstr "拡張機能とテーマのインストール"

msgid ""
"You can use the operator to install extensions and themes that you need for "
"your company or organization. The extension or theme can be anything that "
"{project_name} can consume. For example, you can add a metrics extension. "
"You add the extension or theme to the Keycloak custom resource."
msgstr ""
"Operatorを使用して、会社または組織に必要な拡張機能とテーマをインストールできます。拡張機能またはテーマは、{project_name}が使用できるものであれば何でもかまいません。たとえば、メトリクス拡張を追加できます。Keycloakカスタムリソースに拡張機能またはテーマを追加します。"

msgid ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: Keycloak\n"
"metadata:\n"
"  name: example-keycloak\n"
"  labels:\n"
"   app: keycloak\n"
"spec:\n"
"  instances: 1\n"
"  extensions:\n"
"   - <url_for_extension_or_theme>\n"
"  externalAccess:\n"
"    enabled: True"
msgstr ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: Keycloak\n"
"metadata:\n"
"  name: example-keycloak\n"
"  labels:\n"
"   app: keycloak\n"
"spec:\n"
"  instances: 1\n"
"  extensions:\n"
"   - <url_for_extension_or_theme>\n"
"  externalAccess:\n"
"    enabled: True"

msgid ""
"You can package and deploy themes in the same way as any other extensions. "
"See {developerguide_deploying_themes}[Deploying Themes] manual entry for "
"more information."
msgstr ""
"他の拡張機能と同じ方法でテーマをパッケージ化してデプロイできます。詳細については、{developerguide_deploying_themes}[テーマのデプロイ]のマニュアル・エントリーを参照してください。"

msgid "You have a YAML file for the Keycloak custom resource."
msgstr "Keycloakカスタムリソース用のYAMLファイルがあること。"

msgid ""
"Edit the YAML file for the Keycloak custom resource: `{create_cmd_brief} "
"edit <CR-name>`"
msgstr ""
"`{create_cmd_brief} edit <CR-name>` のようにKeycloakカスタムリソースのYAMLファイルを編集します。"

msgid "Add a line called `extensions:` after the `instances` line."
msgstr "`extensions:` という行を `instances` 行の後に追加します。"

msgid "Add a URL to a JAR file for your custom extension or theme."
msgstr "カスタム拡張機能またはテーマのJARファイルにURLを追加します。"

msgid "Save the file."
msgstr "ファイルを保存します。"

msgid "The Operator downloads the extension or theme and installs it."
msgstr "Operatorは拡張機能またはテーマをダウンロードしてインストールします。"

msgid "Command options for managing custom resources"
msgstr "カスタムリソースを管理するためのコマンド・オプション"

msgid ""
"After you create a custom request, you can edit it or delete using the "
"`{create_cmd_brief}` command."
msgstr "カスタム・リクエストを作成したら、 `{create_cmd_brief}` コマンドを使用して、それを編集または削除できます。"

msgid ""
"To edit a custom request, use this command: `{create_cmd_brief} edit <CR-"
"name>`"
msgstr "カスタム・リクエストを編集するには、次のコマンドを使用します。 `{create_cmd_brief} edit <CR-name>`"

msgid ""
"To delete a custom request, use this command: `{create_cmd_brief} delete "
"<CR-name>`"
msgstr "カスタム・リクエストを削除するには、次のコマンドを使用します。 `{create_cmd_brief} delete <CR-name>`"

msgid ""
"For example, to edit a realm custom request named `test-realm`, use this "
"command:"
msgstr "たとえば、 `test-realm` という名前のレルム・カスタム・リクエストを編集するには、次のコマンドを使用します。"

msgid "$ {create_cmd_brief} edit test-realm"
msgstr "$ {create_cmd_brief} edit test-realm"

msgid "A window opens where you can make changes."
msgstr "変更を加えることができるウィンドウが開きます。"

msgid ""
"You can update the Keycloak CR YAML file and changes will be applied to the "
"deployment."
msgstr "Keycloak CRのYAMLファイルを更新すれば、変更がデプロイメントに適用されます。"

msgid "Updates to the other resources are limited:"
msgstr "その他のリソースの更新には次の制限があります。"

msgid ""
"Keycloak Realm CR only supports basic creation and deletion without sync "
"options. Keycloak User and Client CRs support unidirectional updates "
"(changes to the CR are reflected in Keycloak but changes done in Keycloak "
"are not updated in the CR)."
msgstr ""
"Keycloak Realm CRは、同期オプションのない基本的な作成と削除のみをサポートします。Keycloak User CRとClient "
"CRは、一方向の更新をサポートします（CRへの変更はKeycloakに反映されますが、Keycloakで行われた変更はCRには反映されません）。"

msgid "Upgrade strategy"
msgstr "アップグレード戦略"

msgid ""
"You can configure how the operator performs {project_name} upgrades. You can"
" choose from the following upgrade strategies."
msgstr "オペレーターが{project_name}のアップグレードを実行する方法を設定できます。次のアップグレード戦略から選択できます。"

msgid ""
"`recreate`: This is the default strategy. The operator removes all "
"{project_name} replicas, optionally creates a backup and then creates the "
"replicas based on a newer {project_name} image. This strategy is suitable "
"for major upgrades as a single {project_name} version is accessing the "
"underlying database. The downside is {project_name} needs to be shut down "
"during the upgrade."
msgstr ""
"`recreate`: "
"これがデフォルトの戦略です。オペレーターはすべての{project_name}のレプリカを削除し、オプションでバックアップを作成してから、新しい{project_name}イメージに基づいてレプリカを作成します。この戦略は、単一の{project_name}のバージョンが基盤となるデータベースにアクセスしているため、メジャー・アップグレードに適しています。欠点は、アップグレード中に{project_name}をシャットダウンする必要があることです。"

msgid ""
"`rolling`: The operator removes one replica at a time and creates it again "
"based on a newer {project_name} image. This ensures a zero-downtime upgrade "
"but is more suitable for minor version upgrades that do not require database"
" migration since the database is accessed by multiple {project_name} "
"versions concurrently. Automatic backups are not supported with this "
"strategy."
msgstr ""
"`rolling`: "
"オペレーターは一度に1つのレプリカを削除し、新しい{project_name}のイメージに基づいてレプリカを再作成します。これにより、ゼロ・ダウンタイムのアップグレードが保証されますが、データベースは複数の{project_name}のバージョンによって同時にアクセスされるため、データベースの移行を必要としないマイナー・バージョンのアップグレードに適しています。この戦略では、自動バックアップはサポートされていません。"

msgid ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: Keycloak\n"
"metadata:\n"
"  name: example-keycloak\n"
"  labels:\n"
"   app: keycloak\n"
"spec:\n"
"  instances: 2\n"
"  migration:\n"
"    strategy: recreate\n"
"    backups:\n"
"      enabled: True\n"
"  externalAccess:\n"
"    enabled: True"
msgstr ""
"apiVersion: keycloak.org/v1alpha1\n"
"kind: Keycloak\n"
"metadata:\n"
"  name: example-keycloak\n"
"  labels:\n"
"   app: keycloak\n"
"spec:\n"
"  instances: 2\n"
"  migration:\n"
"    strategy: recreate\n"
"    backups:\n"
"      enabled: True\n"
"  externalAccess:\n"
"    enabled: True"

msgid ""
"For more information on rolling updates, see the "
"https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-"
"set/#rolling-update[Updating StatefulSets manual]."
msgstr ""
"ローリング・アップデートの詳細については、 https://kubernetes.io/docs/tutorials/stateful-"
"application/basic-stateful-set/#rolling-update[Updating StatefulSets manual]"
" を参照してください。"
