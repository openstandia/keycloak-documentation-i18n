# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"Last-Translator: Kohei Tamura <ktamura.biz.80@gmail.com>, 2018\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Title =
#: source/authorization_services/topics/enforcer-js-adapter.adoc:2
#, no-wrap
msgid "JavaScript Integration"
msgstr "JavaScriptの統合"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:6
msgid ""
"The {project_name} Server comes with a JavaScript library you can use to "
"interact with a resource server protected by a policy enforcer.  This "
"library is based on the {project_name} JavaScript adapter, which can be "
"integrated to allow your client to obtain permissions from a {project_name} "
"Server."
msgstr ""
"{project_name}サーバーには、ポリシー・エンフォーサーによって保護されたリソースサーバーと対話するために使用できるJavaScriptライブラリが付属しています。このライブラリは{project_name}"
" JavaScriptアダプターに基づいています。これを統合すると、クライアントは{project_name}サーバーからアクセス権を取得できます。"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:8
msgid ""
"You can obtain this library from a running a {project_name} Server instance "
"by including the following `script` tag in your web page:"
msgstr ""
"次の `script` タグをWebページに含めることで、実行中の{project_name}サーバー・インスタンスからこのライブラリを入手できます。"

#. type: Code block
#: source/authorization_services/topics/enforcer-js-adapter.adoc:11
msgid "<script src=\"http://.../auth/js/keycloak-authz.js\"></script>"
msgstr "<script src=\"http://.../auth/js/keycloak-authz.js\"></script>"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:13
msgid ""
"Once you do that, you can create a `KeycloakAuthorization` instance as "
"follows:"
msgstr "これを実行すると、次のように `KeycloakAuthorization` インスタンスを作成できます。"

#. type: Code block
#: source/authorization_services/topics/enforcer-js-adapter.adoc:17
#, no-wrap
msgid ""
"var keycloak = ... // obtain a Keycloak instance from keycloak.js library\n"
"var authorization = new KeycloakAuthorization(keycloak);\n"
msgstr ""
"var keycloak = ... // obtain a Keycloak instance from keycloak.js library\n"
"var authorization = new KeycloakAuthorization(keycloak);\n"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:19
msgid "The *keycloak-authz.js* library provides two main features:"
msgstr "*keycloak-authz.js* ライブラリには2つの主な機能があります。"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:21
msgid ""
"Handle responses from a resource server protected by a <<_enforcer_overview,"
" {project_name} Policy Enforcer>> and obtain a requesting party token (RPT) "
"with the necessary permissions to gain access to the protected resources on "
"the resource server."
msgstr ""
"<<_enforcer_overview, "
"{project_name}ポリシー・エンフォーサー>>によって保護されたリソースサーバーからのレスポンスを処理し、リソースサーバー上の保護されたリソースにアクセスするために必要な権限を持つリクエスティング・パーティー・トークン（RPT）を取得します。"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:23
#, no-wrap
msgid ""
"** In this case, the library can handle whatever authorization protocol the "
"resource server is using: <<_service_entitlement_api, Entitlements>>.\n"
msgstr ""
"** この場合、ライブラリは、リソースサーバーが使用している認可プロトコル（<<_service_entitlement_api, "
"エンタイトルメント>>）を処理できます。\n"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:25
msgid ""
"Obtain permissions from a {project_name} Server using the "
"<<_service_entitlement_api, Entitlement API>>."
msgstr ""
"<<_service_entitlement_api, エンタイトルメントAPI>>を使用して{project_name}サーバーから権限を取得します。"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:28
msgid ""
"In both cases, the library allows you to easily interact with both resource "
"server and {project_name} Authorization Services to obtain tokens with "
"permissions your client can use as bearer tokens to access the protected "
"resources on a resource server."
msgstr ""
"いずれの場合も、リソースサーバーと{project_name}認可サービスの両方との対話を容易にし、クライアントがリソースサーバー上の保護されたリソースにアクセスするベアラー・トークンとして使用できる権限を持つトークンを取得できます。"

#. type: Title ==
#: source/authorization_services/topics/enforcer-js-adapter.adoc:29
#, no-wrap
msgid "Handling Authorization Responses from a Resource Server"
msgstr "リソースサーバーからの認可レスポンスの処理"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:34
msgid ""
"If a resource server is protected by a policy enforcer, it responds to "
"client requests based on the permissions carried along with a "
"<<_enforcer_bearer, bearer token>>.  Typically, when you try to access a "
"resource server with a bearer token that is lacking permissions to access a "
"protected resource, the resource server responds with a *401* status code "
"and a `WWW-Authenticate` header."
msgstr ""
"リソースサーバーがポリシー・エンフォーサーによって保護されている場合、リソースサーバーは、<<_enforcer_bearer, "
"ベアラートークンベアラー・トークン>>とともに送信される権限に基づいてクライアント・リクエストに応答します。通常、保護されたリソースにアクセスするための権限がないベアラー・トークンを使用してリソースサーバーにアクセスしようとすると、リソースサーバーは"
" *401* ステータスコードと `WWW-Authenticate` ヘッダーで応答します。"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:36
msgid ""
"The value of the `WWW-Authenticate` header depends on the authorization "
"protocol in use by the resource server. Whatever protocol is in use, you can"
" use a `KeycloakAuthorization` instance to handle responses as follows:"
msgstr ""
"`WWW-Authenticate` ヘッダーの値は、リソースサーバーで使用されている認可プロトコルによって異なります。使用中のプロトコルが何であれ、"
" `KeycloakAuthorization` インスタンスを使用して次のようにレスポンスを処理できます。"

#. type: Code block
#: source/authorization_services/topics/enforcer-js-adapter.adoc:49
#, no-wrap
msgid ""
"var wwwAuthenticateHeader = ... // extract WWW-Authenticate Header from the response in case of a 401 status code\n"
"authorization.authorize(wwwAuthenticateHeader).then(function (rpt) {\n"
"    // onGrant callback function.\n"
"    // If authorization was successful you'll receive an RPT\n"
"    // with the necessary permissions to access the resource server\n"
"}, function () {\n"
"    // onDeny callback function.\n"
"    // Called when the authorization request is denied by the server\n"
"}, function () {\n"
"    // onError callback function. Called when the server responds unexpectedly\n"
"});\n"
msgstr ""
"var wwwAuthenticateHeader = ... // extract WWW-Authenticate Header from the response in case of a 401 status code\n"
"authorization.authorize(wwwAuthenticateHeader).then(function (rpt) {\n"
"    // onGrant callback function.\n"
"    // If authorization was successful you'll receive an RPT\n"
"    // with the necessary permissions to access the resource server\n"
"}, function () {\n"
"    // onDeny callback function.\n"
"    // Called when the authorization request is denied by the server\n"
"}, function () {\n"
"    // onError callback function. Called when the server responds unexpectedly\n"
"});\n"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:52
msgid ""
"The `authorize` function is completely asynchronous and supports a few "
"callback functions to receive notifications from the server:"
msgstr "`authorize` 関数は完全に非同期で、サーバーからの通知を受け取るためのいくつかのコールバック関数をサポートしています。"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:54
#: source/authorization_services/topics/enforcer-js-adapter.adoc:75
msgid ""
"`onGrant`: The first argument of the function. If authorization was "
"successful and the server returned an RPT with the requested permissions, "
"the callback receives the RPT."
msgstr "`onGrant`: 関数の第1引数。認可が成功し、サーバーが要求された権限でRPTを返した場合、コールバックはRPTを受け取ります。"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:55
#: source/authorization_services/topics/enforcer-js-adapter.adoc:76
msgid ""
"`onDeny`: The second argument of the function. Only called if the server has"
" denied the authorization request."
msgstr "`onDeny`: 関数の第2引数。サーバーがリクエストを拒否した場合にのみ呼び出されます。"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:56
#: source/authorization_services/topics/enforcer-js-adapter.adoc:77
msgid ""
"`onError`: The third argument of the function. Only called if the server "
"responds unexpectedly."
msgstr "`onError`: 関数の第3引数。サーバーが予期せず応答する場合にのみ呼び出されます。"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:58
msgid ""
"Most applications should use the `onGrant` callback to retry a request after"
" a 401 response. Subsequent requests should include the RPT as a bearer "
"token for retries."
msgstr ""
"ほとんどのアプリケーションは、 `onGrant` "
"コールバックを使用して401応答後にリクエストをリトライする必要があります。以降のリクエストには、RPTをリトライのためのベアラー・トークンとして含める必要があります。"

#. type: Title ==
#: source/authorization_services/topics/enforcer-js-adapter.adoc:59
#: source/authorization_services/topics/service-entitlement-entitlement-api-aapi.adoc:35
#, no-wrap
msgid "Obtaining Entitlements"
msgstr "エンタイトルメントの取得"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:62
msgid ""
"The keycloak-authz.js library provides an `entitlement` function that you "
"can use to obtain an RPT from the server using the Entitlement API."
msgstr ""
"keycloak-authz.jsライブラリには、エンタイトルメントAPIを使用してサーバーからRPTを取得するために使用できる "
"`entitlement` 関数が用意されています。"

#. type: Code block
#: source/authorization_services/topics/enforcer-js-adapter.adoc:69
#, no-wrap
msgid ""
"authorization.entitlement('my-resource-server-id').then(function (rpt) {\n"
"    // onGrant callback function.\n"
"    // If authorization was successful you'll receive an RPT\n"
"    // with the necessary permissions to access the resource server\n"
"});\n"
msgstr ""
"authorization.entitlement('my-resource-server-id').then(function (rpt) {\n"
"    // onGrant callback function.\n"
"    // If authorization was successful you'll receive an RPT\n"
"    // with the necessary permissions to access the resource server\n"
"});\n"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:71
msgid ""
"When using the `entitlement` function, you must provide the _client_id_ of "
"the resource server you want to access."
msgstr "`entitlement` を使用する場合は、アクセスするリソースサーバーの _client_id_ を指定する必要があります。"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:73
msgid ""
"The `entitlement` function is completely asynchronous and supports a few "
"callback functions to receive notifications from the server:"
msgstr "`entitlement` 関数は完全に非同期で、サーバーからの通知を受け取るためのコールバック関数をいくつかサポートしています。"

#. type: Title ==
#: source/authorization_services/topics/enforcer-js-adapter.adoc:78
#, no-wrap
msgid "Obtaining the RPT"
msgstr "RPTの取得"

#. type: Plain text
#: source/authorization_services/topics/enforcer-js-adapter.adoc:81
msgid ""
"If you have already obtained an RPT using any of the authorization functions"
" provided by the library, you can always obtain the RPT as follows from the "
"authorization object (assuming that it has been initialized by one of the "
"techniques shown earlier):"
msgstr ""
"ライブラリによって提供されている認可関数を使用してRPTをすでに取得している場合は、認可オブジェクトから次のようにRPTを得ることができます（前述のいずれかの手法で初期化されているものとします）。"

#. type: Code block
#: source/authorization_services/topics/enforcer-js-adapter.adoc:84
msgid "var rpt = authorization.rpt;"
msgstr "var rpt = authorization.rpt;"
