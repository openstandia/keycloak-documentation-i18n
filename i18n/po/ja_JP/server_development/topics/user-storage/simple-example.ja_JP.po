# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n\n"
"Last-Translator: Hiroshi Aida <daian183@gmail.com>, 2018\n"
"Language-Team: Japanese (Japan) (https://www.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    ...\n"
"}\n"
msgstr ""
"    ...\n"
"}\n"

#. type: delimited block -
#, no-wrap
msgid "    }\n"
msgstr "    }\n"

#. type: Block title
#, no-wrap
msgid "User Federation"
msgstr "ユーザー・フェデレーション"

#. type: Block title
#, no-wrap
msgid "Configured Provider"
msgstr "設定プロバイダー"

#. type: Title ====
#, no-wrap
msgid "Packaging and Deployment"
msgstr "パッケージ化とデプロイ"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {\n"
"        if (!supportsCredentialType(input.getType()) || !(input instanceof UserCredentialModel)) return false;\n"
msgstr ""
"    @Override\n"
"    public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {\n"
"        if (!supportsCredentialType(input.getType()) || !(input instanceof UserCredentialModel)) return false;\n"

#. type: Title ===
#, no-wrap
msgid "Simple Read-Only, Lookup Example"
msgstr "簡単な読み取り専用の参照のサンプル"

#. type: Plain text
msgid ""
"To illustrate the basics of implementing the User Storage SPI let's walk "
"through a simple example. In this chapter you'll see the implementation of a"
" simple `UserStorageProvider` that looks up users in a simple property file."
" The property file contains username and password definitions and is "
"hardcoded to a specific location on the classpath. The provider will be able"
" to look up the user by ID and username and also be able to validate "
"passwords. Users that originate from this provider will be read-only."
msgstr ""
"ユーザー・ストレージSPIの基本実装を示すために、簡単なサンプルで説明します。この章では、簡単なプロパティー・ファイル内でユーザーを検索する簡単な "
"`UserStorageProvider` "
"の実装を見ていきます。プロパティー・ファイルには、ユーザー名とパスワードの定義が含まれており、クラスパス上の特定のロケーションにハードコードされています。プロバイダーにより、IDとユーザー名でユーザーを検索し、パスワードを検証することもできるようになります。このプロバイダーに基づくユーザーは、読み取り専用になります。"

#. type: Title ====
#, no-wrap
msgid "Provider Class"
msgstr "プロバイダー・クラス"

#. type: Plain text
msgid ""
"The first thing we will walk through is the `UserStorageProvider` class."
msgstr "はじめに `UserStorageProvider` クラスについて説明します。"

#. type: delimited block -
#, no-wrap
msgid ""
"public class PropertyFileUserStorageProvider implements\n"
"        UserStorageProvider,\n"
"        UserLookupProvider,\n"
"        CredentialInputValidator,\n"
"        CredentialInputUpdater\n"
"{\n"
"...\n"
"}\n"
msgstr ""
"public class PropertyFileUserStorageProvider implements\n"
"        UserStorageProvider,\n"
"        UserLookupProvider,\n"
"        CredentialInputValidator,\n"
"        CredentialInputUpdater\n"
"{\n"
"...\n"
"}\n"

#. type: Plain text
msgid ""
"Our provider class, `PropertyFileUserStorageProvider`, implements many "
"interfaces. It implements the `UserStorageProvider` as that is a base "
"requirement of the SPI. It implements the `UserLookupProvider` interface "
"because we want to be able to log in with users stored by this provider. It "
"implements the `CredentialInputValidator` interface because we want to be "
"able to validate passwords entered in using the login screen. Our property "
"file is read-only. We implement the `CredentialInputUpdater` because we want"
" to post an error condition when the user attempts to update his password."
msgstr ""
"プロバイダー・クラス `PropertyFileUserStorageProvider` "
"は、多くのインターフェイスを実装しています。SPIの基本要件なので、 `UserLookupProvider` "
"が実装されています。このプロバイダーにより保存されたユーザーでログインできるようにするため、 `UserLookupProvider` "
"インターフェイスが実装されています。ログイン画面で入力したパスワードの検証を可能にする必要があるので、 "
"`CredentialInputValidator` "
"インターフェイスが実装されています。プロパティー・ファイルは読み取り専用です。ユーザーがパスワードを更新しようとする時にエラー状態を通知する必要があるので、"
" `CredentialInputUpdater` が実装されています。"

#. type: delimited block -
#, no-wrap
msgid ""
"    protected KeycloakSession session;\n"
"    protected Properties properties;\n"
"    protected ComponentModel model;\n"
"    // map of loaded users in this transaction\n"
"    protected Map<String, UserModel> loadedUsers = new HashMap<>();\n"
msgstr ""
"    protected KeycloakSession session;\n"
"    protected Properties properties;\n"
"    protected ComponentModel model;\n"
"    // map of loaded users in this transaction\n"
"    protected Map<String, UserModel> loadedUsers = new HashMap<>();\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    public PropertyFileUserStorageProvider(KeycloakSession session, ComponentModel model, Properties properties) {\n"
"        this.session = session;\n"
"        this.model = model;\n"
"        this.properties = properties;\n"
"    }\n"
msgstr ""
"    public PropertyFileUserStorageProvider(KeycloakSession session, ComponentModel model, Properties properties) {\n"
"        this.session = session;\n"
"        this.model = model;\n"
"        this.properties = properties;\n"
"    }\n"

#. type: Plain text
msgid ""
"The constructor for this provider class is going to store the reference to "
"the `KeycloakSession`, `ComponentModel`, and property file. We'll use all of"
" these later. Also notice that there is a map of loaded users. Whenever we "
"find a user we will store it in this map so that we avoid re-creating it "
"again within the same transaction. This is a good practice to follow as many"
" providers will need to do this (that is, any provider that integrates with "
"JPA). Remember also that provider class instances are created once per "
"transaction and are closed after the transaction completes."
msgstr ""
"このプロバイダー・クラスのコンストラクターには、 `KeycloakSession` 、 `ComponentModel` "
"、およびプロパティー・ファイルへの参照が格納されます。後で、これらをすべて使用します。また、ロードされたユーザーのマップがあることにも注意してください。ユーザーを見つけるたびに、このマップに保存して、同じトランザクション内でそれを再度作成しないで済むようにします。多くのプロバイダがこれを行う必要があるので、従うことは良い習慣です（つまり、JPAと統合するすべてのプロバイダー）。プロバイダー・クラス・インスタンスは、トランザクション毎に都度作成され、トランザクション完了後にクローズされることも注意してください。"

#. type: Title =====
#, no-wrap
msgid "UserLookupProvider Implementation"
msgstr "UserLookupProviderの実装"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public UserModel getUserByUsername(String username, RealmModel realm) {\n"
"        UserModel adapter = loadedUsers.get(username);\n"
"        if (adapter == null) {\n"
"            String password = properties.getProperty(username);\n"
"            if (password != null) {\n"
"                adapter = createAdapter(realm, username);\n"
"                loadedUsers.put(username, adapter);\n"
"            }\n"
"        }\n"
"        return adapter;\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public UserModel getUserByUsername(String username, RealmModel realm) {\n"
"        UserModel adapter = loadedUsers.get(username);\n"
"        if (adapter == null) {\n"
"            String password = properties.getProperty(username);\n"
"            if (password != null) {\n"
"                adapter = createAdapter(realm, username);\n"
"                loadedUsers.put(username, adapter);\n"
"            }\n"
"        }\n"
"        return adapter;\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    protected UserModel createAdapter(RealmModel realm, String username) {\n"
"        return new AbstractUserAdapter(session, realm, model) {\n"
"            @Override\n"
"            public String getUsername() {\n"
"                return username;\n"
"            }\n"
"        };\n"
"    }\n"
msgstr ""
"    protected UserModel createAdapter(RealmModel realm, String username) {\n"
"        return new AbstractUserAdapter(session, realm, model) {\n"
"            @Override\n"
"            public String getUsername() {\n"
"                return username;\n"
"            }\n"
"        };\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public UserModel getUserById(String id, RealmModel realm) {\n"
"        StorageId storageId = new StorageId(id);\n"
"        String username = storageId.getExternalId();\n"
"        return getUserByUsername(username, realm);\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public UserModel getUserById(String id, RealmModel realm) {\n"
"        StorageId storageId = new StorageId(id);\n"
"        String username = storageId.getExternalId();\n"
"        return getUserByUsername(username, realm);\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public UserModel getUserByEmail(String email, RealmModel realm) {\n"
"        return null;\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public UserModel getUserByEmail(String email, RealmModel realm) {\n"
"        return null;\n"
"    }\n"

#. type: Plain text
msgid ""
"The `getUserByUsername()` method is invoked by the {project_name} login page"
" when a user logs in. In our implementation we first check the `loadedUsers`"
" map to see if the user has already been loaded within this transaction. If "
"it hasn't been loaded we look in the property file for the username. If it "
"exists we create an implementation of `UserModel`, store it in `loadedUsers`"
" for future reference, and return this instance."
msgstr ""
"`getUserByUsername()` "
"メソッドは、ユーザーがログインする際に{project_name}ログイン・ページにより呼び出されます。実装では、最初に `loadedUsers` "
"マップを確認して、ユーザーが既にトランザクション内にロードされているかどうかを確かめます。ロードされていなかった場合、プロパティー・ファイル内でユーザー名を検索します。それが存在した場合、"
" `UserModel` の実装を作成し、今後の参照のために `loadedUsers` 内にそれを格納し、このインスタンスを返します。"

#. type: Plain text
msgid ""
"The `createAdapter()` method uses the helper class "
"`org.keycloak.storage.adapter.AbstractUserAdapter`. This provides a base "
"implementation for `UserModel`. It automatically generates a user id based "
"on the required storage id format using the username of the user as the "
"external id."
msgstr ""
"`createAdapter()` メソッドは、ヘルパー・クラス "
"`org.keycloak.storage.adapter.AbstractUserAdapter` を使用します。これは、 `UserModel` "
"の基本実装を提供します。これにより、外部IDとしてユーザーのユーザー名を使用する、必須ストレージIDフォーマットに基づいたユーザーIDが自動的に生成されます。"

#. type: delimited block -
#, no-wrap
msgid "\"f:\" + component id + \":\" + username\n"
msgstr "\"f:\" + component id + \":\" + username\n"

#. type: Plain text
msgid ""
"Every get method of `AbstractUserAdapter` either returns null or empty "
"collections. However, methods that return role and group mappings will "
"return the default roles and groups configured for the realm for every user."
"  Every set method of `AbstractUserAdapter` will throw a "
"`org.keycloak.storage.ReadOnlyException`. So if you attempt to modify the "
"user in the admininstration console, you will get an error."
msgstr ""
"`AbstractUserAdapter` "
"のすべてのgetメソッドは、nullか空のコレクションを返します。しかし、ロールとグループ・マッピングを返すメソッドは、全ユーザーのレルム用に設定されたデフォルトのロールとグループを返します。"
" `AbstractUserAdapter` のすべてのsetメソッドは、 "
"`org.keycloak.storage.ReadOnlyException` "
"をスローします。そのため、管理コンソール内でユーザーを更新しようとすると、エラーが発生します。"

#. type: Plain text
msgid ""
"The `getUserById()` method parses the `id` parameter using the "
"`org.keycloak.storage.StorageId' helper class. The "
"`StorageId.getExternalId()` method is invoked to obtain the username embeded"
" in the `id` parameter. The method then delegates to `getUserByUsername()`."
msgstr ""
"`getUserById()` メソッドは、 `org.keycloak.storage.StorageId` ヘルパークラスを使って "
"`id`パラメーターを解析します。 `StorageId.getExternalId()` メソッドは、 "
"`id`パラメーターに埋め込まれたユーザー名を取得するために呼び出されます。そして、このメソッドは `getUserByUsername()` "
"に委譲します。"

#. type: Plain text
msgid "Emails are not stored, so the `getUserByEmail()` method returns null."
msgstr "電子メールは格納されていないので、 `getUserByEmail()` メソッドはnullを返します。"

#. type: Title =====
#, no-wrap
msgid "CredentialInputValidator Implementation"
msgstr "CredentialInputValidatorの実装"

#. type: Plain text
msgid ""
"Next let's look at the method implementations for "
"`CredentialInputValidator`."
msgstr "次に `CredentialInputValidator` の実装メソッドを見ていきましょう。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {\n"
"        String password = properties.getProperty(user.getUsername());\n"
"        return credentialType.equals(CredentialModel.PASSWORD) && password != null;\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {\n"
"        String password = properties.getProperty(user.getUsername());\n"
"        return credentialType.equals(CredentialModel.PASSWORD) && password != null;\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public boolean supportsCredentialType(String credentialType) {\n"
"        return credentialType.equals(CredentialModel.PASSWORD);\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public boolean supportsCredentialType(String credentialType) {\n"
"        return credentialType.equals(CredentialModel.PASSWORD);\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        UserCredentialModel cred = (UserCredentialModel)input;\n"
"        String password = properties.getProperty(user.getUsername());\n"
"        if (password == null) return false;\n"
"        return password.equals(cred.getValue());\n"
"    }\n"
msgstr ""
"        UserCredentialModel cred = (UserCredentialModel)input;\n"
"        String password = properties.getProperty(user.getUsername());\n"
"        if (password == null) return false;\n"
"        return password.equals(cred.getValue());\n"
"    }\n"

#. type: Plain text
msgid ""
"The `isConfiguredFor()` method is called by the runtime to determine if a "
"specific credential type is configured for the user. This method checks to "
"see that the password is set for the user."
msgstr ""
"`isConfiguredFor()` "
"メソッドは、ランタイムによって呼び出されて、特定のクレデンシャル・タイプがユーザーのために設定されているかどうかを判断します。このメソッドは、パスワードがユーザー用に設定されていることを確認します。"

#. type: Plain text
msgid ""
"The `supportsCredentialType()` method returns whether validation is "
"supported for a specific credential type. We check to see if the credential "
"type is `password`."
msgstr ""
"`supportsCredentialType()` "
"メソッドは、特定のクレデンシャル・タイプに対する検証がサポートされているかどうかを返します。クレデンシャル・タイプが `password` "
"であるかどうかを確認します。"

#. type: Plain text
msgid ""
"The `isValid()` method is responsible for validating passwords. The "
"`CredentialInput` parameter is really just an abstract interface for all "
"credential types. We make sure that we support the credential type and also "
"that it is an instance of `UserCredentialModel`. When a user logs in through"
" the login page, the plain text of the password input is put into an "
"instance of `UserCredentialModel`. The `isValid()` method checks this value "
"against the plain text password stored in the properties file. A return "
"value of `true` means the password is valid."
msgstr ""
"`isValid()` メソッドはパスワードの検証を担当します。 `CredentialInput` "
"パラメーターは、すべてのクレデンシャル・タイプのための単なる抽象的なインターフェイスです。クレデンシャル・タイプをサポートしていること、およびそれが "
"`UserCredentialModel` "
"のインスタンスであることも確認します。ユーザーがログイン・ページからログインすると、入力されたパスワードのプレーン・テキストが "
"`UserCredentialModel` のインスタンスに格納されます。 `isValid()` "
"メソッドは、プロパティー・ファイルに格納されているプレーンテキストのパスワードに対してその値を確認します。 `true` "
"の戻り値は、パスワードが有効であるということを意味します。"

#. type: Title =====
#, no-wrap
msgid "CredentialInputUpdater Implementation"
msgstr "CredentialInputUpdaterの実装"

#. type: Plain text
msgid ""
"As noted before, the only reason we implement the `CredentialInputUpdater` "
"interface in this example is to forbid modifications of user passwords. The "
"reason we have to do this is because otherwise the runtime would allow the "
"password to be overriden in {project_name} local storage. We'll talk more "
"about this later in this chapter."
msgstr ""
"以前説明した通り、このサンプル内の `CredentialInputUpdater` "
"インターフェイスを実装するのは、ユーザー・パスワードの変更を禁止するためだけです。これをしなければならない理由は、そうしないと、ランタイムにより{project_name}のローカル・ストレージ内でパスワードがオーバーライドできるようになってしまうからです。これについて、詳しくはこの章で後ほど説明します。"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {\n"
"        if (input.getType().equals(CredentialModel.PASSWORD)) throw new ReadOnlyException(\"user is read only for this update\");\n"
msgstr ""
"    @Override\n"
"    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {\n"
"        if (input.getType().equals(CredentialModel.PASSWORD)) throw new ReadOnlyException(\"user is read only for this update\");\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        return false;\n"
"    }\n"
msgstr ""
"return false;\n"
" }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void disableCredentialType(RealmModel realm, UserModel user, String credentialType) {\n"
msgstr ""
"    @Override\n"
"    public void disableCredentialType(RealmModel realm, UserModel user, String credentialType) {\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n"
"        return Collections.EMPTY_SET;\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n"
"        return Collections.EMPTY_SET;\n"
"    }\n"

#. type: Plain text
msgid ""
"The `updateCredential()` method just checks to see if the credential type is"
" password.  If it is, a `ReadOnlyException` is thrown."
msgstr ""
"`updateCredential()` メソッドは、クレデンシャル・タイプがパスワードであるかどうかを確認するだけです。そうであった場合、 "
"`ReadOnlyException` がスローされます。"

#. type: Title ====
#, no-wrap
msgid "Provider Factory Implementation"
msgstr "プロバイダー・ファクトリーの実装"

#. type: Plain text
msgid ""
"Now that the provider class is complete, we now turn our attention to the "
"provider factory class."
msgstr "プロバイダー・クラスに関しては完了したので、それでは次にプロバイダー・ファクトリー・クラスを見ていきましょう。"

#. type: delimited block -
#, no-wrap
msgid ""
"public class PropertyFileUserStorageProviderFactory\n"
"                 implements UserStorageProviderFactory<PropertyFileUserStorageProvider> {\n"
msgstr ""
"public class PropertyFileUserStorageProviderFactory\n"
"                 implements UserStorageProviderFactory<PropertyFileUserStorageProvider> {\n"

#. type: delimited block -
#, no-wrap
msgid "    public static final String PROVIDER_NAME = \"readonly-property-file\";\n"
msgstr ""
"    public static final String PROVIDER_NAME = \"readonly-property-file\";\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public String getId() {\n"
"        return PROVIDER_NAME;\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public String getId() {\n"
"        return PROVIDER_NAME;\n"
"    }\n"

#. type: Plain text
msgid ""
"First thing to notice is that when implementing the "
"`UserStorageProviderFactory` class, you must pass in the concrete provider "
"class implementation as a template parameter. Here we specify the provider "
"class we defined before: `PropertyFileUserStorageProvider`."
msgstr ""
"まず最初に注意すべき点は、 `UserStorageProviderFactory` "
"クラスを実装する際、テンプレート・パラメーターとして具体的なプロバイダー・クラス・実装を渡す必要があるということです。ここでは、以前に定義したプロバイダー・クラス"
" `PropertyFileUserStorageProvider` を指定します。"

#. type: Plain text
#, no-wrap
msgid ""
"If you do not specify the template parameter, your provider will not function. The runtime does class introspection\n"
"         to determine the _capability interfaces_ that the provider implements.\n"
msgstr ""
"テンプレート・パラメーターを指定しないと、プロバイダーは機能しません。ランタイムは、クラスのイントロスペクションが実行し、プロバイダーが実装する "
"_capability interfaces_ を定義します。\n"

#. type: Plain text
msgid ""
"The `getId()` method identifies the factory in the runtime and will also be "
"the string shown in the admin console when you want to enable a user storage"
" provider for the realm."
msgstr ""
"`getId()` "
"メソッドは、レルム用のユーザー・ストレージ・プロバイダーを有効にする必要がある場合、ランタイム内のファクトリーを識別し、管理コンソールで表示される文字列にもなります。"

#. type: Title =====
#, no-wrap
msgid "Initialization"
msgstr "初期化"

#. type: delimited block -
#, no-wrap
msgid ""
"    private static final Logger logger = Logger.getLogger(PropertyFileUserStorageProviderFactory.class);\n"
"    protected Properties properties = new Properties();\n"
msgstr ""
"    private static final Logger logger = Logger.getLogger(PropertyFileUserStorageProviderFactory.class);\n"
"    protected Properties properties = new Properties();\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public void init(Config.Scope config) {\n"
"        InputStream is = getClass().getClassLoader().getResourceAsStream(\"/users.properties\");\n"
msgstr ""
"    @Override\n"
"    public void init(Config.Scope config) {\n"
"        InputStream is = getClass().getClassLoader().getResourceAsStream(\"/users.properties\");\n"

#. type: delimited block -
#, no-wrap
msgid ""
"        if (is == null) {\n"
"            logger.warn(\"Could not find users.properties in classpath\");\n"
"        } else {\n"
"            try {\n"
"                properties.load(is);\n"
"            } catch (IOException ex) {\n"
"                logger.error(\"Failed to load users.properties file\", ex);\n"
"            }\n"
"        }\n"
"    }\n"
msgstr ""
"        if (is == null) {\n"
"            logger.warn(\"Could not find users.properties in classpath\");\n"
"        } else {\n"
"            try {\n"
"                properties.load(is);\n"
"            } catch (IOException ex) {\n"
"                logger.error(\"Failed to load users.properties file\", ex);\n"
"            }\n"
"        }\n"
"    }\n"

#. type: delimited block -
#, no-wrap
msgid ""
"    @Override\n"
"    public PropertyFileUserStorageProvider create(KeycloakSession session, ComponentModel model) {\n"
"        return new PropertyFileUserStorageProvider(session, model, properties);\n"
"    }\n"
msgstr ""
"    @Override\n"
"    public PropertyFileUserStorageProvider create(KeycloakSession session, ComponentModel model) {\n"
"        return new PropertyFileUserStorageProvider(session, model, properties);\n"
"    }\n"

#. type: Plain text
msgid ""
"The `UserStorageProviderFactory` interface has an optional `init()` method "
"you can implement. When {project_name} boots up, only one instance of each "
"provider factory is created. Also at boot time, the `init()` method is "
"called on each of these factory instances. There's also a `postInit()` "
"method you can implement as well. After each factory's `init()` method is "
"invoked, their `postInit()` methods are called."
msgstr ""
"`UserStorageProviderFactory` インターフェイスにはオプションで実装可能な `init()` "
"メソッドがあります。{project_name}が起動すると、各プロバイダー・ファクトリーのインスタンスが1つだけ作成されます。また、起動時に、 "
"`init()` メソッドがこれらのファクトリー・インスタンスでそれぞれ呼び出されます。また、実装可能な `postInit()` "
"メソッドも同様にあります。ファクトリーの `init()` メソッドがそれぞれ呼び出された後、 `postInit()` メソッドが呼び出されます。"

#. type: Plain text
msgid ""
"In our `init()` method implementation, we find the property file containing "
"our user declarations from the classpath. We then load the `properties` "
"field with the username and password combinations stored there."
msgstr ""
"`init()` "
"メソッドの実装では、クラスパスからのユーザー宣言を含むプロパティー・ファイルが見つかります。次に、そこに格納されているユーザー名とパスワードの組み合わせを、"
" `properties` フィールドをロードします。"

#. type: Plain text
msgid ""
"The `Config.Scope` parameter is factory configuration that can be set up "
"within `standalone.xml`, `standalone-ha.xml`, or `domain.xml`. For more "
"information on where the `standalone.xml`, `standalone-ha.xml`, or "
"`domain.xml` file resides see the "
"link:{installguide_link}[{installguide_name}]."
msgstr ""
"`Config.Scope` パラメーターは、 `standalone.xml` 、 `standalone-ha.xml` 、または "
"`domain.xml` 内で設定することができるファクトリー設定です。 `standalone.xml` 、 `standalone-ha.xml` "
"、または `domain.xml` "
"ファイルがある場所について、詳しくはlink:{installguide_link}[{installguide_name}]を参照ください。"

#. type: Plain text
msgid "For example, by adding the following to `standalone.xml`:"
msgstr "たとえば、以下を `standalone.xml` に追加します。"

#. type: delimited block -
#, no-wrap
msgid ""
"<spi name=\"storage\">\n"
"    <provider name=\"readonly-property-file\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"path\" value=\"/other-users.properties\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>\n"
msgstr ""
"<spi name=\"storage\">\n"
"    <provider name=\"readonly-property-file\" enabled=\"true\">\n"
"        <properties>\n"
"            <property name=\"path\" value=\"/other-users.properties\"/>\n"
"        </properties>\n"
"    </provider>\n"
"</spi>\n"

#. type: Plain text
msgid ""
"We can specify the classpath of the user property file instead of hardcoding"
" it. Then you can retrieve the configuration in the "
"`PropertyFileUserStorageProviderFactory.init()`:"
msgstr ""
"これをハードコーディングせずに、ユーザー・プロパティー・ファイルのクラスパスを指定することができます。次に、以下の通り "
"`PropertyFileUserStorageProviderFactory.init()` で設定を取り込むことができます。"

#. type: delimited block -
#, no-wrap
msgid ""
"public void init(Config.Scope config) {\n"
"    String path = config.get(\"path\");\n"
"    InputStream is = getClass().getClassLoader().getResourceAsStream(path);\n"
msgstr ""
"public void init(Config.Scope config) {\n"
"    String path = config.get(\"path\");\n"
"    InputStream is = getClass().getClassLoader().getResourceAsStream(path);\n"

#. type: Title =====
#, no-wrap
msgid "Create Method"
msgstr "メソッドの作成"

#. type: Plain text
msgid ""
"Our last step in creating the provider factory is the `create()` method."
msgstr "プロバイダー･ファクトリーの作成における最後の手順は `create()` メソッドになります。"

#. type: Plain text
msgid ""
"We simply allocate the `PropertyFileUserStorageProvider` class.  This create"
" method will be called once per transaction."
msgstr ""
"`PropertyFileUserStorageProvider` "
"クラスを単にアロケートするだけです。このcreateメソッドはトランザクション毎に都度呼び出されます。"

#. type: Plain text
msgid ""
"The class files for our provider implementation should be placed in a jar.  "
"You also have to declare the provider factory class within the `META-"
"INF/services/org.keycloak.storage.UserStorageProviderFactory` file."
msgstr ""
"プロバイダー実装のためのクラス・ファイルはjar内に置かれる必要があります。また、 `META-"
"INF/services/org.keycloak.storage.UserStorageProviderFactory` "
"ファイル内でプロバイダー・ファクトリー・クラスを宣言する必要もあります。"

#. type: delimited block -
#, no-wrap
msgid ""
"org.keycloak.examples.federation.properties.FilePropertiesStorageFactory\n"
msgstr ""
"org.keycloak.examples.federation.properties.FilePropertiesStorageFactory\n"

#. type: Plain text
msgid ""
"Once you create the jar you can deploy it using regular JBoss/Wildfly means:"
" copy the jar into the `deploy/` directory or using the JBoss CLI."
msgstr ""
"jarを作成すれば、通常のJBossまたはWildFlyの方法を使って、それをデプロイすることができるようになります。その方法とは、jarを "
"`deploy/` ディレクトリーにコピーするか、JBoss CLIを使用することです。"

#. type: Title ====
#, no-wrap
msgid "Enabling the Provider in the Administration Console"
msgstr "管理コンソール内でのプロバイダーの有効化"

#. type: Plain text
msgid ""
"You enable user storage providers per realm within the `User Federation` "
"page in the administration console."
msgstr "管理コンソールの `User Federation` ページ内で、レルム毎にユーザー・ストレージ・プロバイダーを有効にします。"

#. type: Plain text
msgid "image:{project_images}/empty-user-federation-page.png[]"
msgstr "image:{project_images}/empty-user-federation-page.png[]"

#. type: Plain text
msgid ""
"Select the provider we just created from the list: `readonly-property-file`."
" It brings you to the configuration page for our provider.  We do not have "
"anything to configure, so click *Save*."
msgstr ""
"`readonly-property-file` "
"というリストから作成したプロバイダーを選択します。これで、プロバイダーの設定ページに移動します。何も設定する必要はないので *Save* "
"をクリックします。"

#. type: Plain text
msgid "image:{project_images}/storage-provider-created.png[]"
msgstr "image:{project_images}/storage-provider-created.png[]"

#. type: Plain text
msgid ""
"When you go back to the main `User Federation` page, you now see your "
"provider listed."
msgstr "メインの `User Federation` ページに戻ると、リストアップされたプロバイダーが表示されます。"

#. type: Plain text
msgid "image:{project_images}/user-federation-page.png[]"
msgstr "image:{project_images}/user-federation-page.png[]"

#. type: Plain text
msgid ""
"You will now be able to log in with a user declared in the "
"`users.properties` file. This user will only be able to view the account "
"page after logging in."
msgstr ""
"これで、 `users.properties` "
"ファイル内で宣言されたユーザーを使用してログインすることができます。このユーザーは、ログイン後、アカウントページを見ることしかできません。"
