# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Nomura Research Institute, Ltd.
# This file is distributed under the same license as the keycloak-documentation-i18n package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: keycloak-documentation-i18n  \n"
"POT-Creation-Date: 2017-09-20 08:18+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Plain text
#: source/securing_apps/topics/overview/supported-protocols.adoc:11
#: source/server_admin/topics/sso-protocols/oidc.adoc:9
#, no-wrap
msgid ""
"link:http://openid.net/connect/[Open ID Connect] (OIDC) is an authentication protocol that is an extension of link:https://tools.ietf.org/html/rfc6749[OAuth 2.0].\n"
"While OAuth 2.0 is only a framework for building authorization protocols and is mainly incomplete, OIDC is a full-fledged authentication and authorization\n"
"protocol.  OIDC also makes heavy use of the link:https://jwt.io[Json Web Token] (JWT) set of standards.  These standards define an\n"
"identity token JSON format and ways to digitally sign and encrypt that data in a compact and web-friendly way.\n"
msgstr ""

#. type: Plain text
#: source/securing_apps/topics/overview/supported-protocols.adoc:24
#: source/server_admin/topics/sso-protocols/oidc.adoc:22
#, no-wrap
msgid ""
"The second type of use cases is that of a client that wants to gain access to remote services.  In this case, the client asks {project_name}\n"
"to obtain an _access token_ it can use to invoke on other remote services on behalf of the user.  {project_name} authenticates the user\n"
"then asks the user for consent to grant access to the client requesting it.  The client then receives the _access token_.  This _access token_\n"
"is digitally signed by the realm.  The client can make REST invocations on remote services using this _access token_.  The REST service\n"
"extracts the _access token_, verifies the signature of the token, then decides based on access information within the token whether or not to process\n"
"the request.\n"
msgstr ""

#. type: Title ===
#: source/server_admin/topics/sso-protocols/oidc.adoc:3
#, no-wrap
msgid "Open ID Connect"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:15
#, no-wrap
msgid ""
"There are really two types of use cases when using OIDC.  The first is an application that asks the {project_name} server to authenticate\n"
"a user for them.  After a successful login, the application will receive an _identity token_ and an _access token_.  The _identity token_\n"
"contains information about the user such as username, email, and other profile information.  The _access token_ is digitally signed by\n"
"the realm and contains access information (like user role mappings) that the application can use to determine what resources the user\n"
"is allowed to access on the application.\n"
msgstr ""

#. type: Title ====
#: source/server_admin/topics/sso-protocols/oidc.adoc:25
#, no-wrap
msgid "OIDC Auth Flows"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:30
#, no-wrap
msgid ""
"OIDC has different ways for a client or application to authenticate a user and receive an _identity_ and _access_ token.  Which\n"
"path you use depends greatly on the type of application or client requesting access.  All of these flows are described in the\n"
"OIDC and OAuth 2.0 specifications so only a brief overview will be provided here.\n"
msgstr ""

#. type: Title =====
#: source/server_admin/topics/sso-protocols/oidc.adoc:31
#, no-wrap
msgid "Authorization Code Flow"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:35
#, no-wrap
msgid ""
"This is a browser-based protocol and it is what we recommend you use to authenticate and authorize browser-based applications.  It makes\n"
"heavy use of browser redirects to obtain an _identity_ and _access_ token.  Here's a brief summary:\n"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:39
#: source/server_admin/topics/sso-protocols/oidc.adoc:71
#, no-wrap
msgid ""
"Browser visits application.  The application notices the user is not logged in, so it redirects the browser to {project_name}\n"
"to be authenticated.  The application passes along a callback URL (a redirect URL) as a query parameter in this browser redirect\n"
"that {project_name} will use when it finishes authentication.\n"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:42
#, no-wrap
msgid ""
"{project_name} authenticates the user and creates a one-time, very short lived, temporary code.  {project_name}\n"
"redirects back to the application using the callback URL provided earlier and additionally adds the temporary code\n"
"as a query parameter in the callback URL.\n"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:45
#, no-wrap
msgid ""
"The application extracts the temporary code and makes a background out of band REST invocation to {project_name}\n"
"to exchange the code for an _identity_, _access_ and _refresh_ token.  Once this temporary code has been used once\n"
"to obtain the tokens, it can never be used again.  This prevents potential replay attacks.\n"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:51
#, no-wrap
msgid ""
"It is important to note that _access_ tokens are usually short lived and often expired after only minutes.  The additional _refresh_\n"
"token that was transmitted by the login protocol allows the application to obtain a new access token after it expires.  This\n"
"refresh protocol is important in the situation of a compromised system.  If access tokens are short lived, the whole system is only\n"
"vulnerable to a stolen token for the lifetime of the access token.  Future refresh token requests will fail if an admin\n"
"has revoked access.  This makes things more secure and more scalable.\n"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:59
#, no-wrap
msgid ""
"Another important aspect of this flow is the concept of a _public_ vs. a _confidential_ client.  _Confidential_ clients are required\n"
"to provide a client secret when they exchange the temporary codes for tokens.  _Public_ clients are not required to provide this client secret.\n"
"_Public_ clients are perfectly fine so long as HTTPS is strictly enforced and you are very strict about what redirect URIs are registered for the\n"
"client.  HTML5/JavaScript clients always have to be _public_ clients because there is no way to transmit the client secret to them in a secure\n"
"manner.  Again, this is ok so long as you use HTTPS and strictly enforce redirect URI registration.  This guide goes more detail\n"
"into this in the <<_clients, Managing Clients>> chapter.\n"
msgstr ""

#. type: Title =====
#: source/server_admin/topics/sso-protocols/oidc.adoc:60
#, no-wrap
msgid "Implicit Flow"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:67
#, no-wrap
msgid ""
"This is a browser-based protocol that is similar to Authorization Code Flow except there are fewer requests and no refresh tokens involved.\n"
"We do not recommend this flow as there remains the possibility of _access_ tokens being leaked in the browser history as tokens are transmitted\n"
"via redirect URIs (see below).  Also, since this flow doesn't provide the client with a refresh token, access tokens would either have to\n"
"be long-lived or users would have to re-authenticate when they expired.  This flow is supported because it is in the OIDC and OAuth 2.0 specification.\n"
"Here's a brief summary of the protocol:\n"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:74
#, no-wrap
msgid ""
"{project_name} authenticates the user and creates an _identity_ and _access_ token.  {project_name}\n"
"redirects back to the application using the callback URL provided earlier and additionally adding the _identity_ and\n"
"_access_ tokens as query parameters in the callback URL.\n"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:75
#, no-wrap
msgid "The application extracts the _identity_ and _access_ tokens from the callback URL.\n"
msgstr ""

#. type: Title =====
#: source/server_admin/topics/sso-protocols/oidc.adoc:76
#, no-wrap
msgid "Resource Owner Password Credentials Grant (Direct Access Grants)"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:82
#, no-wrap
msgid ""
"This is referred to in the Admin Console as _Direct Access Grants_. This is used by REST clients that want to obtain a token on behalf of a user.  It is one HTTP POST request that contains\n"
"the credentials of the user as well as the id of the client and the client's secret (if it is a confidential client).  The user's credentials\n"
"are sent within form parameters.  The HTTP response contains\n"
"_identity_, _access_, and _refresh_ tokens.\n"
msgstr ""

#. type: Title =====
#: source/server_admin/topics/sso-protocols/oidc.adoc:84
#, no-wrap
msgid "Client Credentials Grant"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:89
#, no-wrap
msgid ""
"This is also used by REST clients, but instead of obtaining a token that works on behalf\n"
"of an external user, a token is created based on the metadata and permissions of a service account that is associated with the client.\n"
"More info together with example is in <<_service_accounts,Service Accounts>> chapter.\n"
msgstr ""

#. type: Title ====
#: source/server_admin/topics/sso-protocols/oidc.adoc:90
#, no-wrap
msgid "{project_name} Server OIDC URI Endpoints"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:95
#, no-wrap
msgid ""
"Here's a list of OIDC endpoints that the {project_name} publishes.  These URLs are useful if you are using a non-{project_name} client adapter to\n"
"talk OIDC with the auth server.  These are all relative URLs and the root of the URL being the HTTP(S) protocol, hostname, and usually path prefixed with\n"
"_/auth_:  i.e. $$https://localhost:8080/auth$$\n"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:105
#, no-wrap
msgid ""
"/realms/{realm-name}/protocol/openid-connect/token::\n"
"  This is the URL endpoint for obtaining a temporary code in the Authorization Code Flow or for obtaining tokens via the\n"
"  Implicit Flow, Direct Grants, or Client Grants.\n"
"/realms/{realm-name}/protocol/openid-connect/auth::\n"
"  This is the URL endpoint for the Authorization Code Flow to turn a temporary code into a token.\n"
"/realms/{realm-name}/protocol/openid-connect/logout::\n"
"  This is the URL endpoint for performing logouts.\n"
"/realms/{realm-name}/protocol/openid-connect/userinfo::\n"
"  This is the URL endpoint for the User Info service described in the OIDC specification.\n"
msgstr ""

#. type: Plain text
#: source/server_admin/topics/sso-protocols/oidc.adoc:106
#, no-wrap
msgid "In all of these replace _{realm-name}_ with the name of the realm.\n"
msgstr ""
