# 
# Translators:
# n.watanabe <nwatanabe.ase@gmail.com>, 2023
# Tsukasa Amano <t.amano@pro-japan.co.jp>, 2023
# katakura__pro <h.katakura@pro-japan.co.jp>, 2023
# Kohei Tamura <ktamura.biz.80@gmail.com>, 2023
# jic_m_mito <jic-m-mito@nri.co.jp>, 2023
# Hiroyuki Wada <wadahiro@gmail.com>, 2023
# 
msgid ""
msgstr ""
"Last-Translator: Hiroyuki Wada <wadahiro@gmail.com>, 2023\n"
"Language-Team: Japanese (Japan) (https://app.transifex.com/openstandia/teams/79437/ja_JP/)\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Language: ja_JP\n"
"Plural-Forms: nplurals=1; plural=0;\n"

msgid "{developerguide_name}"
msgstr "{developerguide_name}"

msgid "*{release_header_guide}* icon:angle-down[]"
msgstr "*{release_header_guide}* icon:angle-down[]"

msgid "{gettingstarted_link}[{gettingstarted_name_short}]"
msgstr "{gettingstarted_link}[{gettingstarted_name_short}]"

msgid "{adapterguide_link}[{adapterguide_name_short}]"
msgstr "{adapterguide_link}[{adapterguide_name_short}]"

msgid "{adminguide_link}[{adminguide_name_short}]"
msgstr "{adminguide_link}[{adminguide_name_short}]"

msgid "{authorizationguide_link}[{authorizationguide_name_short}]"
msgstr "{authorizationguide_link}[{authorizationguide_name_short}]"

msgid "{upgradingguide_link}[{upgradingguide_name_short}]"
msgstr "{upgradingguide_link}[{upgradingguide_name_short}]"

msgid "{releasenotes_link}[{releasenotes_name_short}]"
msgstr "{releasenotes_link}[{releasenotes_name_short}]"

msgid ""
"Version *{project_version}* _{release_header_latest_link}[Click here for "
"latest]_"
msgstr "バージョン *{project_version}* _{release_header_latest_link}[最新はこちらをクリック]_"

msgid "Preface"
msgstr "はじめに"

msgid ""
"In some of the example listings, what is meant to be displayed on one line "
"does not fit inside the available page width. These lines have been broken "
"up. A '\\' at the end of a line means that a break has been introduced to "
"fit in the page, with the following lines indented. So:"
msgstr ""
"いくつかの例にあるように、1行で表示されることを意図した行がページ幅に収まらないことがあります。これらの行は改行されています。行末の '\\' "
"は、次の行がインデントされたページに収まるように改行が導入されたことを意味します。したがって、"

msgid ""
"Let's pretend to have an extremely \\\n"
"long line that \\\n"
"does not fit\n"
"This one is short"
msgstr ""
"Let's pretend to have an extremely \\\n"
"long line that \\\n"
"does not fit\n"
"This one is short"

msgid "Is really:"
msgstr "上記は、実際には下記のとおりになります。"

msgid ""
"Let's pretend to have an extremely long line that does not fit\n"
"This one is short"
msgstr ""
"Let's pretend to have an extremely long line that does not fit\n"
"This one is short"

msgid "Admin REST API"
msgstr "管理REST API"

msgid ""
"{project_name} comes with a fully functional Admin REST API with all "
"features provided by the Admin Console."
msgstr "{project_name}には、管理コンソールが提供するすべての機能を完全に備えた管理REST APIが付属しています。"

msgid ""
"To invoke the API you need to obtain an access token with the appropriate "
"permissions. The required permissions are described in the Server "
"Administration Guide."
msgstr ""
"APIを呼び出すには、適切な権限を持つアクセストークンを取得する必要があります。必要な権限についてはServer Administration "
"Guideを参照してください。"

msgid ""
"You can obtain a token by enabling authentication for your application using"
" {project_name}; see the Securing Applications and Services Guide. You can "
"also use direct access grant to obtain an access token."
msgstr ""
"トークンを取得するには、{project_name}を使用してアプリケーションの認証を有効にする必要があります。詳細はSecuring "
"Applications and Services "
"Guideを参照してください。また、ダイレクト・アクセス・グラントを使用して、アクセストークンを取得することもできます。"

msgid "Examples of using CURL"
msgstr "CURLを使用した例"

msgid "Authenticating with a username and password"
msgstr "ユーザー名とパスワードで認証する"

msgid ""
"The following example assumes that you created the user `admin` with the "
"password `password` in the `master` realm as shown in the "
"link:{gettingstarted_link}[{gettingstarted_name}] tutorial."
msgstr ""
"次の例は、 link:{gettingstarted_link}[{gettingstarted_name}] のチュートリアルにあるように、 "
"`master` レルムにパスワード `password` を持つユーザー `admin` を作成したと仮定したものです。"

msgid "Procedure"
msgstr "手順"

msgid ""
"Obtain an access token for the user in the realm `master` with username "
"`admin` and password `password`:"
msgstr ""
"ユーザー名 `admin` とパスワード `password` を使用して、以下のとおり、 `master` "
"レルム内のユーザー用にアクセストークンを取得します。"

msgid ""
"curl \\\n"
"  -d \"client_id=admin-cli\" \\\n"
"  -d \"username=admin\" \\\n"
"  -d \"password=password\" \\\n"
"  -d \"grant_type=password\" \\\n"
"  \"http://localhost:8080{kc_realms_path}/master/protocol/openid-connect/token\""
msgstr ""
"curl \\\n"
"  -d \"client_id=admin-cli\" \\\n"
"  -d \"username=admin\" \\\n"
"  -d \"password=password\" \\\n"
"  -d \"grant_type=password\" \\\n"
"  \"http://localhost:8080{kc_realms_path}/master/protocol/openid-connect/token\""

msgid "By default this token expires in 1 minute"
msgstr "デフォルトではこのトークンは1分で使用期限切れとなります。"

msgid "The result will be a JSON document."
msgstr "結果はJSONドキュメントになります。"

msgid ""
"Invoke the API you need by extracting the value of the `access_token` "
"property."
msgstr "`access_token` プロパティーの値を取り出して、必要なAPIを呼び出します。"

msgid ""
"Invoke the API by including the value in the `Authorization` header of "
"requests to the API."
msgstr "APIへのリクエストの `Authorization` ヘッダーにこの値を含めて、APIを呼び出します。"

msgid ""
"The following example shows how to get the details of the master realm:"
msgstr "次の例は、masterレルムの詳細を取得する方法を示しています。"

msgid ""
"curl \\\n"
"  -H \"Authorization: bearer eyJhbGciOiJSUz...\" \\\n"
"  \"http://localhost:8080{kc_admins_path}/realms/master\""
msgstr ""
"curl \\\n"
"  -H \"Authorization: bearer eyJhbGciOiJSUz...\" \\\n"
"  \"http://localhost:8080{kc_admins_path}/realms/master\""

msgid "Authenticating with a service account"
msgstr "サービス・アカウントで認証する"

msgid ""
"To authenticate against the Admin REST API using a `client_id` and a "
"`client_secret`, perform this procedure."
msgstr ""
"管理REST APIに対して、 `client_id` と `client_secret` を使用して認証を行うには、次の手順を実行します。"

msgid "Make sure the client is configured as follows:"
msgstr "クライアントが以下のように設定されていることを確認します。"

msgid ""
"`client_id` is a **confidential** client that belongs to the realm *master*"
msgstr "`client_id` は、レルム *master* に属する **confidential** クライアントであること"

msgid "`client_id` has `Service Accounts Enabled` option enabled"
msgstr "`client_id` は、 `Service Accounts Enabled` オプションが有効になっていること"

msgid "`client_id` has a custom \"Audience\" mapper"
msgstr "`client_id` は、カスタム \"Audience\" マッパーが設定されていること"

msgid "Included Client Audience: `security-admin-console`"
msgstr "含まれるClient Audience： `security-admin-console`"

msgid ""
"Check that `client_id` has the role 'admin' assigned in the \"Service "
"Account Roles\" tab."
msgstr "`client_id` にService Account Rolesタブで 'admin' のロールが割り当てられていることを確認します。"

msgid ""
"curl \\\n"
"  -d \"client_id=<YOUR_CLIENT_ID>\" \\\n"
"  -d \"client_secret=<YOUR_CLIENT_SECRET>\" \\\n"
"  -d \"grant_type=client_credentials\" \\\n"
"  \"http://localhost:8080{kc_realms_path}/master/protocol/openid-connect/token\""
msgstr ""
"curl \\\n"
"  -d \"client_id=<YOUR_CLIENT_ID>\" \\\n"
"  -d \"client_secret=<YOUR_CLIENT_SECRET>\" \\\n"
"  -d \"grant_type=client_credentials\" \\\n"
"  \"http://localhost:8080{kc_realms_path}/master/protocol/openid-connect/token\""

msgid "Example using Java"
msgstr "Javaを使用したサンプル"

msgid ""
"There's a Java client library for the Admin REST API that makes it easy to "
"use from Java. To use it from your application add a dependency on the "
"`keycloak-admin-client` library."
msgstr ""
"Javaから簡単に使用できるようにする管理REST API用のJavaクライアント・ライブラリーがあります。アプリケーションからそれを使用するには、 "
"`keycloak-admin-client` ライブラリーに依存関係を追加します。"

msgid ""
"The following example shows how to use the Java client library to get the "
"details of the master realm:"
msgstr "次の例は、Javaクライアント・ライブラリーを使用して、masterレルムの詳細を取得する方法を示しています。"

msgid ""
"\n"
"import org.keycloak.admin.client.Keycloak;\n"
"import org.keycloak.representations.idm.RealmRepresentation;\n"
"...\n"
"\n"
"Keycloak keycloak = Keycloak.getInstance(\n"
"    \"http://localhost:8080{kc_base_path}\",\n"
"    \"master\",\n"
"    \"admin\",\n"
"    \"password\",\n"
"    \"admin-cli\");\n"
"RealmRepresentation realm = keycloak.realm(\"master\").toRepresentation();"
msgstr ""
"\n"
"import org.keycloak.admin.client.Keycloak;\n"
"import org.keycloak.representations.idm.RealmRepresentation;\n"
"...\n"
"\n"
"Keycloak keycloak = Keycloak.getInstance(\n"
"    \"http://localhost:8080{kc_base_path}\",\n"
"    \"master\",\n"
"    \"admin\",\n"
"    \"password\",\n"
"    \"admin-cli\");\n"
"RealmRepresentation realm = keycloak.realm(\"master\").toRepresentation();"

msgid ""
"Complete Javadoc for the admin client is available at "
"{apidocs_link}[{apidocs_name}]."
msgstr "管理クライアントの完全なJavaのドキュメントは、 {apidocs_link}[{apidocs_name}] を参照してください。"

msgid "Additional resources"
msgstr "追加のリソース"

msgid "{adminguide_link}[{adminguide_name}]"
msgstr "{adminguide_link}[{adminguide_name}]"

msgid "{adapterguide_link}[{adapterguide_name}]"
msgstr "{adapterguide_link}[{adapterguide_name}]"

msgid "{apidocs_link}[{apidocs_name}]"
msgstr "{apidocs_link}[{apidocs_name}]"

msgid "Themes"
msgstr "テーマ"

msgid ""
"{project_name} provides theme support for web pages and emails. This allows "
"customizing the look and feel of end-user facing pages so they can be "
"integrated with your applications."
msgstr ""
"{project_name}では、webページと電子メール用のテーマがサポートされます。これによって、エンドユーザーが見るページのルック・アンド・フィールをカスタマイズすることができ、そのページをアプリケーションに統合することができます。"

msgid "Login page with sunrise example theme"
msgstr "日の出のサンプルのテーマとログインページ"

msgid "Theme types"
msgstr "テーマの種類"

msgid ""
"A theme can provide one or more types to customize different aspects of "
"{project_name}. The types available are:"
msgstr ""
"テーマには1つ以上の種類が用意されており、{project_name}のさまざまな部分をカスタマイズすることができます。用意されている種類は以下のとおりです。"

msgid "Account - Account management"
msgstr "Account - アカウント管理"

msgid "Admin - Admin Console"
msgstr "Admin - 管理コンソール"

msgid "Email - Emails"
msgstr "Email - 電子メール"

msgid "Login - Login forms"
msgstr "Login - ログイン画面"

msgid "Welcome - Welcome page"
msgstr "Welcome - ウェルカムページ"

msgid "Configuring a theme"
msgstr "テーマの設定"

msgid ""
"All theme types, except welcome, are configured through the Admin Console."
msgstr "ウェルカムを除くすべてのテーマタイプは、管理コンソールから設定します。"

msgid "Log into the Admin Console."
msgstr "管理コンソールにログインします。"

msgid "Select your realm from the drop-down box in the top left corner."
msgstr "左上のドロップダウン・ボックスからレルムを選択します。"

msgid "Click *Realm Settings* from the menu."
msgstr "メニューの *Realm Settings* をクリックします。"

msgid "Click the *Themes* tab."
msgstr "*Themes* タブをクリックします。"

msgid ""
"To set the theme for the `master` Admin Console you need to set the Admin "
"Console theme for the `master` realm."
msgstr ""
"`master` の管理コンソール用にテーマをセットするには、 `master` レルム用の管理コンソール・テーマを設定する必要があります。"

msgid "To see the changes to the Admin Console refresh the page."
msgstr "管理コンソールへの変更を確認するには、ページをリフレッシュしてください。"

msgid ""
"Change the welcome theme by using the `spi-theme-welcome-theme` option."
msgstr "`spi-theme-welcome-theme` オプションを使用して、ウェルカムテーマを変更することができます。"

msgid "For example:"
msgstr "例："

msgid "bin/kc.[sh|bat] start --spi-theme-welcome-theme=custom-theme"
msgstr "bin/kc.[sh|bat] start --spi-theme-welcome-theme=custom-theme"

msgid "Default themes"
msgstr "デフォルトのテーマ"

msgid ""
"{project_name} comes bundled with default themes in the server's root "
"`themes` directory. To simplify upgrading you should not edit the bundled "
"themes directly. Instead create your own theme that extends one of the "
"bundled themes."
msgstr ""
"{project_name}には、サーバーのルート `themes` "
"ディレクトリー内のデフォルト・テーマがバンドルされています。アップグレードを簡単にするために、バンドルされたテーマを直接編集しないでください。代わりに、バンドルされたテーマの1つを拡張する独自のテーマを作成してください。"

msgid "Creating a theme"
msgstr "テーマの作成"

msgid "A theme consists of:"
msgstr "テーマは、以下の項目で構成されています。"

msgid "HTML templates (https://freemarker.apache.org/[Freemarker Templates])"
msgstr "HTML templates (https://freemarker.apache.org/[Freemarker Templates])"

msgid "Images"
msgstr "画像"

msgid "Message bundles"
msgstr "メッセージ・バンドル"

msgid "Stylesheets"
msgstr "スタイルシート"

msgid "Scripts"
msgstr "スクリプト"

msgid "Theme properties"
msgstr "テーマ用のpropertiesファイル"

msgid ""
"Unless you plan to replace every single page you should extend another "
"theme. Most likely you will want to extend the {project_name} theme, but you"
" could also consider extending the base theme if you are significantly "
"changing the look and feel of the pages. The base theme primarily consists "
"of HTML templates and message bundles, while the {project_name} theme "
"primarily contains images and stylesheets."
msgstr ""
"ページをすべて置き換えるわけではない場合は、いずれかのテーマを1つ拡張する方法をお勧めします。通常の場合{project_name}のテーマを拡張したいでしょうが、ページのルック・アンド・フィールを大幅に変更する場合は基本テーマを拡張するということも検討対象となります。基本テーマは主にHTMLのテンプレートとメッセージ・バンドルで構成され、"
" {project_name}テーマには主にイメージとスタイルシートが含まれます。"

msgid ""
"When extending a theme you can override individual resources (templates, "
"stylesheets, etc.). If you decide to override HTML templates bear in mind "
"that you may need to update your custom template when upgrading to a new "
"release."
msgstr ""
"テーマを拡張する場合、個々のリソース（テンプレート、スタイルシートなど）を上書きできます。HTMLのテンプレートを上書きする場合、新規リリースへのアップグレードの際に、カズタマイズしたテンプレートをアップグレードする必要があることに留意してください。"

msgid ""
"While creating a theme it's a good idea to disable caching as this makes it "
"possible to edit theme resources directly from the `themes` directory "
"without restarting {project_name}."
msgstr ""
"テーマを作成している間、キャッシュを無効にするのは良いアイデアです。これにより、{project_name}を再起動せずに、 `themes` "
"ディレクトリーから直接テーマリソースを編集することが可能になります。"

msgid "Run Keycloak with the following options:"
msgstr "以下のオプションでKeycloakを実行します。"

msgid ""
"bin/kc.[sh|bat] start --spi-theme-static-max-age=-1 --spi-theme-cache-"
"themes=false --spi-theme-cache-templates=false"
msgstr ""
"bin/kc.[sh|bat] start --spi-theme-static-max-age=-1 --spi-theme-cache-"
"themes=false --spi-theme-cache-templates=false"

msgid "Create a directory in the `themes` directory."
msgstr "`themes` ディレクトリー内で新しいディレクトリーを作成します。"

msgid ""
"The name of the directory becomes the name of the theme. For example to "
"create a theme called `mytheme` create the directory `themes/mytheme`."
msgstr ""
"ディレクトリー名がテーマの名前になります。たとえば、 `mytheme` という名前のテーマを作成するには、 `themes/mytheme` "
"ディレクトリーを作成します。"

msgid ""
"Inside the theme directory, create a directory for each of the types your "
"theme is going to provide."
msgstr "テーマ・ディレクトリーの中に、テーマが提供する各タイプのディレクトリーを作成します。"

msgid ""
"For example, to add the login type to the `mytheme` theme, create the "
"directory `themes/mytheme/login`."
msgstr ""
"たとえば、 `mytheme` テーマにログインタイプを追加するには、 `themes/mytheme/login` というディレクトリーを作成します。"

msgid ""
"For each type create a file `theme.properties` which allows setting some "
"configuration for the theme."
msgstr "各タイプごとに、テーマに関する設定を行うためのファイル `theme.properties` を作成します。"

msgid ""
"For example, to configure the theme `themes/mytheme/login` to extend the "
"base theme and import some common resources, create the file "
"`themes/mytheme/login/theme.properties` with following contents:"
msgstr ""
"たとえば、基本テーマを拡張して共通のリソースをインポートする `themes/mytheme/login` テーマを設定するには、以下の内容で "
"`themes/mytheme/login/theme.properties` ファイルを作成します。"

msgid ""
"parent=base\n"
"import=common/keycloak"
msgstr ""
"parent=base\n"
"import=common/keycloak"

msgid "You have now created a theme with support for the login type."
msgstr "これで、ログインタイプに対応したテーマが作成できました。"

msgid "Log into the Admin Console to check out your new theme"
msgstr "管理コンソールにログインし、新しいテーマを確認します。"

msgid "Select your realm"
msgstr "レルムを選択してださい。"

msgid "Click on the *Themes* tab."
msgstr "*Themes* タブをクリックします。"

msgid "For *Login Theme* select *mytheme* and click *Save*."
msgstr "*Login Theme* で *mytheme* を選択し、*Save* をクリックします。"

msgid "Open the login page for the realm."
msgstr "レルムのログインページを開きます。"

msgid ""
"You can do this either by logging in through your application or by opening "
"the Account Management console (`/realms/{realm name}/account`)."
msgstr ""
"これは、アプリケーションを経由してログインしても、アカウント管理コンソール（ `/realms/{realm name}/account` "
"）を開いても、実行できます。"

msgid ""
"To see the effect of changing the parent theme, set `parent=keycloak` in "
"`theme.properties` and refresh the login page."
msgstr ""
"現在のテーマを変更した際にどのような影響があるか確認するには、 `theme.properties` 内で `parent=keycloak` "
"を設定してログイン・ページをリフレッシュします。"

msgid ""
"Be sure to re-enable caching in production as it will significantly impact "
"performance."
msgstr "パフォーマンスにかなり影響を与える可能性があるので、プロダクション環境でキャッシュを再度有効にするようにしてください。"

msgid ""
"Theme properties are set in the file `<THEME TYPE>/theme.properties` in the "
"theme directory."
msgstr ""
"テーマのプロパティーは、テーマ・ディレクトリー内にある `<THEME TYPE>/theme.properties` ファイルで設定されています。"

msgid "parent - Parent theme to extend"
msgstr "parent - 拡張が可能な親テーマ"

msgid "import - Import resources from another theme"
msgstr "import - 他テーマからリソースをインポートすること"

msgid "styles - Space-separated list of styles to include"
msgstr "styles - スペースで区切られた、インクルードするスタイルのリスト"

msgid "locales - Comma-separated list of supported locales"
msgstr "locales - カンマで区切られた、サポートされるロケールのリスト"

msgid ""
"There are a list of properties that can be used to change the css class used"
" for certain element types. For a list of these properties look at the "
"theme.properties file in the corresponding type of the keycloak theme "
"(`themes/keycloak/<THEME TYPE>/theme.properties`)."
msgstr ""
"特定の要素タイプのために使用される、cssクラスの変更用として使用可能なプロパティーのリストがあります。これらのプロパティーのリストについては、keycloakテーマ（"
" `themes/keycloak/<THEME TYPE>/theme.properties` "
")に対応するタイプのtheme.propertiesファイルを参照してください。"

msgid ""
"You can also add your own custom properties and use them from custom "
"templates."
msgstr "カスタム・プロパティーを追加し、それらをカスタム・テンプレートから使用することができます。"

msgid ""
"When doing so, you can substitute system properties or environment variables"
" by using these formats:"
msgstr "その際、次の形式を使用してシステム・プロパティーまたは環境変数を置き換えることができます。"

msgid "`${some.system.property}` - for system properties"
msgstr "`${some.system.property}` - システム・プロパティー用"

msgid "`${env.ENV_VAR}` - for environment variables."
msgstr "`${env.ENV_VAR}` - 環境変数用"

msgid ""
"A default value can also be provided in case the system property or the "
"environment variable is not found with `${foo:defaultValue}`."
msgstr ""
"システム・プロパティーまたは環境変数が `${foo:defaultValue}` で見つからない場合、デフォルト値を提供することもできます。"

msgid ""
"If no default value is provided and there's no corresponding system property"
" or environment variable, then nothing is replaced and you end up with the "
"format in your template."
msgstr ""
"デフォルト値が提供されておらず、対応するシステム・プロパティーまたは環境変数がない場合は、何も置き換えられず、テンプレートの形式になります。"

msgid "Here's an example of what is possible:"
msgstr "可能な例を次に示します。"

msgid ""
"javaVersion=${java.version}\n"
"\n"
"unixHome=${env.HOME:Unix home not found}\n"
"windowsHome=${env.HOMEPATH:Windows home not found}"
msgstr ""
"javaVersion=${java.version}\n"
"\n"
"unixHome=${env.HOME:Unix home not found}\n"
"windowsHome=${env.HOMEPATH:Windows home not found}"

msgid "Add a stylesheet to a theme"
msgstr "テーマへのスタイルシートの追加"

msgid "You can add one or more stylesheets to a theme."
msgstr "テーマには、1つまたは複数のスタイルシートを追加することができます。"

msgid ""
"Create a file in the `<THEME TYPE>/resources/css` directory of your theme."
msgstr "テーマの `<THEME TYPE>/resources/css` ディレクトリーにファイルを作成します。"

msgid "Add this file to the `styles` property in `theme.properties`."
msgstr "このファイルを `theme.properties` の `styles` プロパティーに追加してください。"

msgid ""
"For example, to add `styles.css` to the `mytheme`, create "
"`themes/mytheme/login/resources/css/styles.css` with the following content:"
msgstr ""
"たとえば、 `mytheme` へ `styles.css` を追加するには、以下の内容で "
"`themes/mytheme/login/resources/css/styles.css` を作成します。"

msgid ""
".login-pf body {\n"
"    background: DimGrey none;\n"
"}"
msgstr ""
".login-pf body {\n"
"    background: DimGrey none;\n"
"}"

msgid "Edit `themes/mytheme/login/theme.properties` and add:"
msgstr "`themes/mytheme/login/theme.properties` を編集し、以下を追加します。"

msgid "styles=css/styles.css"
msgstr "styles=css/styles.css"

msgid "To see the changes, open the login page for your realm."
msgstr "変更を確認するには、レルムのログインページを開いてください。"

msgid ""
"You will notice that the only styles being applied are those from your "
"custom stylesheet."
msgstr "カスタム・スタイルシートのスタイルだけが適用されていることがわかると思います。"

msgid ""
"To include the styles from the parent theme, load the styles from that "
"theme. Edit `themes/mytheme/login/theme.properties` and change `styles` to:"
msgstr ""
"親テーマのスタイルを取り込むには、そのテーマからスタイルを読み込みます。 `themes/mytheme/login/theme.properties`"
" を編集して、 `styles` を次のように変更します。"

msgid ""
"styles=web_modules/@fontawesome/fontawesome-free/css/icons/all.css "
"web_modules/@patternfly/react-core/dist/styles/base.css "
"web_modules/@patternfly/react-core/dist/styles/app.css "
"node_modules/patternfly/dist/css/patternfly.min.css "
"node_modules/patternfly/dist/css/patternfly-additions.min.css css/login.css "
"css/styles.css"
msgstr ""
"styles=web_modules/@fontawesome/fontawesome-free/css/icons/all.css "
"web_modules/@patternfly/react-core/dist/styles/base.css "
"web_modules/@patternfly/react-core/dist/styles/app.css "
"node_modules/patternfly/dist/css/patternfly.min.css "
"node_modules/patternfly/dist/css/patternfly-additions.min.css css/login.css "
"css/styles.css"

msgid ""
"To override styles from the parent stylesheets, ensure that your stylesheet "
"is listed last."
msgstr "親のスタイルシートのスタイルを上書きするには、自分のスタイルシートがリストの最後にあることを確認します。"

msgid "Adding a script to a theme"
msgstr "テーマにスクリプトを追加する"

msgid "You can add one or more scripts to a theme."
msgstr "テーマには、1つまたは複数のスクリプトを追加することができます。"

msgid ""
"Create a file in the `<THEME TYPE>/resources/js` directory of your theme."
msgstr "テーマの `<THEME TYPE>/resources/js` ディレクトリーにファイルを作成します。"

msgid "Add the file to the `scripts` property in `theme.properties`."
msgstr "このファイルを `theme.properties` の `scripts` プロパティーに追加してください。"

msgid ""
"For example, to add `script.js` to the `mytheme`, create "
"`themes/mytheme/login/resources/js/script.js` with the following content:"
msgstr ""
"たとえば、 `mytheme` へ `script.js` を追加するには、以下の内容で "
"`themes/mytheme/login/resources/js/script.js` を作成します。"

msgid "alert('Hello');"
msgstr "alert('Hello');"

msgid "Then edit `themes/mytheme/login/theme.properties` and add:"
msgstr "次に、 `themes/mytheme/login/theme.properties` を編集し、以下を追加します。"

msgid "scripts=js/script.js"
msgstr "scripts=js/script.js"

msgid "Adding an image to a theme"
msgstr "テーマにイメージを追加する"

msgid ""
"To make images available to the theme add them to the `<THEME "
"TYPE>/resources/img` directory of your theme. These can be used from within "
"stylesheets or directly in HTML templates."
msgstr ""
"テーマで画像を使用できるようにするには、テーマの `<THEME TYPE>/resources/img` "
"ディレクトリーに画像を追加します。これらの画像は、スタイルシート内または直接HTMLテンプレート内で使用することができます。"

msgid ""
"For example to add an image to the `mytheme` copy an image to "
"`themes/mytheme/login/resources/img/image.jpg`."
msgstr ""
"たとえば、 `mytheme` へ画像を追加するには、 `themes/mytheme/login/resources/img/image.jpg` "
"へ画像をコピーします。"

msgid "You can then use this image from within a custom stylesheet with:"
msgstr "これで、以下のようにカスタム・スタイルシート内からこのイメージを使うことができます。"

msgid ""
"body {\n"
"    background-image: url('../img/image.jpg');\n"
"    background-size: cover;\n"
"}"
msgstr ""
"body {\n"
"    background-image: url('../img/image.jpg');\n"
"    background-size: cover;\n"
"}"

msgid ""
"Or to use directly in HTML templates add the following to a custom HTML "
"template:"
msgstr "または、HTMLテンプレート内で直接使う場合は、以下をカスタムHTMLテンプレートへ追加します。"

msgid "<img src=\"${url.resourcesPath}/img/image.jpg\">"
msgstr "<img src=\"${url.resourcesPath}/img/image.jpg\">"

msgid "Messages"
msgstr "メッセージ"

msgid ""
"Text in the templates is loaded from message bundles. A theme that extends "
"another theme will inherit all messages from the parent's message bundle and"
" you can override individual messages by adding `<THEME "
"TYPE>/messages/messages_en.properties` to your theme."
msgstr ""
"テンプレート内のテキストは、メッセージ・バンドルからロードされます。他のテーマを拡張するテーマは、親メッセージ・バンドルからすべてのメッセージを引き継ぎ、テーマに"
" `<THEME TYPE>/messages/messages_en.properties` "
"を追加することで個々のメッセージを上書きすることができます。"

msgid ""
"For example to replace `Username` on the login form with `Your Username` for"
" the `mytheme` create the file "
"`themes/mytheme/login/messages/messages_en.properties` with the following "
"content:"
msgstr ""
"たとえば、 `mytheme` でログイン画面上の `Username` を `Your Username` に置き換えるには、以下の内容で "
"`themes/mytheme/login/messages/messages_en.properties` ファイルを作成します。"

msgid "usernameOrEmail=Your Username"
msgstr "usernameOrEmail=Your Username"

msgid ""
"Within a message values like `{0}` and `{1}` are replaced with arguments "
"when the message is used. For example {0} in `Log in to {0}` is replaced "
"with the name of the realm."
msgstr ""
"メッセージ内では、メッセージが使用される際、 `{0}` および `{1}` のような値が引数に置き換えられます。たとえば、 `Log in to "
"{0}` 内の {0} がレルム名に置き換えられます。"

msgid ""
"Texts of these message bundles can be overwritten by realm-specific values. "
"The realm-specific values are manageable via UI and API."
msgstr "これらのメッセージ・バンドルのテキストは、レルム固有の値で上書きできます。レルム固有の値は、UIおよびAPIを介して管理できます。"

msgid "Adding a language to a realm"
msgstr "テーマに言語を追加する"

msgid "Prerequisites"
msgstr "前提条件"

msgid ""
"To enable internationalization for a realm, see the "
"{adminguide_link}[{adminguide_name}]."
msgstr "レルムの国際化を有効にするには、 {adminguide_link}[{adminguide_name}] を参照してください。"

msgid ""
"Create the file `<THEME TYPE>/messages/messages_<LOCALE>.properties` in the "
"directory of your theme."
msgstr ""
"テーマのディレクトリーに、 `<THEME TYPE>/messages/messages_<LOCALE>.properties` "
"というファイルを作成します。"

msgid ""
"Add this file to the `locales` property in `<THEME TYPE>/theme.properties`. "
"For a language to be available to users the realms `login`, `account` and "
"`email`, the theme has to support the language, so you need to add your "
"language for those theme types."
msgstr ""
"このファイルを `<THEME TYPE>/theme.properties` 内の `locales` "
"プロパティーへ追加します。ユーザーが言語を使用できるようにするには、レルムの `login` 、 `account` および `email` "
"のテーマによってその言語がサポートされなければなりません。したがって、それらのテーマタイプとしてその言語を追加する必要があります。"

msgid ""
"For example, to add Norwegian translations to the `mytheme` theme create the"
" file `themes/mytheme/login/messages/messages_no.properties` with the "
"following content:"
msgstr ""
"たとえば、 `mytheme` テーマへノルウェー翻訳を追加するには、以下の内容で "
"`themes/mytheme/login/messages/messages_no.properties` ファイルを作成します。"

msgid ""
"usernameOrEmail=Brukernavn\n"
"password=Passord"
msgstr ""
"usernameOrEmail=Brukernavn\n"
"password=Passord"

msgid "If you omit a translation for messages, they will use English."
msgstr "メッセージの翻訳を省略した場合は、英語を使用します。"

msgid "locales=en,no"
msgstr "locales=en,no"

msgid ""
"Add the same for the `account` and `email` theme types. To do this create "
"`themes/mytheme/account/messages/messages_no.properties` and "
"`themes/mytheme/email/messages/messages_no.properties`. Leaving these files "
"empty will result in the English messages being used."
msgstr ""
"同じものを `account` と `email` のテーマタイプにも追加します。そのためには、 "
"`themes/mytheme/account/messages/messages_no.properties` と "
"`themes/mytheme/email/messages/messages_no.properties` "
"を作成してください。これらのファイルを空にすると、英語のメッセージが使用されるようになります。"

msgid ""
"Copy `themes/mytheme/login/theme.properties` to "
"`themes/mytheme/account/theme.properties` and "
"`themes/mytheme/email/theme.properties`."
msgstr ""
"`themes/mytheme/login/theme.properties` を "
"`themes/mytheme/account/theme.properties` と "
"`themes/mytheme/email/theme.properties` にコピーしてください。"

msgid ""
"Add a translation for the language selector. This is done by adding a "
"message to the English translation. To do this add the following to "
"`themes/mytheme/account/messages/messages_en.properties` and "
"`themes/mytheme/login/messages/messages_en.properties`:"
msgstr ""
"言語セレクターに翻訳を追加します。これは、英語の翻訳にメッセージを追加することで行われます。これを行うには、 "
"`themes/mytheme/account/messages/messages_en.properties` と "
"`themes/mytheme/login/messages/messages_en.properties` に以下を追加してください。"

msgid "locale_no=Norsk"
msgstr "locale_no=Norsk"

msgid ""
"By default message properties files should be encoded using ISO-8859-1. It's"
" also possible to specify the encoding using a special header. For example "
"to use UTF-8 encoding:"
msgstr ""
"デフォルトでは、メッセージ・プロパティー・ファイルはISO-8859-1を使用してエンコードされる必要があります。また、これは特別なヘッダーを使用してエンコーディングを指定する方法でも可能です。たとえば、UTF-8エンコーディングを使用するには、以下のとおりとなります。"

msgid ""
"# encoding: UTF-8\n"
"usernameOrEmail=...."
msgstr ""
"# encoding: UTF-8\n"
"usernameOrEmail=...."

msgid ""
"See <<_locale_selector,Locale Selector>> for details on how the current "
"locale is selected."
msgstr "現在のロケールの選択方法の詳細については、<<_locale_selector,ロケール・セレクター>>を参照してください。"

msgid "Adding custom Identity Providers icons"
msgstr "カスタム・アイデンティティー・プロバイダーのアイコンの追加"

msgid ""
"{project_name} supports adding icons for custom Identity providers, which "
"are displayed on the login screen."
msgstr "{project_name}は、ログイン画面に表示されるカスタム・アイデンティティー・プロバイダーのアイコンの追加に対応しています。"

msgid ""
"Define icon classes in your login `theme.properties` file (for example, "
"`themes/mytheme/login/theme.properties`) with key pattern "
"`kcLogoIdP-<alias>`."
msgstr ""
"ログイン用の `theme.properties` ファイル（例： `themes/mytheme/login/theme.properties` "
"）に、キーパターン `kcLogoIdP-<alias>` でアイコンクラスを定義してください。"

msgid ""
"For an Identity Provider with an alias `myProvider`, you may add a line to "
"`theme.properties` file of your custom theme. For example:"
msgstr ""
"`myProvider` というエイリアスを持つアイデンティティー・プロバイダーの場合、カスタムテーマの `theme.properties` "
"ファイルに一行を追加します。たとえば、以下のようになります。"

msgid "kcLogoIdP-myProvider = fa fa-lock"
msgstr "kcLogoIdP-myProvider = fa fa-lock"

msgid ""
"All icons are available on the official website of PatternFly4. Icons for "
"social providers are already defined in base login theme properties "
"(`themes/keycloak/login/theme.properties`), where you can inspire yourself."
msgstr ""
"すべてのアイコンは、PatternFly4の公式ウェブサイトで入手できます。ソーシャル・プロバイダーのアイコンは、標準提供のログイン・テーマ・プロパティー（"
" `themes/keycloak/login/theme.properties` ）で既に定義されており、変更することができます。"

msgid "Creating a custom HTML template"
msgstr "カスタムHTMLテンプレートの作成"

msgid ""
"{project_name} uses https://freemarker.apache.org/[Apache Freemarker] "
"templates to generate HTML. You can override individual templates in your "
"own theme by creating `<THEME TYPE>/<TEMPLATE>.ftl`. For a list of templates"
" used see `themes/base/<THEME TYPE>`."
msgstr ""
"{project_name}では、HTMLを生成するために https://freemarker.apache.org/[Apache "
"Freemarker] テンプレートが使用されます。テーマ内で `<THEME TYPE>/<TEMPLATE>.ftl` "
"を作成すると、個々のテンプレートを上書きすることができます。使用したテンプレートのリストについては `themes/base/<THEME TYPE>`"
" を参照してください。"

msgid "Copy the template from the base theme to your own theme."
msgstr "ベースとなるテーマからテンプレートを、自分のテーマにコピーします。"

msgid "Apply the modifications you need."
msgstr "必要な変更を適用します。"

msgid ""
"For example, to create a custom login form for the `mytheme` theme, copy "
"`themes/base/login/login.ftl` to `themes/mytheme/login` and open it in an "
"editor."
msgstr ""
"たとえば、 `mytheme` テーマのカスタム・ログイン画面を作成するには、 `themes/base/login/login.ftl` を "
"`themes/mytheme/login` にコピーしてエディターで開いてください。"

msgid ""
"After the first line (<#import ...>), add `<h1>HELLO WORLD!</h1>` as shown "
"here:"
msgstr "最初の行（<#import ...>）の後に、次のように `HELLO<h1>WORLD!</h1>` を追加します。"

msgid ""
"<#import \"template.ftl\" as layout>\n"
"<h1>HELLO WORLD!</h1>\n"
"..."
msgstr ""
"<#import \"template.ftl\" as layout>\n"
"<h1>HELLO WORLD!</h1>\n"
"..."

msgid ""
"Back up the modified template. When upgrading to a new version of "
"{project_name} you may need to update your custom templates to apply changes"
" to the original template if applicable."
msgstr ""
"変更したテンプレートをバックアップします。{project_name}の新しいバージョンにアップグレードする場合、該当する場合は、元のテンプレートの変更をカスタム・テンプレートに適用して更新する必要があります。"

msgid ""
"See the https://freemarker.apache.org/docs/index.html[FreeMarker Manual] for"
" details on how to edit templates."
msgstr ""
"テンプレートの編集方法の詳細ついては、 "
"https://freemarker.apache.org/docs/index.html[FreeMarkerのマニュアル] を参照してください。"

msgid "Emails"
msgstr "電子メール"

msgid ""
"To edit the subject and contents for emails, for example password recovery "
"email, add a message bundle to the `email` type of your theme. There are "
"three messages for each email. One for the subject, one for the plain text "
"body and one for the html body."
msgstr ""
"電子メールの題名と内容（たとえばパスワード・リカバリー電子メールなど）を編集するには、テーマの `email` "
"タイプへメッセージ・バンドルを追加します。各電子メールには3つのメッセージがあります。題名、プレーン・テキストの本文、およびhtmlのbodyです。"

msgid ""
"To see all emails available take a look at "
"`themes/base/email/messages/messages_en.properties`."
msgstr ""
"使用できる電子メールをすべて確認するには、 `themes/base/email/messages/messages_en.properties` "
"を参照してください。"

msgid ""
"For example to change the password recovery email for the `mytheme` theme "
"create `themes/mytheme/email/messages/messages_en.properties` with the "
"following content:"
msgstr ""
"たとえば、 `mytheme` テーマ用にパスワード・リカバリー電子メールを変更するには、以下の内容で "
"`themes/mytheme/email/messages/messages_en.properties` を作成します。"

msgid ""
"passwordResetSubject=My password recovery\n"
"passwordResetBody=Reset password link: {0}\n"
"passwordResetBodyHtml=<a href=\"{0}\">Reset password</a>"
msgstr ""
"passwordResetSubject=My password recovery\n"
"passwordResetBody=Reset password link: {0}\n"
"passwordResetBodyHtml=<a href=\"{0}\">Reset password</a>"

msgid "Deploying themes"
msgstr "テーマのデプロイ"

msgid ""
"Themes can be deployed to {project_name} by copying the theme directory to "
"`themes` or it can be deployed as an archive. During development you can "
"copy the theme to the `themes` directory, but in production you may want to "
"consider using an `archive`. An `archive` makes it simpler to have a "
"versioned copy of the theme, especially when you have multiple instances of "
"{project_name} for example with clustering."
msgstr ""
"テーマは、テーマ・ディレクトリーを `themes` "
"へコピーすることによって、{project_name}へデプロイすることができ、アーカイブとしてデプロイすることも可能です。開発中は、テーマを "
"`themes` ディレクトリーへコピーできますが、プロダクション環境では `archive` の使用を検討した方がいいかもしれません。 "
"`archive` "
"を使用すると、テーマのコピー版の作成が簡単になります。たとえばクラスター構成の{project_name}など、インスタンスが複数ある場合は特に便利です。"

msgid ""
"To deploy a theme as an archive, create a JAR archive with the theme "
"resources."
msgstr "テーマをアーカイブとして配備するには、テーマのリソースを含むJARアーカイブを作成します。"

msgid ""
"Add a file `META-INF/keycloak-themes.json` to the archive that lists the "
"available themes in the archive as well as what types each theme provides."
msgstr ""
"アーカイブに `META-INF/keycloak-themes.json` "
"というファイルを追加し、アーカイブ内で利用可能なテーマと、それぞれのテーマがどのようなタイプを提供するかをリストアップします。"

msgid ""
"For example for the `mytheme` theme create `mytheme.jar` with the contents:"
msgstr "たとえば、 `mytheme` テーマの場合、以下の内容で `mytheme.jar` を作成します。"

msgid "META-INF/keycloak-themes.json"
msgstr "META-INF/keycloak-themes.json"

msgid "theme/mytheme/login/theme.properties"
msgstr "theme/mytheme/login/theme.properties"

msgid "theme/mytheme/login/login.ftl"
msgstr "theme/mytheme/login/login.ftl"

msgid "theme/mytheme/login/resources/css/styles.css"
msgstr "theme/mytheme/login/resources/css/styles.css"

msgid "theme/mytheme/login/resources/img/image.png"
msgstr "theme/mytheme/login/resources/img/image.png"

msgid "theme/mytheme/login/messages/messages_en.properties"
msgstr "theme/mytheme/login/messages/messages_en.properties"

msgid "theme/mytheme/email/messages/messages_en.properties"
msgstr "theme/mytheme/email/messages/messages_en.properties"

msgid "The contents of `META-INF/keycloak-themes.json` in this case would be:"
msgstr "このケースの `META-INF/keycloak-themes.json` の内容は、以下のとおりです。"

msgid ""
"{\n"
"    \"themes\": [{\n"
"        \"name\" : \"mytheme\",\n"
"        \"types\": [ \"login\", \"email\" ]\n"
"    }]\n"
"}"
msgstr ""
"{\n"
"    \"themes\": [{\n"
"        \"name\" : \"mytheme\",\n"
"        \"types\": [ \"login\", \"email\" ]\n"
"    }]\n"
"}"

msgid ""
"A single archive can contain multiple themes and each theme can support one "
"or more types."
msgstr "1つのアーカイブには複数のテーマを含めることができ、各テーマは1つ以上のタイプをサポートすることができます。"

msgid ""
"To deploy the archive to {project_name}, add it to the `providers/` "
"directory of {project_name} and restart the server if it is already running."
msgstr ""
"{project_name}にアーカイブをデプロイするには、{project_name}の `providers/` "
"ディレクトリーにアーカイブを追加し、サーバーが既に起動している場合は再起動します。"

msgid "Theme selector"
msgstr "テーマセレクター"

msgid ""
"By default the theme configured for the realm is used, with the exception of"
" clients being able to override the login theme. This behavior can be "
"changed through the Theme Selector SPI."
msgstr ""
"デフォルトでは、クライアントがログインテーマを上書きできる点を除き、レルムに設定されたテーマが使用されます。この動作は、テーマセレクターSPIによって変更できます。"

msgid ""
"This could be used to select different themes for desktop and mobile devices"
" by looking at the user agent header, for example."
msgstr ""
"これは、ユーザー・エージェント・ヘッダーを見ることにより、たとえばデスクトップおよびモバイルデバイス用の異なるテーマを選択するために使用することができます。"

msgid ""
"To create a custom theme selector you need to implement "
"`ThemeSelectorProviderFactory` and `ThemeSelectorProvider`."
msgstr ""
"カスタム・テーマ・セレクターを作成するには、 `ThemeSelectorProviderFactory` と "
"`ThemeSelectorProvider` を実装する必要があります。"

msgid "Theme resources"
msgstr "テーマリソース"

msgid ""
"When implementing custom providers in {project_name} there may often be a "
"need to add additional templates, resources and messages bundles."
msgstr ""
"{project_name}にカスタム・プロバイダーを実装する場合、テンプレート、リソースおよびメッセージバンドルを追加する必要がよくあります。"

msgid ""
"An example use-case would be a <<_auth_spi,custom authenticator>> that "
"requires additional templates and resources."
msgstr "ユースケースの例は、追加のテンプレートとリソースを必要とする<<_auth_spi, カスタム・オーセンティケーター>>です。"

msgid ""
"The easiest way to load additional theme resources is to create a JAR with "
"templates in `theme-resources/templates` resources in `theme-"
"resources/resources` and messages bundles in `theme-resources/messages`."
msgstr ""
"追加のテーマリソースをロードする最も簡単な方法は、テンプレートを `theme-resources/templates` に、リソースを `theme-"
"resources/resources` に、メッセージ・バンドルを `theme-resources/messages` "
"に入れたJARを作成することです。"

msgid ""
"If you want a more flexible way to load templates and resources that can be "
"achieved through the ThemeResourceSPI. By implementing "
"`ThemeResourceProviderFactory` and `ThemeResourceProvider` you can decide "
"exactly how to load templates and resources."
msgstr ""
"テンプレートとリソースをより柔軟にロードする方法が必要な場合、ThemeResourceSPIを使用して実現できます。 "
"`ThemeResourceProviderFactory` と `ThemeResourceProvider` "
"を実装することで、テンプレートとリソースを読み込む方法を直に決めることができます。"

msgid "Locale selector"
msgstr "ロケール・セレクター"

msgid ""
"By default, the locale is selected using the `DefaultLocaleSelectorProvider`"
" which implements the `LocaleSelectorProvider` interface. English is the "
"default language when internationalization is disabled."
msgstr ""
"デフォルトでは、ロケールは `LocaleSelectorProvider` インターフェイスを実装する "
"`DefaultLocaleSelectorProvider` を使用して選択されます。国際化が無効の場合は、英語がデフォルトの言語です。"

msgid ""
"With internationalization enabled, the locale is resolved according to the "
"logic described in the "
"link:{adminguide_link}#_user_locale_selection[{adminguide_name}]."
msgstr ""
"国際化が有効な場合は、 link:{adminguide_link}#_user_locale_selection[{adminguide_name}]"
" に記載されたロジックに従ってロケールが解決されます。"

msgid ""
"This behavior can be changed through the `LocaleSelectorSPI` by implementing"
" the `LocaleSelectorProvider` and `LocaleSelectorProviderFactory`."
msgstr ""
"この動作は `LocaleSelectorProvider` と `LocaleSelectorProviderFactory` を実装することで "
"`LocaleSelectorSPI` を通して変更することができます。"

msgid ""
"The `LocaleSelectorProvider` interface has a single method, `resolveLocale`,"
" which must return a locale given a `RealmModel` and a nullable `UserModel`."
" The actual request is available from the `KeycloakSession#getContext` "
"method."
msgstr ""
"`LocaleSelectorProvider` インターフェイスは `resolveLocale` という単一のメソッドを持ちます。これは "
"`RealmModel` とnull許容の `UserModel` を与えられたロケールを返さなければなりません。実際のリクエストは "
"`KeycloakSession#getContext` メソッドから利用できます。"

msgid ""
"Custom implementations can extend the `DefaultLocaleSelectorProvider` in "
"order to reuse parts of the default behavior. For example to ignore the "
"`Accept-Language` request header, a custom implementation could extend the "
"default provider, override it's `getAcceptLanguageHeaderLocale`, and return "
"a null value. As a result the locale selection will fall back on the realm's"
" default language."
msgstr ""
"カスタム実装ではデフォルトの振る舞いの一部を再利用するために `DefaultLocaleSelectorProvider` "
"を継承することができます。たとえば `Accept-Language` "
"リクエストヘッダーを無視するために、カスタム実装はデフォルト・プロバイダーを継承し、 `getAcceptLanguageHeaderLocale` "
"をオーバーライドし、そしてnull値を返すことができます。結果として、ロケールの選択はレルムのデフォルト言語に戻ります。"

msgid ""
"For more details on creating and deploying a custom provider, see "
"<<_providers,Service Provider Interfaces>>. == Custom user attributes"
msgstr ""
"カスタムプロバイダーの作成とデプロイの詳細については、<<_providers,サービス・プロバイダー・インターフェイス>>を参照してください。\n"
"\n"
"== カスタムユーザー属性"

msgid ""
"You can add custom user attributes to the registration page and account "
"management console with a custom theme."
msgstr "登録ページとアカウント管理コンソールに、カスタムテーマでカスタムユーザー属性を追加することができます。"

msgid "Registration page"
msgstr "登録ページ"

msgid ""
"Use this procedure to enter custom attributes in the registration page."
msgstr "この手順で、登録ページにカスタム属性を追加します。"

msgid ""
"Copy the template `themes/base/login/register.ftl` to the login type of your"
" custom theme."
msgstr "`themes/base/login/register.ftl` テンプレートを、カスタムテーマのログインタイプにコピーしてください。"

msgid "Open the copy in an editor."
msgstr "エディターでコピーを開きます。"

msgid ""
"For example, to add a mobile number to the registration page, add the "
"following snippet to the form:"
msgstr "たとえば、登録ページに携帯電話番号を追加するには、次のスニペットをフォームに追加します。"

msgid ""
"<div class=\"form-group\">\n"
"   <div class=\"${properties.kcLabelWrapperClass!}\">\n"
"       <label for=\"user.attributes.mobile\" class=\"${properties.kcLabelClass!}\">Mobile number</label>\n"
"   </div>\n"
"\n"
"   <div class=\"${properties.kcInputWrapperClass!}\">\n"
"       <input type=\"text\" class=\"${properties.kcInputClass!}\" id=\"user.attributes.mobile\" name=\"user.attributes.mobile\" value=\"${(register.formData['user.attributes.mobile']!'')}\"/>\n"
"   </div>\n"
"</div>"
msgstr ""
"<div class=\"form-group\">\n"
"   <div class=\"${properties.kcLabelWrapperClass!}\">\n"
"       <label for=\"user.attributes.mobile\" class=\"${properties.kcLabelClass!}\">Mobile number</label>\n"
"   </div>\n"
"\n"
"   <div class=\"${properties.kcInputWrapperClass!}\">\n"
"       <input type=\"text\" class=\"${properties.kcInputClass!}\" id=\"user.attributes.mobile\" name=\"user.attributes.mobile\" value=\"${(register.formData['user.attributes.mobile']!'')}\"/>\n"
"   </div>\n"
"</div>"

msgid ""
"Ensure the name of the input html element starts with `user.attributes`. In "
"the example above, the attribute will be stored by {project_name} with the "
"name `mobile`."
msgstr ""
"inputのhtml要素の名前が `user.attributes` "
"で始まっていることを確認してください。上記の例では、属性は{project_name}によって `mobile` という名前で保存されます。"

msgid ""
"To see the changes, make sure your realm is using your custom theme for the "
"login theme and open the registration page."
msgstr "変更を参照するには、レルムがログインテーマにカスタムテーマを使用していることを確認し、登録ページを開きます。"

msgid "Account Management Console"
msgstr "アカウント管理コンソール"

msgid ""
"Use this procedure to manage custom attributes in the user profile page in "
"the account management console."
msgstr "アカウント管理コンソールのユーザー・プロフィールのページでカスタム属性を管理するには、次の手順を実施します。"

msgid ""
"Copy the template `themes/base/account/account.ftl` to the account type of "
"your custom theme."
msgstr "`themes/base/account/account.ftl` テンプレートをカスタムテーマのアカウントタイプにコピーします。"

msgid ""
"As an example to add a mobile number to the account page add the following "
"snippet to the form:"
msgstr "携帯電話番号をアカウントページに追加する例として、次のスニペットをフォームに追加します。"

msgid ""
"<div class=\"form-group\">\n"
"   <div class=\"col-sm-2 col-md-2\">\n"
"       <label for=\"user.attributes.mobile\" class=\"control-label\">Mobile number</label>\n"
"   </div>\n"
"\n"
"   <div class=\"col-sm-10 col-md-10\">\n"
"       <input type=\"text\" class=\"form-control\" id=\"user.attributes.mobile\" name=\"user.attributes.mobile\" value=\"${(account.attributes.mobile!'')}\"/>\n"
"   </div>\n"
"</div>"
msgstr ""
"<div class=\"form-group\">\n"
"   <div class=\"col-sm-2 col-md-2\">\n"
"       <label for=\"user.attributes.mobile\" class=\"control-label\">Mobile number</label>\n"
"   </div>\n"
"\n"
"   <div class=\"col-sm-10 col-md-10\">\n"
"       <input type=\"text\" class=\"form-control\" id=\"user.attributes.mobile\" name=\"user.attributes.mobile\" value=\"${(account.attributes.mobile!'')}\"/>\n"
"   </div>\n"
"</div>"

msgid ""
"Ensure the name of the input html element starts with `user.attributes`."
msgstr "inputのhtml要素の名前が `user.attributes` で始まっていることを確認してください。"

msgid ""
"To see the changes, make sure your realm is using your custom theme for the "
"account theme and open the user profile page in the account management "
"console."
msgstr ""
"変更を参照するには、レルムがアカウントテーマに対してカスタムテーマを使用していることを確認し、アカウント管理コンソールでユーザー・プロフィールのページを開いてください。"

msgid "See <<_themes,Themes>> for how to create a custom theme."
msgstr "カスタムテーマの作成方法については、<<_themes,Themes>>を参照してください。"

msgid "Identity Brokering APIs"
msgstr "アイデンティティー・ブローカリングAPI"

msgid ""
"{project_name} can delegate authentication to a parent IDP for login.  A "
"typical example of this is the case where you want users to be able to log "
"in through a social provider such as Facebook or Google. You can also link "
"existing accounts to a brokered IDP.  This section describes some APIs that "
"your applications can use as it pertains to identity brokering."
msgstr ""
"{project_name}は、親IDPに認証を委譲してログインすることができます。典型的な例としては、FacebookやGoogleなどのソーシャル・プロバイダーを経由してユーザーにログインできるようにしたい場合です。また、既存のアカウントを仲介されたIDPにリンクすることも可能です。このセクションでは、アイデンティティー・ブローカリングに関連してアプリケーションが使用できるいくつかのAPIについて説明します。"

msgid "Retrieving external IDP tokens"
msgstr "外部IDPトークンの取得"

msgid ""
"{project_name} allows you to store tokens and responses from the "
"authentication process with the external IDP. For that, you can use the "
"`Store Token` configuration option on the IDP's settings page."
msgstr ""
"{project_name}は、外部IDPとの認証プロセスから取得したトークンとレスポンスを保存できます。そのために、IDPの設定ページで `Store"
" Token` の設定オプションを使用できます。"

msgid ""
"Application code can retrieve these tokens and responses to pull in extra "
"user information, or to securely invoke requests on the external IDP. For "
"example, an application might want to use the Google token to invoke on "
"other Google services and REST APIs. To retrieve a token for a particular "
"identity provider you need to send a request as follows:"
msgstr ""
"アプリケーション・コードで、追加のユーザー情報を取得するためにこれらのトークンとレスポンスを検索したり、外部IDPにリクエストを送信することができます。たとえば、アプリケーションは、Googleトークンを使用して、他のGoogleサービスやREST"
" APIを呼び出すことができます。特定のアイデンティティー・プロバイダーのトークンを取得するには、次のようにリクエストを送信する必要があります。"

msgid ""
"GET {kc_realms_path}/{realm}/broker/{provider_alias}/token HTTP/1.1\n"
"Host: localhost:8080\n"
"Authorization: Bearer <KEYCLOAK ACCESS TOKEN>"
msgstr ""
"GET {kc_realms_path}/{realm}/broker/{provider_alias}/token HTTP/1.1\n"
"Host: localhost:8080\n"
"Authorization: Bearer <KEYCLOAK ACCESS TOKEN>"

msgid ""
"An application must have authenticated with {project_name} and have received"
" an access token.  This access token will need to have the `broker` client-"
"level role `read-token` set.  This means that the user must have a role "
"mapping for this role and the client application must have that role within "
"its scope. In this case, given that you are accessing a protected service in"
" {project_name}, you need to send the access token issued by {project_name} "
"during the user authentication. In the broker configuration page you can "
"automatically assign this role to newly imported users by turning on the "
"`Stored Tokens Readable` switch."
msgstr ""
"アプリケーションは{project_name}で認証され、アクセストークンを受け取っている必要があります。このアクセストークンには、 `broker` "
"クライアントレベルの `read-token` "
"ロールが設定されている必要があります。つまり、ユーザーはこのロールのロールマッピングを持っていなければならず、クライアント・アプリケーションのスコープ内でそのロールが必要です。この場合（{project_name}内のセキュリティー保護されたサービスにアクセスしている場合）は、ユーザー認証時に{project_name}が発行したアクセストークンを送信する必要があります。ブローカーの設定ページでは、"
" `Stored Tokens Readable` "
"のスイッチをオンにすることで、新しくインポートされたユーザーにこのロールを自動的に割り当てることができます。"

msgid ""
"These external tokens can be re-established by either logging in again "
"through the provider, or using the client initiated account linking API."
msgstr ""
"これらの外部トークンは、プロバイダーを介して再度ログインするか、Client Initiated Account Linking "
"APIを使用して再確立できます。"

msgid "Client initiated account linking"
msgstr "クライアント起点のアカウントリンク"

msgid ""
"Some applications want to integrate with social providers like Facebook, but"
" do not want to provide an option to login via these social providers.  "
"{project_name} offers a browser-based API that applications can use to link "
"an existing user account to a specific external IDP.  This is called client-"
"initiated account linking. Account linking can only be initiated by OIDC "
"applications."
msgstr ""
"アプリケーションの中には、Facebookなどのソーシャル・プロバイダーと統合したいが、これらのソーシャル・プロバイダーを介してログインするオプションを提供したくないものもあります。{project_name}は、既存のユーザー・アカウントを特定の外部IDPにリンクするためにアプリケーションが使用できる、ブラウザー・ベースのAPIを提供しています。これは、Client-"
"Initiated Account Linkingと呼ばれます。アカウント・リンキングは、OIDCアプリケーションによってのみ開始できます。"

msgid ""
"The way it works is that the application forwards the user's browser to a "
"URL on the {project_name} server requesting that it wants to link the user's"
" account to a specific external provider (i.e. Facebook).  The server "
"initiates a login with the external provider.  The browser logs in at the "
"external provider and is redirected back to the server.  The server "
"establishes the link and redirects back to the application with a "
"confirmation."
msgstr ""
"これを動作させるには、アプリケーションがユーザーのブラウザーを{project_name}サーバーのURLに転送して、ユーザーのアカウントを特定の外部プロバイダー（Facebookなど）にリンクすることを要求します。{project_name}サーバーは、外部プロバイダーとのログインを開始します。ブラウザーは外部プロバイダーにログインし、{project_name}サーバーにリダイレクトされます。{project_name}サーバーはリンクを確立し、確認のためにアプリケーションにリダイレクトします。"

msgid ""
"There are some preconditions that must be met by the client application "
"before it can initiate this protocol:"
msgstr "このプロトコルを開始する上で、クライアント・アプリケーションが満たさなければならない、いくつかの前提条件があります。"

msgid ""
"The desired identity provider must be configured and enabled for the user's "
"realm in the admin console."
msgstr "管理コンソールで、必要なアイデンティティー・プロバイダーを設定し、ユーザーのレルムに対して有効にする必要がある。"

msgid ""
"The user account must already be logged in as an existing user via the OIDC "
"protocol"
msgstr "ユーザー・アカウントは、OIDCプロトコルを介して既存のユーザーとしてログインしている必要がある。"

msgid ""
"The user must have an `account.manage-account` or `account.manage-account-"
"links` role mapping."
msgstr ""
"ユーザーには `account.manage-account` または `account.manage-account-links` "
"のロールマッピングがなければならない。"

msgid ""
"The application must be granted the scope for those roles within its access "
"token"
msgstr "アプリケーションは、アクセストークン内にあるそれらのロールのスコープを許可されている必要がある。"

msgid ""
"The application must have access to its access token as it needs information"
" within it to generate the redirect URL."
msgstr "アプリケーションは、リダイレクトURLを生成するために情報が必要なので、アクセストークンにアクセスする必要がある"

msgid ""
"To initiate the login, the application must fabricate a URL and redirect the"
" user's browser to this URL.  The URL looks like this:"
msgstr ""
"ログインを開始するには、アプリケーションがURLを作成し、ユーザーのブラウザーをこのURLにリダイレクトする必要があります。URLは次のようになります。"

msgid ""
"/{auth-server-"
"root}{kc_realms_path}/{realm}/broker/{provider}/link?client_id={id}&redirect_uri={uri}&nonce={nonce}&hash={hash}"
msgstr ""
"/{auth-server-"
"root}{kc_realms_path}/{realm}/broker/{provider}/link?client_id={id}&redirect_uri={uri}&nonce={nonce}&hash={hash}"

msgid "Here's a description of each path and query param:"
msgstr "各パスとクエリー・パラメーターの説明は次のとおりです。"

msgid "provider"
msgstr "provider"

msgid ""
"This is the provider alias of the external IDP that you defined in the "
"`Identity Provider` section of the admin console."
msgstr "管理コンソールの `アイデンティティー・プロバイダー` のセクションで定義した外部IDPのプロバイダー・エイリアスです。"

msgid "client_id"
msgstr "client_id"

msgid ""
"This is the OIDC client id of your application.  When you registered the "
"application as a client in the admin console, you had to specify this client"
" id."
msgstr ""
"アプリケーションのOIDCクライアントIDです。管理コンソールでアプリケーションをクライアントとして登録したときに、このクライアントIDを指定する必要があります。"

msgid "redirect_uri"
msgstr "redirect_uri"

msgid ""
"This is the application callback URL you want to redirect to after the "
"account link is established.  It must be a valid client redirect URI "
"pattern.  In other words, it must match one of the valid URL patterns you "
"defined when you registered the client in the admin console."
msgstr ""
"アカウントのリンクが確立された後にリダイレクトするアプリケーションのコールバックURLです。有効なクライアント・リダイレクトURIパターンでなければなりません。つまり、管理コンソールでクライアントを登録したときに定義した有効なURLパターンの1つと一致する必要があります。"

msgid "nonce"
msgstr "nonce"

msgid "This is a random string that your application must generate"
msgstr "アプリケーションが生成しなければならないランダムな文字列です。"

msgid "hash"
msgstr "hash"

msgid ""
"This is a Base64 URL encoded hash.  This hash is generated by Base64 URL "
"encoding a SHA_256 hash of `nonce` + `token.getSessionState()` + "
"`token.getIssuedFor()` + `provider`. The token variable are obtained from "
"the OIDC access token.  Basically you are hashing the random nonce, the user"
" session id, the client id, and the identity provider alias you want to "
"access."
msgstr ""
"Base64 URLでエンコードされたハッシュです。このハッシュは、 `nonce` + `token.getSessionState()` + "
"`token.getIssuedFor()` + `provider` のSHA_256ハッシュでエンコードされたBase64 "
"URLによって生成されます。トークン変数はOIDCのアクセストークンから取得されます。基本的には、ランダムなnonce、ユーザーセッションID、クライアントID、およびアクセスするアイデンティティー・プロバイダーのエイリアスをハッシュしています。"

msgid ""
"Here's an example of Java Servlet code that generates the URL to establish "
"the account link."
msgstr "次に、アカウントリンクを確立するためのURLを生成するJavaサーブレット・コードの例を示します。"

msgid ""
"   KeycloakSecurityContext session = (KeycloakSecurityContext) httpServletRequest.getAttribute(KeycloakSecurityContext.class.getName());\n"
"   AccessToken token = session.getToken();\n"
"   String clientId = token.getIssuedFor();\n"
"   String nonce = UUID.randomUUID().toString();\n"
"   MessageDigest md = null;\n"
"   try {\n"
"      md = MessageDigest.getInstance(\"SHA-256\");\n"
"   } catch (NoSuchAlgorithmException e) {\n"
"      throw new RuntimeException(e);\n"
"   }\n"
"   String input = nonce + token.getSessionState() + clientId + provider;\n"
"   byte[] check = md.digest(input.getBytes(StandardCharsets.UTF_8));\n"
"   String hash = Base64Url.encode(check);\n"
"   request.getSession().setAttribute(\"hash\", hash);\n"
"   String redirectUri = ...;\n"
"   String accountLinkUrl = KeycloakUriBuilder.fromUri(authServerRootUrl)\n"
"                    .path(\"{kc_realms_path}/{realm}/broker/{provider}/link\")\n"
"                    .queryParam(\"nonce\", nonce)\n"
"                    .queryParam(\"hash\", hash)\n"
"                    .queryParam(\"client_id\", clientId)\n"
"                    .queryParam(\"redirect_uri\", redirectUri).build(realm, provider).toString();"
msgstr ""
"   KeycloakSecurityContext session = (KeycloakSecurityContext) httpServletRequest.getAttribute(KeycloakSecurityContext.class.getName());\n"
"   AccessToken token = session.getToken();\n"
"   String clientId = token.getIssuedFor();\n"
"   String nonce = UUID.randomUUID().toString();\n"
"   MessageDigest md = null;\n"
"   try {\n"
"      md = MessageDigest.getInstance(\"SHA-256\");\n"
"   } catch (NoSuchAlgorithmException e) {\n"
"      throw new RuntimeException(e);\n"
"   }\n"
"   String input = nonce + token.getSessionState() + clientId + provider;\n"
"   byte[] check = md.digest(input.getBytes(StandardCharsets.UTF_8));\n"
"   String hash = Base64Url.encode(check);\n"
"   request.getSession().setAttribute(\"hash\", hash);\n"
"   String redirectUri = ...;\n"
"   String accountLinkUrl = KeycloakUriBuilder.fromUri(authServerRootUrl)\n"
"                    .path(\"{kc_realms_path}/{realm}/broker/{provider}/link\")\n"
"                    .queryParam(\"nonce\", nonce)\n"
"                    .queryParam(\"hash\", hash)\n"
"                    .queryParam(\"client_id\", clientId)\n"
"                    .queryParam(\"redirect_uri\", redirectUri).build(realm, provider).toString();"

msgid ""
"Why is this hash included?  We do this so that the auth server is guaranteed"
" to know that the client application initiated the request and no other "
"rogue app just randomly asked for a user account to be linked to a specific "
"provider.  The auth server will first check to see if the user is logged in "
"by checking the SSO cookie set at login.  It will then try to regenerate the"
" hash based on the current login and match it up to the hash sent by the "
"application."
msgstr ""
"このハッシュはなぜ含まれるのでしょうか？これにより、認証サーバーはクライアント・アプリケーションが要求を開始したことと、ユーザー・アカウントが特定のプロバイダーにリンクされることをランダムに要求する悪意のあるアプリケーションが無いことを保証します。認証サーバーはまず、ログイン時に設定されたSSO"
" "
"Cookieをチェックして、ユーザーがログインしているかどうかを確認します。次に、現在のログインに基づいてハッシュを再生成し、アプリケーションによって送信されたハッシュと一致するか確認します。"

msgid ""
"After the account has been linked, the auth server will redirect back to the"
" `redirect_uri`.  If there is a problem servicing the link request, the auth"
" server may or may not redirect back to the `redirect_uri`.  The browser may"
" just end up at an error page instead of being redirected back to the "
"application.  If there is an error condition and the auth server deems it "
"safe enough to redirect back to the client app, an additional `error` query "
"parameter will be appended to the `redirect_uri`."
msgstr ""
"アカウントがリンクされると、認証サーバーは `redirect_uri` にリダイレクトします。リンクリクエストの処理に問題がある場合、認証サーバーが "
"`redirect_uri` "
"にリダイレクトされる保障はありません。ブラウザーはアプリケーションにリダイレクトされるのではなく、エラーページにリダイレクトされることがあります。何らかのエラー状態があり、認証サーバーがクライアント・アプリケーションにリダイレクトするのに十分安全であると判断した場合、"
" `error` クエリー・パラメーターが `redirect_uri` に追加されます。"

msgid ""
"   While this API guarantees that the application initiated the request, it "
"does not completely prevent CSRF attacks for this operation.  The "
"application    is still responsible for guarding against CSRF attacks target"
" at itself."
msgstr ""
"このAPIはアプリケーションが要求を開始したことを保証しますが、この操作に対するCSRF攻撃を完全に防止するわけではありません。このアプリケーションは、依然としてCSRFの攻撃のターゲットに対する防御の責任があります。"

msgid "Refreshing external tokens"
msgstr "外部トークンのリフレッシュ"

msgid ""
"If you are using the external token generated by logging into the provider "
"(i.e. a Facebook or GitHub token), you can refresh this token by re-"
"initiating the account linking API."
msgstr ""
"プロバイダーにログインして生成した外部トークン（FacebookやGitHubトークンなど）を使用している場合は、Account Linking "
"APIを再起動することで、このトークンを更新できます。"

msgid "Service Provider Interfaces (SPI)"
msgstr "サービス・プロバイダー・インターフェイス（SPI）"

msgid ""
"{project_name} is designed to cover most use-cases without requiring custom "
"code, but we also want it to be customizable. To achieve this {project_name}"
" has a number of Service Provider Interfaces (SPI) for which you can "
"implement your own providers."
msgstr ""
"{project_name}は、必要なカスタム・コードが無くても、ほとんどのユースケースをカバーできるように作られていますが、カスタマイズもできるようにする必要があります。これを実現するために、{project_name}には独自のプロバイダーを実装できる多数のサービス・プロバイダー・インタフェース（SPI）があります。"

msgid "Implementing an SPI"
msgstr "SPIの実装"

msgid ""
"To implement an SPI you need to implement its ProviderFactory and Provider "
"interfaces. You also need to create a service configuration file."
msgstr ""
"SPIを実装するには、SPIのProviderFactoryとProviderインターフェイスを実装する必要があります。また、サービス設定ファイルを作成する必要があります。"

msgid ""
"For example, to implement the Theme Selector SPI you need to implement "
"ThemeSelectorProviderFactory and ThemeSelectorProvider and also provide the "
"file `META-INF/services/org.keycloak.theme.ThemeSelectorProviderFactory`."
msgstr ""
"たとえば、Theme Selector "
"SPIを実装するには、ThemeSelectorProviderFactoryとThemeSelectorProviderを実装して、 `META-"
"INF/services/org.keycloak.theme.ThemeSelectorProviderFactory` "
"のファイルを提供する必要があります。"

msgid "Example ThemeSelectorProviderFactory:"
msgstr "ThemeSelectorProviderFactoryのサンプルを次に示します。"

msgid ""
"package org.acme.provider;\n"
"\n"
"import ...\n"
"\n"
"public class MyThemeSelectorProviderFactory implements ThemeSelectorProviderFactory {\n"
"\n"
"    @Override\n"
"    public ThemeSelectorProvider create(KeycloakSession session) {\n"
"        return new MyThemeSelectorProvider(session);\n"
"    }\n"
"\n"
"    @Override\n"
"    public void init(Config.Scope config) {\n"
"    }\n"
"\n"
"    @Override\n"
"    public void postInit(KeycloakSessionFactory factory) {\n"
"    }\n"
"\n"
"    @Override\n"
"    public void close() {\n"
"    }\n"
"\n"
"    @Override\n"
"    public String getId() {\n"
"        return \"myThemeSelector\";\n"
"    }\n"
"}"
msgstr ""
"package org.acme.provider;\n"
"\n"
"import ...\n"
"\n"
"public class MyThemeSelectorProviderFactory implements ThemeSelectorProviderFactory {\n"
"\n"
"    @Override\n"
"    public ThemeSelectorProvider create(KeycloakSession session) {\n"
"        return new MyThemeSelectorProvider(session);\n"
"    }\n"
"\n"
"    @Override\n"
"    public void init(Config.Scope config) {\n"
"    }\n"
"\n"
"    @Override\n"
"    public void postInit(KeycloakSessionFactory factory) {\n"
"    }\n"
"\n"
"    @Override\n"
"    public void close() {\n"
"    }\n"
"\n"
"    @Override\n"
"    public String getId() {\n"
"        return \"myThemeSelector\";\n"
"    }\n"
"}"

msgid ""
"It is recommended that your provider factory implementation returns unique "
"id by method `getId()`. However there can be some exceptions to this rule as"
" mentioned below in the <<_override_builtin_providers,Overriding providers>>"
" section."
msgstr ""
"プロバイダー・ファクトリーの実装では、メソッド `getId()` によってユニークなIDを返すことが推奨されます。しかし、以下の "
"<<_override_builtin_providers,ビルトイン・プロバイダーのオーバーライド>> "
"セクションで述べられているように、このルールにはいくつかの例外があります。"

msgid ""
"{project_name} creates a single instance of provider factories which makes "
"it possible to store state for multiple requests. Provider instances are "
"created by calling create on the factory for each request so these should be"
" light-weight object."
msgstr ""
"{project_name}は、複数のリクエストの状態を格納することを可能にするプロバイダー・ファクトリーの単一のインスタンスを作成します。プロバイダー・インスタンスは、それぞれのリクエストに対してファクトリーでcreateを呼び出すことによって作成されるため、軽量オブジェクトである必要があります。"

msgid "Example ThemeSelectorProvider:"
msgstr "ThemeSelectorProviderのサンプルを次に示します。"

msgid ""
"package org.acme.provider;\n"
"\n"
"import ...\n"
"\n"
"public class MyThemeSelectorProvider implements ThemeSelectorProvider {\n"
"\n"
"    public MyThemeSelectorProvider(KeycloakSession session) {\n"
"    }\n"
"\n"
"\n"
"    @Override\n"
"    public String getThemeName(Theme.Type type) {\n"
"        return \"my-theme\";\n"
"    }\n"
"\n"
"    @Override\n"
"\tpublic void close() {\n"
"    }\n"
"}"
msgstr ""
"package org.acme.provider;\n"
"\n"
"import ...\n"
"\n"
"public class MyThemeSelectorProvider implements ThemeSelectorProvider {\n"
"\n"
"    public MyThemeSelectorProvider(KeycloakSession session) {\n"
"    }\n"
"\n"
"\n"
"    @Override\n"
"    public String getThemeName(Theme.Type type) {\n"
"        return \"my-theme\";\n"
"    }\n"
"\n"
"    @Override\n"
"\tpublic void close() {\n"
"    }\n"
"}"

msgid ""
"Example service configuration file (`META-"
"INF/services/org.keycloak.theme.ThemeSelectorProviderFactory`):"
msgstr ""
"サービス設定ファイル（ `META-"
"INF/services/org.keycloak.theme.ThemeSelectorProviderFactory` ）を次に示します。"

msgid "org.acme.provider.MyThemeSelectorProviderFactory"
msgstr "org.acme.provider.MyThemeSelectorProviderFactory"

msgid ""
"To configure your provider, see the "
"link:https://www.keycloak.org/server/configuration-provider[Configuring "
"Providers] guide."
msgstr ""
"プロバイダーの設定は、 link:https://www.keycloak.org/server/configuration-"
"provider[プロバイダーの設定] ガイドを参照してください。"

msgid "For example, to configure a provider you can set options as follows:"
msgstr "例えば、プロバイダーを設定する場合、以下のようにオプションを設定します。"

msgid ""
"bin/kc.[sh|bat] --spi-theme-selector-my-theme-selector-enabled=true --spi-"
"theme-selector-my-theme-selector-theme=my-theme"
msgstr ""
"bin/kc.[sh|bat] --spi-theme-selector-my-theme-selector-enabled=true --spi-"
"theme-selector-my-theme-selector-theme=my-theme"

msgid "Then you can retrieve the config in the `ProviderFactory` init method:"
msgstr "そうすると、 `ProviderFactory` のinitメソッドで設定を取得することができます。"

msgid ""
"public void init(Config.Scope config) {\n"
"    String themeName = config.get(\"theme\");\n"
"}"
msgstr ""
"public void init(Config.Scope config) {\n"
"    String themeName = config.get(\"theme\");\n"
"}"

msgid "Your provider can also look up other providers if needed. For example:"
msgstr "また、プロバイダーも必要に応じて他のプロバイダーを参照することができます。以下が例です。"

msgid ""
"public class MyThemeSelectorProvider implements ThemeSelectorProvider {\n"
"\n"
"    private KeycloakSession session;\n"
"\n"
"    public MyThemeSelectorProvider(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"
"\n"
"    @Override\n"
"    public String getThemeName(Theme.Type type) {\n"
"        return session.getContext().getRealm().getLoginTheme();\n"
"    }\n"
"}"
msgstr ""
"public class MyThemeSelectorProvider implements ThemeSelectorProvider {\n"
"\n"
"    private KeycloakSession session;\n"
"\n"
"    public MyThemeSelectorProvider(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"
"\n"
"    @Override\n"
"    public String getThemeName(Theme.Type type) {\n"
"        return session.getContext().getRealm().getLoginTheme();\n"
"    }\n"
"}"

msgid "Override built-in providers"
msgstr "ビルトイン・プロバイダーのオーバーライド"

msgid ""
"As mentioned above, it is recommended that your `ProviderFactory` "
"implementations use unique ID. However at the same time, it can be useful to"
" override one of the {project_name} built-in providers. The recommended way "
"for this is still ProviderFactory implementation with unique ID and then for"
" instance set the default provider as specified in the "
"link:https://www.keycloak.org/server/configuration-provider[Configuring "
"Providers] guide. On the other hand, this may not be always possible."
msgstr ""
"上記のように、 `ProviderFactory` "
"の実装にはユニークなIDを使用することが推奨されます。しかし同時に、{project_name}のビルトイン・プロバイダーの1つをオーバーライドすることも有用です。そのために推奨される方法は、やはりユニークなIDを持つProviderFactoryを実装し、例えば"
" link:https://www.keycloak.org/server/configuration-provider[Configuring "
"Providers] ガイドで指定されているようにデフォルト・プロバイダーを設定する方法です。一方、これは常に可能であるとは限りません。"

msgid ""
"For instance when you need some customizations to default OpenID Connect "
"protocol behaviour and you want to override default {project_name} "
"implementation of `OIDCLoginProtocolFactory` you need to preserve same "
"providerId. As for example admin console, OIDC protocol well-known endpoint "
"and various other things rely on the ID of the protocol factory being "
"`openid-connect`."
msgstr ""
"例えば、デフォルトのOpenID Connectプロトコルの動作をカスタマイズする必要があり、デフォルトの{project_name}の "
"`OIDCLoginProtocolFactory` "
"の実装をオーバーライドしたい場合、同じプロバイダーIDを維持する必要があります。これは、管理コンソール、OIDCプロトコルのWell-"
"Knownエンドポイント、その他様々なものがプロトコル・ファクトリーのIDが `openid-connect` であることに依存しているからです。"

msgid ""
"For this case, it is highly recommended to implement method `order()` of "
"your custom implementation and make sure that it has higher order than the "
"built-in implementation."
msgstr "この場合、カスタム実装のメソッド `order()` を実装し、ビルトイン実装よりも高いオーダーを持つようにすることが強く推奨されます。"

msgid ""
"public class CustomOIDCLoginProtocolFactory extends OIDCLoginProtocolFactory {\n"
"\n"
"    // Some customizations here\n"
"\n"
"    @Override\n"
"    public int order() {\n"
"        return 1;\n"
"    }\n"
"}"
msgstr ""
"public class CustomOIDCLoginProtocolFactory extends OIDCLoginProtocolFactory {\n"
"\n"
"    // Some customizations here\n"
"\n"
"    @Override\n"
"    public int order() {\n"
"        return 1;\n"
"    }\n"
"}"

msgid ""
"In case of multiple implementations with same provider ID, only the one with"
" highest order will be used by {project_name} runtime."
msgstr "同じプロバイダーIDを持つ複数の実装がある場合、{project_name}ランタイムでは最も高いオーダーのものだけが使用されます。"

msgid "Show info from your SPI implementation in the Admin Console"
msgstr "管理コンソールでのSPI実装の情報表示"

msgid ""
"Sometimes it is useful to show additional info about your Provider to a "
"{project_name} administrator. You can show provider build time information "
"(for example, version of custom provider currently installed), current "
"configuration of the provider (e.g. url of remote system your provider talks"
" to) or some operational info (average time of response from remote system "
"your provider talks to). {project_name} Admin Console provides Server Info "
"page to show this kind of information."
msgstr ""
"{project_name}管理者にプロバイダーに関する追加情報を表示すると、便利なことがあります。 "
"プロバイダー・ビルド・タイム情報（たとえば、現在インストール済みのカスタム・プロバイダーのバージョン）、プロバイダーの現在の設定（たとえば、プロバイダーが通信するリモートシステムのURL）、または動作情報（たとえば、プロバイダーが通信するリモートシステムからの平均レスポンス・タイム）を表示することができます。{project_name}管理コンソールでは、サーバーの情報ページが提供され、この種の情報が表示されます。"

msgid ""
"To show info from your provider it is enough to implement "
"`org.keycloak.provider.ServerInfoAwareProviderFactory` interface in your "
"`ProviderFactory`."
msgstr ""
"プロバイダーからの情報を表示するには、 `ProviderFactory` 内で "
"`org.keycloak.provider.ServerInfoAwareProviderFactory` インターフェイスを実装するだけです。"

msgid ""
"Example implementation for `MyThemeSelectorProviderFactory` from previous "
"example:"
msgstr "前のサンプルの `MyThemeSelectorProviderFactory` のサンプル実装を次に示します。"

msgid ""
"package org.acme.provider;\n"
"\n"
"import ...\n"
"\n"
"public class MyThemeSelectorProviderFactory implements ThemeSelectorProviderFactory, ServerInfoAwareProviderFactory {\n"
"    ...\n"
"\n"
"    @Override\n"
"    public Map<String, String> getOperationalInfo() {\n"
"        Map<String, String> ret = new LinkedHashMap<>();\n"
"        ret.put(\"theme-name\", \"my-theme\");\n"
"        return ret;\n"
"    }\n"
"}"
msgstr ""
"package org.acme.provider;\n"
"\n"
"import ...\n"
"\n"
"public class MyThemeSelectorProviderFactory implements ThemeSelectorProviderFactory, ServerInfoAwareProviderFactory {\n"
"    ...\n"
"\n"
"    @Override\n"
"    public Map<String, String> getOperationalInfo() {\n"
"        Map<String, String> ret = new LinkedHashMap<>();\n"
"        ret.put(\"theme-name\", \"my-theme\");\n"
"        return ret;\n"
"    }\n"
"}"

msgid "Use available providers"
msgstr "利用可能なプロバイダーを使用する"

msgid ""
"In your provider implementation, you can use other providers available in "
"{project_name}. The existing providers can be typically retrieved with the "
"usage of the `KeycloakSession`, which is available to your provider as "
"described in the section <<_implementing_spi,Implementing an SPI>>."
msgstr ""
"プロバイダーの実装では、{project_name} で利用可能な他のプロバイダーを使用できます。通常、既存のプロバイダーは "
"`KeycloakSession` を使用して取得できます。セクション<<_implementing_spi,SPI "
"の実装>>で説明されているように、これをプロバイダーに利用できます。"

msgid "{project_name} has two provider types:"
msgstr "{project_name} には次の2つのプロバイダーのタイプがあります。"

msgid ""
"*Single-implementation provider types* - There can be only a single active "
"implementation of the particular provider type in {project_name} runtime."
msgstr ""
"*単一実装プロバイダー・タイプ* - "
"{project_name}ランタイムにおいて、特定のプロバイダー・タイプのアクティブな実装は1つだけ存在することができます。"

msgid ""
"For example `HostnameProvider` specifies the hostname to be used by "
"{project_name} and that is shared for the whole {project_name} server. Hence"
" there can be only single implementation of this provider active for the "
"{project_name} server. If there are multiple provider implementations "
"available to the server runtime, one of them needs to be specified as the "
"default one."
msgstr ""
"たとえば、 `HostnameProvider` "
"は{project_name}で使用するホスト名を指定しますが、これは{project_name}サーバー全体で共有されます。したがって、{project_name}サーバーで有効なこのプロバイダーの実装は1つだけであるべきです。サーバー・ランタイムで利用可能なプロバイダーの実装が複数ある場合は、そのうちの1つをデフォルトとして指定する必要がある。"

msgid "For example such as:"
msgstr "以下に例を示します。"

msgid "bin/kc.[sh|bat] build --spi-hostname-provider=default"
msgstr "bin/kc.[sh|bat] build --spi-hostname-provider=default"

msgid ""
"The value `default` used as the value of `default-provider` must match the "
"ID returned by the `ProviderFactory.getId()` of the particular provider "
"factory implementation. In the code, you can obtain the provider such as "
"`keycloakSession.getProvider(HostnameProvider.class)`"
msgstr ""
"`default-provider` の値として使用される `default` の値は、特定のプロバイダー・ファクトリーの実装の "
"`ProviderFactory.getId()` によって返されるIDと一致する必要があります。コードでは、 "
"`keycloakSession.getProvider(HostnameProvider.class)` などのプロバイダーを取得できます。"

msgid ""
"*Multiple implementation provider types* - Those are provider types, that "
"allow multiple implementations available and working together in the "
"{project_name} runtime."
msgstr ""
"*複数実装プロバイダー・タイプ* - {project_name}ランタイムで複数の実装を利用でき、一緒に動作することができるプロバイダー・タイプです。"

msgid ""
"For example `EventListener` provider allows to have multiple implementations"
" available and registered, which means that particular event can be sent to "
"all the listeners (jboss-logging, sysout etc). In the code, you can obtain a"
" specified instance of the provider for example such as "
"`session.getProvider(EventListener.class, \"jboss-logging\")` . You need to "
"specify `provider_id` of the provider as the second argument as there can be"
" multiple instances of this provider type as described above."
msgstr ""
"たとえば、 `EventListener` "
"プロバイダーは、複数の実装を利用可能にして登録することができます。これは、特定のイベントをすべてのリスナー（jboss-"
"logging、sysoutなど）に送信できることを意味します。コードでは、たとえば、 "
"`session.getProvider(EventListener.class, \"jboss-logging\")` "
"のようにプロバイダーの指定インスタンスを取得することができます。上記のように、このプロバイダー・タイプのインスタンスは複数存在する可能性があるため、第2引数としてプロバイダーの"
" `provider_id` を指定する必要があります。"

msgid ""
"The provider ID must match the ID returned by the `ProviderFactory.getId()` "
"of the particular provider factory implementation. Some provider types can "
"be retrieved with the usage of `ComponentModel` as the second argument and "
"some (for example `Authenticator`) even need to be retrieved with the usage "
"of `KeycloakSessionFactory`. It is not recommended to implement your own "
"providers this way as it may be deprecated in the future."
msgstr ""
"プロバイダーIDは、特定のプロバイダー・ファクトリー実装の `ProviderFactory.getId()` "
"が返すIDに一致しなければならない。プロバイダーの種類によっては、第2引数に `ComponentModel` "
"を指定することで取得できるものもあり、（たとえば `Authenticator` のように） `KeycloakSessionFactory` "
"を指定して取得する必要があるものもあります。将来的に非推奨となる可能性があるため、この方法で独自のプロバイダーを実装することはお勧めしません。"

msgid "Registering provider implementations"
msgstr "プロバイダー実装の登録"

msgid ""
"Providers are registered with the server by simply copying them to the "
"`providers` directory."
msgstr "プロバイダーは、 `providers` ディレクトリーにコピーするだけでサーバーに登録されます。"

msgid ""
"If your provider needs additional dependencies not already provided by "
"Keycloak copy these to the `providers` directory."
msgstr ""
"もしあなたのプロバイダーがKeycloakによってまだ提供されていない追加の依存関係を必要とするならば、それらを `providers` "
"ディレクトリーにコピーしてください。"

msgid ""
"After registering new providers or dependencies Keycloak needs to be re-"
"built with the `kc.[sh|bat] build` command."
msgstr ""
"新しいプロバイダーや依存関係を登録した後、Keycloakは `kc.[sh|bat] build` コマンドで再ビルドする必要があります。"

msgid "Disabling a provider"
msgstr "プロバイダーの無効化"

msgid ""
"You can disable a provider by setting the enabled attribute for the provider"
" to false. For example to disable the Infinispan user cache provider use:"
msgstr ""
"プロバイダのーenabled属性をfalseに設定することで、プロバイダーを無効にすることができます。たとえば、Infinispanユーザー・キャッシュ・プロバイダーを無効にするには、次のようにします。"

msgid "bin/kc.[sh|bat] build --spi-user-cache-infinispan-enabled=false"
msgstr "bin/kc.[sh|bat] build --spi-user-cache-infinispan-enabled=false"

msgid "JavaScript providers"
msgstr "JavaScriptプロバイダー"

msgid ""
"{project_name} has the ability to execute scripts during runtime in order to"
" allow administrators to customize specific functionalities:"
msgstr "{project_name}には、管理者が特定の機能をカスタマイズできるようにするために、起動中にスクリプトを実行する機能があります。"

msgid "Authenticator"
msgstr "オーセンティケーター"

msgid "JavaScript Policy"
msgstr "JavaScriptポリシー"

msgid "OpenID Connect Protocol Mapper"
msgstr "OpenID Connectプロトコル・マッパー"

msgid "SAML Protocol Mapper"
msgstr "SAMLプロトコル・マッパー"

msgid ""
"Authentication scripts must provide at least one of the following functions:"
" `authenticate(..)`, which is called from "
"`Authenticator#authenticate(AuthenticationFlowContext)` `action(..)`, which "
"is called from `Authenticator#action(AuthenticationFlowContext)`"
msgstr ""
"認証スクリプトは、少なくとも以下の関数のうちの1つを提供しなければなりません。 "
"`Authenticator#authenticate(AuthenticationFlowContext)` から呼び出された "
"`authenticate(..)` 。 `Authenticator#action(AuthenticationFlowContext)` "
"から呼び出された `action(..)` 。"

msgid ""
"Custom `Authenticator` should at least provide the `authenticate(..)` "
"function. You can use the `javax.script.Bindings` script within the code."
msgstr ""
"カスタム `Authenticator` は、少なくとも `authenticate(..)` 関数を提供する必要があります。コード内で "
"`javax.script.Bindings` スクリプトを使用できます。"

msgid "`script`"
msgstr "`script`"

msgid "the `ScriptModel` to access script metadata"
msgstr "スクリプトのメタデータにアクセスするための `ScriptModel` "

msgid "`realm`"
msgstr "`realm`"

msgid "the `RealmModel`"
msgstr "`RealmModel`"

msgid "`user`"
msgstr "`user`"

msgid "the current `UserModel`"
msgstr "現在の `UserModel`"

msgid "`session`"
msgstr "`session`"

msgid "the active `KeycloakSession`"
msgstr "アクティブな `KeycloakSession`"

msgid "`authenticationSession`"
msgstr "`authenticationSession`"

msgid "the current `AuthenticationSessionModel`"
msgstr "現在の `AuthenticationSessionModel`"

msgid "`httpRequest`"
msgstr "`httpRequest`"

msgid "the current `org.jboss.resteasy.spi.HttpRequest`"
msgstr "現在の `org.jboss.resteasy.spi.HttpRequest`"

msgid "`LOG`"
msgstr "`LOG`"

msgid "a `org.jboss.logging.Logger` scoped to `ScriptBasedAuthenticator`"
msgstr "`ScriptBasedAuthenticator` にスコープされた `org.jboss.logging.Logger`"

msgid ""
"You can extract additional context information from the `context` argument "
"passed to the `authenticate(context)` `action(context)` function."
msgstr ""
"`authenticate(context)` や `action(context)` 関数に渡された `context` "
"引数から追加のコンテキスト情報を抽出できます。"

msgid ""
"AuthenticationFlowError = Java.type(\"org.keycloak.authentication.AuthenticationFlowError\");\n"
"\n"
"function authenticate(context) {\n"
"\n"
"  LOG.info(script.name + \" --> trace auth for: \" + user.username);\n"
"\n"
"  if (   user.username === \"tester\"\n"
"      && user.getAttribute(\"someAttribute\")\n"
"      && user.getAttribute(\"someAttribute\").contains(\"someValue\")) {\n"
"\n"
"      context.failure(AuthenticationFlowError.INVALID_USER);\n"
"      return;\n"
"  }\n"
"\n"
"  context.success();\n"
"}"
msgstr ""
"AuthenticationFlowError = Java.type(\"org.keycloak.authentication.AuthenticationFlowError\");\n"
"\n"
"function authenticate(context) {\n"
"\n"
"  LOG.info(script.name + \" --> trace auth for: \" + user.username);\n"
"\n"
"  if (   user.username === \"tester\"\n"
"      && user.getAttribute(\"someAttribute\")\n"
"      && user.getAttribute(\"someAttribute\").contains(\"someValue\")) {\n"
"\n"
"      context.failure(AuthenticationFlowError.INVALID_USER);\n"
"      return;\n"
"  }\n"
"\n"
"  context.success();\n"
"}"

msgid "Create a JAR with the scripts to deploy"
msgstr "デプロイするスクリプトを含むJARの作成"

msgid "JAR files are regular ZIP files with a `.jar` extension."
msgstr "JARファイルは、拡張子が `.jar` の通常のZIPファイルです。"

msgid ""
"In order to make your scripts available to {project_name} you need to deploy"
" them to the server. For that, you should create a `JAR` file with the "
"following structure:"
msgstr ""
"スクリプトを{project_name}で使用できるようにするには、それらをサーバーにデプロイする必要があります。そのためには、次の構造を持つ "
"`JAR` ファイルを作成する必要があります。"

msgid ""
"META-INF/keycloak-scripts.json\n"
"\n"
"my-script-authenticator.js\n"
"my-script-policy.js\n"
"my-script-mapper.js"
msgstr ""
"META-INF/keycloak-scripts.json\n"
"\n"
"my-script-authenticator.js\n"
"my-script-policy.js\n"
"my-script-mapper.js"

msgid ""
"The `META-INF/keycloak-scripts.json` is a file descriptor that provides "
"metadata information about the scripts you want to deploy. It is a JSON file"
" with the following structure:"
msgstr ""
"`META-INF/keycloak-scripts.json` "
"は、デプロイするスクリプトに関するメタデータ情報を提供するファイル・ディスクリプターです。次の構造を持つJSONファイルです。"

msgid ""
"{\n"
"    \"authenticators\": [\n"
"        {\n"
"            \"name\": \"My Authenticator\",\n"
"            \"fileName\": \"my-script-authenticator.js\",\n"
"            \"description\": \"My Authenticator from a JS file\"\n"
"        }\n"
"    ],\n"
"    \"policies\": [\n"
"        {\n"
"            \"name\": \"My Policy\",\n"
"            \"fileName\": \"my-script-policy.js\",\n"
"            \"description\": \"My Policy from a JS file\"\n"
"        }\n"
"    ],\n"
"    \"mappers\": [\n"
"        {\n"
"            \"name\": \"My Mapper\",\n"
"            \"fileName\": \"my-script-mapper.js\",\n"
"            \"description\": \"My Mapper from a JS file\"\n"
"        }\n"
"    ],\n"
"    \"saml-mappers\": [\n"
"        {\n"
"            \"name\": \"My Mapper\",\n"
"            \"fileName\": \"my-script-mapper.js\",\n"
"            \"description\": \"My Mapper from a JS file\"\n"
"        }\n"
"    ]\n"
"}"
msgstr ""
"{\n"
"    \"authenticators\": [\n"
"        {\n"
"            \"name\": \"My Authenticator\",\n"
"            \"fileName\": \"my-script-authenticator.js\",\n"
"            \"description\": \"My Authenticator from a JS file\"\n"
"        }\n"
"    ],\n"
"    \"policies\": [\n"
"        {\n"
"            \"name\": \"My Policy\",\n"
"            \"fileName\": \"my-script-policy.js\",\n"
"            \"description\": \"My Policy from a JS file\"\n"
"        }\n"
"    ],\n"
"    \"mappers\": [\n"
"        {\n"
"            \"name\": \"My Mapper\",\n"
"            \"fileName\": \"my-script-mapper.js\",\n"
"            \"description\": \"My Mapper from a JS file\"\n"
"        }\n"
"    ],\n"
"    \"saml-mappers\": [\n"
"        {\n"
"            \"name\": \"My Mapper\",\n"
"            \"fileName\": \"my-script-mapper.js\",\n"
"            \"description\": \"My Mapper from a JS file\"\n"
"        }\n"
"    ]\n"
"}"

msgid ""
"This file should reference the different types of script providers that you "
"want to deploy:"
msgstr "このファイルは、デプロイするさまざまなタイプのスクリプト・プロバイダーを参照する必要があります。"

msgid "`authenticators`"
msgstr "`authenticators`"

msgid ""
"For OpenID Connect Script Authenticators. You can have one or multiple "
"authenticators in the same JAR file"
msgstr ""
"OpenID Connectスクリプト・オーセンティケーター用です。同じJARファイルに1つ以上のオーセンティケーターを含めることができます。"

msgid "`policies`"
msgstr "`policies`"

msgid ""
"For JavaScript Policies when using {project_name} Authorization Services. "
"You can have one or multiple policies in the same JAR file"
msgstr ""
"{project_name}認可サービスを使用する場合のJavaScriptポリシー用です。同じJARファイルに1つ以上のポリシーを含めることができます。"

msgid "`mappers`"
msgstr "`mappers`"

msgid ""
"For OpenID Connect Script Protocol Mappers. You can have one or multiple "
"mappers in the same JAR file"
msgstr "OpenID Connectスクリプト・プロトコル・マッパー用です。同じJARファイルに1つ以上のマッパーを含めることができます。"

msgid "`saml-mappers`"
msgstr "`saml-mappers`"

msgid ""
"For SAML Script Protocol Mappers. You can have one or multiple mappers in "
"the same JAR file"
msgstr "SAMLスクリプト・プロトコル・マッパー用です。同じJARファイルに1つ以上のマッパーを含めることができます。"

msgid ""
"For each script file in your `JAR` file, you need a corresponding entry in "
"`META-INF/keycloak-scripts.json` that maps your scripts files to a specific "
"provider type. For that you should provide the following properties for each"
" entry:"
msgstr ""
"`JAR` ファイル内の各スクリプト・ファイルに対して、スクリプト・ファイルを特定のプロバイダー・タイプにマッピングする `META-"
"INF/keycloak-scripts.json` "
"に対応するエントリーが必要です。そのためには、各エントリーに次のプロパティーを提供する必要があります。"

msgid "`name`"
msgstr "`name`"

msgid ""
"A friendly name that will be used to show the scripts through the "
"{project_name} Administration Console. If not provided, the name of the "
"script file will be used instead"
msgstr ""
"{project_name}管理コンソールでスクリプトを表示するために使用されるわかりやすい名前です。指定しない場合は、代わりにスクリプト・ファイルの名前が使用されます。"

msgid "`description`"
msgstr "`description`"

msgid "An optional text that better describes the intend of the script file"
msgstr "スクリプト・ファイルの意図をより詳しく説明するオプションのテキストです。"

msgid "`fileName`"
msgstr "`fileName`"

msgid ""
"The name of the script file. This property is *mandatory* and should map to "
"a file within the JAR."
msgstr "スクリプト・ファイルの名前です。このプロパティーは *必須* であり、JAR内のファイルにマップする必要があります。"

msgid "Deploy the script JAR"
msgstr "スクリプトJARのデプロイ"

msgid ""
"Once you have a JAR file with a descriptor and the scripts you want to "
"deploy, you just need to copy the JAR to the {project_name} `providers/` "
"directory, then run `bin/kc.[sh|bat] build`."
msgstr ""
"ディスクリプターとデプロイしたいスクリプトを含むJARファイルを用意したら、{project_name}の `providers/` "
"ディレクトリーにJARをコピーし、`bin/kc.[sh|bat] build` を実行するだけです。"

msgid "Available SPIs"
msgstr "利用可能なSPI"

msgid ""
"If you want to see list of all available SPIs at runtime, you can check "
"`Server Info` page in Admin Console as described in "
"<<_providers_admin_console,Admin Console>> section."
msgstr ""
"利用可能なすべてのSPIのリストを実行時に確認する必要がある場合は、<<_providers_admin_console, "
"管理コンソール>>セクションでの説明通りに、管理コンソール内の `Server Info` ページを確認します。"

msgid "Extending the server"
msgstr "サーバーの拡張"

msgid ""
"The {project_name} SPI framework offers the possibility to implement or "
"override particular built-in providers. However {project_name} also provides"
" capabilities to extend its core functionalities and domain. This includes "
"possibilities to:"
msgstr ""
"{project_name} "
"SPIフレームワークによって、特定のビルトイン・プロバイダーを実装、またはオーバーライドすることができます。ただし、{project_name}自身のコアの機能とドメインを拡張することもできます。これにより、以下も可能になります。"

msgid "Add custom REST endpoints to the {project_name} server"
msgstr "カスタムRESTエンドポイントを{project_name}サーバーに追加"

msgid "Add your own custom SPI"
msgstr "独自のカスタムSPIを追加"

msgid "Add custom JPA entities to the {project_name} data model"
msgstr "カスタムJPAエンティティーを{project_name}データモデルへ追加"

msgid "Add custom REST endpoints"
msgstr "カスタムRESTエンドポイントを追加"

msgid ""
"This is a very powerful extension, which allows you to deploy your own REST "
"endpoints to the {project_name} server. It enables all kinds of extensions, "
"for example the possibility to trigger functionality on the {project_name} "
"server, which is not available through the default set of built-in "
"{project_name} REST endpoints."
msgstr ""
"これは大変強力な拡張機能で、独自のRESTエンドポイントを{project_name}サーバーにデプロイすることができます。これによって、あらゆる種類の拡張が可能になります。たとえば、ビルトインの{project_name}"
" RESTエンドポイントのデフォルトセットでは利用できないような機能を{project_name}サーバー上で起動することができます。"

msgid ""
"To add a custom REST endpoint, you need to implement the "
"`RealmResourceProviderFactory` and `RealmResourceProvider` interfaces. "
"`RealmResourceProvider` has one important method:"
msgstr ""
"カスタムRESTエンドポイントを追加するには、 `RealmResourceProviderFactory` と "
"`RealmResourceProvider` のインターフェイスを実装する必要があります。 `RealmResourceProvider` "
"には、次の重要なメソッドが1つあります。"

msgid ""
"\n"
"Object getResource();\n"
msgstr ""
"\n"
"Object getResource();\n"

msgid ""
"Use this method to return an object, which acts as a https://github.com/jax-"
"rs[JAX-RS Resource]. For more details, see the Javadoc and our examples. "
"There is a very simple example in the example distribution in "
"`providers/rest` and there is a more advanced example in `providers/domain-"
"extension`, which shows how to add an authenticated REST endpoint and other "
"functionalities like <<_extensions_spi, Adding your own SPI>> or "
"<<_extensions_jpa,Extending the datamodel with custom JPA entities>>."
msgstr ""
"https://github.com/jax-rs[JAX-RSリソース] "
"として機能するオブジェクトを返すためにはこのメソッドを使用します。詳しくは、Javadocとサンプルを参照してください。 "
"`providers/rest` のサンプル配布物には非常に簡単なサンプルがあり、 `providers/domain-extension` "
"にはさらに高度なサンプルがあります。この高度なサンプルには、認証されるRESTエンドポイントと、<<_extensions_spi,独自のSPIの追加>>や<<_extensions_jpa,カスタムJPAエンティティーによるデータモデルの拡張>>のようなその他の機能を、追加する方法が示されます。"

msgid ""
"For details on how to package and deploy a custom provider, refer to the "
"<<_providers,Service Provider Interfaces>> chapter."
msgstr ""
"カスタム・プロバイダーをパッケージングしてデプロイする方法についての詳細は、<<_providers,サービス・プロバイダー・インターフェイス>>の章を参照してください。"

msgid ""
"A custom SPI is especially useful with Custom REST endpoints. Use this "
"procedure to add your own SPI"
msgstr "カスタムSPIは、特にカスタムRESTエンドポイントで有用です。独自のSPIを追加するには、次の手順を使用します。"

msgid ""
"implement the interface `org.keycloak.provider.Spi` and define the ID of "
"your SPI and the `ProviderFactory` and `Provider` classes. That looks like "
"this:"
msgstr ""
"インターフェイス `org.keycloak.provider.Spi` を実装し、SPIのIDと `ProviderFactory` および "
"`Provider` クラスを定義します。例えば、次のようになります。"

msgid ""
"package org.keycloak.examples.domainextension.spi;\n"
"\n"
"import ...\n"
"\n"
"public class ExampleSpi implements Spi {\n"
"\n"
"    @Override\n"
"    public boolean isInternal() {\n"
"        return false;\n"
"    }\n"
"\n"
"    @Override\n"
"    public String getName() {\n"
"        return \"example\";\n"
"    }\n"
"\n"
"    @Override\n"
"    public Class<? extends Provider> getProviderClass() {\n"
"        return ExampleService.class;\n"
"    }\n"
"\n"
"    @Override\n"
"    @SuppressWarnings(\"rawtypes\")\n"
"    public Class<? extends ProviderFactory> getProviderFactoryClass() {\n"
"        return ExampleServiceProviderFactory.class;\n"
"    }\n"
"\n"
"}\n"
msgstr ""
"package org.keycloak.examples.domainextension.spi;\n"
"\n"
"import ...\n"
"\n"
"public class ExampleSpi implements Spi {\n"
"\n"
"    @Override\n"
"    public boolean isInternal() {\n"
"        return false;\n"
"    }\n"
"\n"
"    @Override\n"
"    public String getName() {\n"
"        return \"example\";\n"
"    }\n"
"\n"
"    @Override\n"
"    public Class<? extends Provider> getProviderClass() {\n"
"        return ExampleService.class;\n"
"    }\n"
"\n"
"    @Override\n"
"    @SuppressWarnings(\"rawtypes\")\n"
"    public Class<? extends ProviderFactory> getProviderFactoryClass() {\n"
"        return ExampleServiceProviderFactory.class;\n"
"    }\n"
"\n"
"}\n"

msgid ""
"Create the file `META-INF/services/org.keycloak.provider.Spi` and add the "
"class of your SPI to it. For example:"
msgstr ""
"`META-INF/services/org.keycloak.provider.Spi` "
"ファイルを作成し、そのファイルにSPIのクラスを追加します。たとえば、"

msgid "org.keycloak.examples.domainextension.spi.ExampleSpi"
msgstr "org.keycloak.examples.domainextension.spi.ExampleSpi"

msgid ""
"Create the interfaces `ExampleServiceProviderFactory`, which extends from "
"`ProviderFactory` and `ExampleService`, which extends from `Provider`. The "
"`ExampleService` will usually contain the business methods you need for your"
" use case. Note that the `ExampleServiceProviderFactory` instance is always "
"scoped per application, however `ExampleService` is scoped per-request (or "
"more accurately per `KeycloakSession` lifecycle)."
msgstr ""
"`ExampleServiceProviderFactory` インターフェイスを作成します。このインターフェイスは、 `Provider` を継承する"
" `ProviderFactory` と `ExampleService` を継承します。 `ExampleService` "
"には通常、ユースケースで必要なビジネスメソッドが含まれます。 `ExampleServiceProviderFactory` "
"インスタンスは常にアプリケーション毎にスコープされますが、 `ExampleService` はリクエスト毎にスコープされます（より正確に言うと "
"`KeycloakSession` ライフサイクル毎にスコープされます）。"

msgid ""
"Finally you need to implement your providers in the same manner as described"
" in the <<_providers,Service Provider Interfaces>> chapter."
msgstr ""
"最後に、<<_providers,サービス・プロバイダー・インターフェイス>>の章で説明したのと同じ方法で、プロバイダーを実装する必要があります。"

msgid ""
"For more details, take a look at the example distribution at "
"`providers/domain-extension`, which shows an Example SPI similar to the one "
"above."
msgstr ""
"詳しくは、 `providers/domain-extension` "
"配布物のサンプルを参照してください。そこには、上記と同じようなSPIのサンプルが示されています。"

msgid "<<_extensions_rest,Custom REST endpoints>>"
msgstr "<<_extensions_rest,カスタムRESTエンドポイント>>"

msgid ""
"If the {project_name} data model does not exactly match your desired "
"solution, or if you want to add some core functionality to {project_name}, "
"or when you have your own REST endpoint, you might want to extend the "
"{project_name} data model. We enable you to add your own JPA entities to the"
" {project_name} JPA `EntityManager` ."
msgstr ""
"{project_name}データモデルが要求するソリューションとは厳密には違っていた場合やコアの機能を{project_name}に追加する場合、もしくは独自のRESTエンドポイントがある場合、{project_name}データモデルの拡張が検討した方がいいかもしれません。独自のJPAエンティティーを{project_name}のJPA"
" `EntityManager` へ追加することが可能になりました。"

msgid ""
"To add your own JPA entities, you need to implement "
"`JpaEntityProviderFactory` and `JpaEntityProvider`. The `JpaEntityProvider` "
"allows you to return a list of your custom JPA entities and provide the "
"location and id of the Liquibase changelog. An example implementation can "
"look like this:"
msgstr ""
"独自のJPAエンティティーを追加するには、 `JpaEntityProviderFactory` と `JpaEntityProvider` "
"を実装する必要があります。 `JpaEntityProvider` "
"によって、カスタムJPAエンティティーのリストを返し、Liquibaseの変更履歴の場所とidを提供することができます。実装サンプルは、以下のとおりになります。"

msgid ""
"This is an unsupported API, which means you can use it but there is no "
"guarantee that it will not be removed or changed without warning."
msgstr "これはサポートされていないAPIです。つまり、使用することはできますが、警告なしで削除または変更される可能性があります。"

msgid ""
"public class ExampleJpaEntityProvider implements JpaEntityProvider {\n"
"\n"
"    // List of your JPA entities.\n"
"    @Override\n"
"    public List<Class<?>> getEntities() {\n"
"        return Collections.<Class<?>>singletonList(Company.class);\n"
"    }\n"
"\n"
"    // This is used to return the location of the Liquibase changelog file.\n"
"    // You can return null if you don't want Liquibase to create and update the DB schema.\n"
"    @Override\n"
"    public String getChangelogLocation() {\n"
"    \treturn \"META-INF/example-changelog.xml\";\n"
"    }\n"
"\n"
"    // Helper method, which will be used internally by Liquibase.\n"
"    @Override\n"
"    public String getFactoryId() {\n"
"        return \"sample\";\n"
"    }\n"
"\n"
"    ...\n"
"}"
msgstr ""
"public class ExampleJpaEntityProvider implements JpaEntityProvider {\n"
"\n"
"    // List of your JPA entities.\n"
"    @Override\n"
"    public List<Class<?>> getEntities() {\n"
"        return Collections.<Class<?>>singletonList(Company.class);\n"
"    }\n"
"\n"
"    // This is used to return the location of the Liquibase changelog file.\n"
"    // You can return null if you don't want Liquibase to create and update the DB schema.\n"
"    @Override\n"
"    public String getChangelogLocation() {\n"
"    \treturn \"META-INF/example-changelog.xml\";\n"
"    }\n"
"\n"
"    // Helper method, which will be used internally by Liquibase.\n"
"    @Override\n"
"    public String getFactoryId() {\n"
"        return \"sample\";\n"
"    }\n"
"\n"
"    ...\n"
"}"

msgid ""
"In the example above, we added a single JPA entity represented by class "
"`Company`. In the code of your REST endpoint, you can then use something "
"like this to retrieve `EntityManager` and call DB operations on it."
msgstr ""
"上記のサンプルに、 `Company` "
"クラスによって表現された単一のJPAエンティティーを追加しました。次に、RESTエンドポイントのコード内で、これと同じようなものを使用して "
"`EntityManager` を取得し、その上でDBオペレーションを呼び出すことができます。"

msgid ""
"EntityManager em = session.getProvider(JpaConnectionProvider.class).getEntityManager();\n"
"Company myCompany = em.find(Company.class, \"123\");"
msgstr ""
"EntityManager em = session.getProvider(JpaConnectionProvider.class).getEntityManager();\n"
"Company myCompany = em.find(Company.class, \"123\");"

msgid ""
"The methods `getChangelogLocation` and `getFactoryId` are important to "
"support automatic updating of your entities by Liquibase. "
"https://www.liquibase.org/[Liquibase] is a framework for updating the "
"database schema, which {project_name} internally uses to create the DB "
"schema and update the DB schema among versions. You may need to use it as "
"well and create a changelog for your entities. Note that versioning of your "
"own Liquibase changelog is independent of {project_name} versions. In other "
"words, when you update to a new {project_name} version, you are not forced "
"to update your schema at the same time. And vice versa, you can update your "
"schema even without updating the {project_name} version. The Liquibase "
"update is always done at the server startup, so to trigger a DB update of "
"your schema, you just need to add the new changeset to your Liquibase "
"changelog file (in the example above it's the file `META-INF/example-"
"changelog.xml` which must be packed in same JAR as the JPA entities and "
"`ExampleJpaEntityProvider`) and then restart server. The DB schema will be "
"automatically updated at startup."
msgstr ""
"`getChangelogLocation` と `getFactoryId` "
"のメソッドは、Liquibaseによるエンティティーの自動更新をサポートするために重要です。 "
"https://www.liquibase.org/[Liquibase] "
"はデータベース・スキーマを更新するためのフレームワークです。これは{project_name}で内部的に使用され、DBスキーマを作成してバージョン間でDBスキーマを更新します。これを同じように使用して、エンティティーの変更履歴を作成する必要があるかもしれません。独自のLiquibaseの変更履歴のバージョニングは{project_name}のバージョンとは異なる独立したものであることに注意してください。つまり、新しい{project_name}バージョンへ更新した際、同時にスキーマを更新する必要はありません。また、その逆の場合でも、{project_name}バージョンを更新しなくてもスキーマを更新することができます。Liquibaseの更新は常にサーバー起動時に実行されるので、新しい変更セットをLiquibaseの変更履歴ファイル（上記のサンプルでは、これは"
" `META-INF/example-changelog.xml` ファイル（これはJPAエンティティーと "
"`ExampleJpaEntityProvider` "
"と同じJAR内に含まれていなければなりません）になります）を追加して再起動するだけで、スキーマのDB更新のトリガーとなります。起動時に、DBスキーマが自動的に更新されます。"

msgid ""
"For more details, take a look at the example distribution at example "
"`providers/domain-extension`, which shows the `ExampleJpaEntityProvider` and"
" `example-changelog.xml` described above."
msgstr ""
"詳しくは、 `providers/domain-extension` サンプル内のサンプル配布物を参照してください。そこでは、上記で説明された "
"`ExampleJpaEntityProvider` と `example-changelog.xml` のサンプルが示されています。"

msgid ""
"Don't forget to always back up your database before doing any changes in the"
" Liquibase changelog and triggering a DB update."
msgstr "Liquibase変更履歴に変更を加えたりDBの更新をトリガーにする前に、必ずデータベースをバックアップするようにしてください。"

msgid "Authentication SPI"
msgstr "認証SPI"

msgid ""
"{project_name} includes a range of different authentication mechanisms: "
"kerberos, password, otp and others. These mechanisms may not meet all of "
"your requirements and you may want to plug in your own custom ones. "
"{project_name} provides an authentication SPI that you can use to write new "
"plugins. The Admin Console supports applying, ordering, and configuring "
"these new mechanisms."
msgstr ""
"{project_name}には、ケルベロス、パスワード、OTPなどのさまざまな認証機構が用意されています。これらの機構は、要件をすべて満たしているわけではなく、独自のカスタムプラグインを必要とする場合もあります。{project_name}は、新しいプラグインの作成に使用できる認証SPIを提供します。管理コンソールは、これらの新しい機構の適用、順序、設定をサポートしています。"

msgid ""
"{project_name} also supports a simple registration form. Different aspects "
"of this form can be enabled and disabled for example Recaptcha support can "
"be turned off and on. The same authentication SPI can be used to add another"
" page to the registration flow or reimplement it entirely. There's also an "
"additional fine-grained SPI you can use to add specific validations and user"
" extensions to the built-in registration form."
msgstr ""
"{project_name}では簡単な登録フォームもサポートされます。このフォームのさまざまな要素を有効、無効にすることができます。たとえば、reCAPTCHAのサポートをオフにすることができます。同じ認証SPIを使用して、他のページを登録フローに追加したり、それを完全に再実装することができます。また、追加のきめ細かいSPIを使用して、組み込みの登録フォームに特定のバリデーションやユーザー拡張機能を追加することもできます。"

msgid ""
"A required action in {project_name} is an action that a user has to perform "
"after he authenticates. After the action is performed successfully, the user"
" doesn't have to perform the action again. {project_name} comes with some "
"built in required actions like \"reset password\".  This action forces the "
"user to change their password after they have logged in. You can write and "
"plug in your own required actions."
msgstr ""
"{project_name}での必須アクションとは、認証後にユーザーが実行する必要のあるアクションのことです。アクションが実行された後、ユーザーはそのアクションを再実行する必要はありません。{project_name}には、\"パスワードリセット\"などの必須アクションがいくつか組み込まれています。たとえば、パスワードリセットは、ユーザーがログインした後にパスワードを変更するよう強制します。必須アクションを作成してプラグインすることができます。"

msgid ""
"If your authenticator or required action implementation is using some user "
"attributes as the metadata attributes for linking/establishing the user "
"identity, then please make sure that users are not able to edit the "
"attributes and the corresponding attributes are read-only. See the details "
"in the link:{adminguide_link}#_read_only_user_attributes[Threat model "
"mitigation chapter]."
msgstr ""
"オーセンティケーターまたは必須アクションの実装で、ユーザーのアイデンティティーをリンク/確立するためのメタデータ属性として一部のユーザー属性を使用している場合は、ユーザーが属性を編集できず、対応する属性が読み取り専用であることを確認してください。詳細については"
" link:{adminguide_link}#_read_only_user_attributes[脅威モデルの緩和の章] を参照してください。"

msgid "Terms"
msgstr "用語"

msgid ""
"To first learn about the Authentication SPI, let's go over some of the terms"
" used to describe it."
msgstr "まず最初に、認証SPIについて学ぶには、それを説明するためのいくつかの用語を確認していきます。"

msgid "Authentication Flow"
msgstr "認証フロー"

msgid ""
"A flow is a container for all authentications that must happen during login "
"or registration. If you go to the Admin Console authentication page, you can"
" view all the defined flows in the system and what authenticators they are "
"made up of. Flows can contain other flows. You can also bind a new different"
" flow for browser login, direct grant access, and registration."
msgstr ""
"フローは、ログインまたは登録中に必ず発生するすべての認証のためのコンテナーです。管理コンソールの認証ページに移動すると、システム内で定義されたすべてのフローと、どのようなオーセンティケーターで構成されているかが表示されます。フローには、他のフローを含めることができます。また、ブラウザーのログイン、ダイレクト・グラント・アクセス、および登録用に、新しい異なるフローをバインドすることもできます。"

msgid ""
"An authenticator is a pluggable component that hold the logic for performing"
" the authentication or action within a flow. It is usually a singleton."
msgstr ""
"オーセンティケーターは、フロー内で認証またはアクションを実行するためのロジックを保持する、プラグイン可能なコンポーネントです。通常は、シングルトンです。"

msgid "Execution"
msgstr "エグゼキューション"

msgid ""
"An execution is an object that binds the authenticator to the flow and the "
"authenticator to the configuration of the authenticator. Flows contain "
"execution entries."
msgstr ""
"エグゼキューションは、オーセンティケーターをフローにバインドしたり、オーセンティケーターの設定にオーセンティケーターをバインドするオブジェクトです。フローには、エグゼキューション・エントリーが含まれます。"

msgid "Execution Requirement"
msgstr "エグゼキューションのRequirement"

msgid ""
"Each execution defines how an authenticator behaves in a flow. The "
"requirement defines whether the authenticator is enabled, disabled, "
"conditional, required, or an alternative. An alternative requirement means "
"that the authenticator is enough to validate the flow it's in, but isn't "
"necessary. For example, in the built-in browser flow, cookie authentication,"
" the Identity Provider Redirector, and the set of all authenticators in the "
"forms subflow are all alternative. As they are executed in a sequential top-"
"to-bottom order, if one of them is successful, the flow is successful, and "
"any following execution in the flow (or sub-flow) is not evaluated."
msgstr ""
"エグゼキューションごとに、オーセンティケーターがフロー内でどのように動作するかを定義します。要件には、オーセンティケーターがenabled、disabled、conditional、required、またはalternativeのいずれであるかを定義します。alternativeの要件は、オーセンティケーターがそれが入っているフローを検証するのに十分であることを意味しますが、必須ではありません。たとえば、組み込みのブラウザーフローでは、Cookie認証、アイデンティティー・プロバイダー・リダイレクター、およびフォーム・サブフロー内のすべてのオーセンティケーターのセットがすべてalternativeです。これらは上から下へ順番に実行されるため、そのうちの1つが成功した場合、フローは成功し、フロー（またはサブフロー）での後続のエグゼキューションは評価されません。"

msgid "Authenticator Config"
msgstr "オーセンティケーター設定"

msgid ""
"This object defines the configuration for the Authenticator for a specific "
"execution within an authentication flow. Each execution can have a different"
" config."
msgstr ""
"このオブジェクトは、認証フロー内の特定のエグゼキューションに対してのオーセンティケーターの設定を定義します。エグゼキューションごとに異なる設定を持つことができます。"

msgid "Required Action"
msgstr "必須アクション"

msgid ""
"After authentication completes, the user might have one or more one-time "
"actions he must complete before he is allowed to login. The user might be "
"required to set up an OTP token generator or reset an expired password or "
"even accept a Terms and Conditions document."
msgstr ""
"認証が完了した後、ユーザーは、ログインを許可される前に完了する必要がある1つ以上の1回限りのアクションを行う場合があります。ユーザーは、OTPトークン・ジェネレーターをセットアップするか、期限切れのパスワードをリセットするか、利用規約文書に同意する必要があります。"

msgid "Algorithm overview"
msgstr "アルゴリズムの概要"

msgid ""
"Let's talk about how this all works for browser login. Let's assume the "
"following flows, executions and sub flows."
msgstr "これがブラウザー・ログインでどのように機能するか説明します。以下のフロー、エグゼキューション、サブフローを想定してみましょう。"

msgid ""
"\n"
"Cookie - ALTERNATIVE\n"
"Kerberos - ALTERNATIVE\n"
"Forms subflow - ALTERNATIVE\n"
"           Username/Password Form - REQUIRED\n"
"           Conditional OTP subflow - CONDITIONAL\n"
"                      Condition - User Configured - REQUIRED\n"
"                      OTP Form - REQUIRED"
msgstr ""
"\n"
"Cookie - ALTERNATIVE\n"
"Kerberos - ALTERNATIVE\n"
"Forms subflow - ALTERNATIVE\n"
"           Username/Password Form - REQUIRED\n"
"           Conditional OTP subflow - CONDITIONAL\n"
"                      Condition - User Configured - REQUIRED\n"
"                      OTP Form - REQUIRED"

msgid ""
"In the top level of the form we have 3 executions of which all are "
"alternatively required. This means that if any of these are successful, then"
" the others do not have to execute. The Username/Password form is not "
"executed if there is an SSO Cookie set or a successful Kerberos login. Let's"
" walk through the steps from when a client first redirects to keycloak to "
"authenticate the user."
msgstr ""
"フォームのトップレベルには、すべてが選択的に必要な3つのエグゼキューションがあります。これらのいずれかが成功した場合、ほかは実行する必要がないことを意味します。SSO"
" "
"Cookieセットまたはケルベロスのログインが成功した場合、Username/Passwordフォームは実行されません。クライアントが最初にKeycloakにリダイレクトし、ユーザーを認証するまでの手順を説明します。"

msgid ""
"The OpenID Connect or SAML protocol provider unpacks relevant data, verifies"
" the client and any signatures. It creates an AuthenticationSessionModel. It"
" looks up what the browser flow should be, then starts executing the flow."
msgstr ""
"OpenID "
"ConnectまたはSAMLプロトコル・プロバイダーは、関連するデータを展開し、クライアントと署名を検証します。AuthenticationSessionModelを作成します。ブラウザーフローを検索し、フローの実行を開始します。"
" "

msgid ""
"The flow looks at the cookie execution and sees that it is an alternative. "
"It loads the cookie provider. It checks to see if the cookie provider "
"requires that a user already be associated with the authentication session. "
"Cookie provider does not require a user. If it did, the flow would abort and"
" the user would see an error screen. Cookie provider then executes. Its "
"purpose is to see if there is an SSO cookie set. If there is one set, it is "
"validated and the UserSessionModel is verified and associated with the "
"AuthenticationSessionModel. The Cookie provider returns a success() status "
"if the SSO cookie exists and is validated. Since the cookie provider "
"returned success and each execution at this level of the flow is "
"ALTERNATIVE, no other execution is executed and this results in a successful"
" login. If there is no SSO cookie, the cookie provider returns with a status"
" of attempted().  This means there was no error condition, but no success "
"either. The provider tried, but the request just wasn't set up to handle "
"this authenticator."
msgstr ""
"このフローは、Cookieのエグゼキューションを参照し、それがALTERNATIVEであることを確認します。そして、Cookieプロバイダーをロードし、ユーザーが認証セッションに関連付けられていることをCookieプロバイダーが要求しているかどうかを確認します。Cookieプロバイダーには、ユーザーは必要ありません。もしそうであれば、フローは中断され、ユーザーにはエラー画面が表示されます。その後、Cookieプロバイダーが実行されます。その目的は、SSO"
" Cookieセットがあるかどうかを確認することです。1つのセットがある場合、そのSSO "
"CookieとUserSessionModelが検証され、AuthenticationSessionModelに関連付けられます。SSO "
"Cookieが存在し、検証が済むと、Cookieプロバイダーはsuccess()ステータスを返します。Cookieプロバイダーは成功を返すと、このフローのレベルでのそれぞれのエグゼキューションはALTERNATIVEであるため、他のエグゼキューションは実行されず、ログインに成功します。SSO"
" "
"Cookieが存在しない場合は、Cookieプロバイダーはattempted()のステータスを返します。この場合、エラー状態ではありませんが、成功でもないことを意味します。プロバイダーは試行しましたが、リクエストはこのオーセンティケーターを処理するようには設定されていませんでした。"

msgid ""
"Next the flow looks at the Kerberos execution. This is also an alternative. "
"The kerberos provider also does not require a user to be already set up and "
"associated with the AuthenticationSessionModel so this provider is executed."
" Kerberos uses the SPNEGO browser protocol. This requires a series of "
"challenge/responses between the server and client exchanging negotiation "
"headers. The kerberos provider does not see any negotiate header, so it "
"assumes that this is the first interaction between the server and client. It"
" therefore creates an HTTP challenge response to the client and sets a "
"forceChallenge() status. A forceChallenge() means that this HTTP response "
"cannot be ignored by the flow and must be returned to the client. If instead"
" the provider returned a challenge() status, the flow would hold the "
"challenge response until all other alternatives are attempted. So, in this "
"initial phase, the flow would stop and the challenge response would be sent "
"back to the browser. If the browser then responds with a successful "
"negotiate header, the provider associates the user with the "
"AuthenticationSession and the flow ends because the rest of the executions "
"on this level of the flow are all alternatives. Otherwise, again, the "
"kerberos provider sets an attempted() status and the flow continues."
msgstr ""
"次に、フローはケルベロス・エグゼキューションを参照します。これもALTERNATIVEです。ケルベロス・プロバイダーもまた、このプロバイダーを実行されるように、ユーザーに設定されていることと、AuthenticationSessionModelに関連付けられていることを要求しません。ケルベロスは、SPNEGOブラウザー・プロトコルを使用します。これは、サーバーとクライアントがネゴシエーション・ヘッダーを交換する一連のチャレンジ/レスポンスを必要とします。ケルベロス・プロバイダーは、ネゴシエーション・ヘッダーをまったく見ないため、これがサーバーとクライアント間の最初のやりとりであることを前提とします。したがって、クライアントへのHTTPチャレンジ・レスポンスを作成し、forceChallenge()ステータスを設定します。forceChallenge()は、このHTTPレスポンスがフローで無視できないため、クライアントに返す必要があることを意味します。代わりにプロバイダーがchallenge()ステータスを返した場合、フローは他のすべてのALTERNATIVEが試行されるまでチャレンジ・レスポンスを保持します。したがって、この初期フェーズでフローが停止し、チャレンジ・レスポンスがブラウザーに返されます。ブラウザーが成功のネゴシエーション・ヘッダーで応答すると、プロバイダーはユーザーをAuthenticationSessionに関連付け、フローが終了します（このフローのレベルの残りのエグゼキューションはALTERNATIVEであるため）。それ以外の場合は、ケルベロス・プロバイダーは、attempted()を設定し、フローを続行します。"

msgid ""
"The next execution is a subflow called Forms. The executions for this "
"subflow are loaded and the same processing logic occurs."
msgstr ""
"次のエグゼキューションは、Formsと呼ばれるサブフローです。このサブフローのエグゼキューションがロードされ、同じ処理ロジックが発生します。"

msgid ""
"The first execution in the Forms subflow is the UsernamePassword provider. "
"This provider also does not require for a user to already be associated with"
" the flow. This provider creates a challenge HTTP response and sets its "
"status to challenge(). This execution is required, so the flow honors this "
"challenge and sends the HTTP response back to the browser. This response is "
"a rendering of the Username/Password HTML page. The user enters in their "
"username and password and clicks submit. This HTTP request is directed to "
"the UsernamePassword provider. If the user entered an invalid username or "
"password, a new challenge response is created and a status of "
"failureChallenge() is set for this execution. A failureChallenge() means "
"that there is a challenge, but that the flow should log this as an error in "
"the error log. This error log can be used to lock accounts or IP Addresses "
"that have had too many login failures. If the username and password is "
"valid, the provider associated the UserModel with the "
"AuthenticationSessionModel and returns a status of success()."
msgstr ""
"Formsサブフローの最初のエグゼキューションは、UsernamePasswordプロバイダーです。このプロバイダーも、ユーザーがフローに関連付けられていることを要求しません。このプロバイダーは、チャレンジHTTPレスポンスを作成し、そのステータスをchallenge()に設定します。このエグゼキューションは必須なので、フローはこのチャレンジを優先し、ブラウザーにHTTPレスポンスを返します。このレスポンスは、Username/Password"
" "
"HTMLページのレンダリングです。ユーザーは、ユーザー名とパスワードを入力し、送信をクリックします。このHTTPリクエストは、UsernamePasswordプロバイダーに送信されます。ユーザーが無効なユーザー名またはパスワードを入力した場合、新しいチャレンジ・レスポンスが作成され、このエグゼキューションにfailureChallenge()のステータスが設定されます。failureChallenge()は、チャレンジがあるが、エラーログにエラーとして記録する必要があることを意味します。このエラーログは、ログイン失敗回数の多いアカウントまたはIPアドレスをロックするのに使用できます。ユーザー名とパスワードが有効な場合、プロバイダーはUserModelをAuthenticationSessionModelに関連付け、success()ステータスを返します。"

msgid ""
"The next execution is a subflow called Conditional OTP. The executions for "
"this subflow are loaded and the same processing logic occurs. Its "
"Requirement is Conditional. This means that the flow will first evaluate all"
" conditional executors that it contains. Conditional executors are "
"authenticators that implement `ConditionalAuthenticator`, and must implement"
" the method `boolean matchCondition(AuthenticationFlowContext context)`. A "
"conditional subflow will call the `matchCondition` method of all conditional"
" executions it contains, and if all of them evaluate to true, it will act as"
" if it was a required subflow. If not, it will act as if it was a disabled "
"subflow. Conditional authenticators are only used for this purpose, and are "
"not used as authenticators. This means that even if the conditional "
"authenticator evaluates to \"true\", then this will not mark a flow or "
"subflow as successful. For example, a flow containing only a Conditional "
"subflow with only a conditional authenticator will never allow a user to log"
" in."
msgstr ""
"次のエグゼキューションは、Conditional "
"OTPと呼ばれるサブフローです。このサブフローのエグゼキューションがロードされ、同じ処理ロジックが発生します。そのRequirementはConditionalです。これは、フローが最初に含まれるすべてのConditionalエグゼキューターを評価することを意味します。Conditionalエグゼキューターは"
" `ConditionalAuthenticator` を実装するオーセンティケーターであり、メソッド `boolean "
"matchCondition(AuthenticationFlowContext context)` "
"を実装する必要があります。Conditionalサブフローは、含まれるすべてのConditionalエグゼキューションの "
"`matchCondition` "
"メソッドを呼び出し、それらすべてがtrueと評価されると、必要なサブフローであるかのように動作します。そうでない場合は、無効なサブフローであるかのように動作します。Conditionalオーセンティケーターはこの目的にのみ使用され、オーセンティケーターとしては使用されません。これは、Conditionalオーセンティケーターが"
" \"true\" "
"と評価した場合でも、フローまたはサブフローが成功としてマークされないことを意味します。たとえば、Conditionalオーセンティケーターのみを持つConditionalサブフローのみを含むフローでは、ユーザーはログインできません。"

msgid ""
"The first execution of the Conditional OTP subflow is the Condition - User "
"Configured. This provider requires that a user has been associated with the "
"flow. This requirement is satisfied because the UsernamePassword provider "
"already associated the user with the flow. This provider's `matchCondition` "
"method will evaluate the `configuredFor` method for all other Authenticators"
" in its current subflow. If the subflow contains executors with their "
"Requirement set to required, then the `matchCondition` method will only "
"evaluate to true if all the required authenticators' `configuredFor` method "
"evaluate to true. Otherwise, the `matchCondition` method will evaluate to "
"true if any alternative authenticator evaluates to true."
msgstr ""
"Conditional OTPサブフローの最初のエグゼキューションは、Condition - User "
"Configuredです。このプロバイダーでは、ユーザーがフローに関連付けられている必要があります。UsernamePasswordプロバイダーは既にユーザーをフローに関連付けているため、このRequirementは満たされています。このプロバイダーの"
" `matchCondition` メソッドは、現在のサブフロー内の他のすべてのオーセンティケーターの `configuredFor` "
"メソッドを評価します。サブフローに、Requirementがrequiredに設定されたエグゼキューターが含まれている場合、必要なすべてのオーセンティケーターの"
" `configuredFor` メソッドがtrueに評価される場合にのみ、`matchCondition` "
"メソッドはtrueに評価されます。それ以外の場合、alternativeオーセンティケーターがtrueと評価されると、 `matchCondition`"
" メソッドがtrueと評価されます。"

msgid ""
"The next execution is the OTP Form. This provider also requires that a user "
"has been associated with the flow. This requirement is satisfied because the"
" UsernamePassword provider already associated the user with the flow. Since "
"a user is required for this provider, the provider is also asked if the user"
" is configured to use this provider. If user is not configured, then the "
"flow will then set up a required action that the user must perform after "
"authentication is complete. For OTP, this means the OTP setup page. If the "
"user is configured, he will be asked to enter his otp code. In our scenario,"
" because of the conditional sub-flow, the user will never see the OTP login "
"page, unless the Conditional OTP subflow is set to Required."
msgstr ""
"次のエグゼキューションは、OTPフォームです。このプロバイダーでも、ユーザーがフローに関連付けられている必要があります。UsernamePasswordプロバイダーがすでにユーザーをフローに関連付けているため、この要件は満たされます。このプロバイダーは、ユーザーが必須であることから、ユーザーがこのプロバイダーを使用するように設定されているかを求められます。ユーザーが設定されていない場合、フローは認証が完了した後にユーザーが実行する必要のある必須アクションを設定します。OTPの場合、これはOTP設定ページを意味します。ユーザーが設定されている場合、ユーザーはOTPコードを入力するよう求められます。このシナリオでは、Conditional"
" サブフローのため、Conditional OTPサブフローが必須に設定されていない限り、ユーザーにはOTPログインページが表示されません。"

msgid ""
"After the flow is complete, the authentication processor creates a "
"UserSessionModel and associates it with the AuthenticationSessionModel. It "
"then checks to see if the user is required to complete any required actions "
"before logging in."
msgstr ""
"フローが完了すると、認証プロセッサーはUserSessionModelを作成し、それをAuthenticationSessionModelに関連付けます。その後、ユーザーはログイン前に必須アクションを完了する必要があるかどうかを確認します。"

msgid ""
"First, each required action's evaluateTriggers() method is called. This "
"allows the required action provider to figure out if there is some state "
"that might trigger the action to be fired. For example, if your realm has a "
"password expiration policy, it might be triggered by this method."
msgstr ""
"まず、それぞれの必須アクションのevaluateTriggers()メソッドが呼び出されます。これにより、必須アクション・プロバイダーは、アクションが実行されるトリガーとなる可能性があるかを判断できます。たとえば、レルムにパスワード有効期限ポリシーがある場合、このメソッドによってトリガーされる可能性があります。"

msgid ""
"Each required action associated with the user that has its "
"requiredActionChallenge() method called. Here the provider sets up an HTTP "
"response which renders the page for the required action. This is done by "
"setting a challenge status."
msgstr ""
"ユーザーに関連付けられた各必須アクションにあるrequiredActionChallenge()メソッドが呼び出されます。ここでプロバイダーは、必須アクションのページをレンダリングするHTTPレスポンスをセットアップします。これは、チャレンジ・ステータスを設定することで実行されます。"

msgid ""
"If the required action is ultimately successful, then the required action is"
" removed from the user's required actions list."
msgstr "必須アクションが最終的に成功すると、ユーザーの必須アクションリストから必須アクションが削除されます。"

msgid ""
"After all required actions have been resolved, the user is finally logged "
"in."
msgstr "すべての必須アクションが解決した後、ユーザーはようやくログインしたことになります。"

msgid "Authenticator SPI walk through"
msgstr "オーセンティケーターSPIのウォークスルー"

msgid ""
"In this section, we'll take a look at the Authenticator interface. For this,"
" we are going to implement an authenticator that requires that a user enter "
"in the answer to a secret question like \"What is your mother's maiden "
"name?\". This example is fully implemented and contained in the "
"examples/providers/authenticator directory of the demo distribution of "
"{project_name}."
msgstr ""
"このセクションでは、オーセンティケーター・インターフェイスについて説明します。これを説明するために、\"あなたの母親の旧姓は何ですか？\"のような秘密の質問にユーザーが回答を入力する必要のあるオーセンティケーターを実装していきます。この例は、完全に実装されており、{project_name}のデモ配布物のexamples/providers/authenticatorディレクトリーに含まれています。"

msgid ""
"To create an authenticator, you must at minimum implement the "
"org.keycloak.authentication.AuthenticatorFactory and Authenticator "
"interfaces. The Authenticator interface defines the logic. The "
"AuthenticatorFactory is responsible for creating instances of an "
"Authenticator. They both extend a more generic Provider and ProviderFactory "
"set of interfaces that other {project_name} components like User Federation "
"do."
msgstr ""
"オーセンティケーターを作成するには、少なくともorg.keycloak.authentication.AuthenticatorFactoryおよびAuthenticatorインターフェースを実装する必要があります。Authenticatorインターフェイスはロジックを定義します。AuthenticatorFactoryは、Authenticatorインスタンスの作成を担います。それらは両方とも、ユーザー・フェデレーションのような他の{project_name}コンポーネントが行う、より汎用的なProviderとProviderFactoryのインターフェイスのセットを継承します。"

msgid ""
"Some authenticators, like the CookieAuthenticator don't rely on a Credential"
" that the user has or knows to authenticate the user. However, some "
"authenticators, such as the PasswordForm authenticator or the "
"OTPFormAuthenticator rely on the user inputting some information and "
"verifying that information against some information in the database. For the"
" PasswordForm for example, the authenticator will verify the hash of the "
"password against a hash stored in the database, while the "
"OTPFormAuthenticator will verify the OTP received against the one generated "
"from the shared secret stored in the database."
msgstr ""
"CookieAuthenticatorなどの一部のオーセンティケーターは、ユーザーを認証するためにユーザーが持っている、または知っているCredentialに依存しません。ただし、PasswordFormオーセンティケーターやOTPFormAuthenticatorなどの一部のオーセンティケーターは、ユーザーが何らかの情報を入力し、その情報をデータベース内のいくつかの情報と照合することに依存しています。たとえば、PasswordFormの場合、オーセンティケーターはデータベースに保存されているハッシュに対してパスワードのハッシュを検証し、OTPFormAuthenticatorはデータベースに保存されている共有シークレットから生成されたOTPに対して受信したOTPを検証します。"

msgid ""
"These types of authenticators are called CredentialValidators, and will "
"require you to implement a few more classes:"
msgstr ""
"これらのタイプのオーセンティケーターはCredentialValidatorsと呼ばれ、さらに次のいくつかのクラスを実装する必要があります。"

msgid ""
"A class that extends org.keycloak.credential.CredentialModel, and that can "
"generate the correct format of the credential in the database"
msgstr ""
"org.keycloak.credential.CredentialModelを継承し、データベースでクレデンシャルの正しい形式を生成できるクラス"

msgid ""
"A class implementing the org.keycloak.credential.CredentialProvider and "
"interface, and a class implementing its CredentialProviderFactory factory "
"interface."
msgstr ""
"org.keycloak.credential.CredentialProviderとインターフェイスを実装するクラス、およびそのCredentialProviderFactoryファクトリー・インターフェイスを実装するクラス。"

msgid ""
"The SecretQuestionAuthenticator we'll see in this walk through is a "
"CredentialValidator, so we'll see how to implement all these classes."
msgstr ""
"このウォークスルーで確認するSecretQuestionAuthenticatorはCredentialValidatorであるため、これらのクラスをすべて実装する方法を確認します。"

msgid "Packaging classes and deployment"
msgstr "クラスのパッケージ化とデプロイ"

msgid ""
"You will package your classes within a single jar. This jar must contain a "
"file named  `org.keycloak.authentication.AuthenticatorFactory` and must be "
"contained in the `META-INF/services/` directory of your jar. This file must "
"list the fully qualified class name of each AuthenticatorFactory "
"implementation you have in the jar. For example:"
msgstr ""
"1つのjarファイル内にクラスをパッケージ化します。このjarには、 "
"`org.keycloak.authentication.AuthenticatorFactory` という名前のファイルが、jarの `META-"
"INF/services/` "
"ディレクトリーに含まれている必要があります。このファイルには、jarファイル内にある各AuthenticatorFactory実装の完全修飾クラス名が一覧化されている必要があります。たとえば、以下のとおりになります。"

msgid ""
"org.keycloak.examples.authenticator.SecretQuestionAuthenticatorFactory\n"
"org.keycloak.examples.authenticator.AnotherProviderFactory"
msgstr ""
"org.keycloak.examples.authenticator.SecretQuestionAuthenticatorFactory\n"
"org.keycloak.examples.authenticator.AnotherProviderFactory"

msgid ""
"This services/ file is used by {project_name} to scan the providers it has "
"to load into the system."
msgstr ""
"このservices/ファイルは、システムにロードする必要があるプロバイダーを{project_name}がスキャンするために使用されます。"

msgid "To deploy this jar, just copy it to the providers directory."
msgstr "このjarをデプロイするには、これをprovidersディレクトリーにコピーします。"

msgid "Extending the CredentialModel class"
msgstr "CredentialModelクラスの継承"

msgid ""
"In {project_name}, credentials are stored in the database in the Credentials"
" table. It has the following structure:"
msgstr ""
"{project_name}では、クレデンシャルはデータベースのCredentialsテーブルに保存されます。次のテーブル定義になっています。"

msgid ""
"-----------------------------\n"
"| ID                        |\n"
"-----------------------------\n"
"| user_ID                   |\n"
"-----------------------------\n"
"| credential_type           |\n"
"-----------------------------\n"
"| created_date              |\n"
"-----------------------------\n"
"| user_label                |\n"
"-----------------------------\n"
"| secret_data               |\n"
"-----------------------------\n"
"| credential_data           |\n"
"-----------------------------\n"
"| priority                  |\n"
"-----------------------------"
msgstr ""
"-----------------------------\n"
"| ID                        |\n"
"-----------------------------\n"
"| user_ID                   |\n"
"-----------------------------\n"
"| credential_type           |\n"
"-----------------------------\n"
"| created_date              |\n"
"-----------------------------\n"
"| user_label                |\n"
"-----------------------------\n"
"| secret_data               |\n"
"-----------------------------\n"
"| credential_data           |\n"
"-----------------------------\n"
"| priority                  |\n"
"-----------------------------"

msgid "Where:"
msgstr "各列は以下のとおりです。"

msgid "`ID` is the primary key of the credential."
msgstr "`ID` は、Credentialsテーブルの主キーです。"

msgid "`user_ID` is the foreign key linking the credential to a user."
msgstr "`user_ID` は、クレデンシャルをユーザーにリンクする外部キーです。"

msgid ""
"`credential_type` is a string set during the creation that must reference an"
" existing credential type."
msgstr "`credential_type` は、作成中に設定される文字列で、既存のクレデンシャル・タイプを参照する必要があります。"

msgid ""
"`created_date` is the creation timestamp (in long format) of the credential."
msgstr "`created_date` は、クレデンシャルの作成タイムスタンプ（長い形式）です。"

msgid "`user_label` is the editable name of the credential by the user"
msgstr "`user_label` は、ユーザーによるクレデンシャルの編集可能な名前です。"

msgid ""
"`secret_data` contains a static json with the information that cannot be "
"transmitted outside of {project_name}"
msgstr "`secret_data` には、{project_name}の外部に送信できない情報を持つ静的JSONが含まれます。"

msgid ""
"`credential_data` contains a json with the static information of the "
"credential that can be shared in the Admin Console or via the REST API."
msgstr ""
"`credential_data` には、管理コンソールまたはREST APIを介して共有できるクレデンシャルの静的情報を含むJSONが含まれています。"

msgid ""
"`priority` defines how \"preferred\" a credential is for a user, to "
"determine which credential to present when a user has multiple choices."
msgstr ""
"`priority` "
"は、ユーザーが複数の選択肢を持っているときにどのクレデンシャルを提示するかを決定するために、ユーザーにとってクレデンシャルがどのように\"優先される\"かを定義します。"

msgid ""
"As the secret_data and credential_data fields are designed to contain json, "
"it is up to you to determine how to structure, read and write into these "
"fields, allowing you a lot of flexibility."
msgstr ""
"secret_dataフィールドとcredential_dataフィールドはjsonを含むように設計されているため、これらのフィールドの構成や、読み取り、書き込みの方法を柔軟に変更できます。"

msgid ""
"For this example, we are going to use a very simple credential data, "
"containing only the question asked to the user:"
msgstr "この例では、ユーザーに尋ねられた質問のみを含む非常に単純なクレデンシャル・データを使用します。"

msgid ""
"{\n"
"  \"question\":\"aQuestion\"\n"
"}"
msgstr ""
"{\n"
"  \"question\":\"aQuestion\"\n"
"}"

msgid "with an equally simple secret data, containing only the secret answer:"
msgstr "以下は、同様に単純な秘密データを使用します（秘密の答えのみを含む）。"

msgid ""
"{\n"
"  \"answer\":\"anAnswer\"\n"
"}"
msgstr ""
"{\n"
"  \"answer\":\"anAnswer\"\n"
"}"

msgid ""
"Here the answer will be kept in plain text in the database for the sake of "
"simplicity, but it would also be possible to have a salted hash for the "
"answer, as is the case for passwords in {project_name}. In this case, the "
"secret data would also have to contain a field for the salt, and the "
"credential data information about the algorithm such as the type of "
"algorithm used and the number of iterations used. For more details you can "
"consult the implementation of the "
"`org.keycloak.models.credential.PasswordCredentialModel` class."
msgstr ""
"ここでは、簡単にするために、回答はデータベースにプレーンテキストで保存しますが、{project_name}のパスワードの場合のように、回答にソルトハッシュを使用することもできます。この場合、秘密データには、ソルトのフィールドと、使用されたアルゴリズムのタイプや使用された反復数などのアルゴリズムに関するクレデンシャル・データ情報も含まれている必要があります。詳細については、"
" `org.keycloak.models.credential.PasswordCredentialModel` クラスの実装を参照してください。"

msgid "In our case we create the class `SecretQuestionCredentialModel`:"
msgstr "この場合、以下のようなクラス `SecretQuestionCredentialModel` を作成します。"

msgid ""
"public class SecretQuestionCredentialModel extends CredentialModel {\n"
"    public static final String TYPE = \"SECRET_QUESTION\";\n"
"\n"
"    private final SecretQuestionCredentialData credentialData;\n"
"    private final SecretQuestionSecretData secretData;"
msgstr ""
"public class SecretQuestionCredentialModel extends CredentialModel {\n"
"    public static final String TYPE = \"SECRET_QUESTION\";\n"
"\n"
"    private final SecretQuestionCredentialData credentialData;\n"
"    private final SecretQuestionSecretData secretData;"

msgid ""
"Where `TYPE` is the credential_type we write in the database. For "
"consistency, we make sure that this String is always the one referenced when"
" getting the type for this credential. The classes "
"`SecretQuestionCredentialData` and `SecretQuestionSecretData` are used to "
"marshal and unmarshal the json:"
msgstr ""
"`TYPE` "
"は、データベースに書き込むcredential_typeです。一貫性を保つために、このクレデンシャルの型を取得するときにこのStringが常に参照されるようにします。クラス"
" `SecretQuestionCredentialData` と `SecretQuestionSecretData` "
"は、jsonのマーシャリングとアンマーシャリングに使用されます。"

msgid ""
"public class SecretQuestionCredentialData {\n"
"\n"
"    private final String question;\n"
"\n"
"    @JsonCreator\n"
"    public SecretQuestionCredentialData(@JsonProperty(\"question\") String question) {\n"
"        this.question = question;\n"
"    }\n"
"\n"
"    public String getQuestion() {\n"
"        return question;\n"
"    }\n"
"}"
msgstr ""
"public class SecretQuestionCredentialData {\n"
"\n"
"    private final String question;\n"
"\n"
"    @JsonCreator\n"
"    public SecretQuestionCredentialData(@JsonProperty(\"question\") String question) {\n"
"        this.question = question;\n"
"    }\n"
"\n"
"    public String getQuestion() {\n"
"        return question;\n"
"    }\n"
"}"

msgid ""
"public class SecretQuestionSecretData {\n"
"\n"
"     private final String answer;\n"
"\n"
"    @JsonCreator\n"
"     public SecretQuestionSecretData(@JsonProperty(\"answer\") String answer) {\n"
"         this.answer = answer;\n"
"     }\n"
"\n"
"    public String getAnswer() {\n"
"        return answer;\n"
"    }\n"
"}"
msgstr ""
"public class SecretQuestionSecretData {\n"
"\n"
"     private final String answer;\n"
"\n"
"    @JsonCreator\n"
"     public SecretQuestionSecretData(@JsonProperty(\"answer\") String answer) {\n"
"         this.answer = answer;\n"
"     }\n"
"\n"
"    public String getAnswer() {\n"
"        return answer;\n"
"    }\n"
"}"

msgid ""
"To be fully usable, the `SecretQuestionCredentialModel` objects must both "
"contain the raw json data from its parent class, and the unmarshalled "
"objects in its own attributes. This leads us to create a method which reads "
"from a simple CredentialModel, such as is created when reading from the "
"database, to make a `SecretQuestionCredentialModel`:"
msgstr ""
"完全に使用可能にするために、 `SecretQuestionCredentialModel` "
"オブジェクトには、その親クラスからのそのままのjsonデータと、独自の属性のアンマーシャルされたオブジェクトの両方が含まれている必要があります。これにより、データベースから読み取るときに作成されるような単純なCredentialModelから読み取るメソッドを作成し、"
" `SecretQuestionCredentialModel` を作成します。"

msgid ""
"private SecretQuestionCredentialModel(SecretQuestionCredentialData credentialData, SecretQuestionSecretData secretData) {\n"
"    this.credentialData = credentialData;\n"
"    this.secretData = secretData;\n"
"}\n"
"\n"
"public static SecretQuestionCredentialModel createFromCredentialModel(CredentialModel credentialModel){\n"
"    try {\n"
"        SecretQuestionCredentialData credentialData = JsonSerialization.readValue(credentialModel.getCredentialData(), SecretQuestionCredentialData.class);\n"
"        SecretQuestionSecretData secretData = JsonSerialization.readValue(credentialModel.getSecretData(), SecretQuestionSecretData.class);\n"
"\n"
"        SecretQuestionCredentialModel secretQuestionCredentialModel = new SecretQuestionCredentialModel(credentialData, secretData);\n"
"        secretQuestionCredentialModel.setUserLabel(credentialModel.getUserLabel());\n"
"        secretQuestionCredentialModel.setCreatedDate(credentialModel.getCreatedDate());\n"
"        secretQuestionCredentialModel.setType(TYPE);\n"
"        secretQuestionCredentialModel.setId(credentialModel.getId());\n"
"        secretQuestionCredentialModel.setSecretData(credentialModel.getSecretData());\n"
"        secretQuestionCredentialModel.setCredentialData(credentialModel.getCredentialData());\n"
"        return secretQuestionCredentialModel;\n"
"    } catch (IOException e){\n"
"        throw new RuntimeException(e);\n"
"    }\n"
"}"
msgstr ""
"private SecretQuestionCredentialModel(SecretQuestionCredentialData credentialData, SecretQuestionSecretData secretData) {\n"
"    this.credentialData = credentialData;\n"
"    this.secretData = secretData;\n"
"}\n"
"\n"
"public static SecretQuestionCredentialModel createFromCredentialModel(CredentialModel credentialModel){\n"
"    try {\n"
"        SecretQuestionCredentialData credentialData = JsonSerialization.readValue(credentialModel.getCredentialData(), SecretQuestionCredentialData.class);\n"
"        SecretQuestionSecretData secretData = JsonSerialization.readValue(credentialModel.getSecretData(), SecretQuestionSecretData.class);\n"
"\n"
"        SecretQuestionCredentialModel secretQuestionCredentialModel = new SecretQuestionCredentialModel(credentialData, secretData);\n"
"        secretQuestionCredentialModel.setUserLabel(credentialModel.getUserLabel());\n"
"        secretQuestionCredentialModel.setCreatedDate(credentialModel.getCreatedDate());\n"
"        secretQuestionCredentialModel.setType(TYPE);\n"
"        secretQuestionCredentialModel.setId(credentialModel.getId());\n"
"        secretQuestionCredentialModel.setSecretData(credentialModel.getSecretData());\n"
"        secretQuestionCredentialModel.setCredentialData(credentialModel.getCredentialData());\n"
"        return secretQuestionCredentialModel;\n"
"    } catch (IOException e){\n"
"        throw new RuntimeException(e);\n"
"    }\n"
"}"

msgid ""
"And a method to create a `SecretQuestionCredentialModel` from the question "
"and answer:"
msgstr "そして、質問と回答から `SecretQuestionCredentialModel` を生成するメソッドは次のようになります。"

msgid ""
"private SecretQuestionCredentialModel(String question, String answer) {\n"
"    credentialData = new SecretQuestionCredentialData(question);\n"
"    secretData = new SecretQuestionSecretData(answer);\n"
"}\n"
"\n"
"public static SecretQuestionCredentialModel createSecretQuestion(String question, String answer) {\n"
"    SecretQuestionCredentialModel credentialModel = new SecretQuestionCredentialModel(question, answer);\n"
"    credentialModel.fillCredentialModelFields();\n"
"    return credentialModel;\n"
"}\n"
"\n"
"private void fillCredentialModelFields(){\n"
"    try {\n"
"        setCredentialData(JsonSerialization.writeValueAsString(credentialData));\n"
"        setSecretData(JsonSerialization.writeValueAsString(secretData));\n"
"        setType(TYPE);\n"
"        setCreatedDate(Time.currentTimeMillis());\n"
"    } catch (IOException e) {\n"
"        throw new RuntimeException(e);\n"
"    }\n"
"}"
msgstr ""
"private SecretQuestionCredentialModel(String question, String answer) {\n"
"    credentialData = new SecretQuestionCredentialData(question);\n"
"    secretData = new SecretQuestionSecretData(answer);\n"
"}\n"
"\n"
"public static SecretQuestionCredentialModel createSecretQuestion(String question, String answer) {\n"
"    SecretQuestionCredentialModel credentialModel = new SecretQuestionCredentialModel(question, answer);\n"
"    credentialModel.fillCredentialModelFields();\n"
"    return credentialModel;\n"
"}\n"
"\n"
"private void fillCredentialModelFields(){\n"
"    try {\n"
"        setCredentialData(JsonSerialization.writeValueAsString(credentialData));\n"
"        setSecretData(JsonSerialization.writeValueAsString(secretData));\n"
"        setType(TYPE);\n"
"        setCreatedDate(Time.currentTimeMillis());\n"
"    } catch (IOException e) {\n"
"        throw new RuntimeException(e);\n"
"    }\n"
"}"

msgid "Implementing a CredentialProvider"
msgstr "CredentialProviderの実装"

msgid ""
"As with all Providers, to allow {project_name} to generate the "
"CredentialProvider, we require a CredentialProviderFactory. For this "
"requirement we create the SecretQuestionCredentialProviderFactory, whose "
"`create` method will be called when a SecretQuestionCredentialProvider is "
"asked for:"
msgstr ""
"すべてのプロバイダーで同様に、{project_name}がCredentialProviderを生成できるようにするには、CredentialProviderFactoryが必要です。この要件のために、SecretQuestionCredentialProviderFactoryを生成します。SecretQuestionCredentialProviderが要求されたときに、以下のように"
" `create` メソッドが呼び出されます。"

msgid ""
"public class SecretQuestionCredentialProviderFactory implements CredentialProviderFactory<SecretQuestionCredentialProvider> {\n"
"\n"
"    public static final String PROVIDER_ID =  \"secret-question\";\n"
"\n"
"    @Override\n"
"    public String getId() {\n"
"        return PROVIDER_ID;\n"
"    }\n"
"\n"
"    @Override\n"
"    public CredentialProvider create(KeycloakSession session) {\n"
"        return new SecretQuestionCredentialProvider(session);\n"
"    }\n"
"}"
msgstr ""
"public class SecretQuestionCredentialProviderFactory implements CredentialProviderFactory<SecretQuestionCredentialProvider> {\n"
"\n"
"    public static final String PROVIDER_ID =  \"secret-question\";\n"
"\n"
"    @Override\n"
"    public String getId() {\n"
"        return PROVIDER_ID;\n"
"    }\n"
"\n"
"    @Override\n"
"    public CredentialProvider create(KeycloakSession session) {\n"
"        return new SecretQuestionCredentialProvider(session);\n"
"    }\n"
"}"

msgid ""
"The CredentialProvider interface takes a generic parameter that extends a "
"CredentialModel. In our case we to use the SecretQuestionCredentialModel we "
"created:"
msgstr ""
"CredentialProviderインターフェイスは、CredentialModelを継承するジェネリックなパラメーターを扱います。この場合、作成したSecretQuestionCredentialModelを使用します。"

msgid ""
"public class SecretQuestionCredentialProvider implements CredentialProvider<SecretQuestionCredentialModel>, CredentialInputValidator {\n"
"    private static final Logger logger = Logger.getLogger(SecretQuestionCredentialProvider.class);\n"
"\n"
"    protected KeycloakSession session;\n"
"\n"
"    public SecretQuestionCredentialProvider(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"
"\n"
"    private UserCredentialStore getCredentialStore() {\n"
"        return session.userCredentialManager();\n"
"    }"
msgstr ""
"public class SecretQuestionCredentialProvider implements CredentialProvider<SecretQuestionCredentialModel>, CredentialInputValidator {\n"
"    private static final Logger logger = Logger.getLogger(SecretQuestionCredentialProvider.class);\n"
"\n"
"    protected KeycloakSession session;\n"
"\n"
"    public SecretQuestionCredentialProvider(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"
"\n"
"    private UserCredentialStore getCredentialStore() {\n"
"        return session.userCredentialManager();\n"
"    }"

msgid ""
"We also want to implement the CredentialInputValidator interface, as this "
"allows {project_name} to know that this provider can also be used to "
"validate a credential for an Authenticator. For the CredentialProvider "
"interface, the first method that needs to be implemented is the `getType()` "
"method. This will simply return the `SecretQuestionCredentialModel`'s TYPE "
"String:"
msgstr ""
"このプロバイダーを使用してAuthenticatorのクレデンシャルを検証できることを{project_name}が知ることができるため、CredentialInputValidatorインターフェイスも実装します。CredentialProviderインターフェースの場合、実装する必要がある最初のメソッドは"
" `getType()` メソッドです。これは、次のように `SecretQuestionCredentialModel` のTYPE文字列を返します。"

msgid ""
"@Override\n"
"public String getType() {\n"
"    return SecretQuestionCredentialModel.TYPE;\n"
"}"
msgstr ""
"@Override\n"
"public String getType() {\n"
"    return SecretQuestionCredentialModel.TYPE;\n"
"}"

msgid ""
"The second method is to create a `SecretQuestionCredentialModel` from a "
"`CredentialModel`. For this method we simply call the existing static method"
" from `SecretQuestionCredentialModel`:"
msgstr ""
"2番目の方法は、 `CredentialModel` から `SecretQuestionCredentialModel` "
"を作成することです。このメソッドは、 `SecretQuestionCredentialModel` から既存の静的メソッドを呼び出します。"

msgid ""
"@Override\n"
"public SecretQuestionCredentialModel getCredentialFromModel(CredentialModel model) {\n"
"    return SecretQuestionCredentialModel.createFromCredentialModel(model);\n"
"}"
msgstr ""
"@Override\n"
"public SecretQuestionCredentialModel getCredentialFromModel(CredentialModel model) {\n"
"    return SecretQuestionCredentialModel.createFromCredentialModel(model);\n"
"}"

msgid ""
"Finally, we have the methods to create a credential and delete a credential."
" These methods call the KeycloakSession's `userCredentialManager`, which is "
"responsible for knowing where to read or write the credential, for example "
"local storage or federated storage."
msgstr ""
"最後に、クレデンシャルを作成するメソッドと、クレデンシャルを削除するメソッドがあります。これらのメソッドは、KeycloakSessionの "
"`userCredentialManager` "
"を呼び出します。これらには、クレデンシャルの読み取りまたは書き込みの場所（たとえば、ローカル・ストレージやフェデレーション・ストレージなど）を把握する責任があります。"

msgid ""
"@Override\n"
"public CredentialModel createCredential(RealmModel realm, UserModel user, SecretQuestionCredentialModel credentialModel) {\n"
"    if (credentialModel.getCreatedDate() == null) {\n"
"        credentialModel.setCreatedDate(Time.currentTimeMillis());\n"
"    }\n"
"    return getCredentialStore().createCredential(realm, user, credentialModel);\n"
"}\n"
"\n"
"@Override\n"
"public boolean deleteCredential(RealmModel realm, UserModel user, String credentialId) {\n"
"    return getCredentialStore().removeStoredCredential(realm, user, credentialId);\n"
"}"
msgstr ""
"@Override\n"
"public CredentialModel createCredential(RealmModel realm, UserModel user, SecretQuestionCredentialModel credentialModel) {\n"
"    if (credentialModel.getCreatedDate() == null) {\n"
"        credentialModel.setCreatedDate(Time.currentTimeMillis());\n"
"    }\n"
"    return getCredentialStore().createCredential(realm, user, credentialModel);\n"
"}\n"
"\n"
"@Override\n"
"public boolean deleteCredential(RealmModel realm, UserModel user, String credentialId) {\n"
"    return getCredentialStore().removeStoredCredential(realm, user, credentialId);\n"
"}"

msgid ""
"For the CredentialInputValidator, the main method to implement is the "
"`isValid`, which tests whether a credential is valid for a given user in a "
"given realm. This is the method that is called by the Authenticator when it "
"seeks to validate the user's input. Here we simply need to check that the "
"input String is the one recorded in the Credential:"
msgstr ""
"CredentialInputValidatorの場合、実装するメインメソッドは `isValid` "
"です。これは、特定のレルム内の特定のユーザーに対して認証情報が有効かどうかをテストします。これは、Authenticatorがユーザーの入力を検証しようとしたときに呼び出されるメソッドです。ここでは、入力文字列がクレデンシャルに記録されたものであることを確認するだけです。"

msgid ""
"@Override\n"
"public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {\n"
"    if (!(input instanceof UserCredentialModel)) {\n"
"        logger.debug(\"Expected instance of UserCredentialModel for CredentialInput\");\n"
"        return false;\n"
"    }\n"
"    if (!input.getType().equals(getType())) {\n"
"        return false;\n"
"    }\n"
"    String challengeResponse = input.getChallengeResponse();\n"
"    if (challengeResponse == null) {\n"
"        return false;\n"
"    }\n"
"    CredentialModel credentialModel = getCredentialStore().getStoredCredentialById(realm, user, input.getCredentialId());\n"
"    SecretQuestionCredentialModel sqcm = getCredentialFromModel(credentialModel);\n"
"    return sqcm.getSecretQuestionSecretData().getAnswer().equals(challengeResponse);\n"
"}"
msgstr ""
"@Override\n"
"public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {\n"
"    if (!(input instanceof UserCredentialModel)) {\n"
"        logger.debug(\"Expected instance of UserCredentialModel for CredentialInput\");\n"
"        return false;\n"
"    }\n"
"    if (!input.getType().equals(getType())) {\n"
"        return false;\n"
"    }\n"
"    String challengeResponse = input.getChallengeResponse();\n"
"    if (challengeResponse == null) {\n"
"        return false;\n"
"    }\n"
"    CredentialModel credentialModel = getCredentialStore().getStoredCredentialById(realm, user, input.getCredentialId());\n"
"    SecretQuestionCredentialModel sqcm = getCredentialFromModel(credentialModel);\n"
"    return sqcm.getSecretQuestionSecretData().getAnswer().equals(challengeResponse);\n"
"}"

msgid ""
"The other two methods to implement are a test if the CredentialProvider "
"supports the given credential type and a test to check if the credential "
"type is configured for a given user. For our case, the latter test simply "
"means checking if the user has a credential of the SECRET_QUESTION type:"
msgstr ""
"実装する他の2つの方法は、CredentialProviderが指定されたクレデンシャル・タイプをサポートするかどうかのテストと、クレデンシャル・タイプが特定のユーザーに対して設定されているかどうかを確認するテストです。私たちの場合、後者のテストは単に、ユーザーがSECRET_QUESTIONタイプのクレデンシャルを持っているかどうかを確認することを意味します。"

msgid ""
"@Override\n"
"public boolean supportsCredentialType(String credentialType) {\n"
"    return getType().equals(credentialType);\n"
"}\n"
"\n"
"@Override\n"
"public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {\n"
"    if (!supportsCredentialType(credentialType)) return false;\n"
"    return !getCredentialStore().getStoredCredentialsByType(realm, user, credentialType).isEmpty();\n"
"}"
msgstr ""
"@Override\n"
"public boolean supportsCredentialType(String credentialType) {\n"
"    return getType().equals(credentialType);\n"
"}\n"
"\n"
"@Override\n"
"public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {\n"
"    if (!supportsCredentialType(credentialType)) return false;\n"
"    return !getCredentialStore().getStoredCredentialsByType(realm, user, credentialType).isEmpty();\n"
"}"

msgid "Implementing an authenticator"
msgstr "Authenticatorの実装"

msgid ""
"When implementing an authenticator that uses Credentials to authenticate a "
"user, you should have the authenticator implement the CredentialValidator "
"interface. This interfaces takes a class extending a CredentialProvider as a"
" parameter, and will allow {project_name} to directly call the methods from "
"the CredentialProvider. The only method that needs to be implemented is "
"`getCredentialProvider` method, which in our example allows the "
"SecretQuestionAuthenticator to retrieve the "
"SecretQuestionCredentialProvider:"
msgstr ""
"Credentialsを使用してユーザーを認証するオーセンティケーターを実装する場合、AuthenticatorにCredentialValidatorインターフェイスを実装させる必要があります。このインターフェイスは、CredentialProviderをパラメーターとして拡張するクラスを取り、{project_name}がCredentialProviderからメソッドを直接呼び出すことを許可します。実装する必要がある唯一のメソッドは"
" `getCredentialProvider` "
"メソッドです。この例では、SecretQuestionAuthenticatorがSecretQuestionCredentialProviderを取得できます。"

msgid ""
"public SecretQuestionCredentialProvider getCredentialProvider(KeycloakSession session) {\n"
"    return (SecretQuestionCredentialProvider)session.getProvider(CredentialProvider.class, SecretQuestionCredentialProviderFactory.PROVIDER_ID);\n"
"}"
msgstr ""
"public SecretQuestionCredentialProvider getCredentialProvider(KeycloakSession session) {\n"
"    return (SecretQuestionCredentialProvider)session.getProvider(CredentialProvider.class, SecretQuestionCredentialProviderFactory.PROVIDER_ID);\n"
"}"

msgid ""
"When implementing the Authenticator interface, the first method that needs "
"to be implemented is the requiresUser() method. For our example, this method"
" must return true as we need to validate the secret question associated with"
" the user. A provider like kerberos would return false from this method as "
"it can resolve a user from the negotiate header. This example, however, is "
"validating a specific credential of a specific user."
msgstr ""
"Authenticatorインターフェースを実装する場合、実装する必要がある最初のメソッドはrequiresUser()メソッドです。この例では、ユーザーに関連付けられた秘密の質問を検証する必要があるため、このメソッドはtrueを返す必要があります。Kerberosのようなプロバイダーは、Negotiateヘッダーからユーザーを解決できるため、このメソッドからfalseを返します。ただし、この例では、特定のユーザーの特定のクレデンシャルを検証しています。"

msgid ""
"The next method to implement is the configuredFor() method. This method is "
"responsible for determining if the user is configured for this particular "
"authenticator. In our case, we can just call the method implemented in the "
"SecretQuestionCredentialProvider"
msgstr ""
"実装する次のメソッドはconfiguredFor()メソッドです。このメソッドは、ユーザーがこの特定の認証用に設定されているかどうかを判断します。この場合、SecretQuestionCredentialProviderに実装されているメソッドを呼び出すだけです。"

msgid ""
"@Override\n"
"public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {\n"
"    return getCredentialProvider(session).isConfiguredFor(realm, user, getType(session));\n"
"}"
msgstr ""
"@Override\n"
"public boolean configuredFor(KeycloakSession session, RealmModel realm, UserModel user) {\n"
"    return getCredentialProvider(session).isConfiguredFor(realm, user, getType(session));\n"
"}"

msgid ""
"The next method to implement on the Authenticator is setRequiredActions(). "
"If configuredFor() returns false and our example authenticator is required "
"within the flow, this method will be called, but only if the associated "
"AuthenticatorFactory's `isUserSetupAllowed` method returns true. The "
"setRequiredActions() method is responsible for registering any required "
"actions that must be performed by the user. In our example, we need to "
"register a required action that will force the user to set up the answer to "
"the secret question. We will implement this required action provider later "
"in this chapter. Here is the implementation of the setRequiredActions() "
"method."
msgstr ""
"Authenticatorに実装する次のメソッドはsetRequiredActions()です。configuredFor()がfalseを返し、サンプルのオーセンティケーターがフロー内で必要な場合、このメソッドが呼び出されますが、関連付けられたAuthenticatorFactoryの"
" `isUserSetupAllowed` "
"メソッドがtrueを返す場合に限られます。setRequiredActions()メソッドは、ユーザーが実行する必要のある必要なアクションを登録します。この例では、秘密の質問への回答をユーザーに設定させる必要なアクションを登録する必要があります。この必須のアクション・プロバイダーは、この章の後半で実装します。setRequiredActions()メソッドの実装は次のとおりです。"

msgid ""
"    @Override\n"
"    public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {\n"
"        user.addRequiredAction(\"SECRET_QUESTION_CONFIG\");\n"
"    }"
msgstr ""
"    @Override\n"
"    public void setRequiredActions(KeycloakSession session, RealmModel realm, UserModel user) {\n"
"        user.addRequiredAction(\"SECRET_QUESTION_CONFIG\");\n"
"    }"

msgid ""
"Now we are getting into the meat of the Authenticator implementation. The "
"next method to implement is authenticate().  This is the initial method the "
"flow invokes when the execution is first visited. What we want is that if a "
"user has answered the secret question already on their browser's machine, "
"then the user doesn't have to answer the question again, making that machine"
" \"trusted\".  The authenticate() method isn't responsible for processing "
"the secret question form. Its sole purpose is to render the page or to "
"continue the flow."
msgstr ""
"Authenticatorの実装の要点を説明します。実装する次のメソッドはauthenticate()です。これは、実行が最初にアクセスされたときにフローが呼び出す最初のメソッドです。ユーザーがブラウザーのマシン上で秘密の質問にすでに答えている場合、ユーザーは質問に再度答える必要がなく、そのマシンを\"信頼できる\"ものにすることが望まれます。authenticate()メソッドは、秘密の質問フォームの処理を担当しません。その唯一の目的は、ページをレンダリングするか、フローを継続することです。"

msgid ""
"@Override\n"
"public void authenticate(AuthenticationFlowContext context) {\n"
"    if (hasCookie(context)) {\n"
"        context.success();\n"
"        return;\n"
"    }\n"
"    Response challenge = context.form()\n"
"            .createForm(\"secret-question.ftl\");\n"
"    context.challenge(challenge);\n"
"}\n"
"\n"
"protected boolean hasCookie(AuthenticationFlowContext context) {\n"
"    Cookie cookie = context.getHttpRequest().getHttpHeaders().getCookies().get(\"SECRET_QUESTION_ANSWERED\");\n"
"    boolean result = cookie != null;\n"
"    if (result) {\n"
"        System.out.println(\"Bypassing secret question because cookie is set\");\n"
"    }\n"
"    return result;\n"
"}"
msgstr ""
"@Override\n"
"public void authenticate(AuthenticationFlowContext context) {\n"
"    if (hasCookie(context)) {\n"
"        context.success();\n"
"        return;\n"
"    }\n"
"    Response challenge = context.form()\n"
"            .createForm(\"secret-question.ftl\");\n"
"    context.challenge(challenge);\n"
"}\n"
"\n"
"protected boolean hasCookie(AuthenticationFlowContext context) {\n"
"    Cookie cookie = context.getHttpRequest().getHttpHeaders().getCookies().get(\"SECRET_QUESTION_ANSWERED\");\n"
"    boolean result = cookie != null;\n"
"    if (result) {\n"
"        System.out.println(\"Bypassing secret question because cookie is set\");\n"
"    }\n"
"    return result;\n"
"}"

msgid ""
"The hasCookie() method checks to see if there is already a cookie set on the"
" browser which indicates that the secret question has already been answered."
" If that returns true, we just mark this execution's status as SUCCESS using"
" the AuthenticationFlowContext.success() method and returning from the "
"authentication() method."
msgstr ""
"hasCookie()メソッドは、秘密の質問がすでに回答されたことを示すCookieがブラウザーに設定されているかどうかを確認します。それがtrueを返す場合、AuthenticationFlowContext.success()メソッドを使用してauthentication()メソッドから戻ることで、この実行のステータスをSUCCESSとしてマークします。"

msgid ""
"If the hasCookie() method returns false, we must return a response that "
"renders the secret question HTML form. AuthenticationFlowContext has a "
"form() method that initializes a Freemarker page builder with appropriate "
"base information needed to build the form. This page builder is called "
"`org.keycloak.login.LoginFormsProvider`. The LoginFormsProvider.createForm()"
" method loads a Freemarker template file from your login theme. Additionally"
" you can call the LoginFormsProvider.setAttribute() method if you want to "
"pass additional information to the Freemarker template. We'll go over this "
"later."
msgstr ""
"hasCookie()メソッドがfalseを返す場合、秘密の質問のHTMLフォームをレンダリングするレスポンスを返す必要があります。AuthenticationFlowContextには、フォームの構築に必要な適切な基本情報でFreemarkerページビルダーを初期化するform()メソッドがあります。このページビルダーは"
" `org.keycloak.login.LoginFormsProvider` "
"と呼ばれます。LoginFormsProvider.createForm()メソッドは、ログインテーマからFreemarkerテンプレートファイルをロードします。さらに、Freemarkerテンプレートに追加情報を渡す場合は、LoginFormsProvider.setAttribute()メソッドを呼び出すことができます。これについては後で説明します。"

msgid ""
"Calling LoginFormsProvider.createForm() returns a JAX-RS Response object. We"
" then call AuthenticationFlowContext.challenge() passing in this response. "
"This sets the status of the execution as CHALLENGE and if the execution is "
"Required, this JAX-RS Response object will be sent to the browser."
msgstr ""
"LoginFormsProvider.createForm()を呼び出すと、JAX-RS "
"Responseオブジェクトが返されます。次に、このレスポンスで渡すAuthenticationFlowContext.challenge()を呼び出します。これにより、エグゼキューションのステータスがCHALLENGEに設定され、エグゼキューションがREQUIREDの場合、このJAX-"
"RSレスポンスのオブジェクトがブラウザーに送信されます。"

msgid ""
"So, the HTML page asking for the answer to a secret question is displayed to"
" the user and the user enters in the answer and clicks submit. The action "
"URL of the HTML form will send an HTTP request to the flow. The flow will "
"end up invoking the action() method of our Authenticator implementation."
msgstr ""
"したがって、秘密の質問に対する回答を求めるHTMLページがユーザーに表示され、ユーザーが回答を入力して送信をクリックします。HTMLフォームのアクションURLは、HTTPリクエストをフローに送信します。フローは、Authenticatorの実装のaction()メソッドを呼び出すことになります。"

msgid ""
"@Override\n"
"public void action(AuthenticationFlowContext context) {\n"
"    boolean validated = validateAnswer(context);\n"
"    if (!validated) {\n"
"        Response challenge =  context.form()\n"
"                .setError(\"badSecret\")\n"
"                .createForm(\"secret-question.ftl\");\n"
"        context.failureChallenge(AuthenticationFlowError.INVALID_CREDENTIALS, challenge);\n"
"        return;\n"
"    }\n"
"    setCookie(context);\n"
"    context.success();\n"
"}"
msgstr ""
"@Override\n"
"public void action(AuthenticationFlowContext context) {\n"
"    boolean validated = validateAnswer(context);\n"
"    if (!validated) {\n"
"        Response challenge =  context.form()\n"
"                .setError(\"badSecret\")\n"
"                .createForm(\"secret-question.ftl\");\n"
"        context.failureChallenge(AuthenticationFlowError.INVALID_CREDENTIALS, challenge);\n"
"        return;\n"
"    }\n"
"    setCookie(context);\n"
"    context.success();\n"
"}"

msgid ""
"If the answer is not valid, we rebuild the HTML Form with an additional "
"error message. We then call AuthenticationFlowContext.failureChallenge() "
"passing in the reason for the value and the JAX-RS response. "
"failureChallenge() works the same as challenge(), but it also records the "
"failure so it can be analyzed by any attack detection service."
msgstr ""
"回答が有効でない場合、HTMLフォームを追加のエラーメッセージで再構築します。次に、原因となる値とJAX-"
"RSレスポンスを渡すAuthenticationFlowContext.failureChallenge()を呼び出します。failureChallenge()はchallenge()と同じ働きをしますが、失敗も記録するので、攻撃検出サービスによって解析できます。"

msgid ""
"If validation is successful, then we set a cookie to remember that the "
"secret question has been answered and we call "
"AuthenticationFlowContext.success()."
msgstr ""
"検証に成功すると、秘密の質問に回答したことを記憶するCookieを設定し、AuthenticationFlowContext.success()を呼び出します。"

msgid ""
"The validation itself gets the data that was received from the form, and "
"calls the isValid method from the SecretQuestionCredentialProvider. You'll "
"notice that there's a section of the code concerning getting the credential "
"Id. This is because if {project_name} is configured to allow multiple types "
"of alternative authenticators, or if the user could record multiple "
"credentials of the SECRET_QUESTION type (for example if we allowed to choose"
" from several questions, and we allowed the user to have answers for more "
"than one of those questions), then {project_name} needs to know which "
"credential is being used to log the user. In case there is more than one "
"credential, {project_name} allows the user to choose during the login which "
"credential is being used, and the information is transmitted by the form to "
"the Authenticator. In case the form doesn't present this information, "
"credential id used is given by the CredentialProvider's `default "
"getDefaultCredential` method, which will return the \"most preferred\" "
"credential of the correct type of the user,"
msgstr ""
"検証自体は、フォームから受信したデータを取得し、SecretQuestionCredentialProviderからisValidメソッドを呼び出します。クレデンシャルIDの取得に関するコードのセクションがあることに気付くでしょう。これは、{project_name}が複数のタイプの代替オーセンティケーターを許可するように設定されている場合、またはユーザーがSECRET_QUESTIONタイプの複数のクレデンシャルを記録できる場合（たとえば、複数の質問から選択でき、ユーザーがこれらの質問の1つ以上に回答できるようにできる場合）、{project_name}はユーザーのログ記録に使用されているクレデンシャルを知る必要があります。複数のクレデンシャルがある場合、{project_name}を使用すると、ログイン時にユーザーがどのクレデンシャルを使用するかを選択できます。情報はフォームからオーセンティケーターに送信されます。フォームがこの情報を提示しない場合、使用されるクレデンシャルIDは、CredentialProviderの"
" `default getDefaultCredential` "
"メソッドによって与えられます。このメソッドは、ユーザーの正しいタイプの\"最も優先される\"クレデンシャルを返します。"

msgid ""
"protected boolean validateAnswer(AuthenticationFlowContext context) {\n"
"    MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"    String secret = formData.getFirst(\"secret_answer\");\n"
"    String credentialId = formData.getFirst(\"credentialId\");\n"
"    if (credentialId == null || credentialId.isEmpty()) {\n"
"        credentialId = getCredentialProvider(context.getSession())\n"
"                .getDefaultCredential(context.getSession(), context.getRealm(), context.getUser()).getId();\n"
"    }\n"
"\n"
"    UserCredentialModel input = new UserCredentialModel(credentialId, getType(context.getSession()), secret);\n"
"    return getCredentialProvider(context.getSession()).isValid(context.getRealm(), context.getUser(), input);\n"
"}"
msgstr ""
"protected boolean validateAnswer(AuthenticationFlowContext context) {\n"
"    MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"    String secret = formData.getFirst(\"secret_answer\");\n"
"    String credentialId = formData.getFirst(\"credentialId\");\n"
"    if (credentialId == null || credentialId.isEmpty()) {\n"
"        credentialId = getCredentialProvider(context.getSession())\n"
"                .getDefaultCredential(context.getSession(), context.getRealm(), context.getUser()).getId();\n"
"    }\n"
"\n"
"    UserCredentialModel input = new UserCredentialModel(credentialId, getType(context.getSession()), secret);\n"
"    return getCredentialProvider(context.getSession()).isValid(context.getRealm(), context.getUser(), input);\n"
"}"

msgid ""
"Next method is the setCookie(). This is an example of providing "
"configuration for the Authenticator. In this case we want the max age of the"
" cookie to be configurable."
msgstr ""
"次のメソッドはsetCookie()です。これは、オーセンティケーターの設定を提供する例です。この場合、Cookieの最大有効期間を設定可能にする必要があります。"

msgid ""
"protected void setCookie(AuthenticationFlowContext context) {\n"
"    AuthenticatorConfigModel config = context.getAuthenticatorConfig();\n"
"    int maxCookieAge = 60 * 60 * 24 * 30; // 30 days\n"
"    if (config != null) {\n"
"        maxCookieAge = Integer.valueOf(config.getConfig().get(\"cookie.max.age\"));\n"
"\n"
"    }\n"
"    URI uri = context.getUriInfo().getBaseUriBuilder().path(\"realms\").path(context.getRealm().getName()).build();\n"
"    addCookie(context, \"SECRET_QUESTION_ANSWERED\", \"true\",\n"
"            uri.getRawPath(),\n"
"            null, null,\n"
"            maxCookieAge,\n"
"            false, true);\n"
"}"
msgstr ""
"protected void setCookie(AuthenticationFlowContext context) {\n"
"    AuthenticatorConfigModel config = context.getAuthenticatorConfig();\n"
"    int maxCookieAge = 60 * 60 * 24 * 30; // 30 days\n"
"    if (config != null) {\n"
"        maxCookieAge = Integer.valueOf(config.getConfig().get(\"cookie.max.age\"));\n"
"\n"
"    }\n"
"    URI uri = context.getUriInfo().getBaseUriBuilder().path(\"realms\").path(context.getRealm().getName()).build();\n"
"    addCookie(context, \"SECRET_QUESTION_ANSWERED\", \"true\",\n"
"            uri.getRawPath(),\n"
"            null, null,\n"
"            maxCookieAge,\n"
"            false, true);\n"
"}"

msgid ""
"We obtain an AuthenticatorConfigModel from the "
"AuthenticationFlowContext.getAuthenticatorConfig() method. If configuration "
"exists we pull the max age config out of it. We will see how we can define "
"what should be configured when we talk about the AuthenticatorFactory "
"implementation. The config values can be defined within the Admin Console if"
" you set up config definitions in your AuthenticatorFactory implementation."
msgstr ""
"AuthenticationFlowContext.getAuthenticatorConfig()メソッドからAuthenticatorConfigModelを取得します。設定が存在する場合は、その設定の最大有効期間を取り出します。何を設定するべきかを定義する方法については、AuthenticatorFactoryの実装について説明する際に確認していきます。AuthenticatorFactory実装で設定の定義をした場合、管理コンソール内で設定値を定義できます。"

msgid ""
"@Override\n"
"    public CredentialTypeMetadata getCredentialTypeMetadata(CredentialTypeMetadataContext metadataContext) {\n"
"        return CredentialTypeMetadata.builder()\n"
"                .type(getType())\n"
"                .category(CredentialTypeMetadata.Category.TWO_FACTOR)\n"
"                .displayName(SecretQuestionCredentialProviderFactory.PROVIDER_ID)\n"
"                .helpText(\"secret-question-text\")\n"
"                .createAction(SecretQuestionAuthenticatorFactory.PROVIDER_ID)\n"
"                .removeable(false)\n"
"                .build(session);\n"
"    }"
msgstr ""
"@Override\n"
"    public CredentialTypeMetadata getCredentialTypeMetadata(CredentialTypeMetadataContext metadataContext) {\n"
"        return CredentialTypeMetadata.builder()\n"
"                .type(getType())\n"
"                .category(CredentialTypeMetadata.Category.TWO_FACTOR)\n"
"                .displayName(SecretQuestionCredentialProviderFactory.PROVIDER_ID)\n"
"                .helpText(\"secret-question-text\")\n"
"                .createAction(SecretQuestionAuthenticatorFactory.PROVIDER_ID)\n"
"                .removeable(false)\n"
"                .build(session);\n"
"    }"

msgid ""
"The last method to implement in the SecretQuestionCredentialProvider class "
"is getCredentialTypeMetadata(CredentialTypeMetadataContext metadataContext),"
" which is an abstract method of the CredentialProvider interface. Each "
"Credential provider has to provide and implement this method. The method "
"returns an instance of CredentialTypeMetadata, which should at least include"
" type and category of authenticator, displayName and removable item. In this"
" example, the builder takes type of authenticator from method getType(), "
"category is Two Factor (the authenticator can be used as second factor of "
"authentication) and removable, which is set up to false (user can't remove "
"some previously registered credentials)."
msgstr ""
"SecretQuestionCredentialProviderクラスに実装する最後のメソッドは、CredentialProviderインターフェイスの抽象メソッドであるgetCredentialTypeMetadata(CredentialTypeMetadataContext"
" "
"metadataContext)です。各クレデンシャル・プロバイダーは、このメソッドを提供および実装する必要があります。このメソッドは、CredentialTypeMetadataのインスタンスを返します。これには、少なくともオーセンティケーターのタイプとカテゴリー、displayName、および取り外し可能なアイテムが含まれている必要があります。この例では、ビルダーはメソッドgetType()からオーセンティケーターのタイプを取り、カテゴリーは2要素（オーセンティケーターは認証の2番目の要素として使用できます）かつ取り外し可能で、falseに設定されています（ユーザーは以前に登録されたクレデンシャルを削除できません）。"

msgid ""
"Other items of builder are helpText (will be shown to the user on various "
"screens), createAction (the providerID of the required action, which can be "
"used by the user to create new credential) or updateAction (same as "
"createAction, but instead of creating the new credential, it will update the"
" credential)."
msgstr ""
"ビルダーの他の項目は、helpText（さまざまな画面でユーザーに表示されます）、createAction（必要なアクションのプロバイダーID、ユーザーが新しいクレデンシャルを作成するために使用できます）、またはupdateAction（createActionと同じですが、新しいクレデンシャルを作成する代わりに、クレデンシャルを更新します）です。"

msgid "Implementing an AuthenticatorFactory"
msgstr "AuthenticatorFactoryの実装"

msgid ""
"The next step in this process is to implement an AuthenticatorFactory. This "
"factory is responsible for instantiating an Authenticator. It also provides "
"deployment and configuration metadata about the Authenticator."
msgstr ""
"このプロセスでの次のステップは、AuthenticatorFactoryを実装することです。このファクトリーはAuthenticatorのインスタンス化を担当します。また、Authenticatorに関する配備と設定のメタデータも提供します。"

msgid ""
"The getId() method is just the unique name of the component. The create() "
"method is called by the runtime to allocate and process the Authenticator."
msgstr ""
"getId()メソッドは、コンポーネントの一意の名前です。create()メソッドは、Authenticatorを割り当てて処理するために、ランタイムによって呼び出されます。"

msgid ""
"\n"
"public class SecretQuestionAuthenticatorFactory implements AuthenticatorFactory, ConfigurableAuthenticatorFactory {\n"
"\n"
"    public static final String PROVIDER_ID = \"secret-question-authenticator\";\n"
"    private static final SecretQuestionAuthenticator SINGLETON = new SecretQuestionAuthenticator();\n"
"\n"
"    @Override\n"
"    public String getId() {\n"
"        return PROVIDER_ID;\n"
"    }\n"
"\n"
"    @Override\n"
"    public Authenticator create(KeycloakSession session) {\n"
"        return SINGLETON;\n"
"    }"
msgstr ""
"\n"
"public class SecretQuestionAuthenticatorFactory implements AuthenticatorFactory, ConfigurableAuthenticatorFactory {\n"
"\n"
"    public static final String PROVIDER_ID = \"secret-question-authenticator\";\n"
"    private static final SecretQuestionAuthenticator SINGLETON = new SecretQuestionAuthenticator();\n"
"\n"
"    @Override\n"
"    public String getId() {\n"
"        return PROVIDER_ID;\n"
"    }\n"
"\n"
"    @Override\n"
"    public Authenticator create(KeycloakSession session) {\n"
"        return SINGLETON;\n"
"    }"

msgid ""
"The next thing the factory is responsible for is to specify the allowed "
"requirement switches. While there are four different requirement types:  "
"ALTERNATIVE, REQUIRED, CONDITIONAL, DISABLED, AuthenticatorFactory "
"implementations can limit which requirement options are shown in the Admin "
"Console when defining a flow. CONDITIONAL should only always be used for "
"subflows, and unless there's a good reason for doing otherwise, the "
"requirement on an authenticator should be REQUIRED, ALTERNATIVE and "
"DISABLED:"
msgstr ""
"ファクトリーが次に受け持つのは、許可されたスイッチの要件を指定することです。ALTERNATIVE、REQUIRED、CONDITIONAL、DISABLEDの4種類の要件タイプがありますが、AuthenticatorFactoryの実装では、フローを定義する際に管理コンソールに表示されるオプションの要件を制限できます。CONDITIONALは常にサブフローにのみ使用する必要があり、そうする正当な理由がない限り、オーセンティケーターの要件はREQUIRED、ALTERNATIVE、およびDISABLEDである必要があります。"

msgid ""
"\n"
"    private static AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {\n"
"            AuthenticationExecutionModel.Requirement.REQUIRED,\n"
"            AuthenticationExecutionModel.Requirement.ALTERNATIVE,\n"
"            AuthenticationExecutionModel.Requirement.DISABLED\n"
"    };\n"
"    @Override\n"
"    public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {\n"
"        return REQUIREMENT_CHOICES;\n"
"    }"
msgstr ""
"\n"
"    private static AuthenticationExecutionModel.Requirement[] REQUIREMENT_CHOICES = {\n"
"            AuthenticationExecutionModel.Requirement.REQUIRED,\n"
"            AuthenticationExecutionModel.Requirement.ALTERNATIVE,\n"
"            AuthenticationExecutionModel.Requirement.DISABLED\n"
"    };\n"
"    @Override\n"
"    public AuthenticationExecutionModel.Requirement[] getRequirementChoices() {\n"
"        return REQUIREMENT_CHOICES;\n"
"    }"

msgid ""
"The AuthenticatorFactory.isUserSetupAllowed() is a flag that tells the flow "
"manager whether or not Authenticator.setRequiredActions() method will be "
"called. If an Authenticator is not configured for a user, the flow manager "
"checks isUserSetupAllowed().  If it is false, then the flow aborts with an "
"error. If it returns true, then the flow manager will invoke "
"Authenticator.setRequiredActions()."
msgstr ""
"AuthenticatorFactory.isUserSetupAllowed()は、Authenticator.setRequiredActions()メソッドが呼び出されるかどうかをフロー・マネージャーに通知するフラグです。オーセンティケーターがユーザーに設定されていない場合、フロー・マネージャーはisUserSetupAllowed()をチェックします。falseの場合、エラーを返して異常終了します。trueを返すと、フロー・マネージャーはAuthenticator.setRequiredActions()を呼び出します。"

msgid ""
"\n"
"    @Override\n"
"    public boolean isUserSetupAllowed() {\n"
"        return true;\n"
"    }"
msgstr ""
"\n"
"    @Override\n"
"    public boolean isUserSetupAllowed() {\n"
"        return true;\n"
"    }"

msgid ""
"The next few methods define how the Authenticator can be configured. The "
"isConfigurable() method is a flag which specifies to the Admin Console on "
"whether the Authenticator can be configured within a flow. The "
"getConfigProperties() method returns a list of ProviderConfigProperty "
"objects. These objects define a specific configuration attribute."
msgstr ""
"次のいくつかのメソッドは、オーセンティケーターの設定方法を定義します。isConfigurable()メソッドは、オーセンティケーターをフロー内で設定することができるかどうかを管理コンソールに指定するフラグです。getConfigProperties()メソッドは、ProviderConfigPropertyオブジェクトのリストを返します。これらのオブジェクトは、特定の設定属性を定義します。"

msgid ""
"\n"
"    @Override\n"
"    public List<ProviderConfigProperty> getConfigProperties() {\n"
"        return configProperties;\n"
"    }\n"
"\n"
"    private static final List<ProviderConfigProperty> configProperties = new ArrayList<ProviderConfigProperty>();\n"
"\n"
"    static {\n"
"        ProviderConfigProperty property;\n"
"        property = new ProviderConfigProperty();\n"
"        property.setName(\"cookie.max.age\");\n"
"        property.setLabel(\"Cookie Max Age\");\n"
"        property.setType(ProviderConfigProperty.STRING_TYPE);\n"
"        property.setHelpText(\"Max age in seconds of the SECRET_QUESTION_COOKIE.\");\n"
"        configProperties.add(property);\n"
"    }"
msgstr ""
"\n"
"    @Override\n"
"    public List<ProviderConfigProperty> getConfigProperties() {\n"
"        return configProperties;\n"
"    }\n"
"\n"
"    private static final List<ProviderConfigProperty> configProperties = new ArrayList<ProviderConfigProperty>();\n"
"\n"
"    static {\n"
"        ProviderConfigProperty property;\n"
"        property = new ProviderConfigProperty();\n"
"        property.setName(\"cookie.max.age\");\n"
"        property.setLabel(\"Cookie Max Age\");\n"
"        property.setType(ProviderConfigProperty.STRING_TYPE);\n"
"        property.setHelpText(\"Max age in seconds of the SECRET_QUESTION_COOKIE.\");\n"
"        configProperties.add(property);\n"
"    }"

msgid ""
"Each ProviderConfigProperty defines the name of the config property. This is"
" the key used in the config map stored in AuthenticatorConfigModel. The "
"label defines how the config option will be displayed in the Admin Console. "
"The type defines if it is a String, Boolean, or other type. The Admin "
"Console will display different UI inputs depending on the type. The help "
"text is what will be shown in the tooltip for the config attribute in the "
"Admin Console. Read the javadoc of ProviderConfigProperty for more detail."
msgstr ""
"それぞれのProviderConfigPropertyは、設定プロパティーの名前を定義します。これが、AuthenticatorConfigModelに格納されている設定マップで使用されるキーとなります。ラベルは、管理コンソールでどのように設定オプションが表示されるかを定義します。タイプは、そのプロパティーがString、Booleanまたはその他のタイプであるかを定義します。管理コンソールには、タイプによって異なるUI入力が表示されます。ヘルプのテキストは、管理コンソールの設定属性のツールチップに表示されるものです。詳しくは、ProviderConfigPropertyのjavadocを参照してください。"

msgid ""
"The rest of the methods are for the Admin Console. getHelpText() is the "
"tooltip text that will be shown when you are picking the Authenticator you "
"want to bind to an execution. getDisplayType() is the text that will be "
"shown in the Admin Console when listing the Authenticator. "
"getReferenceCategory() is just a category the Authenticator belongs to."
msgstr ""
"残りのメソッドは管理コンソール用です。getHelpText()は、エグゼキューションにバインドさせるオーセンティケーターを選択するときに表示されるツールチップ・テキストです。getDisplayType()は、オーセンティケーターを一覧表示する際に管理コンソールに表示されるテキストです。getReferenceCategory()は、オーセンティケーターが属するカテゴリーです。"

msgid "Adding an authenticator form"
msgstr "オーセンティケーター・フォームの追加"

msgid ""
"{project_name} comes with a Freemarker <<_themes,theme and template "
"engine>>. The createForm() method you called within authenticate() of your "
"Authenticator class, builds an HTML page from a file within your login "
"theme: `secret-question.ftl`. This file should be added to the `theme-"
"resources/templates` in your JAR, see <<_theme_resource,Theme Resource "
"Provider>> for more details."
msgstr ""
"{project_name}には、Freemarker<<_themes,テーマとエンジン・テンプレート>> "
"が付属しています。オーセンティケーター・クラスのauthenticate()内で呼び出されたcreateForm()メソッドは、ログインテーマ内のsecret-"
"question.ftlファイルからHTMLページを構築します。このファイルは、JAR内の `theme-resources/templates` "
"に追加する必要があります。詳細については、<<_theme_resource,テーマ・リソース・プロバイダ>>を参照してください。"

msgid ""
"Let's take a bigger look at secret-question.ftl  Here's a small code "
"snippet:"
msgstr "secret-question.ftlの詳細を見ていきましょう。以下は、短いコードスニペットになります。"

msgid ""
"\n"
"        <form id=\"kc-totp-login-form\" class=\"${properties.kcFormClass!}\" action=\"${url.loginAction}\" method=\"post\">\n"
"            <div class=\"${properties.kcFormGroupClass!}\">\n"
"                <div class=\"${properties.kcLabelWrapperClass!}\">\n"
"                    <label for=\"totp\" class=\"${properties.kcLabelClass!}\">${msg(\"loginSecretQuestion\")}</label>\n"
"                </div>\n"
"\n"
"                <div class=\"${properties.kcInputWrapperClass!}\">\n"
"                    <input id=\"totp\" name=\"secret_answer\" type=\"text\" class=\"${properties.kcInputClass!}\" />\n"
"                </div>\n"
"            </div>\n"
"        </form>"
msgstr ""
"\n"
"        <form id=\"kc-totp-login-form\" class=\"${properties.kcFormClass!}\" action=\"${url.loginAction}\" method=\"post\">\n"
"            <div class=\"${properties.kcFormGroupClass!}\">\n"
"                <div class=\"${properties.kcLabelWrapperClass!}\">\n"
"                    <label for=\"totp\" class=\"${properties.kcLabelClass!}\">${msg(\"loginSecretQuestion\")}</label>\n"
"                </div>\n"
"\n"
"                <div class=\"${properties.kcInputWrapperClass!}\">\n"
"                    <input id=\"totp\" name=\"secret_answer\" type=\"text\" class=\"${properties.kcInputClass!}\" />\n"
"                </div>\n"
"            </div>\n"
"        </form>"

msgid ""
"Any piece of text enclosed in `${}` corresponds to an attribute or template "
"function. If you see the form's action, you see it points to "
"`${url.loginAction}`. This value is automatically generated when you invoke "
"the AuthenticationFlowContext.form() method. You can also obtain this value "
"by calling the AuthenticationFlowContext.getActionURL() method in Java code."
msgstr ""
"`${}` で囲まれたテキストは、属性またはテンプレートの関数に対応します。フォームのアクションが表示された場合、それは "
"`${url.loginAction}` "
"を指しています。この値は、AuthenticationFlowContext.form()メソッドを呼び出すと自動的に生成されます。JavaコードでAuthenticationFlowContext.getActionURL()メソッドを呼び出すことで、この値を取得することもできます。"

msgid ""
"You'll also see `${properties.someValue}`. These correspond to properties "
"defined in your theme.properties file of our theme.  `${msg(\"someValue\")}`"
" corresponds to the internationalized message bundles (.properties files) "
"included with the login theme messages/ directory. If you're just using "
"english, you can just add the value of the `loginSecretQuestion`. This "
"should be the question you want to ask the user."
msgstr ""
"`${properties.someValue}` "
"も同じく表示されます。これらは、テーマのtheme.propertiesファイルで定義されたプロパティに対応します。 "
"`${msg(\"someValue\")}` "
"は、ログインテーマのmessages/ディレクトリーに含まれている国際化されたメッセージ・バンドル（.properties "
"files）に対応します。英語のみを使用している場合は、 `loginSecretQuestion` "
"の値を追加することができます。これがユーザーに要求する質問になります。"

msgid ""
"When you call AuthenticationFlowContext.form() this gives you a "
"LoginFormsProvider  instance. If you called, "
"`LoginFormsProvider.setAttribute(\"foo\", \"bar\")`, the value of \"foo\" "
"would be available for reference in your form as `${foo}`. The value of an "
"attribute can be any Java bean as well."
msgstr ""
"AuthenticationFlowContext.form()を呼び出すと、LoginFormsProviderインスタンスが生成されます。 "
"`LoginFormsProvider.setAttribute(\"foo\", \"bar\")` を呼び出した場合、\"foo\"の値は "
"`${foo}` という形式で参照することができます。属性の値は、Java beanでも構いません。"

msgid ""
"If you look at the top of the file, you'll see that we are importing a "
"template:"
msgstr "ファイルの上部を見ると、テンプレートをインポートしていることがわかります。"

msgid "<#import \"select.ftl\" as layout>"
msgstr "<#import \"select.ftl\" as layout>"

msgid ""
"Importing this template, instead of the standard `template.ftl` allows "
"{project_name} to display a dropdown box that allows the user to select a "
"different credential or execution."
msgstr ""
"標準の `template.ftl` "
"の代わりにこのテンプレートをインポートすると、{project_name}はユーザーが別のクレデンシャルまたはエグゼキューションを選択できるドロップダウン・ボックスを表示できます。"

msgid "Adding an authenticator to a flow"
msgstr "フローにオーセンティケーターを追加"

msgid ""
"Adding an Authenticator to a flow must be done in the Admin Console. If you "
"go to the Authentication menu item and go to the Flow tab, you will be able "
"to view the currently defined flows. You cannot modify built in flows, so, "
"to add the Authenticator we've created you have to copy an existing flow or "
"create your own. Our hope is that the user interface is sufficiently clear "
"so that you can determine how to create a flow and add the Authenticator. "
"For more details, see the `Authentication Flows` chapter in "
"link:{adminguide_link}[{adminguide_name}] ."
msgstr ""
"オーセンティケーターをフローに追加するには、管理コンソールで行う必要があります。Authenticationメニュー項目に移動してFlowタブに移動すると、現在定義されているフローを表示できます。組み込みフローを変更することはできないため、作成した認証システムを追加するには、既存のフローをコピーするか、独自のフローを作成する必要があります。ユーザー・インターフェイスが十分に明確であり、フローの作成方法とオーセンティケーターの追加方法を決定できることが期待されます。詳細については、"
" link:{adminguide_link}[{adminguide_name}] の `Authentication Flows` "
"の章を参照してください。"

msgid ""
"After you've created your flow, you have to bind it to the login action you "
"want to bind it to. If you go to the Authentication menu and go  to the "
"Bindings tab you will see options to bind a flow to the browser, "
"registration, or direct grant flow."
msgstr ""
"フローを作成したら、バインドさせたいログイン・アクションに、そのフローをバインドする必要があります。Authenticationメニューに移動して、Bindingsタブを選択すると、フローをBrowser、Registration、またはDirect"
" Grantフローにバインドするオプションが表示されます。"

msgid "Required action walkthrough"
msgstr "必須アクションのウォークスルー"

msgid ""
"In this section we will discuss how to define a required action. In the "
"Authenticator section you may have wondered, \"How will we get the user's "
"answer to the secret question entered into the system?\".  As we showed in "
"the example, if the answer is not set up, a required action will be "
"triggered. This section discusses how to implement the required action for "
"the Secret Question Authenticator."
msgstr ""
"このセクションでは、必須アクションを定義する方法について説明します。オーセンティケーターのセクションでは、\"どのようにしてシステムに入力された秘密の質問に対するユーザーの回答をもらえば良いのだろう\"と疑問に思ったかもしれません。例で示したように、回答が設定されていない場合は、必須アクションがトリガーされます。このセクションでは、シークレット・クエスチョン・オーセンティケーターに必須アクションを実装する方法について説明します。"

msgid ""
"You will package your classes within a single jar. This jar does not have to"
" be separate from other provider classes but it must contain a file named  "
"`org.keycloak.authentication.RequiredActionFactory`                and must "
"be contained in the `META-INF/services/` directory of your jar. This file "
"must list the fully qualified classname of each RequiredActionFactory "
"implementation you have in the jar. For example:"
msgstr ""
"1つのJARファイル内にクラスをパッケージ化します。このJARは、他のプロバイダーのクラスとは別にする必要はありませんが、 "
"`org.keycloak.authentication.RequiredActionFactory` という名前のファイルが、JARの `META-"
"INF/services/` "
"ディレクトリーに含まれている必要があります。このファイルには、JARファイル内にある各RequiredActionFactory実装の完全修飾クラス名が一覧化されている必要があります。たとえば、以下のとおりになります。"

msgid ""
"org.keycloak.examples.authenticator.SecretQuestionRequiredActionFactory"
msgstr ""
"org.keycloak.examples.authenticator.SecretQuestionRequiredActionFactory"

msgid ""
"To deploy this jar, copy it to the `providers/` directory, then run "
"`bin/kc.[sh|bat] build`."
msgstr ""
"このjarをデプロイするには、`providers/` ディレクトリーにコピーし、 `bin/kc.[sh|bat] build` を実行します。"

msgid "Implement the RequiredActionProvider"
msgstr "RequiredActionProviderの実装"

msgid ""
"Required actions must first implement the RequiredActionProvider interface. "
"The RequiredActionProvider.requiredActionChallenge() is the initial call by "
"the flow manager into the required action. This method is responsible for "
"rendering the HTML form that will drive the required action."
msgstr ""
"必須アクションは、最初にRequiredActionProviderインターフェイスを実装する必要があります。RequiredActionProvider.requiredActionChallenge()は、フロー・マネージャーによる必須アクションの最初の呼び出しになります。このメソッドは、必須アクションを実行するHTMLフォームのレンダリングを行います。"

msgid ""
"\n"
"    @Override\n"
"    public void requiredActionChallenge(RequiredActionContext context) {\n"
"        Response challenge = context.form().createForm(\"secret_question_config.ftl\");\n"
"        context.challenge(challenge);\n"
"\n"
"    }"
msgstr ""
"\n"
"    @Override\n"
"    public void requiredActionChallenge(RequiredActionContext context) {\n"
"        Response challenge = context.form().createForm(\"secret_question_config.ftl\");\n"
"        context.challenge(challenge);\n"
"\n"
"    }"

msgid ""
"You see that RequiredActionContext has similar methods to "
"AuthenticationFlowContext. The form() method allows you to render the page "
"from a Freemarker template. The action URL is preset by the call to this "
"form() method. You just need to reference it within your HTML form. I'll "
"show you this later."
msgstr ""
"RequiredActionContextには、AuthenticationFlowContextと同じようなメソッドがあります。form()メソッドにより、Freemarkerテンプレートからページをレンダリングすることができます。アクションURLは、このform()メソッドの呼び出しにより事前に設定されるため、HTMLフォーム内で参照するだけで済みます。これについては、後ほど説明します。"

msgid ""
"The challenge() method notifies the flow manager that a required action must"
" be executed."
msgstr "challenge()メソッドは、必須アクションを実行する必要があることをフローマネージャーに通知します。"

msgid ""
"The next method is responsible for processing input from the HTML form of "
"the required action. The action URL of the form will be routed to the "
"RequiredActionProvider.processAction() method"
msgstr ""
"次のメソッドは、必須アクションのHTMLフォームからの入力を処理します。フォームのアクションURLは、RequiredActionProvider.processAction()メソッドにルーティングされます。"

msgid ""
"\n"
"    @Override\n"
"    public void processAction(RequiredActionContext context) {\n"
"        String answer = (context.getHttpRequest().getDecodedFormParameters().getFirst(\"answer\"));\n"
"        UserCredentialValueModel model = new UserCredentialValueModel();\n"
"        model.setValue(answer);\n"
"        model.setType(SecretQuestionAuthenticator.CREDENTIAL_TYPE);\n"
"        context.getUser().updateCredentialDirectly(model);\n"
"        context.success();\n"
"    }"
msgstr ""
"\n"
"    @Override\n"
"    public void processAction(RequiredActionContext context) {\n"
"        String answer = (context.getHttpRequest().getDecodedFormParameters().getFirst(\"answer\"));\n"
"        UserCredentialValueModel model = new UserCredentialValueModel();\n"
"        model.setValue(answer);\n"
"        model.setType(SecretQuestionAuthenticator.CREDENTIAL_TYPE);\n"
"        context.getUser().updateCredentialDirectly(model);\n"
"        context.success();\n"
"    }"

msgid ""
"The answer is pulled out of the form post. A UserCredentialValueModel is "
"created and the type and value of the credential are set. Then "
"UserModel.updateCredentialDirectly() is invoked. Finally, "
"RequiredActionContext.success() notifies the container that the required "
"action was successful."
msgstr ""
"回答はフォームのpostから取り出されます。UserCredentialValueModelが作成され、クレデンシャルのタイプと値がセットされます。その後、UserModel.updateCredentialDirectly()が呼び出されます。最後に、RequiredActionContext.success()は、必須アクションが成功したことをコンテナーに通知します。"

msgid "Implement the RequiredActionFactory"
msgstr "RequiredActionFactoryの実装"

msgid ""
"This class is really simple. It is just responsible for creating the "
"required action provider instance."
msgstr "このクラスは非常にシンプルです。これは必須アクション・プロバイダー・インスタンスの作成を行うだけです。"

msgid ""
"\n"
"public class SecretQuestionRequiredActionFactory implements RequiredActionFactory {\n"
"\n"
"    private static final SecretQuestionRequiredAction SINGLETON = new SecretQuestionRequiredAction();\n"
"\n"
"    @Override\n"
"    public RequiredActionProvider create(KeycloakSession session) {\n"
"        return SINGLETON;\n"
"    }\n"
"\n"
"\n"
"    @Override\n"
"    public String getId() {\n"
"        return SecretQuestionRequiredAction.PROVIDER_ID;\n"
"    }\n"
"\n"
"    @Override\n"
"    public String getDisplayText() {\n"
"        return \"Secret Question\";\n"
"    }"
msgstr ""
"\n"
"public class SecretQuestionRequiredActionFactory implements RequiredActionFactory {\n"
"\n"
"    private static final SecretQuestionRequiredAction SINGLETON = new SecretQuestionRequiredAction();\n"
"\n"
"    @Override\n"
"    public RequiredActionProvider create(KeycloakSession session) {\n"
"        return SINGLETON;\n"
"    }\n"
"\n"
"\n"
"    @Override\n"
"    public String getId() {\n"
"        return SecretQuestionRequiredAction.PROVIDER_ID;\n"
"    }\n"
"\n"
"    @Override\n"
"    public String getDisplayText() {\n"
"        return \"Secret Question\";\n"
"    }"

msgid ""
"The getDisplayText() method is just for the Admin Console when it wants to "
"display a friendly name for the required action."
msgstr "getDisplayText()メソッドは、必須アクションに対して分かりやすい名前を表示させたいときに、管理コンソールで使用されます。"

msgid "Enable required action"
msgstr "必須アクションの有効化"

msgid ""
"The final thing you have to do is go into the Admin Console. Click on the "
"Authentication left menu. Click on the Required Actions tab. Click on the "
"Register button and choose your new Required Action. Your new required "
"action should now be displayed and enabled in the required actions list."
msgstr ""
"最後に、管理コンソールに移動する必要があります。左メニューのAuthenticationをクリックします。Required "
"Actionsタブをクリックします。Registerボタンをクリックし、新しい必須アクションを選択します。必須アクションのリストに新しい必須アクションが表示され、有効になります。"

msgid "Modifying or extending the registration form"
msgstr "登録フォームの変更または拡張"

msgid ""
"It is entirely possible for you to implement your own flow with a set of "
"Authenticators to totally change how registration is done in {project_name}."
" But what you'll usually want to do is just add a bit of validation to the "
"out-of-the-box registration page. An additional SPI was created to be able "
"to do this. It basically allows you to add validation of form elements on "
"the page as well as to initialize UserModel attributes and data after the "
"user has been registered. We'll look at both the implementation of the user "
"profile registration processing as well as the registration Google Recaptcha"
" plugin."
msgstr ""
"{project_name}での登録方法を完全に変更するために、オーセンティケーターのセットを使用して独自のフローを実装することが可能です。しかし、独自の登録ページにちょっとしたバリデーションを加えたいことも普通にあるかと思います。これを行うために追加のSPIが作成されました。このSPIは、基本的には、ページにフォーム要素のバリデーションを追加するだけでなく、ユーザー登録後にUserModel属性とデータを初期化することもできます。ユーザー・プロファイルの登録処理の実装とGoogle"
" Recaptchaプラグインの登録の両方を説明していきます。"

msgid "Implementation FormAction interface"
msgstr "FormActionインターフェイスの実装"

msgid ""
"The core interface you have to implement is the FormAction interface. A "
"FormAction is responsible for rendering and processing a portion of the "
"page. Rendering is done in the buildPage() method, validation is done in the"
" validate() method, post validation operations are done in success().  Let's"
" first take a look at buildPage() method of the Recaptcha plugin."
msgstr ""
"実装する必要のあるコアとなるインターフェイスは、FormActionインターフェイスです。FormActionは、ページの一部のレンダリングと処理を受け待ちます。レンダリングはbuildPage()メソッド、バリデーションはvalidate()メソッド、バリデーション後の動作はsuccess()で行います。まずは、RecaptchaプラグインのbuildPage()メソッドを見ていきます。"

msgid ""
"\n"
"    @Override\n"
"    public void buildPage(FormContext context, LoginFormsProvider form) {\n"
"        AuthenticatorConfigModel captchaConfig = context.getAuthenticatorConfig();\n"
"        if (captchaConfig == null || captchaConfig.getConfig() == null\n"
"                || captchaConfig.getConfig().get(SITE_KEY) == null\n"
"                || captchaConfig.getConfig().get(SITE_SECRET) == null\n"
"                ) {\n"
"            form.addError(new FormMessage(null, Messages.RECAPTCHA_NOT_CONFIGURED));\n"
"            return;\n"
"        }\n"
"        String siteKey = captchaConfig.getConfig().get(SITE_KEY);\n"
"        form.setAttribute(\"recaptchaRequired\", true);\n"
"        form.setAttribute(\"recaptchaSiteKey\", siteKey);\n"
"        form.addScript(\"https://www.google.com/recaptcha/api.js\");\n"
"    }"
msgstr ""
"\n"
"    @Override\n"
"    public void buildPage(FormContext context, LoginFormsProvider form) {\n"
"        AuthenticatorConfigModel captchaConfig = context.getAuthenticatorConfig();\n"
"        if (captchaConfig == null || captchaConfig.getConfig() == null\n"
"                || captchaConfig.getConfig().get(SITE_KEY) == null\n"
"                || captchaConfig.getConfig().get(SITE_SECRET) == null\n"
"                ) {\n"
"            form.addError(new FormMessage(null, Messages.RECAPTCHA_NOT_CONFIGURED));\n"
"            return;\n"
"        }\n"
"        String siteKey = captchaConfig.getConfig().get(SITE_KEY);\n"
"        form.setAttribute(\"recaptchaRequired\", true);\n"
"        form.setAttribute(\"recaptchaSiteKey\", siteKey);\n"
"        form.addScript(\"https://www.google.com/recaptcha/api.js\");\n"
"    }"

msgid ""
"The Recaptcha buildPage() method is a callback by the form flow to help "
"render the page. It receives a form parameter which is a LoginFormsProvider."
" You can add additional attributes to the form provider so that they can be "
"displayed in the HTML page generated by the registration Freemarker "
"template."
msgstr ""
"RecaptchaのbuildPage()メソッドは、ページのレンダリングを支援するフォームフローからのコールバックです。これは、LoginFormsProviderであるフォーム・パラメーターを受け取ります。フォーム・プロバイダーに追加属性を加えて、登録Freemarkerテンプレートによって生成されたHTMLページに表示させることができます。"

msgid ""
"The code above is from the registration recaptcha plugin. Recaptcha requires"
" some specific settings that must be obtained from configuration. "
"FormActions are configured in the exact same as Authenticators are. In this "
"example, we pull the Google Recaptcha site key from configuration and add it"
" as an attribute to the form provider. Our registration template file can "
"read this attribute now."
msgstr ""
"上記のコードは、登録Recaptchaプラグインからのものです。Recaptchaには、設定から取得する必要のある特定の設定が必要です。FormActionsは、オーセンティケーターとまったく同じように設定されています。この例では、Google"
" "
"Recaptchaの公開鍵を設定から取り出し、フォーム・プロバイダーに属性として追加します。これで、登録テンプレート・ファイルはこの属性を読み込むことができます。"

msgid ""
"Recaptcha also has the requirement of loading a JavaScript script. You can "
"do this by calling LoginFormsProvider.addScript() passing in the URL."
msgstr ""
"Recaptchaには、JavaScriptの読み込み要件もあります。これを行うには、URLを渡すLoginFormsProvider.addScript()を呼び出します。"

msgid ""
"For user profile processing, there is no additional information that it "
"needs to add to the form, so its buildPage() method is empty."
msgstr "ユーザー・プロファイルを処理する場合、フォームに加える必要がある追加情報はないため、buildPage()メソッドは空です。"

msgid ""
"The next meaty part of this interface is the validate() method. This is "
"called immediately upon receiving a form post. Let's look at the Recaptcha's"
" plugin first."
msgstr ""
"このインターフェイスの次の部分は、validate()メソッドです。これは、フォームのpostを受け取ると、直後に呼び出されます。最初に、Recaptchaのプラグインを見ていきます。"

msgid ""
"\n"
"    @Override\n"
"    public void validate(ValidationContext context) {\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        List<FormMessage> errors = new ArrayList<>();\n"
"        boolean success = false;\n"
"\n"
"        String captcha = formData.getFirst(G_RECAPTCHA_RESPONSE);\n"
"        if (!Validation.isBlank(captcha)) {\n"
"            AuthenticatorConfigModel captchaConfig = context.getAuthenticatorConfig();\n"
"            String secret = captchaConfig.getConfig().get(SITE_SECRET);\n"
"\n"
"            success = validateRecaptcha(context, success, captcha, secret);\n"
"        }\n"
"        if (success) {\n"
"            context.success();\n"
"        } else {\n"
"            errors.add(new FormMessage(null, Messages.RECAPTCHA_FAILED));\n"
"            formData.remove(G_RECAPTCHA_RESPONSE);\n"
"            context.validationError(formData, errors);\n"
"            return;\n"
"\n"
"\n"
"        }\n"
"    }"
msgstr ""
"\n"
"    @Override\n"
"    public void validate(ValidationContext context) {\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        List<FormMessage> errors = new ArrayList<>();\n"
"        boolean success = false;\n"
"\n"
"        String captcha = formData.getFirst(G_RECAPTCHA_RESPONSE);\n"
"        if (!Validation.isBlank(captcha)) {\n"
"            AuthenticatorConfigModel captchaConfig = context.getAuthenticatorConfig();\n"
"            String secret = captchaConfig.getConfig().get(SITE_SECRET);\n"
"\n"
"            success = validateRecaptcha(context, success, captcha, secret);\n"
"        }\n"
"        if (success) {\n"
"            context.success();\n"
"        } else {\n"
"            errors.add(new FormMessage(null, Messages.RECAPTCHA_FAILED));\n"
"            formData.remove(G_RECAPTCHA_RESPONSE);\n"
"            context.validationError(formData, errors);\n"
"            return;\n"
"\n"
"\n"
"        }\n"
"    }"

msgid ""
"Here we obtain the form data that the Recaptcha widget adds to the form. We "
"obtain the Recaptcha secret key from configuration. We then validate the "
"recaptcha. If successful, ValidationContext.success() is called. If not, we "
"invoke ValidationContext.validationError() passing in the formData (so the "
"user doesn't have to re-enter data), we also specify an error message we "
"want displayed. The error message must point to a message bundle property in"
" the internationalized message bundles. For other registration extensions "
"validate() might be validating the format of a form element, for example an "
"alternative email attribute."
msgstr ""
"ここでは、Recaptchaウィジェットがフォームに追加するフォームデータを取得します。設定からRecaptchaの秘密鍵を取得します。次に、Recaptchaを検証します。成功すると、ValidationContext.success()が呼び出されます。成功しなかった場合は、formDataで渡すValidationContext.validationError()を呼び出します（ユーザーがデータを再入力する必要はありません）。また、表示するエラーメッセージを指定します。エラーメッセージは、国際化されたメッセージ・バンドルのメッセージ・バンドル・プロパティーを指し示している必要があります。他の登録拡張の場合、validate()はフォーム要素のフォーマット、つまり別の電子メール属性を検証する可能性もあります。"

msgid ""
"Let's also look at the user profile plugin that is used to validate email "
"address and other user information when registering."
msgstr "また、登録時にメールアドレスや他のユーザー情報を検証するために使用されるユーザー・プロファイル・プラグインについても見ていきましょう。"

msgid ""
"\n"
"    @Override\n"
"    public void validate(ValidationContext context) {\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        List<FormMessage> errors = new ArrayList<>();\n"
"\n"
"        String eventError = Errors.INVALID_REGISTRATION;\n"
"\n"
"        if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_FIRST_NAME)))) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_FIRST_NAME, Messages.MISSING_FIRST_NAME));\n"
"        }\n"
"\n"
"        if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_LAST_NAME)))) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_LAST_NAME, Messages.MISSING_LAST_NAME));\n"
"        }\n"
"\n"
"        String email = formData.getFirst(Validation.FIELD_EMAIL);\n"
"        if (Validation.isBlank(email)) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.MISSING_EMAIL));\n"
"        } else if (!Validation.isEmailValid(email)) {\n"
"            formData.remove(Validation.FIELD_EMAIL);\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.INVALID_EMAIL));\n"
"        }\n"
"\n"
"        if (context.getSession().users().getUserByEmail(email, context.getRealm()) != null) {\n"
"            formData.remove(Validation.FIELD_EMAIL);\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.EMAIL_EXISTS));\n"
"        }\n"
"\n"
"        if (errors.size() > 0) {\n"
"            context.validationError(formData, errors);\n"
"            return;\n"
"\n"
"        } else {\n"
"            context.success();\n"
"        }\n"
"    }"
msgstr ""
"\n"
"    @Override\n"
"    public void validate(ValidationContext context) {\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        List<FormMessage> errors = new ArrayList<>();\n"
"\n"
"        String eventError = Errors.INVALID_REGISTRATION;\n"
"\n"
"        if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_FIRST_NAME)))) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_FIRST_NAME, Messages.MISSING_FIRST_NAME));\n"
"        }\n"
"\n"
"        if (Validation.isBlank(formData.getFirst((RegistrationPage.FIELD_LAST_NAME)))) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_LAST_NAME, Messages.MISSING_LAST_NAME));\n"
"        }\n"
"\n"
"        String email = formData.getFirst(Validation.FIELD_EMAIL);\n"
"        if (Validation.isBlank(email)) {\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.MISSING_EMAIL));\n"
"        } else if (!Validation.isEmailValid(email)) {\n"
"            formData.remove(Validation.FIELD_EMAIL);\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.INVALID_EMAIL));\n"
"        }\n"
"\n"
"        if (context.getSession().users().getUserByEmail(email, context.getRealm()) != null) {\n"
"            formData.remove(Validation.FIELD_EMAIL);\n"
"            errors.add(new FormMessage(RegistrationPage.FIELD_EMAIL, Messages.EMAIL_EXISTS));\n"
"        }\n"
"\n"
"        if (errors.size() > 0) {\n"
"            context.validationError(formData, errors);\n"
"            return;\n"
"\n"
"        } else {\n"
"            context.success();\n"
"        }\n"
"    }"

msgid ""
"As you can see, this validate() method of user profile processing makes sure"
" that the email, first, and last name are filled in the form. It also makes "
"sure that email is in the right format. If any of these validations fail, an"
" error message is queued up for rendering. Any fields in error are removed "
"from the form data. Error messages are represented by the FormMessage class."
" The first parameter of the constructor of this class takes the HTML element"
" id. The input in error will be highlighted when the form is re-rendered. "
"The second parameter is a message reference id. This id must correspond to a"
" property in one of the localized message bundle files. in the theme."
msgstr ""
"上記に示されているとおり、ユーザー・プロファイル処理のvalidate()メソッドは、電子メール、名および姓がフォームに入力されていることを確認します。また、電子メールが適切なフォーマットであることを確認します。これらのバリデーションのいずれかが失敗すると、レンダリング用にエラーメッセージがキューに入れられます。エラーのあるフィールドは、すべてフォームデータから削除されます。エラーメッセージは、FormMessageクラスによって表されます。このクラスのコンストラクターでの最初のパラメーターは、HTML要素IDが取得されます。フォームが再レンダリングされると、エラー入力がハイライトされます。2番目のパラメーターはメッセージ参照IDです。このIDは、テーマ内でローカライズされたメッセージ・バンドル・ファイルのいずれかのプロパティーに対応している必要があります。"

msgid ""
"After all validations have been processed then, the form flow then invokes "
"the FormAction.success() method. For recaptcha this is a no-op, so we won't "
"go over it. For user profile processing, this method fills in values in the "
"registered user."
msgstr ""
"すべてのバリデーションが処理された後、フォームフローはFormAction.success()メソッドを呼び出します。Recapthaに対して、これは何も行わないので説明はしません。ユーザー・プロファイル処理の場合、このメソッドは登録ユーザーの値を入力します。"

msgid ""
"\n"
"    @Override\n"
"    public void success(FormContext context) {\n"
"        UserModel user = context.getUser();\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        user.setFirstName(formData.getFirst(RegistrationPage.FIELD_FIRST_NAME));\n"
"        user.setLastName(formData.getFirst(RegistrationPage.FIELD_LAST_NAME));\n"
"        user.setEmail(formData.getFirst(RegistrationPage.FIELD_EMAIL));\n"
"    }"
msgstr ""
"\n"
"    @Override\n"
"    public void success(FormContext context) {\n"
"        UserModel user = context.getUser();\n"
"        MultivaluedMap<String, String> formData = context.getHttpRequest().getDecodedFormParameters();\n"
"        user.setFirstName(formData.getFirst(RegistrationPage.FIELD_FIRST_NAME));\n"
"        user.setLastName(formData.getFirst(RegistrationPage.FIELD_LAST_NAME));\n"
"        user.setEmail(formData.getFirst(RegistrationPage.FIELD_EMAIL));\n"
"    }"

msgid ""
"Pretty simple implementation. The UserModel of the newly registered user is "
"obtained from the FormContext. The appropriate methods are called to "
"initialize UserModel data."
msgstr ""
"とてもシンプルな実装です。新しく登録されたユーザーのUserModelは、FormContextから取得されます。適切なメソッドが呼び出され、UserModelデータが初期化されます。"

msgid ""
"Finally, you are also required to define a FormActionFactory class. This "
"class is implemented similarly to AuthenticatorFactory, so we won't go over "
"it."
msgstr ""
"最後に、FormActionFactoryクラスを定義する必要もあります。このクラスは、AuthenticatorFactoryと同様に実装されるため、ここでは説明はしません。"

msgid "Packaging the action"
msgstr "アクションのパッケージ化"

msgid ""
"You will package your classes within a single jar. This jar must contain a "
"file named  `org.keycloak.authentication.FormActionFactory`                "
"and must be contained in the `META-INF/services/` directory of your jar. "
"This file must list the fully qualified class name of each FormActionFactory"
" implementation you have in the jar. For example:"
msgstr ""
"1つのJARファイル内にクラスをパッケージ化します。このJARには、 "
"`org.keycloak.authentication.FormActionFactory` という名前のファイルが、JARの `META-"
"INF/services/` "
"ディレクトリーに含まれている必要があります。このファイルには、JARファイル内にある各FormActionFactory実装の完全修飾クラス名が一覧化されている必要があります。たとえば、以下のようになります。"

msgid ""
"\n"
"org.keycloak.authentication.forms.RegistrationProfile\n"
"org.keycloak.authentication.forms.RegistrationRecaptcha"
msgstr ""
"\n"
"org.keycloak.authentication.forms.RegistrationProfile\n"
"org.keycloak.authentication.forms.RegistrationRecaptcha"

msgid "Adding FormAction to the registration flow"
msgstr "RegistrationフローへのFormActionの追加"

msgid ""
"Adding a FormAction to a registration page flow must be done in the Admin "
"Console. If you go to the Authentication menu item and go to the Flow tab, "
"you will be able to view the currently defined flows. You cannot modify "
"built in flows, so, to add the Authenticator we've created you have to copy "
"an existing flow or create your own. I'm hoping the UI is intuitive enough "
"so that you can figure out for yourself how to create a flow and add the "
"FormAction."
msgstr ""
"登録ページフローへのFormActionの追加は管理コンソールで行う必要があります。Authenticationメニュー項目へ移動してFlowタブを選択すると、現在定義されているフローが表示されます。組み込みのフローは変更することはできません。そのため、作成したオーセンティケーターを追加するには、既存のフローをコピーするか独自のフローを作成する必要があります。このUIは非常に分かりやすく作られているので、フローを作成してFormActionを追加する方法を見つけることができると思っています。"

msgid ""
"Basically you'll have to copy the registration flow. Then click Actions menu"
" to the right of the Registration Form, and pick \"Add execution\" to add a "
"new execution. You'll pick the FormAction from the selection list. Make sure"
" your FormAction comes after \"Registration User Creation\" by using the "
"down buttons to move it if your FormAction isn't already listed after "
"\"Registration User Creation\".  You want your FormAction to come after user"
" creation because the success() method of Registration User Creation is "
"responsible for creating the new UserModel."
msgstr ""
"基本的には、Registrationフローをコピーする必要があります。次に、Registration "
"Formの右側にあるActionsメニューをクリックし、\"Add "
"execution\"を選択して新しいエグゼキューションを追加します。選択リストからFormActionを選択します。FormActionが\"Registration"
" User Creation\"の後に表示されていない場合は、ダウンボタンを使用してFormActionが\"Registration User "
"Creation\"の後に来ることを確認してください。Regsitration User "
"Creationのsuccess()メソッドは、新しいUserModelの作成を受け持つため、FormActionはユーザー作成の後に表示される必要があります。"

msgid ""
"After you've created your flow, you have to bind it to registration. If you "
"go to the Authentication menu and go  to the Bindings tab you will see "
"options to bind a flow to the browser, registration, or direct grant flow."
msgstr ""
"フローを作成した後、そのフローをRegistrationにバインドする必要があります。Authenticationメニューに移動してBindingsタブを選択すると、フローをBrowser、Registration、またはDirect"
" Grantフローにバインドするオプションが表示されます。"

msgid "Modifying forgot password/credential flow"
msgstr "パスワード忘れおよびクレデンシャル・フローの変更"

msgid ""
"{project_name} also has a specific authentication flow for forgot password, "
"or rather credential reset initiated by a user. If you go to the Admin "
"Console flows page, there is a \"reset credentials\" flow. By default, "
"{project_name} asks for the email or username of the user and sends an email"
" to them. If the user clicks on the link, then they are able to reset both "
"their password and OTP (if an OTP has been set up).  You can disable "
"automatic OTP reset by disabling the \"Reset OTP\" authenticator in the "
"flow."
msgstr ""
"{project_name}には、パスワードを忘れた場合の特定の認証フロー、またはユーザーにより発行されたクレデンシャルのリセットもあります。管理コンソールのフローページに移動すると、\"Reset"
" "
"Credentials\"フローがあります。デフォルトでは、{project_name}はユーザーの電子メールまたはユーザー名を要求し、ユーザーに電子メールを送信します。ユーザーがリンクをクリックすると、パスワードとOTP（OTPが設定されている場合）の両方をリセットすることができます。フローの\"Reset"
" OTP\"オーセンティケーターを無効にすると、自動のOTPリセットを無効にすることができます。"

msgid ""
"You can add additional functionality to this flow as well. For example, many"
" deployments would like for the user to answer one or more secret questions "
"in additional to sending an email with a link. You could expand on the "
"secret question example that comes with the distro and incorporate it into "
"the reset credential flow."
msgstr ""
"このフローにも機能を追加することができます。たとえば、多くのデプロイメントでは、リンク付きの電子メールを送信することに加え、ユーザーが1つ以上の秘密の質問に回答するようにしたいと考えています。配布物に付属している秘密の質問のサンプルを拡張し、それをReset"
" Credentialフローに組み込むことができます。"

msgid ""
"One thing to note if you are extending the reset credentials flow. The first"
" \"authenticator\" is just a page to obtain the username or email. If the "
"username or email exists, then the AuthenticationFlowContext.getUser() will "
"return the located user. Otherwise this will be null. This form *WILL NOT* "
"re-ask the user to enter an email or username if the previous email or "
"username did not exist. You need to prevent attackers from being able to "
"guess valid users. So, if AuthenticationFlowContext.getUser() returns null, "
"you should proceed with the flow to make it look like a valid user was "
"selected. I suggest that if you want to add secret questions to this flow, "
"you should ask these questions after the email is sent. In other words, add "
"your custom authenticator after the \"Send Reset Email\" authenticator."
msgstr ""
"Reset "
"Credentialsフローを拡張する場合、1つ注意点があります。最初の\"オーセンティケーター\"は、ユーザー名または電子メールを取得するための単なるページです。ユーザー名または電子メールが存在する場合、AuthenticationFlowContext.getUser()はそのユーザーを返します。それ以外の場合はnullになります。このフォームは、以前の電子メールまたはユーザー名が存在しない場合、電子メールまたはユーザー名を入力するようにユーザーに再要求"
" *しません* "
"。攻撃者が有効なユーザーを推測できないようにする必要があるため、AuthenticationFlowContext.getUser()がnullを返す場合、有効なユーザーが選択されたかのように見せかけるために、フローを続行する必要があります。このフローに秘密の質問を追加する場合は、電子メールの送信後にこれらの質問をすることをお勧めします。つまり、\"Send"
" Reset Email\"オーセンティケーターの後に、カスタム・オーセンティケーターを追加してください。"

msgid "Modifying first broker login flow"
msgstr "First Broker Loginフローの変更"

msgid ""
"First Broker Login flow is used during first login with some identity "
"provider. Term `First Login` means that there is not yet existing "
"{project_name} account linked with the particular authenticated identity "
"provider account."
msgstr ""
"First Broker Loginフローは、アイデンティティー・プロバイダーに最初にログインした時に使用されます。 `First Login` "
"という用語は、特定の認証されたアイデンティティー・プロバイダー・アカウントにリンクされている{project_name}アカウントがまだ存在していないことを意味します。"

msgid ""
"See the `Identity Brokering` chapter in "
"link:{adminguide_link}[{adminguide_name}] ."
msgstr ""
"link:{adminguide_link}[{adminguide_name}] の `アイデンティティー・ブローカリング` の章を参照してください。"

msgid "Authentication of clients"
msgstr "クライアントの認証"

msgid ""
"{project_name} actually supports pluggable authentication for "
"https://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect] client"
" applications. Authentication of client (application) is used under the hood"
" by the {project_name} adapter during sending any backchannel requests to "
"the {project_name} server (like the request for exchange code to access "
"token after successful authentication or request to refresh token). But the "
"client authentication can be also used directly by you during `Direct Access"
" grants` (represented by OAuth2 `Resource Owner Password Credentials Flow`) "
"or during `Service account` authentication (represented by OAuth2 `Client "
"Credentials Flow`)."
msgstr ""
"{project_name}は実際には、 https://openid.net/specs/openid-connect-"
"core-1_0.html[OpenID Connect] "
"クライアント・アプリケーションのためのプラグイン可能な認証をサポートしています。クライアント（アプリケーション）の認証は、{project_name}アダプターがバックチャネル・リクエストを{project_name}サーバーに送信中に内部で使用されます（認証が成功した後にコードとアクセストークンを交換する要求をしたり、リフレッシュトークンを要求したりするなど）。しかし、"
" `ダイレクト・アクセス・グラント` （OAuth2により表される `Resource Owner Password Credentials Flow`"
" ）または `サービス・アカウント` 認証（OAuth2により表される `Client Credentials Flow` "
"）でクライアント認証を直接使用することも可能です。"

msgid ""
"For more details about {project_name} adapter and OAuth2 flows see "
"link:{adapterguide_link}[{adapterguide_name}]."
msgstr ""
"{project_name}アダプターとOAuth2フローの詳細については、link:{adapterguide_link}[{adapterguide_name}]を参照してください。"

msgid "Default implementations"
msgstr "デフォルト実装"

msgid ""
"Actually {project_name} has 2 default implementations of client "
"authentication:"
msgstr "実際、{project_name}には、以下の2つのクライアント認証の実装が組み込まれています。"

msgid "Traditional authentication with client_id and client_secret"
msgstr "client_idとclient_secretによる従来の認証"

msgid ""
"This is default mechanism mentioned in the https://openid.net/specs/openid-"
"connect-core-1_0.html[OpenID Connect]                                or "
"https://datatracker.ietf.org/doc/html/rfc6749[OAuth2] specification and "
"{project_name} supports it since it's early days. The public client needs to"
" include `client_id` parameter with its ID in the POST request (so it's de "
"facto not authenticated) and the confidential client needs to include "
"`Authorization: Basic` header with the clientId and clientSecret used as "
"username and password."
msgstr ""
"これは、 https://openid.net/specs/openid-connect-core-1_0.html[OpenID Connect] "
"または https://datatracker.ietf.org/doc/html/rfc6749[OAuth2] "
"の仕様で記載されているデフォルトのメカニズムであり、{project_name}は初期段階からサポートしています。パブリック・クライアントは、POSTリクエストに自身のIDを指定した"
" `client_id` パラメーターが含まれている必要があり（実際は認証されていません）、コンフィデンシャル・クライアントは、 "
"`Authorization: Basic` "
"ヘッダーとともに、ユーザー名とパスワードとして使用されるクライアントIDとクライアント・シークレットが含まれている必要があります。"

msgid "Authentication with signed JWT"
msgstr "署名付きJWTによる認証"

msgid ""
"This is based on the https://datatracker.ietf.org/doc/html/rfc7523[JWT "
"Bearer Token Profiles for OAuth 2.0] specification. The client/adapter "
"generates the https://datatracker.ietf.org/doc/html/rfc7519[JWT] and signs "
"it with his private key. The {project_name} then verifies the signed JWT "
"with the client's public key and authenticates client based on it."
msgstr ""
"これは、 https://datatracker.ietf.org/doc/html/rfc7523[JWT Bearer Token Profiles"
" for OAuth 2.0] 仕様に基づいています。クライアントまたはアダプターは、 "
"https://datatracker.ietf.org/doc/html/rfc7519[JWT] "
"を生成し、秘密鍵で署名します。{project_name}は、署名されたJWTをクライアントの公開鍵で検証し、それに基づいてクライアントを認証します。"

msgid ""
"See the demo example and especially the `examples/preconfigured-"
"demo/product-app` for the example application showing the application using "
"client authentication with signed JWT."
msgstr ""
"署名付きJWTでクライアント認証を使用するアプリケーションを示すアプリケーションの例については、デモのサンプルと、特に "
"`examples/preconfigured-demo/product-app` を参照してください。"

msgid "Implement your own client authenticator"
msgstr "独自のクライアント・オーセンティケーターの実装"

msgid ""
"For plug your own client authenticator, you need to implement few interfaces"
" on both client (adapter) and server side."
msgstr ""
"独自のクライアント・オーセンティケーターをプラグインするには、クライアント（アダプター）とサーバー側の両方にいくつかのインターフェイスを実装する必要があります。"

msgid "Client side"
msgstr "クライアント側"

msgid ""
"Here you need to implement "
"`org.keycloak.adapters.authentication.ClientCredentialsProvider` and put the"
" implementation either to:"
msgstr ""
"ここでは、 `org.keycloak.adapters.authentication.ClientCredentialsProvider` "
"を実装し、以下のいずれかにその実装を入れる必要があります。"

msgid ""
"your WAR file into WEB-INF/classes . But in this case, the implementation "
"can be used just for this single WAR application"
msgstr "WARファイル内のWEB-INF/classes。ただし、この場合、実装はこの単一のWARアプリケーションに対してのみ使用できます。"

msgid "Some JAR file, which will be added into WEB-INF/lib of your WAR"
msgstr "WARのWEB-INF/libに追加されるJARファイル。"

msgid ""
"Some JAR file, which will be used as jboss module and configured in jboss-"
"deployment-structure.xml of your WAR.                                In all "
"cases, you also need to create the file `META-"
"INF/services/org.keycloak.adapters.authentication.ClientCredentialsProvider`"
"                                either in the WAR or in your JAR."
msgstr ""
"JBossモジュールとして使用され、WARのjboss-deployment-structure.xmlで設定されるJARファイル。 "
"いずれの場合も、WARまたはJARに `META-"
"INF/services/org.keycloak.adapters.authentication.ClientCredentialsProvider`"
" ファイルを作成する必要があります。"

msgid "Server side"
msgstr "サーバー側"

msgid ""
"Here you need to implement "
"`org.keycloak.authentication.ClientAuthenticatorFactory` and "
"`org.keycloak.authentication.ClientAuthenticator` . You also need to add the"
" file `META-"
"INF/services/org.keycloak.authentication.ClientAuthenticatorFactory` with "
"the name of the implementation classes. See "
"<<_auth_spi_walkthrough,authenticators>> for more details."
msgstr ""
"ここでは、 `org.keycloak.authentication.ClientAuthenticatorFactory` と "
"`org.keycloak.authentication.ClientAuthenticator` を実装する必要があります。また、 `META-"
"INF/services/org.keycloak.authentication.ClientAuthenticatorFactory` "
"ファイルに実装クラスの名前を追加する必要があります。詳細については、<<_auth_spi_walkthrough,オーセンティケーター>> "
"を参照してください。"

msgid "Action Token Handler SPI"
msgstr "アクション・トークン・ハンドラーSPI"

msgid ""
"An action token is a special instance of Json Web Token (JWT) that permits "
"its bearer to perform some actions, e.g. to reset a password or validate "
"e-mail address. They are usually sent to users in form of a link that points"
" to an endpoint processing action tokens for a particular realm."
msgstr ""
"アクション・トークンとは、Json Web "
"Token（JWT）の特別なインスタンスで、その持参者がいくつかの動作を実行できるようにするものです。たとえば、パスワードをリセットしたり、電子メールアドレスを検証したりすることができます。それらは通常、特定のレルムのアクション・トークンを処理するエンドポイントを指すリンクの形式でユーザーに送信されます。"

msgid "{project_name} offers four basic token types allowing the bearer to:"
msgstr "{project_name}は、4つの基本のトークンタイプを提供して、持参者が以下を実行できるようにします。"

msgid "Reset credentials"
msgstr "クレデンシャルのリセット"

msgid "Confirm e-mail address"
msgstr "電子メールアドレスの確認"

msgid "Execute required action(s)"
msgstr "必須アクションの実行"

msgid ""
"Confirm linking of an account with account in external identity provider"
msgstr "外部のアイデンティティー・プロバイダーのアカウントを使用した、アカウントのリンク付けの確認"

msgid ""
"In addition to that, it is possible to implement any functionality that "
"initiates or modifies authentication session using action token handler SPI,"
" details of which are described in the text below."
msgstr ""
"これに加えて、アクショントークン・ハンドラーSPIを使用して認証セッションを開始したり、変更したりする機能を実装することができます。これについて、詳しくは、以下で説明していきます。"

msgid "Anatomy of action token"
msgstr "アクション・トークンの解剖"

msgid ""
"Action token is a standard Json Web Token signed with active realm key where"
" the payload contains several fields:"
msgstr ""
"アクション・トークンは、ペイロードに複数のフィールドが含まれている、アクティブなレルム鍵で署名された標準のJson Web Tokenです。"

msgid "`typ` - Identification of the action (e.g. `verify-email`)"
msgstr "`typ` - アクションの識別子（例： `verify-email` ）"

msgid "`iat` and `exp` - Times of token validity"
msgstr "`iat` と `exp` - トークンの有効期限"

msgid "`sub` - ID of the user"
msgstr "`sub` - ユーザーのID"

msgid "`azp` - Client name"
msgstr "`azp` - クライアント名"

msgid "`iss` - Issuer - URL of the issuing realm"
msgstr "`iss` - 発行者 - 発行するレルムのURL"

msgid "`aud` - Audience - list containing URL of the issuing realm"
msgstr "`aud` - Audience - 発行するレルムのURLを含むリスト"

msgid "`asid` - ID of the authentication session (_optional_)"
msgstr "`asid` - 認証セッションのID (_optional_)"

msgid ""
"`nonce` - Random nonce to guarantee uniqueness of use if the operation can "
"only be executed once (_optional_)"
msgstr "`nonce` - 操作が1回しか実行できない場合の、使用の一意性を保証するためのランダムなノンス (_optional_)"

msgid ""
"In addition, an action token can contain any number of custom fields "
"serializable into JSON."
msgstr "さらに、アクション・トークンには、JSON内にシリアライズできるカスタム・フィールドをいくつか含めることができます。"

msgid "Action token processing"
msgstr "アクション・トークン処理"

msgid ""
"When an action token is passed to a {project_name} endpoint "
"`_KEYCLOAK_ROOT_{kc_realms_path}/master/login-actions/action-token` via "
"`key` parameter, it is validated and a proper action token handler is "
"executed. *The processing always takes place in a context of an "
"authentication session*, either a fresh one or the action token service "
"joins an existing authentication session (details are described below). The "
"action token handler can perform actions prescribed by the token (often it "
"alters the authentication session) and results into an HTTP response (e.g. "
"it can continue in authentication or display an information/error page). "
"These steps are detailed below."
msgstr ""
"アクション・トークンが{project_name}エンドポイント "
"`_KEYCLOAK_ROOT_{kc_realms_path}/master/login-actions/action-token` に `key` "
"パラメーターを介して渡されると、それが検証され、適切なアクション・トークン・ハンドラーが実行されます。 "
"*この処理は常に認証セッションのコンテキストに沿って行われ* "
"、新しいものかアクション・トークン・サービスが既存の認証セッションに加わります（詳しくは、後で説明します）。アクション・トークン・ハンドラーは、トークン（これで認証セッションを変更することが多い）によって規定されたアクションを実行し、HTTPレスポンスを返すことができます（たとえば、認証を続けるか、情報またはエラーページを表示することができます）。これらの手順について、詳しくは以下のとおりです。"

msgid ""
"*Basic action token validation.* Signature and time validity is checked, and"
" action token handler is determined based on `typ` field."
msgstr ""
"*基本的なアクショントークンの検証* 。シグネチャーと時間の有効性がチェックされ、アクション・トークン・ハンドラーが `typ` "
"フィールドに基づいて決定されます。"

msgid ""
"[[determining-auth-sess]]*Determining authentication session.* If the action"
" token URL was opened in browser with existing authentication session, and "
"the token contains authentication session ID matching the authentication "
"session from the browser, action token validation and handling will attach "
"this ongoing authentication session. Otherwise, action token handler creates"
" a fresh authentication session that replaces any other authentication "
"session present at that time in the browser."
msgstr ""
"[[determining-auth-sess]]*認証セッションの決定。* "
"アクション・トークンURLが既存の認証セッションを使用するブラウザーで開かれ、トークンにブラウザーからの認証セッションと一致する認証セッションIDが含まれている場合、アクション・トークンの検証と処理により、この進行中の認証セッションが追加されます。"
" そうでない場合は、アクション・トークン・ハンドラーはその時点でブラウザーに存在する他の認証セッションを置き換える新しい認証セッションを作成します。"

msgid ""
"*Token validations specific for token type.* Action token endpoint logic "
"validates that the user (`sub` field) and client (`azp`) from the token "
"exist, are valid and not disabled. Then it validates all custom validations "
"defined in the action token handler. Furthermore, token handler can request "
"this token be single-use. Already used tokens would then be rejected by "
"action token endpoint logic."
msgstr ""
"*トークンタイプ固有のトークンの検証。* アクション・トークン・エンドポイント・ロジックは、トークンにユーザー（ `sub` "
"フィールド）とクライアント（ `azp` "
"）が存在し、無効ではないことを検証します。次に、アクション・トークン・ハンドラー内で定義されたカスタム・バリデーションがすべて検証されます。さらに、トークン・ハンドラーは、トークンを使い捨てるように要求できます。これで、すでに使用済みのトークンは、アクション・トークン・エンドポイント・ロジックによって拒否されます。"

msgid ""
"*Performing the action.* After all these validations, action token handler "
"code is called that performs the actual action according to parameters in "
"the token."
msgstr ""
"*アクションの実行。* "
"これらの検証がすべて行われた後で、トークン内のパラメーターに応じて実際にアクションを実行する、アクション・トークン・ハンドラー・コードが呼び出されます。"

msgid ""
"*Invalidation of single-Use tokens.* If the token is set to single-use, once"
" the authentication flow finishes, the action token is invalidated."
msgstr "*使い捨てトークンの無効化。* トークンを使い捨てるように設定されている場合、認証フローが完了次第、アクション・トークンは無効になります。"

msgid "Implement your own action token and its handler"
msgstr "独自のアクション・トークンとそのハンドラーの実装"

msgid "How to create an action token"
msgstr "アクション・トークンの作成方法"

msgid ""
"As action token is just a signed JWT with few mandatory fields (see "
"<<_action_token_anatomy,Anatomy of action token>> above), it can be "
"serialized and signed as such using Keycloak's `JWSBuilder` class. This way "
"has been already implemented in `serialize(session, realm, uriInfo)` method "
"of `org.keycloak.authentication.actiontoken.DefaultActionToken` and can be "
"leveraged by implementors by using that class for tokens instead of plain "
"`JsonWebToken`."
msgstr ""
"アクション・トークンは、必須フィールドがほとんどない署名付きJWTなので、Keycloakの `JWSBuilder` "
"クラスを使用してシリアライズして署名することができます（<<_action_token_anatomy,アクショントークンの解剖>> "
"を参照してください）。この方法は、 "
"`org.keycloak.authentication.actiontoken.DefaultActionToken` の "
"`serialize(session, realm, uriInfo)` メソッドにすでに実装されており、実装者はプレーンな "
"`JsonWebToken` の代わりにそのクラスを使うことで活用できます。"

msgid ""
"The following example shows the implementation of a simple action token. "
"Note that the class must have a private constructor without any arguments. "
"This is necessary to deserialize the token class from JWT."
msgstr ""
"次の例は、単純なアクショントークンの実装を示しています。クラスには引数のないprivateコンストラクターが必要です。これは、JWTからトークンクラスをデシリアライズするために必要です。"

msgid ""
"import org.keycloak.authentication.actiontoken.DefaultActionToken;\n"
"\n"
"public class DemoActionToken extends DefaultActionToken {\n"
"\n"
"    public static final String TOKEN_TYPE = \"my-demo-token\";\n"
"\n"
"    public DemoActionToken(String userId, int absoluteExpirationInSecs, String compoundAuthenticationSessionId) {\n"
"        super(userId, TOKEN_TYPE, absoluteExpirationInSecs, null, compoundAuthenticationSessionId);\n"
"    }\n"
"\n"
"    private DemoActionToken() {\n"
"        // Required to deserialize from JWT\n"
"        super();\n"
"    }\n"
"}"
msgstr ""
"import org.keycloak.authentication.actiontoken.DefaultActionToken;\n"
"\n"
"public class DemoActionToken extends DefaultActionToken {\n"
"\n"
"    public static final String TOKEN_TYPE = \"my-demo-token\";\n"
"\n"
"    public DemoActionToken(String userId, int absoluteExpirationInSecs, String compoundAuthenticationSessionId) {\n"
"        super(userId, TOKEN_TYPE, absoluteExpirationInSecs, null, compoundAuthenticationSessionId);\n"
"    }\n"
"\n"
"    private DemoActionToken() {\n"
"        // Required to deserialize from JWT\n"
"        super();\n"
"    }\n"
"}"

msgid ""
"If the action token you are implementing contains any custom fields that "
"should be serializabled to JSON fields, you should consider implementing a "
"descendant of `org.keycloak.representations.JsonWebToken` class that would "
"implement `org.keycloak.models.ActionTokenKeyModel` interface. In that case,"
" you can take advantage of the existing "
"`org.keycloak.authentication.actiontoken.DefaultActionToken` class as it "
"already satisfies both these conditions, and either use it directly or "
"implement its child, the fields of which can be annotated with appropriate "
"Jackson annotations, e.g. `com.fasterxml.jackson.annotation.JsonProperty` to"
" serialize them to JSON."
msgstr ""
"実装しているアクション・トークンが、JSONフィールドにシリアライズされる必要があるカスタム・フィールドを含んでいる場合、 "
"`org.keycloak.models.ActionTokenKeyModel` インターフェイスを実装する "
"`org.keycloak.representations.JsonWebToken` "
"クラスの子孫を実装することを検討する必要があります。この場合、既存の "
"`org.keycloak.authentication.actiontoken.DefaultActionToken` "
"クラスは、すでに両方の条件を満たしており、直接使用するか、そのクラスの子を実装することができます。フィールドには適切なJacksonアノテーション（たとえば、JSONにそれらをシリアライズするには"
" `com.fasterxml.jackson.annotation.JsonProperty` ）を付けることができます。"

msgid ""
"The following example extends the `DemoActionToken` from the previous "
"example with the field `demo-id`:"
msgstr "次の例は、前の例の `DemoActionToken` をフィールド `demo-id` で拡張しています。"

msgid ""
"import com.fasterxml.jackson.annotation.JsonProperty;\n"
"import org.keycloak.authentication.actiontoken.DefaultActionToken;\n"
"\n"
"public class DemoActionToken extends DefaultActionToken {\n"
"\n"
"    public static final String TOKEN_TYPE = \"my-demo-token\";\n"
"\n"
"    private static final String JSON_FIELD_DEMO_ID = \"demo-id\";\n"
"\n"
"    @JsonProperty(value = JSON_FIELD_DEMO_ID)\n"
"    private String demoId;\n"
"\n"
"    public DemoActionToken(String userId, int absoluteExpirationInSecs, String compoundAuthenticationSessionId, String demoId) {\n"
"        super(userId, TOKEN_TYPE, absoluteExpirationInSecs, null, compoundAuthenticationSessionId);\n"
"        this.demoId =  demoId;\n"
"    }\n"
"\n"
"    private DemoActionToken() {\n"
"        // you must have this private constructor for deserializer\n"
"    }\n"
"\n"
"    public String getDemoId() {\n"
"        return demoId;\n"
"    }\n"
"}\n"
msgstr ""
"import com.fasterxml.jackson.annotation.JsonProperty;\n"
"import org.keycloak.authentication.actiontoken.DefaultActionToken;\n"
"\n"
"public class DemoActionToken extends DefaultActionToken {\n"
"\n"
"    public static final String TOKEN_TYPE = \"my-demo-token\";\n"
"\n"
"    private static final String JSON_FIELD_DEMO_ID = \"demo-id\";\n"
"\n"
"    @JsonProperty(value = JSON_FIELD_DEMO_ID)\n"
"    private String demoId;\n"
"\n"
"    public DemoActionToken(String userId, int absoluteExpirationInSecs, String compoundAuthenticationSessionId, String demoId) {\n"
"        super(userId, TOKEN_TYPE, absoluteExpirationInSecs, null, compoundAuthenticationSessionId);\n"
"        this.demoId =  demoId;\n"
"    }\n"
"\n"
"    private DemoActionToken() {\n"
"        // you must have this private constructor for deserializer\n"
"    }\n"
"\n"
"    public String getDemoId() {\n"
"        return demoId;\n"
"    }\n"
"}\n"

msgid ""
"To plug your own action token and its handler, you need to implement few "
"interfaces on server side:"
msgstr "独自のアクション・トークンとそのハンドラーをプラグインするには、サーバー側のインターフェイスを少し実装する必要があります。"

msgid ""
"`org.keycloak.authentication.actiontoken.ActionTokenHandler` - actual "
"handler of action token for a particular action (i.e. for a given value of "
"`typ` token field)."
msgstr ""
"`org.keycloak.authentication.actiontoken.ActionTokenHandler` - "
"特定のアクションに対する（つまり、 `typ` トークン・フィールドに指定された値に対する）アクション・トークンの実際のハンドラー。"

msgid ""
"The central method in that interface is `handleToken(token, context)` which "
"defines actual operation executed upon receiving the action token. Usually "
"it is some alteration of authentication session notes but generally it can "
"be arbitrary. This method is only called if all verifiers (including those "
"defined in `getVerifiers(context)`) have succeeded, and it is guaranteed "
"that the `token` would be of the class returned by `getTokenClass()` method."
msgstr ""
"そのインターフェイス内の中心的なメソッドは、アクション・トークンを受け取る際に実行される実際の操作を定義する `handleToken(token, "
"context)` です。通常、それは認証セッション記録の変更ですが、一般的には任意です。このメソッドは、ベリファイア（ "
"`getVerifiers(context)` で定義されたものを含む）がすべて成功し、 `token` が `getTokenClass()` "
"メソッドによって返されるクラスであることが保証されている場合にのみ呼び出されます。"

msgid ""
"To be able to determine whether the action token was issued for the current "
"authentication session as described in <<determining-auth-sess,Item 2 "
"above>>, method for extracting authentication session ID has to be declared "
"in `getAuthenticationSessionIdFromToken(token, context)` method. The "
"implementation in `DefaultActionToken` returns the value of `asid` field "
"from the token if it is defined. Note that you can override that method to "
"return current authentication session ID regardless of the token - that way "
"you can create tokens that would step into the ongoing authentication flow "
"before any authentication flow would be started."
msgstr ""
"<<determining-auth-"
"sess,上記の2項目>>の説明どおり、現在の認証セッションに対してアクション・トークンが発行されたのか否かを決定するには、認証セッションIDを抽出するメソッドが"
" `getAuthenticationSessionIdFromToken(token, context)` メソッドで宣言されなければなりません。 "
"`DefaultActionToken` の実装は、トークンから `asid` "
"フィールドの値を返します。このメソッドをオーバーライドして、トークンに関係なく、現在の認証セッションIDを返すことができることに注意してください。つまり、任意の認証フローを開始する前に進行中の認証フローにステップインするトークンを作成できます。"

msgid ""
"If the authentication session from the token does not match the current one,"
" the action token handler would be asked to start a fresh one by calling "
"`startFreshAuthenticationSession(token, context)`. It can throw a "
"`VerificationException` (or better its more descriptive variant "
"`ExplainedTokenVerificationException`) to signal that would be forbidden."
msgstr ""
"トークンから取得した認証セッションが現在のものと一致しない場合、アクション・トークン・ハンドラーは、 "
"`startFreshAuthenticationSession(token, context)` "
"を呼び出すことにより新しいセッションを開始するよう要求されます。これにより、禁止されることを通知するための "
"`VerificationException` （または、より説明的な表現である "
"`ExplainedTokenVerificationException` ）をスローできます。"

msgid ""
"The token handler also determines via method `canUseTokenRepeatedly(token, "
"context)` whether the token would be invalidated after it is used and "
"authentication completes. Note that if you would have a flow utilizing "
"multiple action token, only the last token would be invalidated. In that "
"case, you should use `org.keycloak.models.SingleUseObjectProvider` in action"
" token handler to invalidate the used tokens manually."
msgstr ""
"また、トークン・ハンドラーにより、 `canUseTokenRepeatedly(token, context)` "
"メソッドを介して、トークンが使用されて認証が完了した後に、トークンが無効になるかどうかが決定されます。複数のアクション・トークンを利用するフローがある場合、最後のトークンだけが無効になることに注意してください。この場合、アクション・トークン・ハンドラー内で"
" `org.keycloak.models.SingleUseObjectProvider` "
"を使用し、使用されたトークンを手動で無効にする必要があります。"

msgid ""
"Default implementation of most of the `ActionTokenHandler` methods is the "
"`org.keycloak.authentication.actiontoken.AbstractActionTokenHandler` "
"abstract class in `keycloak-services` module. The only method that needs to "
"be implemented is `handleToken(token, context)` that performs the actual "
"action."
msgstr ""
"ほとんどの `ActionTokenHandler` メソッドのデフォルト実装は、 `keycloak-services` モジュール内の "
"`org.keycloak.authentication.actiontoken.AbstractActionTokenHandler` "
"抽象クラスです。実装する必要のある唯一のメソッドは、実際のアクションを実行する `handleToken(token, context)` です。"

msgid ""
"`org.keycloak.authentication.actiontoken.ActionTokenHandlerFactory` - "
"factory that instantiates action token handler. Implementations have to "
"override `getId()` to return value that must match precisely the value of "
"`typ` field in the action token."
msgstr ""
"`org.keycloak.authentication.actiontoken.ActionTokenHandlerFactory` - "
"アクション・トークン・ハンドラーを開始するファクトリー。アクション・トークン内の `typ` フィールドの値と正確に一致する値を返すため、実装は "
"`getId()` をオーバーライドする必要があります。"

msgid ""
"Note that you have to register the custom `ActionTokenHandlerFactory` "
"implementation as explained in the <<_providers,Service Provider "
"Interfaces>> section of this guide."
msgstr ""
"カスタムの `ActionTokenHandlerFactory` "
"実装を、このガイドの<<_providers,サービス・プロバイダー・インターフェイス>>のセクションで説明するとおりに、登録しなければならないことに注意してください。"

msgid "Event Listener SPI"
msgstr "イベントリスナーSPI"

msgid ""
"Writing an Event Listener Provider starts by implementing the "
"`EventListenerProvider` and `EventListenerProviderFactory` interfaces. "
"Please see the Javadoc and examples for complete details on how to do this."
msgstr ""
"イベントリスナー・プロバイダーの作成は、 `EventListenerProvider` インタフェースと "
"`EventListenerProviderFactory` "
"インタフェースを実装することから始まります。これを行う方法の詳細については、Javadocとサンプルを参照してください。"

msgid ""
"For details on how to package and deploy a custom provider refer to the "
"<<_providers,Service Provider Interfaces>> chapter."
msgstr ""
"カスタム・プロバイダーをパッケージングしてデプロイする方法についての詳細は、<<_providers,サービス・プロバイダー・インターフェイス>>の章を参照してください。"

msgid "SAML role mappings SPI"
msgstr "SAMLロールマッピングSPI"

msgid ""
"{project_name} defines an SPI for mapping SAML roles into roles that exist "
"in the SP environment. The roles returned by a third-party IDP might not "
"always correspond to the roles that were defined for the SP application so "
"there is a need for a mechanism that allows mapping the SAML roles into "
"different roles. It is used by the SAML adapter after it extracts the roles "
"from the SAML assertion to set up the container's security context."
msgstr ""
"{project_name}は、SP環境に存在するロールにSAMLロールをマッピングするためのSPIを定義します。サードパーティーのIDPによって返されるロールは、SPアプリケーション用に定義されたロールに常に対応するとは限らないため、SAMLロールを異なるロールにマッピングできるメカニズムが必要です。SAMLアサーションからロールを抽出してコンテナのセキュリティー・コンテキストをセットアップした後、SAMLアダプターによって使用されます。"

msgid ""
"The `org.keycloak.adapters.saml.RoleMappingsProvider` SPI doesn't impose any"
" restrictions on the mappings that can be performed. Implementations can not"
" only map roles into other roles but also add or remove roles (and thus "
"augment or reduce the set of roles assigned to the SAML principal) depending"
" on the use case."
msgstr ""
"`org.keycloak.adapters.saml.RoleMappingsProvider` "
"SPIは、実行可能なマッピングに制限を課しません。実装は、ロールを他のロールにマッピングするだけでなく、ユースケースに応じてロールを追加または削除することができます（したがって、SAMLプリンシパルに割り当てられたロールのセットを増やしたり減らしたりします）。"

msgid ""
"For details about the configuration of the role mappings provider for the "
"SAML adapter as well as a description of the default implementations "
"available see the link:{adapterguide_link}[{adapterguide_name}]."
msgstr ""
"SAMLアダプターのロールマッピング・プロバイダーの設定の詳細、および利用可能なデフォルトの実装の説明については、link:{adapterguide_link}[{adapterguide_name}]を参照してください。"

msgid "Implementing a custom role mappings provider"
msgstr "カスタム・ロールマッピング・プロバイダーの実装"

msgid ""
"To implement a custom role mappings provider one first needs to implement "
"the `org.keycloak.adapters.saml.RoleMappingsProvider` interface. Then, a "
"`META-INF/services/org.keycloak.adapters.saml.RoleMappingsProvider` file "
"containing the fully qualified name of the custom implementation must be "
"added to the archive that also contains the implementation class. This "
"archive can be:"
msgstr ""
"カスタム・ロールマッピング・プロバイダーを実装するには、最初に "
"`org.keycloak.adapters.saml.RoleMappingsProvider` "
"インターフェイスを実装する必要があります。次に、カスタム実装の完全修飾名を含む `META-"
"INF/services/org.keycloak.adapters.saml.RoleMappingsProvider` "
"ファイルを、実装クラスも含むアーカイブに追加する必要があります。このアーカイブには次のものがあります。"

msgid ""
"The SP application WAR file where the provider class is included in WEB-"
"INF/classes;"
msgstr "プロバイダー・クラスがWEB-INF/classesに含まれているSPアプリケーションWARファイル。"

msgid ""
"A custom JAR file which will be added into WEB-INF/lib of the SP application"
" WAR;"
msgstr "SPアプリケーションのWARのWEB-INF/libに追加されるカスタムJARファイル。"

msgid ""
"(WildFly/JBoss EAP only) A custom JAR file configured as a `jboss module` "
"and referenced in `jboss-deployment-structure.xml` of the SP application "
"WAR."
msgstr ""
"（WildFly/JBoss EAPのみ） `jboss module` として設定され、SPアプリケーションのWARの `jboss-"
"deployment-structure.xml` で参照されるカスタムJARファイル。"

msgid ""
"When the SP application is deployed, the role mappings provider that will be"
" used is selected by the id that was set in `keycloak-saml.xml` or in the "
"`keycloak-saml` subsystem. So to enable your custom provider simply make "
"sure that its id is properly set in the adapter configuration."
msgstr ""
"SPアプリケーションがデプロイされると、使用されるロールマッピング・プロバイダーは、 `keycloak-saml.xml` または "
"`keycloak-saml` "
"サブシステムで設定されたIDによって選択されます。したがって、カスタム・プロバイダーを有効にするには、アダプター設定でそのIDが適切に設定されていることを確認するだけです。"

msgid "User Storage SPI"
msgstr "ユーザー・ストレージSPI"

msgid ""
"This functionality depends on APIs bundled in the `keycloak-model-legacy` "
"module. It will soon be replaced with the new map storage API which provides"
" a uniform way to access both local and external information about users and"
" other entities, and the old APIs will be removed eventually."
msgstr ""
"この機能は `keycloak-model-legacy` "
"モジュールにバンドルされているAPIに依存しています。これは、ユーザーや他のエンティティーに関するローカルと外部の両方の情報にアクセスするための統一された方法を提供する新しいマップストレージAPIにまもなく置き換えられ、古いAPIは最終的に削除される予定です。"

msgid ""
"You can use the User Storage SPI to write extensions to {project_name} to "
"connect to external user databases and credential stores. The built-in LDAP "
"and ActiveDirectory support is an implementation of this SPI in action. Out "
"of the box, {project_name} uses its local database to create, update, and "
"look up users and validate credentials. Often though, organizations have "
"existing external proprietary user databases that they cannot migrate to "
"{project_name}'s data model. For those situations, application developers "
"can write implementations of the User Storage SPI to bridge the external "
"user store and the internal user object model that {project_name} uses to "
"log in users and manage them."
msgstr ""
"ユーザー・ストレージSPIを使用して、外部ユーザー・データベースとクレデンシャル・ストアに接続するように、{project_name}の拡張機能を実装できます。組み込みのLDAPとActive"
" "
"Directoryのサポートは、このSPIを実際に実装したものです。設定などの作業をせず、すぐに{project_name}はローカル・データベースを使用して、ユーザーの作成、更新、検索とクレデンシャルの検証をします。しかし、多くの場合、組織は{project_name}のデータモデルに移行できない外部の独自ユーザー・データベースをすでに持っています。このような状況では、アプリケーション開発者は、ユーザー・ストレージSPIの実装をコーディングして、外部ユーザーストアと、{project_name}がユーザーのログインおよび管理に使用する内部ユーザー・オブジェクト・モデルをブリッジすることができます。"

msgid ""
"When the {project_name} runtime needs to look up a user, such as when a user"
" is logging in, it performs a number of steps to locate the user. It first "
"looks to see if the user is in the user cache; if the user is found it uses "
"that in-memory representation. Then it looks for the user within the "
"{project_name} local database. If the user is not found, it then loops "
"through User Storage SPI provider implementations to perform the user query "
"until one of them returns the user the runtime is looking for. The provider "
"queries the external user store for the user and maps the external data "
"representation of the user to {project_name}'s user metamodel."
msgstr ""
"{project_name}ランタイムは、ユーザーがログインしているときなどの、ユーザーを検索する必要があるときに、ユーザーを特定するためいくつかの手順を実行します。まず、ユーザーがユーザー・キャッシュに入っているかどうかを調べます。ユーザーが見つかった場合は、そのメモリー内表現を使用します。次に、{project_name}ローカル・データベース内のユーザーを探します。ユーザーが見つからない場合は、ユーザー・ストレージSPIプロバイダーの実装をループして、そのうちの1つがランタイムが探しているユーザーを返すまでユーザークエリーを実行します。プロバイダーは外部ユーザーストアにユーザーを照会し、ユーザーの外部データ表現を{project_name}のユーザー・メタモデルにマップします。"

msgid ""
"User Storage SPI provider implementations can also perform complex criteria "
"queries, perform CRUD operations on users, validate and manage credentials, "
"or perform bulk updates of many users at once. It depends on the "
"capabilities of the external store."
msgstr ""
"ユーザー・ストレージSPIプロバイダーの実装では、複雑な条件のクエリーを実行したり、ユーザーに対してCRUD操作を実行したり、クレデンシャルを検証および管理したり、一度に多くのユーザーの一括更新を実行することもできます。これは外部ストアの機能に依存します。"

msgid ""
"User Storage SPI provider implementations are packaged and deployed "
"similarly to (and often are) Jakarta EE components. They are not enabled by "
"default, but instead must be enabled and configured per realm under the "
"`User Federation` tab in the administration console."
msgstr ""
"ユーザー・ストレージSPIプロバイダーの実装は、Jakarta EEコンポーネントと同様にパッケージ化され、デプロイされます（しばしばJakarta "
"EEコンポーネントです）。デフォルトでは有効になっていませんが、管理コンソールの `User Federation` "
"タブでレルムごとに有効にして設定する必要があります。"

msgid ""
"If your user provider implementation is using some user attributes as the "
"metadata attributes for linking/establishing the user identity, then please "
"make sure that users are not able to edit the attributes and the "
"corresponding attributes are read-only. The example is the `LDAP_ID` "
"attribute, which the built-in {project_name} LDAP provider is using for to "
"store the ID of the user on the LDAP server side. See the details in the "
"link:{adminguide_link}#_read_only_user_attributes[Threat model mitigation "
"chapter]."
msgstr ""
"ユーザー・プロバイダーの実装で、ユーザーのアイデンティティーをリンク/確立するためのメタデータ属性として一部のユーザー属性を使用している場合は、ユーザーが属性を編集できず、対応する属性が読み取り専用であることを確認してください。この例は、組み込みの{project_name}"
" LDAPプロバイダーがLDAPサーバー側でユーザーのIDを保存するために使用している `LDAP_ID` 属性です。詳細については "
"link:{adminguide_link}#_read_only_user_attributes[脅威モデルの緩和の章] を参照してください。"

msgid ""
"There are two sample projects in "
"link:{quickstartRepo_link}[{quickstartRepo_name}]. Each quickstart has a "
"`README` file with instructions on how to build, deploy, and test the sample"
" project. The following table provides a brief description of the available "
"User Storage SPI quickstarts:"
msgstr ""
"link:{quickstartRepo_link}[{quickstartRepo_name}] "
"には、2つのサンプルプロジェクトがあります。各クイックスタートには `README` "
"ファイルがあり、サンプル・プロジェクトのビルド、デプロイ、テストの方法が書かれています。次の表は、利用可能なユーザー・ストレージSPIクイックスタートの簡単な説明です。"

msgid "User Storage SPI Quickstarts"
msgstr "ユーザー・ストレージSPIクイックスタート"

msgid "Name"
msgstr "名前"

msgid "Description"
msgstr "説明"

msgid "{quickstartRepo_link}/tree/latest/user-storage-jpa[user-storage-jpa]"
msgstr "{quickstartRepo_link}/tree/latest/user-storage-jpa[user-storage-jpa]"

msgid "Demonstrates implementing a user storage provider using EJB and JPA."
msgstr "EJBとJPAを使用したユーザー・ストレージ・プロバイダーの実装を紹介しています。"

msgid ""
"{quickstartRepo_link}/tree/latest/user-storage-simple[user-storage-simple]"
msgstr ""
"{quickstartRepo_link}/tree/latest/user-storage-simple[user-storage-simple]"

msgid ""
"Demonstrates implementing a user storage provider using a simple properties "
"file that contains username/password key pairs."
msgstr ""
"ユーザー名とパスワードのキーペアを含むシンプルなプロパティー・ファイルを使用して、ユーザー・ストレージ・プロバイダーを実装する方法を紹介しています。"

msgid "Provider interfaces"
msgstr "プロバイダー・インターフェイス"

msgid ""
"When building an implementation of the User Storage SPI you have to define a"
" provider class and a provider factory. Provider class instances are created"
" per transaction by provider factories. Provider classes do all the heavy "
"lifting of user lookup and other user operations.  They must implement the "
"`org.keycloak.storage.UserStorageProvider` interface."
msgstr ""
"ユーザー・ストレージSPIを実装する場合、プロバイダー・クラスとプロバイダー・ファクトリーを定義する必要があります。プロバイダー・クラス・インスタンスは、プロバイダー・ファクトリーによってトランザクション毎に作成されます。プロバイダー・クラスは、ユーザーのルックアップやその他の操作などの重い処理をすべて請け負います。プロバイダー・クラスは、"
" `org.keycloak.storage.UserStorageProvider` インターフェイスを実装する必要があります。"

msgid ""
"package org.keycloak.storage;\n"
"\n"
"public interface UserStorageProvider extends Provider {\n"
"\n"
"\n"
"    /**\n"
"     * Callback when a realm is removed.  Implement this if, for example, you want to do some\n"
"     * cleanup in your user storage when a realm is removed\n"
"     *\n"
"     * @param realm\n"
"     */\n"
"    default\n"
"    void preRemove(RealmModel realm) {\n"
"\n"
"    }\n"
"\n"
"    /**\n"
"     * Callback when a group is removed.  Allows you to do things like remove a user\n"
"     * group mapping in your external store if appropriate\n"
"     *\n"
"     * @param realm\n"
"     * @param group\n"
"     */\n"
"    default\n"
"    void preRemove(RealmModel realm, GroupModel group) {\n"
"\n"
"    }\n"
"\n"
"    /**\n"
"     * Callback when a role is removed.  Allows you to do things like remove a user\n"
"     * role mapping in your external store if appropriate\n"
"\n"
"     * @param realm\n"
"     * @param role\n"
"     */\n"
"    default\n"
"    void preRemove(RealmModel realm, RoleModel role) {\n"
"\n"
"    }\n"
"\n"
"}"
msgstr ""
"package org.keycloak.storage;\n"
"\n"
"public interface UserStorageProvider extends Provider {\n"
"\n"
"\n"
"    /**\n"
"     * Callback when a realm is removed.  Implement this if, for example, you want to do some\n"
"     * cleanup in your user storage when a realm is removed\n"
"     *\n"
"     * @param realm\n"
"     */\n"
"    default\n"
"    void preRemove(RealmModel realm) {\n"
"\n"
"    }\n"
"\n"
"    /**\n"
"     * Callback when a group is removed.  Allows you to do things like remove a user\n"
"     * group mapping in your external store if appropriate\n"
"     *\n"
"     * @param realm\n"
"     * @param group\n"
"     */\n"
"    default\n"
"    void preRemove(RealmModel realm, GroupModel group) {\n"
"\n"
"    }\n"
"\n"
"    /**\n"
"     * Callback when a role is removed.  Allows you to do things like remove a user\n"
"     * role mapping in your external store if appropriate\n"
"\n"
"     * @param realm\n"
"     * @param role\n"
"     */\n"
"    default\n"
"    void preRemove(RealmModel realm, RoleModel role) {\n"
"\n"
"    }\n"
"\n"
"}"

msgid ""
"You may be thinking that the `UserStorageProvider` interface is pretty "
"sparse? You'll see later in this chapter that there are other mix-in "
"interfaces your provider class may implement to support the meat of user "
"integration."
msgstr ""
"`UserStorageProvider` "
"インターフェイスは非常に稀薄だと思うかもしれません。この章の後半で、ユーザー統合の重要性をサポートするために、プロバイダー・クラスが実装するかもしれないミックスイン・インターフェイスがあることが分かります。"

msgid ""
"`UserStorageProvider` instances are created once per transaction. When the "
"transaction is complete, the `UserStorageProvider.close()` method is invoked"
" and the instance is then garbage collected. Instances are created by "
"provider factories. Provider factories implement the "
"`org.keycloak.storage.UserStorageProviderFactory` interface."
msgstr ""
"`UserStorageProvider` インスタンスはトランザクション毎に都度作成されます。トランザクションが完了すると、 "
"`UserStorageProvider.close()` "
"メソッドが呼び出され、次にインスタンスがガーベッジ・コレクション処理されます。インスタンスはプロバイダー・ファクトリーにより作成されます。プロバイダー・ファクトリーは"
" `org.keycloak.storage.UserStorageProviderFactory` インターフェイスを実装します。"

msgid ""
"package org.keycloak.storage;\n"
"\n"
"/**\n"
" * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n"
" * @version $Revision: 1 $\n"
" */\n"
"public interface UserStorageProviderFactory<T extends UserStorageProvider> extends ComponentFactory<T, UserStorageProvider> {\n"
"\n"
"    /**\n"
"     * This is the name of the provider and will be shown in the admin console as an option.\n"
"     *\n"
"     * @return\n"
"     */\n"
"    @Override\n"
"    String getId();\n"
"\n"
"    /**\n"
"     * called per Keycloak transaction.\n"
"     *\n"
"     * @param session\n"
"     * @param model\n"
"     * @return\n"
"     */\n"
"    T create(KeycloakSession session, ComponentModel model);\n"
"...\n"
"}"
msgstr ""
"package org.keycloak.storage;\n"
"\n"
"/**\n"
" * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n"
" * @version $Revision: 1 $\n"
" */\n"
"public interface UserStorageProviderFactory<T extends UserStorageProvider> extends ComponentFactory<T, UserStorageProvider> {\n"
"\n"
"    /**\n"
"     * This is the name of the provider and will be shown in the admin console as an option.\n"
"     *\n"
"     * @return\n"
"     */\n"
"    @Override\n"
"    String getId();\n"
"\n"
"    /**\n"
"     * called per Keycloak transaction.\n"
"     *\n"
"     * @param session\n"
"     * @param model\n"
"     * @return\n"
"     */\n"
"    T create(KeycloakSession session, ComponentModel model);\n"
"...\n"
"}"

msgid ""
"Provider factory classes must specify the concrete provider class as a "
"template parameter when implementing the `UserStorageProviderFactory`.  This"
" is a must as the runtime will introspect this class to scan for its "
"capabilities (the other interfaces it implements).  So for example, if your "
"provider class is named `FileProvider`, then the factory class should look "
"like this:"
msgstr ""
"プロバイダー・ファクトリー・クラスが `UserStorageProviderFactory` "
"を実装する場合、具体的なプロバイダー・クラスをテンプレート・パラメーターとして指定する必要があります。ランタイムがこのクラスをイントロスペクトしてその機能（それが実装する他のインターフェイス）をスキャンするので、これは必須です。たとえば、現在は、プロバイダー・クラスが"
" `FileProvider` という名前の場合、ファクトリー・クラスは以下のように表示されます。"

msgid ""
"public class FileProviderFactory implements UserStorageProviderFactory<FileProvider> {\n"
"\n"
"    public String getId() { return \"file-provider\"; }\n"
"\n"
"    public FileProvider create(KeycloakSession session, ComponentModel model) {\n"
"       ...\n"
"    }"
msgstr ""
"public class FileProviderFactory implements UserStorageProviderFactory<FileProvider> {\n"
"\n"
"    public String getId() { return \"file-provider\"; }\n"
"\n"
"    public FileProvider create(KeycloakSession session, ComponentModel model) {\n"
"       ...\n"
"    }"

msgid ""
"The `getId()` method returns the name of the User Storage provider.  This id"
" will be displayed in the admin console's User Federation page when you want"
" to enable the provider for a specific realm."
msgstr ""
"`getId()` "
"メソッドはユーザー・ストレージ・プロバイダーの名前を返します。特定のレルムのプロバイダーを有効にしたい場合、このidは管理コンソールのUser "
"Federationページ内に表示されます。"

msgid ""
"The `create()` method is responsible for allocating an instance of the "
"provider class.  It takes a `org.keycloak.models.KeycloakSession` parameter."
"  This object can be used to look up other information and metadata as well "
"as provide access to various other components within the runtime.  The "
"`ComponentModel` parameter represents how the provider was enabled and "
"configured within a specific realm.  It contains the instance id of the "
"enabled provider as well as any configuration you may have specified for it "
"when you enabled through the admin console."
msgstr ""
"`create()` メソッドは、プロバイダー・クラスのインスタンスの割り当てを担当します。これは "
"`org.keycloak.models.KeycloakSession` "
"パラメーターを受け取ります。このオブジェクトは、ランタイム内で他のさまざまなコンポーネントへアクセスできるようにするだけでなく、他の情報やメタデータを参照することにも使用できます。"
" `ComponentModel` "
"パラメーターは、特定のレルム内でプロバイダーがどのように有効にされ設定されたかを表します。これには、有効なプロバイダーのインスタンスIDと、管理コンソールで有効にした際に指定した可能性がある設定が含まれます"

msgid ""
"The `UserStorageProviderFactory` has other capabilities as well which we "
"will go over later in this chapter."
msgstr "`UserStorageProviderFactory` には他にも機能がありますが、それはこの章で後ほど説明します。"

msgid "Provider capability interfaces"
msgstr "プロバイダー・ケイパビリティー・インターフェイス"

msgid ""
"If you have examined the `UserStorageProvider` interface closely you might "
"notice that it does not define any methods for locating or managing users. "
"These methods are actually defined in other _capability interfaces_ "
"depending on what scope of capabilities your external user store can provide"
" and execute on. For example, some external stores are read-only and can "
"only do simple queries and credential validation. You will only be required "
"to implement the _capability interfaces_ for the features you are able to. "
"You can implement these interfaces:"
msgstr ""
"`UserStorageProvider` "
"インターフェイスを注意深く見てみると、ユーザーを検索したり管理したりするメソッドが定義されていないことに気がつくでしょう。これらのメソッドは "
"_ケイパビリティー・インターフェイス_ "
"として定義されており、外部ユーザーストアが持つ機能に依存しています。たとえば、あるユーザーストアがリードオンリーで単純なクエリーとクレデンシャル検証機能のみ持つ場合、必要な作業はそれらの機能のみを"
" _ケイパビリティー・インターフェイス_ として実装することだけです。"

msgid "SPI"
msgstr "SPI"

msgid "`org.keycloak.storage.user.UserLookupProvider`"
msgstr "`org.keycloak.storage.user.UserLookupProvider`"

msgid ""
"This interface is required if you want to be able to log in with users from "
"this external store. Most (all?) providers implement this interface."
msgstr ""
"このインターフェイスは外部ストアからのユーザーをログインさせるのに必要です。ほとんど（全ての？）プロバイダーはこのインターフェイスを実装します。"

msgid "`org.keycloak.storage.user.UserQueryProvider`"
msgstr "`org.keycloak.storage.user.UserQueryProvider`"

msgid ""
"Defines complex queries that are used to locate one or more users. You must "
"implement this interface if you want to view and manage users from the "
"administration console."
msgstr ""
"1つ以上のユーザーを検索する複雑なクエリーを定義します。管理コンソールでユーザーを閲覧・管理する場合はこのインターフェイスを実装する必要があります。"

msgid "`org.keycloak.storage.user.UserRegistrationProvider`"
msgstr "`org.keycloak.storage.user.UserRegistrationProvider`"

msgid ""
"Implement this interface if your provider supports adding and removing "
"users."
msgstr "プロバイダーがユーザーの削除をサポートする場合はこのインターフェイスを実装します。"

msgid "`org.keycloak.storage.user.UserBulkUpdateProvider`"
msgstr "`org.keycloak.storage.user.UserBulkUpdateProvider`"

msgid ""
"Implement this interface if your provider supports bulk update of a set of "
"users."
msgstr "プロバイダーがユーザーのバルク更新をサポートする場合はこのインターフェイスを実装します。"

msgid "`org.keycloak.credential.CredentialInputValidator`"
msgstr "`org.keycloak.credential.CredentialInputValidator`"

msgid ""
"Implement this interface if your provider can validate one or more different"
" credential types (for example, if your provider can validate a password)."
msgstr ""
"プロバイダーが1つ以上の異なるクレデンシャル・タイプを検証する（たとえば、プロバイダーがパスワード検証をする）場合はこのインターフェイスを実装します。"

msgid "`org.keycloak.credential.CredentialInputUpdater`"
msgstr "`org.keycloak.credential.CredentialInputUpdater`"

msgid ""
"Implement this interface if your provider supports updating one or more "
"different credential types."
msgstr "プロバイダーが1つ以上の異なるクレデンシャル・タイプを更新する場合はこのインターフェイスを実装します。"

msgid "Model interfaces"
msgstr "モデル・インターフェイス"

msgid ""
"Most of the methods defined in the _capability_ _interfaces_ either return "
"or are passed in representations of a user. These representations are "
"defined by the `org.keycloak.models.UserModel` interface. App developers are"
" required to implement this interface. It provides a mapping between the "
"external user store and the user metamodel that {project_name} uses."
msgstr ""
"_ケイパビリティー・インターフェイス_ で定義されたメソッドのほとんどは、ユーザーの表現が返されるか、または渡されます。これらの表現は、 "
"`org.keycloak.models.UserModel` "
"インターフェイスによって定義されます。アプリ開発者はこのインターフェイスを実装する必要があります。これは、外部ユーザーストアと{project_name}が使用するユーザー・メタモデルとの間のマッピングを提供します。"

msgid ""
"package org.keycloak.models;\n"
"\n"
"public interface UserModel extends RoleMapperModel {\n"
"    String getId();\n"
"\n"
"    String getUsername();\n"
"    void setUsername(String username);\n"
"\n"
"    String getFirstName();\n"
"    void setFirstName(String firstName);\n"
"\n"
"    String getLastName();\n"
"    void setLastName(String lastName);\n"
"\n"
"    String getEmail();\n"
"    void setEmail(String email);\n"
"...\n"
"}"
msgstr ""
"package org.keycloak.models;\n"
"\n"
"public interface UserModel extends RoleMapperModel {\n"
"    String getId();\n"
"\n"
"    String getUsername();\n"
"    void setUsername(String username);\n"
"\n"
"    String getFirstName();\n"
"    void setFirstName(String firstName);\n"
"\n"
"    String getLastName();\n"
"    void setLastName(String lastName);\n"
"\n"
"    String getEmail();\n"
"    void setEmail(String email);\n"
"...\n"
"}"

msgid ""
"`UserModel` implementations provide access to read and update metadata about"
" the user including things like username, name, email, role and group "
"mappings, as well as other arbitrary attributes."
msgstr ""
"`UserModel` "
"の実装は、ユーザー名、名前、電子メール、ロール、グループ・マッピング、その他の任意の属性などのユーザーに関するメタデータの読み取りと更新のためのアクセスを提供します。"

msgid ""
"There are other model classes within the `org.keycloak.models` package that "
"represent other parts of the {project_name} metamodel: `RealmModel`, "
"`RoleModel`, `GroupModel`, and `ClientModel`."
msgstr ""
"`org.keycloak.models` パッケージには、{project_name}メタモデルの他の部分を表す他のモデルクラス、 "
"`RealmModel` 、 `RoleModel` 、 `GroupModel` 、および `ClientModel` があります。"

msgid "Storage Ids"
msgstr "ストレージID"

msgid ""
"One important method of `UserModel` is the `getId()` method. When "
"implementing `UserModel` developers must be aware of the user id format. The"
" format must be:"
msgstr ""
"`UserModel` の重要なメソッドの1つは `getId()` メソッドです。 `UserModel` "
"を実装する場合、開発者はユーザーIDの形式を意識している必要があります。フォーマットは以下のとおりでなければなりません。"

msgid "\"f:\" + component id + \":\" + external id"
msgstr "\"f:\" + component id + \":\" + external id"

msgid ""
"The {project_name} runtime often has to look up users by their user id. The "
"user id contains enough information so that the runtime does not have to "
"query every single `UserStorageProvider` in the system to find the user."
msgstr ""
"{project_name}ランタイムは、多くの場合、ユーザーIDでユーザーを検索する必要があります。ユーザーIDには十分な情報が含まれているため、ランタイムはユーザーを検索する際にシステム内のすべての"
" `UserStorageProvider` にクエリーを発行する必要がありません。"

msgid ""
"The component id is the id returned from `ComponentModel.getId()`. The "
"`ComponentModel` is passed in as a parameter when creating the provider "
"class so you can get it from there. The external id is information your "
"provider class needs to find the user in the external store. This is often a"
" username or a uid. For example, it might look something like this:"
msgstr ""
"コンポーネントIDは、 `ComponentModel.getId()` から返されたIDです。 `ComponentModel` "
"は、プロバイダー・クラスを作成するときにパラメーターとして渡されるので、そこから取得できます。外部IDは、プロバイダー・クラスが外部ストアでユーザーを見つけるために必要な情報です。これは多くの場合、ユーザー名かUIDです。たとえば、次のようになります。"

msgid "f:332a234e31234:wburke"
msgstr "f:332a234e31234:wburke"

msgid ""
"When the runtime does a lookup by id, the id is parsed to obtain the "
"component id. The component id is used to locate the `UserStorageProvider` "
"that was originally used to load the user. That provider is then passed the "
"id. The provider again parses the id to obtain the external id and it will "
"use to locate the user in external user storage."
msgstr ""
"ランタイムがIDによるルックアップを実行すると、コンポーネントIDを取得するためにIDが解析されます。コンポーネントIDは、もともとユーザーをロードするために使用された"
" `UserStorageProvider` "
"の場所を特定するために使用されます。そのプロバイダーにはIDが渡されます。プロバイダーは、外部IDを取得するためにIDを再度解析し、それを外部ユーザー・ストレージにユーザーを配置するために使用します。"

msgid "Packaging and deployment"
msgstr "パッケージ化とデプロイ"

msgid ""
"In order for {project_name} to recognize the provider, you need to add a "
"file to the JAR: `META-"
"INF/services/org.keycloak.storage.UserStorageProviderFactory`. This file "
"must contain a line-separated list of fully qualified classnames of the "
"`UserStorageProviderFactory` implementations:"
msgstr ""
"{project_name}がプロバイダーを認識するためには、JARに `META-"
"INF/services/org.keycloak.storage.UserStorageProviderFactory` "
"のファイルを追加する必要があります。このファイルには、次のような `UserStorageProviderFactory` "
"の実装の完全修飾クラス名の行区切りリストが含まれていなければなりません。"

msgid ""
"org.keycloak.examples.federation.properties.ClasspathPropertiesStorageFactory\n"
"org.keycloak.examples.federation.properties.FilePropertiesStorageFactory"
msgstr ""
"org.keycloak.examples.federation.properties.ClasspathPropertiesStorageFactory\n"
"org.keycloak.examples.federation.properties.FilePropertiesStorageFactory"

msgid "Simple read-only, lookup example"
msgstr "簡単な読み取り専用の参照のサンプル"

msgid ""
"To illustrate the basics of implementing the User Storage SPI let's walk "
"through a simple example. In this chapter you'll see the implementation of a"
" simple `UserStorageProvider` that looks up users in a simple property file."
" The property file contains username and password definitions and is "
"hardcoded to a specific location on the classpath. The provider will be able"
" to look up the user by ID and username and also be able to validate "
"passwords. Users that originate from this provider will be read-only."
msgstr ""
"ユーザー・ストレージSPIの基本実装を示すために、簡単なサンプルで説明します。この章では、簡単なプロパティー・ファイル内でユーザーを検索する簡単な "
"`UserStorageProvider` "
"の実装を見ていきます。プロパティー・ファイルには、ユーザー名とパスワードの定義が含まれており、クラスパス上の特定のロケーションにハードコードされています。プロバイダーにより、IDとユーザー名でユーザーを検索し、パスワードを検証することもできるようになります。このプロバイダーに基づくユーザーは、読み取り専用になります。"

msgid "Provider class"
msgstr "プロバイダー・クラス"

msgid ""
"The first thing we will walk through is the `UserStorageProvider` class."
msgstr "はじめに `UserStorageProvider` クラスについて説明します。"

msgid ""
"public class PropertyFileUserStorageProvider implements\n"
"        UserStorageProvider,\n"
"        UserLookupProvider,\n"
"        CredentialInputValidator,\n"
"        CredentialInputUpdater\n"
"{\n"
"...\n"
"}"
msgstr ""
"public class PropertyFileUserStorageProvider implements\n"
"        UserStorageProvider,\n"
"        UserLookupProvider,\n"
"        CredentialInputValidator,\n"
"        CredentialInputUpdater\n"
"{\n"
"...\n"
"}"

msgid ""
"Our provider class, `PropertyFileUserStorageProvider`, implements many "
"interfaces. It implements the `UserStorageProvider` as that is a base "
"requirement of the SPI. It implements the `UserLookupProvider` interface "
"because we want to be able to log in with users stored by this provider. It "
"implements the `CredentialInputValidator` interface because we want to be "
"able to validate passwords entered in using the login screen. Our property "
"file is read-only. We implement the `CredentialInputUpdater` because we want"
" to post an error condition when the user attempts to update his password."
msgstr ""
"プロバイダー・クラス `PropertyFileUserStorageProvider` "
"は、多くのインターフェイスを実装しています。SPIの基本要件なので、 `UserLookupProvider` "
"が実装されています。このプロバイダーにより保存されたユーザーでログインできるようにするため、 `UserLookupProvider` "
"インターフェイスが実装されています。ログイン画面で入力したパスワードの検証を可能にする必要があるので、 "
"`CredentialInputValidator` "
"インターフェイスが実装されています。プロパティー・ファイルは読み取り専用です。ユーザーがパスワードを更新しようとする時にエラー状態を通知する必要があるので、"
" `CredentialInputUpdater` が実装されています。"

msgid ""
"    protected KeycloakSession session;\n"
"    protected Properties properties;\n"
"    protected ComponentModel model;\n"
"    // map of loaded users in this transaction\n"
"    protected Map<String, UserModel> loadedUsers = new HashMap<>();\n"
"\n"
"    public PropertyFileUserStorageProvider(KeycloakSession session, ComponentModel model, Properties properties) {\n"
"        this.session = session;\n"
"        this.model = model;\n"
"        this.properties = properties;\n"
"    }"
msgstr ""
"    protected KeycloakSession session;\n"
"    protected Properties properties;\n"
"    protected ComponentModel model;\n"
"    // map of loaded users in this transaction\n"
"    protected Map<String, UserModel> loadedUsers = new HashMap<>();\n"
"\n"
"    public PropertyFileUserStorageProvider(KeycloakSession session, ComponentModel model, Properties properties) {\n"
"        this.session = session;\n"
"        this.model = model;\n"
"        this.properties = properties;\n"
"    }"

msgid ""
"The constructor for this provider class is going to store the reference to "
"the `KeycloakSession`, `ComponentModel`, and property file. We'll use all of"
" these later. Also notice that there is a map of loaded users. Whenever we "
"find a user we will store it in this map so that we avoid re-creating it "
"again within the same transaction. This is a good practice to follow as many"
" providers will need to do this (that is, any provider that integrates with "
"JPA). Remember also that provider class instances are created once per "
"transaction and are closed after the transaction completes."
msgstr ""
"このプロバイダー・クラスのコンストラクターには、 `KeycloakSession` 、 `ComponentModel` "
"、およびプロパティー・ファイルへの参照が格納されます。後で、これらをすべて使用します。また、ロードされたユーザーのマップがあることにも注意してください。ユーザーを見つけるたびに、このマップに保存して、同じトランザクション内でそれを再度作成しないで済むようにします。多くのプロバイダがこれを行う必要があるので、従うことは良い習慣です（つまり、JPAと統合するすべてのプロバイダー）。プロバイダー・クラス・インスタンスは、トランザクション毎に都度作成され、トランザクション完了後にクローズされることも注意してください。"

msgid "UserLookupProvider implementation"
msgstr "UserLookupProviderの実装"

msgid ""
"    @Override\n"
"    public UserModel getUserByUsername(String username, RealmModel realm) {\n"
"        UserModel adapter = loadedUsers.get(username);\n"
"        if (adapter == null) {\n"
"            String password = properties.getProperty(username);\n"
"            if (password != null) {\n"
"                adapter = createAdapter(realm, username);\n"
"                loadedUsers.put(username, adapter);\n"
"            }\n"
"        }\n"
"        return adapter;\n"
"    }\n"
"\n"
"    protected UserModel createAdapter(RealmModel realm, String username) {\n"
"        return new AbstractUserAdapter(session, realm, model) {\n"
"            @Override\n"
"            public String getUsername() {\n"
"                return username;\n"
"            }\n"
"        };\n"
"    }\n"
"\n"
"    @Override\n"
"    public UserModel getUserById(String id, RealmModel realm) {\n"
"        StorageId storageId = new StorageId(id);\n"
"        String username = storageId.getExternalId();\n"
"        return getUserByUsername(username, realm);\n"
"    }\n"
"\n"
"    @Override\n"
"    public UserModel getUserByEmail(String email, RealmModel realm) {\n"
"        return null;\n"
"    }\n"
"\n"
msgstr ""
"    @Override\n"
"    public UserModel getUserByUsername(String username, RealmModel realm) {\n"
"        UserModel adapter = loadedUsers.get(username);\n"
"        if (adapter == null) {\n"
"            String password = properties.getProperty(username);\n"
"            if (password != null) {\n"
"                adapter = createAdapter(realm, username);\n"
"                loadedUsers.put(username, adapter);\n"
"            }\n"
"        }\n"
"        return adapter;\n"
"    }\n"
"\n"
"    protected UserModel createAdapter(RealmModel realm, String username) {\n"
"        return new AbstractUserAdapter(session, realm, model) {\n"
"            @Override\n"
"            public String getUsername() {\n"
"                return username;\n"
"            }\n"
"        };\n"
"    }\n"
"\n"
"    @Override\n"
"    public UserModel getUserById(String id, RealmModel realm) {\n"
"        StorageId storageId = new StorageId(id);\n"
"        String username = storageId.getExternalId();\n"
"        return getUserByUsername(username, realm);\n"
"    }\n"
"\n"
"    @Override\n"
"    public UserModel getUserByEmail(String email, RealmModel realm) {\n"
"        return null;\n"
"    }\n"
"\n"

msgid ""
"The `getUserByUsername()` method is invoked by the {project_name} login page"
" when a user logs in. In our implementation we first check the `loadedUsers`"
" map to see if the user has already been loaded within this transaction. If "
"it hasn't been loaded we look in the property file for the username. If it "
"exists we create an implementation of `UserModel`, store it in `loadedUsers`"
" for future reference, and return this instance."
msgstr ""
"`getUserByUsername()` "
"メソッドは、ユーザーがログインする際に{project_name}ログインページにより呼び出されます。実装では、最初に `loadedUsers` "
"マップを確認して、ユーザーがすでにトランザクション内にロードされているかどうかを確かめます。ロードされていなかった場合、プロパティー・ファイル内でユーザー名を検索します。それが存在した場合、"
" `UserModel` の実装を作成し、今後の参照のために `loadedUsers` 内にそれを格納し、このインスタンスを返します。"

msgid ""
"The `createAdapter()` method uses the helper class "
"`org.keycloak.storage.adapter.AbstractUserAdapter`. This provides a base "
"implementation for `UserModel`. It automatically generates a user id based "
"on the required storage id format using the username of the user as the "
"external id."
msgstr ""
"`createAdapter()` メソッドは、ヘルパー・クラス "
"`org.keycloak.storage.adapter.AbstractUserAdapter` を使用します。これは、 `UserModel` "
"の基本実装を提供します。これにより、外部IDとしてユーザーのユーザー名を使用する、必須ストレージIDフォーマットに基づいたユーザーIDが自動的に生成されます。"

msgid "\"f:\" + component id + \":\" + username"
msgstr "\"f:\" + component id + \":\" + username"

msgid ""
"Every get method of `AbstractUserAdapter` either returns null or empty "
"collections. However, methods that return role and group mappings will "
"return the default roles and groups configured for the realm for every user."
"  Every set method of `AbstractUserAdapter` will throw a "
"`org.keycloak.storage.ReadOnlyException`. So if you attempt to modify the "
"user in the Admin Console, you will get an error."
msgstr ""
"`AbstractUserAdapter` "
"のすべてのgetメソッドは、nullか空のコレクションを返します。しかし、ロールとグループ・マッピングを返すメソッドは、全ユーザーのレルム用に設定されたデフォルトのロールとグループを返します。"
" `AbstractUserAdapter` のすべてのsetメソッドは、 "
"`org.keycloak.storage.ReadOnlyException` "
"をスローします。そのため、管理コンソール内でユーザーを更新しようとすると、エラーが発生します。"

msgid ""
"The `getUserById()` method parses the `id` parameter using the "
"`org.keycloak.storage.StorageId` helper class. The "
"`StorageId.getExternalId()` method is invoked to obtain the username "
"embedded in the `id` parameter. The method then delegates to "
"`getUserByUsername()`."
msgstr ""
"`getUserById()` メソッドは、 `org.keycloak.storage.StorageId` ヘルパークラスを使って `id` "
"パラメーターを解析します。 `StorageId.getExternalId()` メソッドは、 `id` "
"パラメーターに埋め込まれたユーザー名を取得するために呼び出されます。そして、このメソッドは `getUserByUsername()` に委譲します。"

msgid "Emails are not stored, so the `getUserByEmail()` method returns null."
msgstr "電子メールは格納されていないので、 `getUserByEmail()` メソッドはnullを返します。"

msgid "CredentialInputValidator implementation"
msgstr "CredentialInputValidatorの実装"

msgid ""
"Next let's look at the method implementations for "
"`CredentialInputValidator`."
msgstr "次に `CredentialInputValidator` の実装メソッドを見ていきましょう。"

msgid ""
"    @Override\n"
"    public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {\n"
"        String password = properties.getProperty(user.getUsername());\n"
"        return credentialType.equals(PasswordCredentialModel.TYPE) && password != null;\n"
"    }\n"
"\n"
"    @Override\n"
"    public boolean supportsCredentialType(String credentialType) {\n"
"        return credentialType.equals(PasswordCredentialModel.TYPE);\n"
"    }\n"
"\n"
"    @Override\n"
"    public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {\n"
"        if (!supportsCredentialType(input.getType())) return false;\n"
"\n"
"        String password = properties.getProperty(user.getUsername());\n"
"        if (password == null) return false;\n"
"        return password.equals(input.getChallengeResponse());\n"
"    }"
msgstr ""
"    @Override\n"
"    public boolean isConfiguredFor(RealmModel realm, UserModel user, String credentialType) {\n"
"        String password = properties.getProperty(user.getUsername());\n"
"        return credentialType.equals(PasswordCredentialModel.TYPE) && password != null;\n"
"    }\n"
"\n"
"    @Override\n"
"    public boolean supportsCredentialType(String credentialType) {\n"
"        return credentialType.equals(PasswordCredentialModel.TYPE);\n"
"    }\n"
"\n"
"    @Override\n"
"    public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {\n"
"        if (!supportsCredentialType(input.getType())) return false;\n"
"\n"
"        String password = properties.getProperty(user.getUsername());\n"
"        if (password == null) return false;\n"
"        return password.equals(input.getChallengeResponse());\n"
"    }"

msgid ""
"The `isConfiguredFor()` method is called by the runtime to determine if a "
"specific credential type is configured for the user. This method checks to "
"see that the password is set for the user."
msgstr ""
"`isConfiguredFor()` "
"メソッドは、ランタイムによって呼び出されて、特定のクレデンシャル・タイプがユーザーのために設定されているかどうかを判断します。このメソッドは、パスワードがユーザー用に設定されていることを確認します。"

msgid ""
"The `supportsCredentialType()` method returns whether validation is "
"supported for a specific credential type. We check to see if the credential "
"type is `password`."
msgstr ""
"`supportsCredentialType()` "
"メソッドは、特定のクレデンシャル・タイプに対する検証がサポートされているかどうかを返します。クレデンシャル・タイプが `password` "
"であるかどうかを確認します。"

msgid ""
"The `isValid()` method is responsible for validating passwords. The "
"`CredentialInput` parameter is really just an abstract interface for all "
"credential types. We make sure that we support the credential type and also "
"that it is an instance of `UserCredentialModel`. When a user logs in through"
" the login page, the plain text of the password input is put into an "
"instance of `UserCredentialModel`. The `isValid()` method checks this value "
"against the plain text password stored in the properties file. A return "
"value of `true` means the password is valid."
msgstr ""
"`isValid()` メソッドはパスワードの検証を担当します。 `CredentialInput` "
"パラメーターは、すべてのクレデンシャル・タイプのための単なる抽象的なインターフェイスです。クレデンシャル・タイプをサポートしていること、およびそれが "
"`UserCredentialModel` "
"のインスタンスであることも確認します。ユーザーがログイン・ページからログインすると、入力されたパスワードのプレーン・テキストが "
"`UserCredentialModel` のインスタンスに格納されます。 `isValid()` "
"メソッドは、プロパティー・ファイルに格納されているプレーンテキストのパスワードに対してその値を確認します。 `true` "
"の戻り値は、パスワードが有効であるということを意味します。"

msgid "CredentialInputUpdater implementation"
msgstr "CredentialInputUpdaterの実装"

msgid ""
"As noted before, the only reason we implement the `CredentialInputUpdater` "
"interface in this example is to forbid modifications of user passwords. The "
"reason we have to do this is because otherwise the runtime would allow the "
"password to be overridden in {project_name} local storage. We'll talk more "
"about this later in this chapter."
msgstr ""
"以前説明したとおり、このサンプル内の `CredentialInputUpdater` "
"インターフェイスを実装するのは、ユーザー・パスワードの変更を禁止するためだけです。これをしなければならない理由は、そうしないと、ランタイムにより{project_name}のローカル・ストレージ内でパスワードがオーバーライドできるようになってしまうからです。これについて、詳しくはこの章で後ほど説明します。"

msgid ""
"    @Override\n"
"    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {\n"
"        if (input.getType().equals(PasswordCredentialModel.TYPE)) throw new ReadOnlyException(\"user is read only for this update\");\n"
"\n"
"        return false;\n"
"    }\n"
"\n"
"    @Override\n"
"    public void disableCredentialType(RealmModel realm, UserModel user, String credentialType) {\n"
"\n"
"    }\n"
"\n"
"    @Override\n"
"    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n"
"        return Collections.EMPTY_SET;\n"
"    }"
msgstr ""
"    @Override\n"
"    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {\n"
"        if (input.getType().equals(PasswordCredentialModel.TYPE)) throw new ReadOnlyException(\"user is read only for this update\");\n"
"\n"
"        return false;\n"
"    }\n"
"\n"
"    @Override\n"
"    public void disableCredentialType(RealmModel realm, UserModel user, String credentialType) {\n"
"\n"
"    }\n"
"\n"
"    @Override\n"
"    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n"
"        return Collections.EMPTY_SET;\n"
"    }"

msgid ""
"The `updateCredential()` method just checks to see if the credential type is"
" password.  If it is, a `ReadOnlyException` is thrown."
msgstr ""
"`updateCredential()` メソッドは、クレデンシャル・タイプがパスワードであるかどうかを確認するだけです。そうであった場合、 "
"`ReadOnlyException` がスローされます。"

msgid "Provider factory implementation"
msgstr "プロバイダー・ファクトリーの実装"

msgid ""
"Now that the provider class is complete, we now turn our attention to the "
"provider factory class."
msgstr "プロバイダー・クラスに関しては完了したので、それでは次にプロバイダー・ファクトリー・クラスを見ていきましょう。"

msgid ""
"public class PropertyFileUserStorageProviderFactory\n"
"                 implements UserStorageProviderFactory<PropertyFileUserStorageProvider> {\n"
"\n"
"    public static final String PROVIDER_NAME = \"readonly-property-file\";\n"
"\n"
"    @Override\n"
"    public String getId() {\n"
"        return PROVIDER_NAME;\n"
"    }"
msgstr ""
"public class PropertyFileUserStorageProviderFactory\n"
"                 implements UserStorageProviderFactory<PropertyFileUserStorageProvider> {\n"
"\n"
"    public static final String PROVIDER_NAME = \"readonly-property-file\";\n"
"\n"
"    @Override\n"
"    public String getId() {\n"
"        return PROVIDER_NAME;\n"
"    }"

msgid ""
"First thing to notice is that when implementing the "
"`UserStorageProviderFactory` class, you must pass in the concrete provider "
"class implementation as a template parameter. Here we specify the provider "
"class we defined before: `PropertyFileUserStorageProvider`."
msgstr ""
"まず最初に注意すべき点は、 `UserStorageProviderFactory` "
"クラスを実装する際、テンプレート・パラメーターとして具体的なプロバイダー・クラスの実装を渡す必要があるということです。ここでは、以前に定義したプロバイダー・クラス"
" `PropertyFileUserStorageProvider` を指定します。"

msgid ""
"If you do not specify the template parameter, your provider will not "
"function. The runtime does class introspection          to determine the "
"_capability interfaces_ that the provider implements."
msgstr ""
"テンプレート・パラメーターを指定しないと、プロバイダーは機能しません。ランタイムは、クラスのイントロスペクションが実行し、プロバイダーが実装する "
"_ケイパビリティー･インターフェース_ を定義します。"

msgid ""
"The `getId()` method identifies the factory in the runtime and will also be "
"the string shown in the admin console when you want to enable a user storage"
" provider for the realm."
msgstr ""
"`getId()` "
"メソッドは、レルム用のユーザー・ストレージ・プロバイダーを有効にする必要がある場合、ランタイム内のファクトリーを識別し、管理コンソールで表示される文字列にもなります。"

msgid "Initialization"
msgstr "初期化"

msgid ""
"    private static final Logger logger = Logger.getLogger(PropertyFileUserStorageProviderFactory.class);\n"
"    protected Properties properties = new Properties();\n"
"\n"
"    @Override\n"
"    public void init(Config.Scope config) {\n"
"        InputStream is = getClass().getClassLoader().getResourceAsStream(\"/users.properties\");\n"
"\n"
"        if (is == null) {\n"
"            logger.warn(\"Could not find users.properties in classpath\");\n"
"        } else {\n"
"            try {\n"
"                properties.load(is);\n"
"            } catch (IOException ex) {\n"
"                logger.error(\"Failed to load users.properties file\", ex);\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    @Override\n"
"    public PropertyFileUserStorageProvider create(KeycloakSession session, ComponentModel model) {\n"
"        return new PropertyFileUserStorageProvider(session, model, properties);\n"
"    }"
msgstr ""
"    private static final Logger logger = Logger.getLogger(PropertyFileUserStorageProviderFactory.class);\n"
"    protected Properties properties = new Properties();\n"
"\n"
"    @Override\n"
"    public void init(Config.Scope config) {\n"
"        InputStream is = getClass().getClassLoader().getResourceAsStream(\"/users.properties\");\n"
"\n"
"        if (is == null) {\n"
"            logger.warn(\"Could not find users.properties in classpath\");\n"
"        } else {\n"
"            try {\n"
"                properties.load(is);\n"
"            } catch (IOException ex) {\n"
"                logger.error(\"Failed to load users.properties file\", ex);\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    @Override\n"
"    public PropertyFileUserStorageProvider create(KeycloakSession session, ComponentModel model) {\n"
"        return new PropertyFileUserStorageProvider(session, model, properties);\n"
"    }"

msgid ""
"The `UserStorageProviderFactory` interface has an optional `init()` method "
"you can implement. When {project_name} boots up, only one instance of each "
"provider factory is created. Also at boot time, the `init()` method is "
"called on each of these factory instances. There's also a `postInit()` "
"method you can implement as well. After each factory's `init()` method is "
"invoked, their `postInit()` methods are called."
msgstr ""
"`UserStorageProviderFactory` インターフェイスにはオプションで実装可能な `init()` "
"メソッドがあります。{project_name}が起動すると、各プロバイダー・ファクトリーのインスタンスが1つだけ作成されます。また、起動時に、 "
"`init()` メソッドがこれらのファクトリー・インスタンスでそれぞれ呼び出されます。また、実装可能な `postInit()` "
"メソッドも同様にあります。ファクトリーの `init()` メソッドがそれぞれ呼び出された後、 `postInit()` メソッドが呼び出されます。"

msgid ""
"In our `init()` method implementation, we find the property file containing "
"our user declarations from the classpath. We then load the `properties` "
"field with the username and password combinations stored there."
msgstr ""
"`init()` "
"メソッドの実装では、クラスパスからユーザー宣言を含むプロパティー・ファイルを見つけます。次に、そこに格納されているユーザー名とパスワードの組み合わせを "
"`properties` フィールドにロードします。"

msgid ""
"The `Config.Scope` parameter is factory configuration that configured "
"through server configuration."
msgstr "`Config.Scope` パラメーターは、サーバー設定により設定されるファクトリー設定です。"

msgid "For example, by running the server with the following argument:"
msgstr "たとえば、次のような引数でサーバーを起動することができます。"

msgid ""
"kc.[sh|bat] start --spi-storage-readonly-property-file-path=/other-"
"users.properties"
msgstr ""
"kc.[sh|bat] start --spi-storage-readonly-property-file-path=/other-"
"users.properties"

msgid ""
"We can specify the classpath of the user property file instead of hardcoding"
" it. Then you can retrieve the configuration in the "
"`PropertyFileUserStorageProviderFactory.init()`:"
msgstr ""
"これをハードコーディングせずに、ユーザー・プロパティー・ファイルのクラスパスを指定することができます。次に、以下のとおり "
"`PropertyFileUserStorageProviderFactory.init()` で設定を取り込むことができます。"

msgid ""
"public void init(Config.Scope config) {\n"
"    String path = config.get(\"path\");\n"
"    InputStream is = getClass().getClassLoader().getResourceAsStream(path);\n"
"\n"
"    ...\n"
"}"
msgstr ""
"public void init(Config.Scope config) {\n"
"    String path = config.get(\"path\");\n"
"    InputStream is = getClass().getClassLoader().getResourceAsStream(path);\n"
"\n"
"    ...\n"
"}"

msgid "Create method"
msgstr "メソッドの作成"

msgid ""
"Our last step in creating the provider factory is the `create()` method."
msgstr "プロバイダー･ファクトリーの作成における最後の手順は `create()` メソッドになります。"

msgid ""
"    @Override\n"
"    public PropertyFileUserStorageProvider create(KeycloakSession session, ComponentModel model) {\n"
"        return new PropertyFileUserStorageProvider(session, model, properties);\n"
"    }"
msgstr ""
"    @Override\n"
"    public PropertyFileUserStorageProvider create(KeycloakSession session, ComponentModel model) {\n"
"        return new PropertyFileUserStorageProvider(session, model, properties);\n"
"    }"

msgid ""
"We simply allocate the `PropertyFileUserStorageProvider` class.  This create"
" method will be called once per transaction."
msgstr ""
"`PropertyFileUserStorageProvider` "
"クラスを単にアロケートするだけです。このcreateメソッドはトランザクション毎に都度呼び出されます。"

msgid ""
"The class files for our provider implementation should be placed in a jar.  "
"You also have to declare the provider factory class within the `META-"
"INF/services/org.keycloak.storage.UserStorageProviderFactory` file."
msgstr ""
"プロバイダー実装のためのクラス・ファイルはjar内に置かれる必要があります。また、 `META-"
"INF/services/org.keycloak.storage.UserStorageProviderFactory` "
"ファイル内でプロバイダー・ファクトリー・クラスを宣言する必要もあります。"

msgid ""
"org.keycloak.examples.federation.properties.FilePropertiesStorageFactory"
msgstr ""
"org.keycloak.examples.federation.properties.FilePropertiesStorageFactory"

msgid "Enabling the provider in the Admin Console"
msgstr "管理コンソールでのプロバイダーの有効化"

msgid ""
"You enable user storage providers per realm within the *User Federation* "
"page in the Admin Console."
msgstr "管理コンソールの `User Federation` ページ内で、レルム毎にユーザー・ストレージ・プロバイダーを有効にします。"

msgid "User Federation"
msgstr "User Federation"

msgid "image:images/empty-user-federation-page.png[]"
msgstr "image:images/empty-user-federation-page.png[]"

msgid ""
"Select the provider we just created from the list: `readonly-property-file`."
msgstr "先ほど作成したプロバイダーを一覧から選択します。 `readonly-property-file` を選択します。"

msgid "The configuration page for our provider displays."
msgstr "プロバイダーの設定ページが表示されます。"

msgid "Click *Save* because we have nothing to configure."
msgstr "設定するものがないので、 *Save* をクリックします。"

msgid "Configured Provider"
msgstr "設定されたプロバイダー"

msgid "image:images/storage-provider-created.png[]"
msgstr "image:images/storage-provider-created.png[]"

msgid "Return to the main *User Federation* page"
msgstr "*User Federation* のメインページに戻ります。"

msgid "You now see your provider listed."
msgstr "これで、プロバイダーが表示されるようになりました。"

msgid "image:images/user-federation-page.png[]"
msgstr "image:images/user-federation-page.png[]"

msgid ""
"You will now be able to log in with a user declared in the "
"`users.properties` file. This user will only be able to view the account "
"page after logging in."
msgstr ""
"これで、 `users.properties` "
"ファイル内で宣言されたユーザーを使用してログインすることができます。このユーザーは、ログイン後、アカウントページを見ることしかできません。"

msgid "Configuration techniques"
msgstr "設定のテクニック"

msgid ""
"Our `PropertyFileUserStorageProvider` example is a bit contrived. It is "
"hardcoded to a property file that is embedded in the jar of the provider, "
"which is not terribly useful. We might want to make the location of this "
"file configurable per instance of the provider. In other words, we might "
"want to reuse this provider multiple times in multiple different realms and "
"point to completely different user property files. We'll also want to "
"perform this configuration within the Admin Console UI."
msgstr ""
"`PropertyFileUserStorageProvider` "
"のサンプルには少し工夫が必要です。プロバイダーのjarに組み込まれたプロパティー・ファイルにハードコードされていて、これはあまり便利ではありません。プロバイダーのインスタンス毎にこのファイルの場所を設定できるようにすることをお勧めします。つまり、このプロバイダーを複数の異なるレルムで複数回再利用して、まったく異なるユーザー・プロパティー・ファイルを指すようにしたい場合があります。また、この設定は管理コンソールのUI内でも変更できるようにすることをお勧めします。"

msgid ""
"The `UserStorageProviderFactory` has additional methods you can implement "
"that handle provider configuration. You describe the variables you want to "
"configure per provider and the Admin Console automatically renders a generic"
" input page to gather this configuration. When implemented, callback methods"
" also validate the configuration before it is saved, when a provider is "
"created for the first time, and when it is updated. "
"`UserStorageProviderFactory` inherits these methods from the "
"`org.keycloak.component.ComponentFactory` interface."
msgstr ""
"`UserStorageProviderFactory` "
"には、プロバイダーの設定を処理する、実装可能な追加のメソッドがあります。プロバイダーごとに設定したい変数を記述すると、管理コンソールが自動的に汎用入力ページを表示してこの設定を収集します。実装されると、プロバイダーが初めて作成された時、および更新時に、callbackメソッドが設定を保存する前に検証します。"
" `UserStorageProviderFactory` は `org.keycloak.component.ComponentFactory` "
"インターフェイスからこれらのメソッドを継承します。"

msgid ""
"    List<ProviderConfigProperty> getConfigProperties();\n"
"\n"
"    default\n"
"    void validateConfiguration(KeycloakSession session, RealmModel realm, ComponentModel model)\n"
"            throws ComponentValidationException\n"
"    {\n"
"\n"
"    }\n"
"\n"
"    default\n"
"    void onCreate(KeycloakSession session, RealmModel realm, ComponentModel model) {\n"
"\n"
"    }\n"
"\n"
"    default\n"
"    void onUpdate(KeycloakSession session, RealmModel realm, ComponentModel model) {\n"
"\n"
"    }"
msgstr ""
"    List<ProviderConfigProperty> getConfigProperties();\n"
"\n"
"    default\n"
"    void validateConfiguration(KeycloakSession session, RealmModel realm, ComponentModel model)\n"
"            throws ComponentValidationException\n"
"    {\n"
"\n"
"    }\n"
"\n"
"    default\n"
"    void onCreate(KeycloakSession session, RealmModel realm, ComponentModel model) {\n"
"\n"
"    }\n"
"\n"
"    default\n"
"    void onUpdate(KeycloakSession session, RealmModel realm, ComponentModel model) {\n"
"\n"
"    }"

msgid ""
"The `ComponentFactory.getConfigProperties()` method returns a list of "
"`org.keycloak.provider.ProviderConfigProperty` instances. These instances "
"declare metadata that is needed to render and store each configuration "
"variable of the provider."
msgstr ""
"`ComponentFactory.getConfigProperties()` メソッドは、 "
"`org.keycloak.provider.ProviderConfigProperty` "
"インスタンスのリストを返します。これらのインスタンスは、プロバイダーの設定変数をそれぞれレンダリングして格納するのに必要なメタデータを宣言します。"

msgid "Configuration example"
msgstr "設定のサンプル"

msgid ""
"Let's expand our `PropertyFileUserStorageProviderFactory` example to allow "
"you to point a provider instance to a specific file on disk."
msgstr ""
"プロバイダー・インスタンスがディスク上の特定のファイルを参照するように、 "
"`PropertyFileUserStorageProviderFactory` のサンプルを拡張してみましょう。"

msgid "PropertyFileUserStorageProviderFactory"
msgstr "PropertyFileUserStorageProviderFactory"

msgid ""
"public class PropertyFileUserStorageProviderFactory\n"
"                  implements UserStorageProviderFactory<PropertyFileUserStorageProvider> {\n"
"\n"
"    protected static final List<ProviderConfigProperty> configMetadata;\n"
"\n"
"    static {\n"
"        configMetadata = ProviderConfigurationBuilder.create()\n"
"                .property().name(\"path\")\n"
"                .type(ProviderConfigProperty.STRING_TYPE)\n"
"                .label(\"Path\")\n"
"                .defaultValue(\"${jboss.server.config.dir}/example-users.properties\")\n"
"                .helpText(\"File path to properties file\")\n"
"                .add().build();\n"
"    }\n"
"\n"
"    @Override\n"
"    public List<ProviderConfigProperty> getConfigProperties() {\n"
"        return configMetadata;\n"
"    }"
msgstr ""
"public class PropertyFileUserStorageProviderFactory\n"
"                  implements UserStorageProviderFactory<PropertyFileUserStorageProvider> {\n"
"\n"
"    protected static final List<ProviderConfigProperty> configMetadata;\n"
"\n"
"    static {\n"
"        configMetadata = ProviderConfigurationBuilder.create()\n"
"                .property().name(\"path\")\n"
"                .type(ProviderConfigProperty.STRING_TYPE)\n"
"                .label(\"Path\")\n"
"                .defaultValue(\"${jboss.server.config.dir}/example-users.properties\")\n"
"                .helpText(\"File path to properties file\")\n"
"                .add().build();\n"
"    }\n"
"\n"
"    @Override\n"
"    public List<ProviderConfigProperty> getConfigProperties() {\n"
"        return configMetadata;\n"
"    }"

msgid ""
"The `ProviderConfigurationBuilder` class is a great helper class to create a"
" list of configuration properties. Here we specify a variable named `path` "
"that is a String type. On the Admin Console configuration page for this "
"provider, this configuration variable is labeled as `Path` and has a default"
" value of `${jboss.server.config.dir}/example-users.properties`. When you "
"hover over the tooltip of this configuration option, it displays the help "
"text, `File path to properties file`."
msgstr ""
"`ProviderConfigurationBuilder` "
"クラスは、設定プロパティーのリストを作成するための優れたヘルパークラスです。ここでは、String型のpathという名前の変数を指定します。管理コンソールにおけるこのプロバイダーの設定ページでは、この設定変数は"
" `Path` というラベルが付けられており、デフォルト値は `${jboss.server.config.dir}/example-"
"users.properties` です。この設定オプションのツールチップにカーソルを合わせると、ヘルプテキスト `File path to "
"properties file` が表示されます。"

msgid ""
"The next thing we want to do is to verify that this file exists on disk. We "
"do not want to enable an instance of this provider in the realm unless it "
"points to a valid user property file. To do this, we implement the "
"`validateConfiguration()` method."
msgstr ""
"次にすべきことは、このファイルがディスク上に存在することを確認することです。有効なユーザー・プロパティー・ファイルを指していない限り、レルム内でこのプロバイダーのインスタンスを有効にしたくありません。これを行うには、"
" `validateConfiguration()` メソッドを実装します。"

msgid ""
"    @Override\n"
"    public void validateConfiguration(KeycloakSession session, RealmModel realm, ComponentModel config)\n"
"                   throws ComponentValidationException {\n"
"        String fp = config.getConfig().getFirst(\"path\");\n"
"        if (fp == null) throw new ComponentValidationException(\"user property file does not exist\");\n"
"        fp = EnvUtil.replace(fp);\n"
"        File file = new File(fp);\n"
"        if (!file.exists()) {\n"
"            throw new ComponentValidationException(\"user property file does not exist\");\n"
"        }\n"
"    }"
msgstr ""
"    @Override\n"
"    public void validateConfiguration(KeycloakSession session, RealmModel realm, ComponentModel config)\n"
"                   throws ComponentValidationException {\n"
"        String fp = config.getConfig().getFirst(\"path\");\n"
"        if (fp == null) throw new ComponentValidationException(\"user property file does not exist\");\n"
"        fp = EnvUtil.replace(fp);\n"
"        File file = new File(fp);\n"
"        if (!file.exists()) {\n"
"            throw new ComponentValidationException(\"user property file does not exist\");\n"
"        }\n"
"    }"

msgid ""
"In the `validateConfiguration()` method we get the configuration variable "
"from the `ComponentModel` and we check to see if that file exists on disk. "
"Notice that we use the `org.keycloak.common.util.EnvUtil.replace()` method. "
"With this method any string that has `${}` within it will replace that with "
"a system property value. The `${jboss.server.config.dir}` string corresponds"
" to the `configuration/` directory of our server and is really useful for "
"this example."
msgstr ""
"`validateConfiguration()` メソッド内では、 `ComponentModel` "
"から設定変数を取得し、そのファイルがディスク上に存在するかどうかを確認します。 "
"`org.keycloak.common.util.EnvUtil.replace()` "
"メソッドを使用していることに注意してください。このメソッドを使用すると、 `${}` が含まれる文字列がシステム・プロパティー値で置換されます。 "
"`${jboss.server.config.dir}` という文字列は、サーバーの `configuration/` "
"ディレクトリーに対応しており、このサンプルでは非常に便利です。"

msgid ""
"Next thing we have to do is remove the old `init()` method. We do this "
"because user property files are going to be unique per provider instance. We"
" move this logic to the `create()` method."
msgstr ""
"次にすべきことは、古い `init()` "
"メソッドの削除です。これを行う理由は、ユーザー・プロパティー・ファイルがプロバイダー・インスタンス毎に独自のものになるからです。このロジックを "
"`create()` メソッドへ移します。"

msgid ""
"    @Override\n"
"    public PropertyFileUserStorageProvider create(KeycloakSession session, ComponentModel model) {\n"
"        String path = model.getConfig().getFirst(\"path\");\n"
"\n"
"        Properties props = new Properties();\n"
"        try {\n"
"            InputStream is = new FileInputStream(path);\n"
"            props.load(is);\n"
"            is.close();\n"
"        } catch (IOException e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"\n"
"        return new PropertyFileUserStorageProvider(session, model, props);\n"
"    }"
msgstr ""
"    @Override\n"
"    public PropertyFileUserStorageProvider create(KeycloakSession session, ComponentModel model) {\n"
"        String path = model.getConfig().getFirst(\"path\");\n"
"\n"
"        Properties props = new Properties();\n"
"        try {\n"
"            InputStream is = new FileInputStream(path);\n"
"            props.load(is);\n"
"            is.close();\n"
"        } catch (IOException e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"\n"
"        return new PropertyFileUserStorageProvider(session, model, props);\n"
"    }"

msgid ""
"This logic is, of course, inefficient as every transaction reads the entire "
"user property file from disk, but hopefully this illustrates, in a simple "
"way, how to hook in configuration variables."
msgstr ""
"このロジックは、すべてのトランザクションがディスクからユーザー・プロパティー・ファイル全体を読み込むので、もちろん非効率ですが、設定変数にフックする簡単な方法を示しているはずです。"

msgid "Configuring the provider in the Admin Console"
msgstr "管理コンソールでのプロバイダー設定"

msgid ""
"Now that the configuration is enabled, you can set the `path` variable when "
"you configure the provider in the Admin Console."
msgstr "これで、設定ができるようになりました。管理コンソールでプロバイダーを設定すると、 `path` 変数を設定することができます。"

msgid "image:images/storage-provider-with-config.png[]"
msgstr "image:images/storage-provider-with-config.png[]"

msgid "Add/Remove user and query capability interfaces"
msgstr "ユーザーの追加/削除およびクエリーのケイパビリティー・インターフェイス"

msgid ""
"One thing we have not done with our example is allow it to add and remove "
"users or change passwords. Users defined in our example are also not "
"queryable or viewable in the Admin Console. To add these enhancements, our "
"example provider must implement the `UserQueryProvider` and "
"`UserRegistrationProvider` interfaces."
msgstr ""
"これまでのサンプルで行っていないことの1つは、ユーザーの追加と削除やパスワードの変更をできるようにすることです。これまでのサンプルで定義されたユーザーは、管理コンソールで照会することも表示することもできません。これらの拡張機能を追加するには、サンプル・プロバイダーで"
" `UserQueryProvider` と `UserRegistrationProvider` インターフェイスを実装する必要があります。"

msgid "Implementing UserRegistrationProvider"
msgstr "UserRegistrationProviderの実装"

msgid ""
"Use this procedure to implement adding and removing users from the "
"particular store, we first have to be able to save our properties file to "
"disk."
msgstr ""
"この手順を使用して、特定のストアに対するユーザーの追加と削除を実装するためには、まずプロパティー・ファイルをディスクに保存できるようにする必要があります。"

msgid "PropertyFileUserStorageProvider"
msgstr "PropertyFileUserStorageProvider"

msgid ""
"    public void save() {\n"
"        String path = model.getConfig().getFirst(\"path\");\n"
"        path = EnvUtil.replace(path);\n"
"        try {\n"
"            FileOutputStream fos = new FileOutputStream(path);\n"
"            properties.store(fos, \"\");\n"
"            fos.close();\n"
"        } catch (IOException e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }"
msgstr ""
"    public void save() {\n"
"        String path = model.getConfig().getFirst(\"path\");\n"
"        path = EnvUtil.replace(path);\n"
"        try {\n"
"            FileOutputStream fos = new FileOutputStream(path);\n"
"            properties.store(fos, \"\");\n"
"            fos.close();\n"
"        } catch (IOException e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }"

msgid ""
"Then, the implementation of the `addUser()` and `removeUser()` methods "
"becomes simple."
msgstr "このとき、 `addUser()` メソッドと `removeUser()` メソッドの実装は単純になります。"

msgid ""
"    public static final String UNSET_PASSWORD=\"#$!-UNSET-PASSWORD\";\n"
"\n"
"    @Override\n"
"    public UserModel addUser(RealmModel realm, String username) {\n"
"        synchronized (properties) {\n"
"            properties.setProperty(username, UNSET_PASSWORD);\n"
"            save();\n"
"        }\n"
"        return createAdapter(realm, username);\n"
"    }\n"
"\n"
"    @Override\n"
"    public boolean removeUser(RealmModel realm, UserModel user) {\n"
"        synchronized (properties) {\n"
"            if (properties.remove(user.getUsername()) == null) return false;\n"
"            save();\n"
"            return true;\n"
"        }\n"
"    }"
msgstr ""
"    public static final String UNSET_PASSWORD=\"#$!-UNSET-PASSWORD\";\n"
"\n"
"    @Override\n"
"    public UserModel addUser(RealmModel realm, String username) {\n"
"        synchronized (properties) {\n"
"            properties.setProperty(username, UNSET_PASSWORD);\n"
"            save();\n"
"        }\n"
"        return createAdapter(realm, username);\n"
"    }\n"
"\n"
"    @Override\n"
"    public boolean removeUser(RealmModel realm, UserModel user) {\n"
"        synchronized (properties) {\n"
"            if (properties.remove(user.getUsername()) == null) return false;\n"
"            save();\n"
"            return true;\n"
"        }\n"
"    }"

msgid ""
"Notice that when adding a user we set the password value of the property map"
" to be `UNSET_PASSWORD`.  We do this as we can't have null values for a "
"property in the property value. We also have to modify the "
"`CredentialInputValidator` methods to reflect this."
msgstr ""
"ユーザーを追加する際に、プロパティー・マップのパスワード値を `UNSET_PASSWORD` "
"に設定することに注意してください。これは、プロパティー値をnullにすることができないためです。これを反映するために、 "
"`CredentialInputValidator` メソッドを変更する必要もあります。"

msgid ""
"The `addUser()` method will be called if the provider implements the "
"`UserRegistrationProvider` interface. If your provider has a configuration "
"switch to turn off adding a user, returning `null` from this method will "
"skip the provider and call the next one."
msgstr ""
"プロバイダーが `UserRegistrationProvider` インターフェイスを実装している場合、 `addUser()` "
"メソッドが呼び出されます。プロバイダーがユーザーの追加をオフにする設定スイッチを持っている場合、このメソッドから  `null` "
"を返すことで、このプロバイダーをスキップして、次を呼び出すようにできます。"

msgid ""
"    @Override\n"
"    public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {\n"
"        if (!supportsCredentialType(input.getType()) || !(input instanceof UserCredentialModel)) return false;\n"
"\n"
"        UserCredentialModel cred = (UserCredentialModel)input;\n"
"        String password = properties.getProperty(user.getUsername());\n"
"        if (password == null || UNSET_PASSWORD.equals(password)) return false;\n"
"        return password.equals(cred.getValue());\n"
"    }"
msgstr ""
"    @Override\n"
"    public boolean isValid(RealmModel realm, UserModel user, CredentialInput input) {\n"
"        if (!supportsCredentialType(input.getType()) || !(input instanceof UserCredentialModel)) return false;\n"
"\n"
"        UserCredentialModel cred = (UserCredentialModel)input;\n"
"        String password = properties.getProperty(user.getUsername());\n"
"        if (password == null || UNSET_PASSWORD.equals(password)) return false;\n"
"        return password.equals(cred.getValue());\n"
"    }"

msgid ""
"Since we can now save our property file, it also makes sense to allow "
"password updates."
msgstr "これでプロパティー・ファイルを保存できるようになったので、パスワードも更新できるようになります。"

msgid ""
"    @Override\n"
"    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {\n"
"        if (!(input instanceof UserCredentialModel)) return false;\n"
"        if (!input.getType().equals(CredentialModel.PASSWORD)) return false;\n"
"        UserCredentialModel cred = (UserCredentialModel)input;\n"
"        synchronized (properties) {\n"
"            properties.setProperty(user.getUsername(), cred.getValue());\n"
"            save();\n"
"        }\n"
"        return true;\n"
"    }"
msgstr ""
"    @Override\n"
"    public boolean updateCredential(RealmModel realm, UserModel user, CredentialInput input) {\n"
"        if (!(input instanceof UserCredentialModel)) return false;\n"
"        if (!input.getType().equals(CredentialModel.PASSWORD)) return false;\n"
"        UserCredentialModel cred = (UserCredentialModel)input;\n"
"        synchronized (properties) {\n"
"            properties.setProperty(user.getUsername(), cred.getValue());\n"
"            save();\n"
"        }\n"
"        return true;\n"
"    }"

msgid "We can now also implement disabling a password."
msgstr "また、パスワードを無効にすることができます。"

msgid ""
"    @Override\n"
"    public void disableCredentialType(RealmModel realm, UserModel user, String credentialType) {\n"
"        if (!credentialType.equals(CredentialModel.PASSWORD)) return;\n"
"        synchronized (properties) {\n"
"            properties.setProperty(user.getUsername(), UNSET_PASSWORD);\n"
"            save();\n"
"        }\n"
"\n"
"    }\n"
"\n"
"    private static final Set<String> disableableTypes = new HashSet<>();\n"
"\n"
"    static {\n"
"        disableableTypes.add(CredentialModel.PASSWORD);\n"
"    }\n"
"\n"
"    @Override\n"
"    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n"
"\n"
"        return disableableTypes;\n"
"    }"
msgstr ""
"    @Override\n"
"    public void disableCredentialType(RealmModel realm, UserModel user, String credentialType) {\n"
"        if (!credentialType.equals(CredentialModel.PASSWORD)) return;\n"
"        synchronized (properties) {\n"
"            properties.setProperty(user.getUsername(), UNSET_PASSWORD);\n"
"            save();\n"
"        }\n"
"\n"
"    }\n"
"\n"
"    private static final Set<String> disableableTypes = new HashSet<>();\n"
"\n"
"    static {\n"
"        disableableTypes.add(CredentialModel.PASSWORD);\n"
"    }\n"
"\n"
"    @Override\n"
"    public Set<String> getDisableableCredentialTypes(RealmModel realm, UserModel user) {\n"
"\n"
"        return disableableTypes;\n"
"    }"

msgid ""
"With these methods implemented, you'll now be able to change and disable the"
" password for the user in the Admin Console."
msgstr "これらのメソッドを実装すると、管理コンソールでユーザーのパスワードの変更や無効化ができるようになります。"

msgid "Implementing UserQueryProvider"
msgstr "UserQueryProviderの実装"

msgid ""
"Without implementing `UserQueryProvider` the Admin Console would not be able"
" to view and manage users that were loaded by our example provider. Let's "
"look at implementing this interface."
msgstr ""
"`UserQueryProvider` "
"を実装しなければ、管理コンソールはサンプル・プロバイダーによってロードされたユーザーを表示および管理できません。このインターフェイスの実装を見てみましょう。"

msgid ""
"    @Override\n"
"    public int getUsersCount(RealmModel realm) {\n"
"        return properties.size();\n"
"    }\n"
"\n"
"    @Override\n"
"    public List<UserModel> getUsers(RealmModel realm) {\n"
"        return getUsers(realm, 0, Integer.MAX_VALUE);\n"
"    }\n"
"\n"
"    @Override\n"
"    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n"
"        List<UserModel> users = new LinkedList<>();\n"
"        int i = 0;\n"
"        for (Object obj : properties.keySet()) {\n"
"            if (i++ < firstResult) continue;\n"
"            String username = (String)obj;\n"
"            UserModel user = getUserByUsername(username, realm);\n"
"            users.add(user);\n"
"            if (users.size() >= maxResults) break;\n"
"        }\n"
"        return users;\n"
"    }"
msgstr ""
"    @Override\n"
"    public int getUsersCount(RealmModel realm) {\n"
"        return properties.size();\n"
"    }\n"
"\n"
"    @Override\n"
"    public List<UserModel> getUsers(RealmModel realm) {\n"
"        return getUsers(realm, 0, Integer.MAX_VALUE);\n"
"    }\n"
"\n"
"    @Override\n"
"    public List<UserModel> getUsers(RealmModel realm, int firstResult, int maxResults) {\n"
"        List<UserModel> users = new LinkedList<>();\n"
"        int i = 0;\n"
"        for (Object obj : properties.keySet()) {\n"
"            if (i++ < firstResult) continue;\n"
"            String username = (String)obj;\n"
"            UserModel user = getUserByUsername(username, realm);\n"
"            users.add(user);\n"
"            if (users.size() >= maxResults) break;\n"
"        }\n"
"        return users;\n"
"    }"

msgid ""
"The `getUsers()` method iterates over the key set of the property file, "
"delegating to `getUserByUsername()` to load a user. Notice that we are "
"indexing this call based on the `firstResult` and `maxResults` parameter. If"
" your external store does not support pagination, you will have to do "
"similar logic."
msgstr ""
"`getUsers()` メソッドはプロパティー・ファイルのキーセットを反復し、 `getUserByUsername()` "
"に委譲してユーザーをロードします。 `firstResult` と `maxResults` "
"パラメーターに基づいてこの呼び出しにインデックスを付けることに注目してください。外部ストアがページネーションをサポートしていない場合は、同様のロジックを実行する必要があります。"

msgid ""
"    @Override\n"
"    public List<UserModel> searchForUser(String search, RealmModel realm) {\n"
"        return searchForUser(search, realm, 0, Integer.MAX_VALUE);\n"
"    }\n"
"\n"
"    @Override\n"
"    public List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults) {\n"
"        List<UserModel> users = new LinkedList<>();\n"
"        int i = 0;\n"
"        for (Object obj : properties.keySet()) {\n"
"            String username = (String)obj;\n"
"            if (!username.contains(search)) continue;\n"
"            if (i++ < firstResult) continue;\n"
"            UserModel user = getUserByUsername(username, realm);\n"
"            users.add(user);\n"
"            if (users.size() >= maxResults) break;\n"
"        }\n"
"        return users;\n"
"    }"
msgstr ""
"    @Override\n"
"    public List<UserModel> searchForUser(String search, RealmModel realm) {\n"
"        return searchForUser(search, realm, 0, Integer.MAX_VALUE);\n"
"    }\n"
"\n"
"    @Override\n"
"    public List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults) {\n"
"        List<UserModel> users = new LinkedList<>();\n"
"        int i = 0;\n"
"        for (Object obj : properties.keySet()) {\n"
"            String username = (String)obj;\n"
"            if (!username.contains(search)) continue;\n"
"            if (i++ < firstResult) continue;\n"
"            UserModel user = getUserByUsername(username, realm);\n"
"            users.add(user);\n"
"            if (users.size() >= maxResults) break;\n"
"        }\n"
"        return users;\n"
"    }"

msgid ""
"The first declaration of `searchForUser()` takes a `String` parameter. This "
"is supposed to be a string that you use to search username and email "
"attributes to find the user. This string can be a substring, which is why we"
" use the `String.contains()` method when doing our search."
msgstr ""
"`searchForUser()` の最初の宣言は `String` "
"パラメーターを受け取ります。これは、ユーザー名と電子メールの属性を検索してユーザーを見つけるために使用する文字列です。この文字列は部分文字列にすることができるので、検索を行うときに"
" `String.contains()` メソッドを使用しています。"

msgid ""
"    @Override\n"
"    public List<UserModel> searchForUser(Map<String, String> params, RealmModel realm) {\n"
"        return searchForUser(params, realm, 0, Integer.MAX_VALUE);\n"
"    }\n"
"\n"
"    @Override\n"
"    public List<UserModel> searchForUser(Map<String, String> params, RealmModel realm, int firstResult, int maxResults) {\n"
"        // only support searching by username\n"
"        String usernameSearchString = params.get(\"username\");\n"
"        if (usernameSearchString == null) return Collections.EMPTY_LIST;\n"
"        return searchForUser(usernameSearchString, realm, firstResult, maxResults);\n"
"    }"
msgstr ""
"    @Override\n"
"    public List<UserModel> searchForUser(Map<String, String> params, RealmModel realm) {\n"
"        return searchForUser(params, realm, 0, Integer.MAX_VALUE);\n"
"    }\n"
"\n"
"    @Override\n"
"    public List<UserModel> searchForUser(Map<String, String> params, RealmModel realm, int firstResult, int maxResults) {\n"
"        // only support searching by username\n"
"        String usernameSearchString = params.get(\"username\");\n"
"        if (usernameSearchString == null) return Collections.EMPTY_LIST;\n"
"        return searchForUser(usernameSearchString, realm, firstResult, maxResults);\n"
"    }"

msgid ""
"The `searchForUser()` method that takes a `Map` parameter can search for a "
"user based on first, last name, username, and email. We only store "
"usernames, so we only search based on usernames. We delegate to "
"`searchForUser()` for this."
msgstr ""
"`Map` パラメーターを受け取る `searchForUser()` "
"メソッドは、姓、名、電子メールに基づいてユーザーを検索できます。ユーザー名のみを保存するので、ユーザー名に基づいて検索します。このため、`searchForUser()`"
" に処理を委譲しています。"

msgid ""
"    @Override\n"
"    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n"
"        return Collections.EMPTY_LIST;\n"
"    }\n"
"\n"
"    @Override\n"
"    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n"
"        return Collections.EMPTY_LIST;\n"
"    }\n"
"\n"
"    @Override\n"
"    public List<UserModel> searchForUserByUserAttribute(String attrName, String attrValue, RealmModel realm) {\n"
"        return Collections.EMPTY_LIST;\n"
"    }"
msgstr ""
"    @Override\n"
"    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group, int firstResult, int maxResults) {\n"
"        return Collections.EMPTY_LIST;\n"
"    }\n"
"\n"
"    @Override\n"
"    public List<UserModel> getGroupMembers(RealmModel realm, GroupModel group) {\n"
"        return Collections.EMPTY_LIST;\n"
"    }\n"
"\n"
"    @Override\n"
"    public List<UserModel> searchForUserByUserAttribute(String attrName, String attrValue, RealmModel realm) {\n"
"        return Collections.EMPTY_LIST;\n"
"    }"

msgid ""
"We do not store groups or attributes, so the other methods return an empty "
"list."
msgstr "グループや属性は保存しないので、他のメソッドは空のリストを返します。"

msgid "Augmenting external storage"
msgstr "外部ストレージの拡張"

msgid ""
"The `PropertyFileUserStorageProvider` example is really limited.  While we "
"will be able to log in with users stored in a property file, we won't be "
"able to do much else.  If users loaded by this provider need special role or"
" group mappings to fully access particular applications there is no way for "
"us to add additional role mappings to these users. You also can't modify or "
"add additional important attributes like email, first and last name."
msgstr ""
"`PropertyFileUserStorageProvider` "
"のサンプルは実際には限定されています。プロパティー・ファイルに保存されているユーザーでログインすることはできますが、他のことはあまりできません。このプロバイダーによってロードされたユーザーが、特定のアプリケーションに完全にアクセスするための特殊なロールまたはグループ・マッピングを必要とする場合、これらのユーザーにロールマッピングを追加する方法はありません。また、電子メール、姓名などの重要な属性を変更または追加することもできません。"

msgid ""
"For these types of situations, {project_name} allows you to augment your "
"external store by storing extra information in {project_name}'s database.  "
"This is called federated user storage and is encapsulated within the "
"`org.keycloak.storage.federated.UserFederatedStorageProvider` class."
msgstr ""
"このような状況の場合、{project_name}は{project_name}のデータベースに追加の情報を保存することで、外部ストアを拡張することができます。これはフェデレーテッド・ユーザー・ストレージと呼ばれ、"
" `org.keycloak.storage.federated.UserFederatedStorageProvider` "
"クラス内にカプセル化されています。"

msgid "UserFederatedStorageProvider"
msgstr "UserFederatedStorageProvider"

msgid ""
"package org.keycloak.storage.federated;\n"
"\n"
"public interface UserFederatedStorageProvider extends Provider {\n"
"\n"
"    Set<GroupModel> getGroups(RealmModel realm, String userId);\n"
"    void joinGroup(RealmModel realm, String userId, GroupModel group);\n"
"    void leaveGroup(RealmModel realm, String userId, GroupModel group);\n"
"    List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max);\n"
"\n"
"...\n"
msgstr ""
"package org.keycloak.storage.federated;\n"
"\n"
"public interface UserFederatedStorageProvider extends Provider {\n"
"\n"
"    Set<GroupModel> getGroups(RealmModel realm, String userId);\n"
"    void joinGroup(RealmModel realm, String userId, GroupModel group);\n"
"    void leaveGroup(RealmModel realm, String userId, GroupModel group);\n"
"    List<String> getMembership(RealmModel realm, GroupModel group, int firstResult, int max);\n"
"\n"
"...\n"

msgid ""
"The `UserFederatedStorageProvider` instance is available on the "
"`KeycloakSession.userFederatedStorage()` method. It has all different kinds "
"of methods for storing attributes, group and role mappings, different "
"credential types, and required actions.  If your external store's datamodel"
"  cannot support the full {project_name} feature set, then this service can "
"fill in the gaps."
msgstr ""
"`UserFederatedStorageProvider` インスタンスは、 "
"`KeycloakSession.userFederatedStorage()` "
"メソッドで利用できます。これには、属性、グループとロールマッピング、異なるクレデンシャル・タイプ、および必須アクションを保存するためのすべての種類のメソッドがあります。外部ストアのデータモデルが完全な{project_name}の機能セットをサポートできない場合、このサービスはそのギャップを埋めることができます。"

msgid ""
"{project_name} comes with a helper class "
"`org.keycloak.storage.adapter.AbstractUserAdapterFederatedStorage` that will"
" delegate every single `UserModel` method except get/set of username to user"
" federated storage.  Override the methods you need to override to delegate "
"to your external storage representations.  It is strongly suggested you read"
" the javadoc of this class as it has smaller protected methods you may want "
"to override.  Specifically surrounding group membership and role mappings."
msgstr ""
"{project_name}には、ユーザー名の取得/設定を除く全ての `UserModel` "
"のメソッドをユーザー・フェデレーティッド・ストレージに委譲するヘルパークラス "
"`org.keycloak.storage.adapter.AbstractUserAdapterFederatedStorage` "
"が付属しています。外部ストレージ表現に委譲するため、オーバーライドする必要があるメソッドはオーバーライドします。このクラスは、オーバーライドしてもよい、より小さなprotectedのメソッドを持っているため、Javadocを読むことを強くお勧めします。特に、グループ・メンバーシップとロールマッピングのあたりを読んでください。"

msgid "Augmentation example"
msgstr "拡張の例"

msgid ""
"In our `PropertyFileUserStorageProvider` example, we just need a simple "
"change to our provider to use the `AbstractUserAdapterFederatedStorage`."
msgstr ""
"`PropertyFileUserStorageProvider` の例では、 "
"`AbstractUserAdapterFederatedStorage` を使うためにプロバイダーに簡単な変更が必要です。"

msgid ""
"    protected UserModel createAdapter(RealmModel realm, String username) {\n"
"        return new AbstractUserAdapterFederatedStorage(session, realm, model) {\n"
"            @Override\n"
"            public String getUsername() {\n"
"                return username;\n"
"            }\n"
"\n"
"            @Override\n"
"            public void setUsername(String username) {\n"
"                String pw = (String)properties.remove(username);\n"
"                if (pw != null) {\n"
"                    properties.put(username, pw);\n"
"                    save();\n"
"                }\n"
"            }\n"
"        };\n"
"    }"
msgstr ""
"    protected UserModel createAdapter(RealmModel realm, String username) {\n"
"        return new AbstractUserAdapterFederatedStorage(session, realm, model) {\n"
"            @Override\n"
"            public String getUsername() {\n"
"                return username;\n"
"            }\n"
"\n"
"            @Override\n"
"            public void setUsername(String username) {\n"
"                String pw = (String)properties.remove(username);\n"
"                if (pw != null) {\n"
"                    properties.put(username, pw);\n"
"                    save();\n"
"                }\n"
"            }\n"
"        };\n"
"    }"

msgid ""
"We instead define an anonymous class implementation of  "
"`AbstractUserAdapterFederatedStorage`.  The `setUsername()` method makes "
"changes to the properties file and saves it."
msgstr ""
"代わりに `AbstractUserAdapterFederatedStorage` の匿名クラスの実装を定義します。 `setUsername()` "
"メソッドはプロパティー・ファイルを変更して保存します。"

msgid "Import implementation strategy"
msgstr "インポート実装による方法"

msgid ""
"When implementing a user storage provider, there's another strategy you can "
"take. Instead of using user federated storage, you can create a user locally"
" in the {project_name} built-in user database and copy attributes from your "
"external store into this local copy. There are many advantages to this "
"approach."
msgstr ""
"ユーザー・ストレージ・プロバイダーを実装する場合、選択可能な別の方法がもう1つあります。ユーザー・フェデレーティッド・ストレージを使用せずに、ローカルの{project_name}の組み込みユーザー・データベース内でユーザーを作成し、外部のストアからこのローカルコピーに属性をコピーすることができます。このアプローチにはたくさんの利点があります。"

msgid ""
"{project_name} basically becomes a persistence user cache for your external "
"store. Once the user is imported you'll no longer hit the external store "
"thus taking load off of it."
msgstr ""
"{project_name}は、基本的に外部ユーザーストア用の永続的なユーザー・キャッシュになります。ユーザーがインポートされると、外部ストアにヒットすることはなくなり、その負荷が取り除かれます。"

msgid ""
"If you are moving to {project_name} as your official user store and "
"deprecating the old external store, you can slowly migrate applications to "
"use {project_name}. When all applications have been migrated, unlink the "
"imported user, and retire the old legacy external store."
msgstr ""
"公式のユーザーストアを{project_name}にし、従来の外部ストアは廃止する場合、アプリケーションを徐々に移行して{project_name}を使用することができます。すべてのアプリケーションが移行されたら、インポートされたユーザーのリンクを解除し、従来のレガシー外部ストアは廃止します。"

msgid ""
"There are some obvious disadvantages though to using an import strategy:"
msgstr "インポートによる方法の使用には明らかな欠点がいくつかあります。"

msgid ""
"Looking up a user for the first time will require multiple updates to "
"{project_name} database. This can be a big performance loss under load and "
"put a lot of strain on the {project_name} database. The user federated "
"storage approach will only store extra data as needed and may never be used "
"depending on the capabilities of your external store."
msgstr ""
"初回のユーザーの検索では、{project_name}のデータベースを複数回更新する必要があります。これは大きなパフォーマンス低下を招き、{project_name}のデータベースに多くの負担をかけることになります。ユーザー・フェデレーティッド・ストレージのアプローチでは、必要に応じて追加のデータのみが保存されるだけであり、外部ストアの機能によってはまったく使用されない可能性もあります。"

msgid ""
"With the import approach, you have to keep local {project_name} storage and "
"external storage in sync. The User Storage SPI has capability interfaces "
"that you can implement to support synchronization, but this can quickly "
"become painful and messy."
msgstr ""
"インポートのアプローチでは、ローカルの{project_name}ストレージと外部ストレージを同期させておく必要があります。ユーザー・ストレージSPIには、同期をサポートできるために実装できるケーパビリティー・インターフェイスがありますが、これはすぐにやっかいで面倒なものになります。"

msgid ""
"To implement the import strategy you simply check to see first if the user "
"has been imported locally. If so return the local user, if not create the "
"user locally and import data from the external store. You can also proxy the"
" local user so that most changes are automatically synchronized."
msgstr ""
"インポートによる方法を実装する場合は、ユーザーがローカルにインポートされているかどうかを初回のみ確認します。インポートされている場合は、ローカルユーザーを返します。インポートされていない場合は、ユーザーをローカルで作成して外部ストアからデータをインポートします。ほとんどの変更が自動的に同期されるように、ローカルユーザーをプロキシーすることもできます。"

msgid ""
"This will be a bit contrived, but we can extend our "
"`PropertyFileUserStorageProvider` to take this approach. We begin first by "
"modifying the `createAdapter()` method."
msgstr ""
"少し工夫が必要ですが、 `PropertyFileUserStorageProvider` を拡張してこのアプローチをとることができます。まずは "
"`createAdapter()` メソッドを変更することからはじめます。"

msgid ""
"    protected UserModel createAdapter(RealmModel realm, String username) {\n"
"        UserModel local = session.userLocalStorage().getUserByUsername(username, realm);\n"
"        if (local == null) {\n"
"            local = session.userLocalStorage().addUser(realm, username);\n"
"            local.setFederationLink(model.getId());\n"
"        }\n"
"        return new UserModelDelegate(local) {\n"
"            @Override\n"
"            public void setUsername(String username) {\n"
"                String pw = (String)properties.remove(username);\n"
"                if (pw != null) {\n"
"                    properties.put(username, pw);\n"
"                    save();\n"
"                }\n"
"                super.setUsername(username);\n"
"            }\n"
"        };\n"
"    }"
msgstr ""
"    protected UserModel createAdapter(RealmModel realm, String username) {\n"
"        UserModel local = session.userLocalStorage().getUserByUsername(username, realm);\n"
"        if (local == null) {\n"
"            local = session.userLocalStorage().addUser(realm, username);\n"
"            local.setFederationLink(model.getId());\n"
"        }\n"
"        return new UserModelDelegate(local) {\n"
"            @Override\n"
"            public void setUsername(String username) {\n"
"                String pw = (String)properties.remove(username);\n"
"                if (pw != null) {\n"
"                    properties.put(username, pw);\n"
"                    save();\n"
"                }\n"
"                super.setUsername(username);\n"
"            }\n"
"        };\n"
"    }"

msgid ""
"In this method we call the `KeycloakSession.userLocalStorage()` method to "
"obtain a reference to local {project_name} user storage. We see if the user "
"is stored locally, if not, we add it locally. Do not set the `id` of the "
"local user. Let {project_name} automatically generate the `id`.  Also note "
"that we call `UserModel.setFederationLink()` and pass in the ID of the "
"`ComponentModel` of our provider. This sets a link between the provider and "
"the imported user."
msgstr ""
"このメソッドでは `KeycloakSession.userLocalStorage()` "
"メソッドを呼び出し、ローカルの{project_name}ユーザー・ストレージへの参照を取得します。ユーザーがローカルで保存されたかどうかを確認し、保存されていない場合はローカルにユーザーを追加します。ローカルユーザーの"
" `id` を設定しないでください。{project_name}が `id` を自動生成します。また、 "
"`UserModel.setFederationLink()` を呼び出して、プロバイダーの `ComponentModel` "
"のIDを渡すことにも注意してください。これにより、プロバイダーとインポートされたユーザーの間でリンクが設定されます。"

msgid ""
"When a user storage provider is removed, any user imported by it will also "
"be removed.  This is one of the       purposes of calling "
"`UserModel.setFederationLink()`."
msgstr ""
"ユーザー・ストレージ・プロバイダーが削除されると、それによりインポートされたユーザーもすべて削除されます。これが "
"`UserModel.setFederationLink()` を呼び出す目的の1つです。"

msgid ""
"Another thing to note is that if a local user is linked, your storage "
"provider will still be delegated to for methods that it implements from the "
"`CredentialInputValidator` and `CredentialInputUpdater` interfaces. "
"Returning `false` from a validation or update will just result in "
"{project_name} seeing if it can validate or update using local storage."
msgstr ""
"もう1つ注意することは、ローカルユーザーがリンクされている場合、ストレージ・プロバイダーは `CredentialInputValidator` "
"インターフェイスと `CredentialInputUpdater` インターフェイスから実装されているメソッドに委譲されることです。検証または更新から"
" `false` が返ると、{project_name}は、ローカル・ストレージを使用して検証または更新できるかどうかを確認します。"

msgid ""
"Also notice that we are proxying the local user using the "
"`org.keycloak.models.utils.UserModelDelegate` class. This class is an "
"implementation of `UserModel`. Every method just delegates to the "
"`UserModel` it was instantiated with. We override the `setUsername()` method"
" of this delegate class to synchronize automatically with the property file."
" For your providers, you can use this to _intercept_ other methods on the "
"local `UserModel` to perform synchronization with your external store.  For "
"example, get methods could make sure that the local store is in sync. Set "
"methods keep the external store in sync with the local one.  One thing to "
"note is that the `getId()` method should always return  the id that was auto"
" generated when you created the user locally.  You should not return a "
"federated id as shown in the other non-import examples."
msgstr ""
"また、 `org.keycloak.models.utils.UserModelDelegate` "
"クラスを使用しているローカルユーザーをプロキシーしている点にも注意してください。このクラスは `UserModel` "
"の実装です。どのメソッドもインスタンス化された `UserModel` に委譲するだけです。この委譲クラスの `setUsername()` "
"メソッドをオーバーライドし、自動的にプロパティー・ファイルと同期させます。プロバイダーの場合は、これを使用して、ローカルの `UserModel` "
"上の他のメソッドを _インターセプト_ "
"して、外部ストアと同期させることができます。たとえば、getメソッドは、ローカルストアが同期していることを確認することができます。setメソッドは、外部ストアをローカルストアと同期し続けることができます。注目すべきは、"
" `getId()` "
"メソッドは、ユーザーをローカルで作成したときに自動的に生成されたIDを常に返すべきだということです。他のインポートではないサンプルが示すように、フェデレーションIDを返すべきではありません。"

msgid ""
"If your provider is implementing the `UserRegistrationProvider` interface, "
"your `removeUser()` method does not       need to remove the user from local"
" storage.  The runtime will automatically perform this operation.  Also"
"       note that `removeUser()` will be invoked before it is removed from "
"local storage."
msgstr ""
"プロバイダーが `UserRegistrationProvider` インターフェイスを実装している場合、 `removeUser()` "
"メソッドはローカル・ストレージからユーザーを削除する必要はありません。ランタイムがこの操作を自動的に実行します。また、 `removeUser()` "
"は、ローカル・ストレージから削除される前に呼び出される点に注意してください。"

msgid "ImportedUserValidation interface"
msgstr "ImportedUserValidationインターフェイス"

msgid ""
"If you remember earlier in this chapter, we discussed how querying for a "
"user worked.  Local storage is queried first, if the user is found there, "
"then the query ends.  This is a problem for our above implementation as we "
"want to proxy the local `UserModel` so that we can keep usernames in sync.  "
"The User Storage SPI has a callback for whenever a linked local user is "
"loaded from the local database."
msgstr ""
"この章の前半で、ユーザーに対するクエリーの機能について説明しました。ローカル・ストレージが最初に照会され、ユーザーがそこで見つかった場合、クエリーは終了します。これは、ユーザー名を同期させるためにローカルの"
" `UserModel` "
"をプロキシーする必要があるので、上記の実装では問題になります。ユーザー・ストレージSPIでは、リンクされたローカルユーザーがローカル・データベースからロードされるたびに、コールバックがあります。"

msgid ""
"package org.keycloak.storage.user;\n"
"public interface ImportedUserValidation {\n"
"    /**\n"
"     * If this method returns null, then the user in local storage will be removed\n"
"     *\n"
"     * @param realm\n"
"     * @param user\n"
"     * @return null if user no longer valid\n"
"     */\n"
"    UserModel validate(RealmModel realm, UserModel user);\n"
"}"
msgstr ""
"package org.keycloak.storage.user;\n"
"public interface ImportedUserValidation {\n"
"    /**\n"
"     * If this method returns null, then the user in local storage will be removed\n"
"     *\n"
"     * @param realm\n"
"     * @param user\n"
"     * @return null if user no longer valid\n"
"     */\n"
"    UserModel validate(RealmModel realm, UserModel user);\n"
"}"

msgid ""
"Whenever a linked local user is loaded, if the user storage provider class "
"implements this interface, then the `validate()` method is called. Here you "
"can proxy the local user passed in as a parameter and return it. That new "
"`UserModel` will be used. You can also optionally do a check to see if the "
"user still exists in the external store. If `validate()` returns `null`, "
"then the local user will be removed from the database."
msgstr ""
"リンクされたローカルユーザーがロードされるたびに、ユーザー・ストレージ・プロバイダー・クラスがこのインターフェイスを実装すると、 "
"`validate()` "
"メソッドが呼び出されます。ここでは、パラメーターとして渡されたローカルユーザーをプロキシーして返すことができます。それにより、新しい "
"`UserModel` が使用されます。また、ユーザーが外部ストアにまだ存在するかどうかを任意で確認することもできます。 `validate()` が "
"`null` を返すと、ローカルユーザーはデータベースから削除されます。"

msgid "ImportSynchronization interface"
msgstr "ImportSynchronizationインターフェイス"

msgid ""
"With the import strategy you can see that it is possible for the local user "
"copy to get out of sync with external storage. For example, maybe a user has"
" been removed from the external store. The User Storage SPI has an "
"additional interface you can implement to deal with this, "
"`org.keycloak.storage.user.ImportSynchronization`:"
msgstr ""
"インポートによる方法を使用すると、ローカルユーザーのコピーが外部ストレージと同期しない可能性があるということがわかります。たとえば、ユーザーが外部ストアから削除されている可能性があります。ユーザー・ストレージSPIには、"
" これに対処するために実装可能な追加のインターフェイス、 "
"`org.keycloak.storage.user.ImportSynchronization` があります。"

msgid ""
"package org.keycloak.storage.user;\n"
"\n"
"public interface ImportSynchronization {\n"
"    SynchronizationResult sync(KeycloakSessionFactory sessionFactory, String realmId, UserStorageProviderModel model);\n"
"    SynchronizationResult syncSince(Date lastSync, KeycloakSessionFactory sessionFactory, String realmId, UserStorageProviderModel model);\n"
"}"
msgstr ""
"package org.keycloak.storage.user;\n"
"\n"
"public interface ImportSynchronization {\n"
"    SynchronizationResult sync(KeycloakSessionFactory sessionFactory, String realmId, UserStorageProviderModel model);\n"
"    SynchronizationResult syncSince(Date lastSync, KeycloakSessionFactory sessionFactory, String realmId, UserStorageProviderModel model);\n"
"}"

msgid ""
"This interface is implemented by the provider factory. Once this interface "
"is implemented by the provider factory, the administration console "
"management page for the provider shows additional options. You can manually "
"force a synchronization by clicking a button. This invokes the "
"`ImportSynchronization.sync()` method. Also, additional configuration "
"options are displayed that allow you to automatically schedule a "
"synchronization. Automatic synchronizations invoke the `syncSince()` method."
msgstr ""
"このインターフェイスは、プロバイダー・ファクトリーによって実装されます。このインターフェイスがプロバイダー・ファクトリーによって実装されると、管理コンソールのプロバイダーの管理ページに追加のオプションが表示されます。ボタンをクリックして、手動で同期させることができます。こうして、"
" `ImportSynchronization.sync()` "
"メソッドが呼び出されます。また、追加の設定オプションが表示され、自動的に同期実行が予定されます。自動同期によって、 `syncSince()` "
"メソッドが呼び出されます。"

msgid "User caches"
msgstr "ユーザー・キャッシュ"

msgid ""
"When a user object is loaded by ID, username, or email queries it is cached."
" When a user object is being cached, it iterates through the entire "
"`UserModel` interface and pulls this information to a local in-memory-only "
"cache. In a cluster, this cache is still local, but it becomes an "
"invalidation cache. When a user object is modified, it is evicted. This "
"eviction event is propagated to the entire cluster so that the other nodes' "
"user cache is also invalidated."
msgstr ""
"ID、ユーザー名、または電子メールのクエリーによってユーザー・オブジェクトが読み込まれると、キャッシュされます。ユーザー・オブジェクトがキャッシュされると、それは"
" `UserModel` "
"インターフェイス全体を反復し、この情報をローカルのメモリー内専用キャッシュに保持します。クラスターでは、このキャッシュはまだローカルですが、無効化キャッシュになります。ユーザー・オブジェクトが変更されると、キャッシュは削除されます。このエビクション・イベントはクラスター全体に伝播され、他のノードのユーザー・キャッシュも無効になります。"

msgid "Managing the user cache"
msgstr "ユーザー・キャッシュの管理"

msgid ""
"You can access the user cache by calling `KeycloakSession.userCache()`."
msgstr "`KeycloakSession.userCache()` を呼び出すことで、ユーザー・キャッシュにアクセスできます。"

msgid ""
"/**\n"
" * All these methods effect an entire cluster of Keycloak instances.\n"
" *\n"
" * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n"
" * @version $Revision: 1 $\n"
" */\n"
"public interface UserCache extends UserProvider {\n"
"    /**\n"
"     * Evict user from cache.\n"
"     *\n"
"     * @param user\n"
"     */\n"
"    void evict(RealmModel realm, UserModel user);\n"
"\n"
"    /**\n"
"     * Evict users of a specific realm\n"
"     *\n"
"     * @param realm\n"
"     */\n"
"    void evict(RealmModel realm);\n"
"\n"
"    /**\n"
"     * Clear cache entirely.\n"
"     *\n"
"     */\n"
"    void clear();\n"
"}"
msgstr ""
"/**\n"
" * All these methods effect an entire cluster of Keycloak instances.\n"
" *\n"
" * @author <a href=\"mailto:bill@burkecentral.com\">Bill Burke</a>\n"
" * @version $Revision: 1 $\n"
" */\n"
"public interface UserCache extends UserProvider {\n"
"    /**\n"
"     * Evict user from cache.\n"
"     *\n"
"     * @param user\n"
"     */\n"
"    void evict(RealmModel realm, UserModel user);\n"
"\n"
"    /**\n"
"     * Evict users of a specific realm\n"
"     *\n"
"     * @param realm\n"
"     */\n"
"    void evict(RealmModel realm);\n"
"\n"
"    /**\n"
"     * Clear cache entirely.\n"
"     *\n"
"     */\n"
"    void clear();\n"
"}"

msgid ""
"There are methods for evicting specific users, users contained in a specific"
" realm, or the entire cache."
msgstr "特定のユーザー、レルムに含まれるユーザー、またはキャッシュ全体を削除するメソッドがあります。"

msgid "OnUserCache callback interface"
msgstr "OnUserCacheコールバック・インターフェイス"

msgid ""
"You might want to cache additional information that is specific to your "
"provider implementation. The User Storage SPI has a callback whenever a user"
" is cached: `org.keycloak.models.cache.OnUserCache`."
msgstr ""
"プロバイダーの実装に固有の追加情報をキャッシュすることができます。ユーザー・ストレージSPIには、ユーザーがキャッシュされるたびにコールバックがあります（"
" `org.keycloak.models.cache.OnUserCache` ）。"

msgid ""
"public interface OnUserCache {\n"
"    void onCache(RealmModel realm, CachedUserModel user, UserModel delegate);\n"
"}"
msgstr ""
"public interface OnUserCache {\n"
"    void onCache(RealmModel realm, CachedUserModel user, UserModel delegate);\n"
"}"

msgid ""
"Your provider class should implement this interface if it wants this "
"callback. The `UserModel` delegate parameter is the `UserModel` instance "
"returned by your provider. The `CachedUserModel` is an expanded `UserModel` "
"interface. This is the instance that is cached locally in local storage."
msgstr ""
"このコールバックが必要な場合、プロバイダー・クラスはこのインターフェイスを実装する必要があります。 `UserModel` "
"デリゲート・パラメーターはプロバイダーから返された `UserModel` インスタンスです。 `CachedUserModel` は拡張された "
"`UserModel` インターフェイスです。これは、ローカル・ストレージにローカルでキャッシュされるインスタンスです。"

msgid ""
"public interface CachedUserModel extends UserModel {\n"
"\n"
"    /**\n"
"     * Invalidates the cache for this user and returns a delegate that represents the actual data provider\n"
"     *\n"
"     * @return\n"
"     */\n"
"    UserModel getDelegateForUpdate();\n"
"\n"
"    boolean isMarkedForEviction();\n"
"\n"
"    /**\n"
"     * Invalidate the cache for this model\n"
"     *\n"
"     */\n"
"    void invalidate();\n"
"\n"
"    /**\n"
"     * When was the model was loaded from database.\n"
"     *\n"
"     * @return\n"
"     */\n"
"    long getCacheTimestamp();\n"
"\n"
"    /**\n"
"     * Returns a map that contains custom things that are cached along with this model.  You can write to this map.\n"
"     *\n"
"     * @return\n"
"     */\n"
"    ConcurrentHashMap getCachedWith();\n"
"}"
msgstr ""
"public interface CachedUserModel extends UserModel {\n"
"\n"
"    /**\n"
"     * Invalidates the cache for this user and returns a delegate that represents the actual data provider\n"
"     *\n"
"     * @return\n"
"     */\n"
"    UserModel getDelegateForUpdate();\n"
"\n"
"    boolean isMarkedForEviction();\n"
"\n"
"    /**\n"
"     * Invalidate the cache for this model\n"
"     *\n"
"     */\n"
"    void invalidate();\n"
"\n"
"    /**\n"
"     * When was the model was loaded from database.\n"
"     *\n"
"     * @return\n"
"     */\n"
"    long getCacheTimestamp();\n"
"\n"
"    /**\n"
"     * Returns a map that contains custom things that are cached along with this model.  You can write to this map.\n"
"     *\n"
"     * @return\n"
"     */\n"
"    ConcurrentHashMap getCachedWith();\n"
"}"

msgid ""
"This `CachedUserModel` interface allows you to evict the user from the cache"
" and get the provider `UserModel` instance. The `getCachedWith()` method "
"returns a map that allows you to cache additional information pertaining to "
"the user. For example, credentials are not part of the `UserModel` "
"interface. If you wanted to cache credentials in memory, you would implement"
" `OnUserCache` and cache your user's credentials using the `getCachedWith()`"
" method."
msgstr ""
"この `CachedUserModel` インターフェイスは、キャッシュからユーザーを削除し、プロバイダーの `UserModel` "
"インスタンスを取得することを可能にします。 `getCachedWith()` "
"メソッドは、ユーザーに関する追加情報をキャッシュするためのマップを返します。たとえば、クレデンシャルは `UserModel` "
"インターフェイスの一部ではありません。メモリーにクレデンシャルをキャッシュしたい場合は、 `OnUserCache` を実装し、 "
"`getCachedWith()` メソッドを使ってユーザーのクレデンシャルをキャッシュします。"

msgid "Cache policies"
msgstr "キャッシュ・ポリシー"

msgid ""
"On the administration console management page for your user storage "
"provider, you can specify a unique cache policy."
msgstr "管理コンソールのユーザー・ストレージ・プロバイダーの管理ページで、一意なキャッシュ・ポリシーを指定できます。"

msgid "Leveraging Jakarta EE"
msgstr "Jakarta EEの活用"

msgid ""
"The user storage providers can be packaged within any Jakarta EE component "
"if you set up the `META-INF/services` file correctly to point to your "
"providers. For example, if your provider needs to use third-party libraries,"
" you can package up your provider within an EAR and store these third-party "
"libraries in the `lib/` directory of the EAR. Also note that provider JARs "
"can make use of the `jboss-deployment-structure.xml` file that EJBs, WARS, "
"and EARs can use in a {appserver_name} environment. For more details on this"
" file, see the {appserver_name} documentation. It allows you to pull in "
"external dependencies among other fine-grained actions."
msgstr ""
"プロバイダーを指し示す、 `META-INF/services` ファイルを正しく設定すると、ユーザー・ストレージ・プロバイダーは任意のJakarta "
"EEコンポーネント内にパッケージ化することができます。たとえば、プロバイダーがサードパーティー・ライブラリーを使用する必要がある場合は、EAR内でプロバイダーをパッケージ化し、これらのサードパーティー・ライブラリーをEARの"
" `lib/` "
"ディレクトリーに格納することができます。また、プロバイダーJARは、EJB、WAR、およびEARが{appserver_name}環境で使用できる "
"`jboss-deployment-structure.xml` "
"ファイルを利用できます。このファイルの詳細については、{appserver_name}のドキュメントを参照してください。他のきめ細かなアクション間の外部依存関係を引き出すことができます。"

msgid ""
"Provider implementations are required to be plain java objects. But we also "
"currently support implementing `UserStorageProvider` classes as Stateful "
"EJBs. This is especially useful if you want to use JPA to connect to a "
"relational store. This is how you would do it:"
msgstr ""
"プロバイダーの実装はプレーンなJavaオブジェクトである必要があります。しかし、現在、 `UserStorageProvider` "
"クラスをステートフルEJBとして実装することもサポートしています。これは、JPAを使用してリレーショナル・ストアに接続する場合に特に便利です。それを行う方法は以下のとおりです。"

msgid ""
"@Stateful\n"
"@Local(EjbExampleUserStorageProvider.class)\n"
"public class EjbExampleUserStorageProvider implements UserStorageProvider,\n"
"        UserLookupProvider,\n"
"        UserRegistrationProvider,\n"
"        UserQueryProvider,\n"
"        CredentialInputUpdater,\n"
"        CredentialInputValidator,\n"
"        OnUserCache\n"
"{\n"
"    @PersistenceContext\n"
"    protected EntityManager em;\n"
"\n"
"    protected ComponentModel model;\n"
"    protected KeycloakSession session;\n"
"\n"
"    public void setModel(ComponentModel model) {\n"
"        this.model = model;\n"
"    }\n"
"\n"
"    public void setSession(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"
"\n"
"\n"
"    @Remove\n"
"    @Override\n"
"    public void close() {\n"
"    }\n"
"...\n"
"}"
msgstr ""
"@Stateful\n"
"@Local(EjbExampleUserStorageProvider.class)\n"
"public class EjbExampleUserStorageProvider implements UserStorageProvider,\n"
"        UserLookupProvider,\n"
"        UserRegistrationProvider,\n"
"        UserQueryProvider,\n"
"        CredentialInputUpdater,\n"
"        CredentialInputValidator,\n"
"        OnUserCache\n"
"{\n"
"    @PersistenceContext\n"
"    protected EntityManager em;\n"
"\n"
"    protected ComponentModel model;\n"
"    protected KeycloakSession session;\n"
"\n"
"    public void setModel(ComponentModel model) {\n"
"        this.model = model;\n"
"    }\n"
"\n"
"    public void setSession(KeycloakSession session) {\n"
"        this.session = session;\n"
"    }\n"
"\n"
"\n"
"    @Remove\n"
"    @Override\n"
"    public void close() {\n"
"    }\n"
"...\n"
"}"

msgid ""
"You have to define the `@Local` annotation and specify your provider class "
"there. If you do not do this, EJB will not proxy the user correctly and your"
" provider won't work."
msgstr ""
"`@Local` "
"アノテーションを定義して、そこにプロバイダー・クラスを指定する必要があります。これをしないと、EJBはユーザーを正しくプロキシーしないので、プロバイダーは動作しません。"

msgid ""
"You must put the `@Remove` annotation on the `close()` method of your "
"provider. If you do not, the stateful bean will never be cleaned up and you "
"might eventually see error messages."
msgstr ""
"`@Remove` アノテーションは、プロバイダーの `close()` "
"メソッドに付与する必要があります。そうしないと、ステートフルBeanはクリーンアップされず、最終的にエラーメッセージが表示されることがあります。"

msgid ""
"Implementations of `UserStorageProvider` are required to be plain Java "
"objects. Your factory class would perform a JNDI lookup of the Stateful EJB "
"in its create() method."
msgstr ""
"`UserStorageProvider` "
"の実装はプレーンなJavaオブジェクトである必要があります。ファクトリー・クラスは、create()メソッドでステートフルEJBのJNDIルックアップを実行します。"

msgid ""
"public class EjbExampleUserStorageProviderFactory\n"
"        implements UserStorageProviderFactory<EjbExampleUserStorageProvider> {\n"
"\n"
"    @Override\n"
"    public EjbExampleUserStorageProvider create(KeycloakSession session, ComponentModel model) {\n"
"        try {\n"
"            InitialContext ctx = new InitialContext();\n"
"            EjbExampleUserStorageProvider provider = (EjbExampleUserStorageProvider)ctx.lookup(\n"
"                     \"java:global/user-storage-jpa-example/\" + EjbExampleUserStorageProvider.class.getSimpleName());\n"
"            provider.setModel(model);\n"
"            provider.setSession(session);\n"
"            return provider;\n"
"        } catch (Exception e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }"
msgstr ""
"public class EjbExampleUserStorageProviderFactory\n"
"        implements UserStorageProviderFactory<EjbExampleUserStorageProvider> {\n"
"\n"
"    @Override\n"
"    public EjbExampleUserStorageProvider create(KeycloakSession session, ComponentModel model) {\n"
"        try {\n"
"            InitialContext ctx = new InitialContext();\n"
"            EjbExampleUserStorageProvider provider = (EjbExampleUserStorageProvider)ctx.lookup(\n"
"                     \"java:global/user-storage-jpa-example/\" + EjbExampleUserStorageProvider.class.getSimpleName());\n"
"            provider.setModel(model);\n"
"            provider.setSession(session);\n"
"            return provider;\n"
"        } catch (Exception e) {\n"
"            throw new RuntimeException(e);\n"
"        }\n"
"    }"

msgid ""
"This example also assumes that you have defined a JPA deployment in the same"
" JAR as the provider. This means a `persistence.xml` file as well as any JPA"
" `@Entity` classes."
msgstr ""
"また、この例では、プロバイダーと同じJAR内にJPAデプロイメントを定義していることを前提としています。これはJPAの `@Entity` "
"クラスだけでなく `persistence.xml` ファイルも意味します。"

msgid ""
"When using JPA any additional datasource must be an XA datasource. The "
"{project_name} datasource          is not an XA datasource. If you interact "
"with two or more non-XA datasources in the same transaction, the server "
"returns          an error message. Only one non-XA resource is permitted in "
"a single transaction. See the {appserver_name} manual for more details on "
"deploying an XA datasource."
msgstr ""
"JPAを使用する場合、追加のデータソースはXAデータソースでなければなりません。{project_name}データソースはXAデータソースではありません。同じトランザクションで2つ以上の非XAデータソースと対話する場合、サーバーはエラーメッセージを返します。単一のトランザクションでは、非XAリソースは1つだけ許可されます。XAデータソースのデプロイの詳細については、{appserver_name}のマニュアルを参照してください。"

msgid "CDI is not supported."
msgstr "CDIはサポートされていません。"

msgid "REST management API"
msgstr "REST管理API"

msgid ""
"You can create, remove, and update your user storage provider deployments "
"through the administrator REST API. The User Storage SPI is built on top of "
"a generic component interface so you will be using that generic API to "
"manage your providers."
msgstr ""
"管理者のREST "
"APIを使用して、ユーザー・ストレージ・プロバイダーの配備を作成、削除、更新できます。ユーザー・ストレージSPIは汎用コンポーネント・インターフェイスの上に構築されているため、汎用APIを使用してプロバイダーを管理します。"

msgid "The REST Component API lives under your realm admin resource."
msgstr "RESTコンポーネントAPIは、レルム管理リソースの下にあります。"

msgid "/admin/realms/{realm-name}/components"
msgstr "/admin/realms/{realm-name}/components"

msgid ""
"We will only show this REST API interaction with the Java client. Hopefully "
"you can extract how to do this from `curl` from this API."
msgstr ""
"このREST APIのJavaクライアントとの対話のみを示します。うまくいけば、このAPIから `curl` を使ってこれを行う方法を抽出できます。"

msgid ""
"public interface ComponentsResource {\n"
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public List<ComponentRepresentation> query();\n"
"\n"
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public List<ComponentRepresentation> query(@QueryParam(\"parent\") String parent);\n"
"\n"
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public List<ComponentRepresentation> query(@QueryParam(\"parent\") String parent, @QueryParam(\"type\") String type);\n"
"\n"
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public List<ComponentRepresentation> query(@QueryParam(\"parent\") String parent,\n"
"                                               @QueryParam(\"type\") String type,\n"
"                                               @QueryParam(\"name\") String name);\n"
"\n"
"    @POST\n"
"    @Consumes(MediaType.APPLICATION_JSON)\n"
"    Response add(ComponentRepresentation rep);\n"
"\n"
"    @Path(\"{id}\")\n"
"    ComponentResource component(@PathParam(\"id\") String id);\n"
"}\n"
"\n"
"public interface ComponentResource {\n"
"    @GET\n"
"    public ComponentRepresentation toRepresentation();\n"
"\n"
"    @PUT\n"
"    @Consumes(MediaType.APPLICATION_JSON)\n"
"    public void update(ComponentRepresentation rep);\n"
"\n"
"    @DELETE\n"
"    public void remove();\n"
"}\n"
msgstr ""
"public interface ComponentsResource {\n"
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public List<ComponentRepresentation> query();\n"
"\n"
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public List<ComponentRepresentation> query(@QueryParam(\"parent\") String parent);\n"
"\n"
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public List<ComponentRepresentation> query(@QueryParam(\"parent\") String parent, @QueryParam(\"type\") String type);\n"
"\n"
"    @GET\n"
"    @Produces(MediaType.APPLICATION_JSON)\n"
"    public List<ComponentRepresentation> query(@QueryParam(\"parent\") String parent,\n"
"                                               @QueryParam(\"type\") String type,\n"
"                                               @QueryParam(\"name\") String name);\n"
"\n"
"    @POST\n"
"    @Consumes(MediaType.APPLICATION_JSON)\n"
"    Response add(ComponentRepresentation rep);\n"
"\n"
"    @Path(\"{id}\")\n"
"    ComponentResource component(@PathParam(\"id\") String id);\n"
"}\n"
"\n"
"public interface ComponentResource {\n"
"    @GET\n"
"    public ComponentRepresentation toRepresentation();\n"
"\n"
"    @PUT\n"
"    @Consumes(MediaType.APPLICATION_JSON)\n"
"    public void update(ComponentRepresentation rep);\n"
"\n"
"    @DELETE\n"
"    public void remove();\n"
"}\n"

msgid ""
"To create a user storage provider, you must specify the provider id, a "
"provider type of the string `org.keycloak.storage.UserStorageProvider`, as "
"well as the configuration."
msgstr ""
"ユーザー・ストレージ・プロバイダーを作成するには、プロバイダーID、文字列  "
"`org.keycloak.storage.UserStorageProvider` のプロバイダー・タイプ、および設定を指定する必要があります。"

msgid ""
"import org.keycloak.admin.client.Keycloak;\n"
"import org.keycloak.representations.idm.RealmRepresentation;\n"
"...\n"
"\n"
"Keycloak keycloak = Keycloak.getInstance(\n"
"    \"http://localhost:8080{kc_base_path}\",\n"
"    \"master\",\n"
"    \"admin\",\n"
"    \"password\",\n"
"    \"admin-cli\");\n"
"RealmResource realmResource = keycloak.realm(\"master\");\n"
"RealmRepresentation realm = realmResource.toRepresentation();\n"
"\n"
"ComponentRepresentation component = new ComponentRepresentation();\n"
"component.setName(\"home\");\n"
"component.setProviderId(\"readonly-property-file\");\n"
"component.setProviderType(\"org.keycloak.storage.UserStorageProvider\");\n"
"component.setParentId(realm.getId());\n"
"component.setConfig(new MultivaluedHashMap());\n"
"component.getConfig().putSingle(\"path\", \"~/users.properties\");\n"
"\n"
"realmResource.components().add(component);\n"
"\n"
"// retrieve a component\n"
"\n"
"List<ComponentRepresentation> components = realmResource.components().query(realm.getId(),\n"
"                                                                    \"org.keycloak.storage.UserStorageProvider\",\n"
"                                                                    \"home\");\n"
"component = components.get(0);\n"
"\n"
"// Update a component\n"
"\n"
"component.getConfig().putSingle(\"path\", \"~/my-users.properties\");\n"
"realmResource.components().component(component.getId()).update(component);\n"
"\n"
"// Remove a component\n"
"\n"
"realmREsource.components().component(component.getId()).remove();"
msgstr ""
"import org.keycloak.admin.client.Keycloak;\n"
"import org.keycloak.representations.idm.RealmRepresentation;\n"
"...\n"
"\n"
"Keycloak keycloak = Keycloak.getInstance(\n"
"    \"http://localhost:8080{kc_base_path}\",\n"
"    \"master\",\n"
"    \"admin\",\n"
"    \"password\",\n"
"    \"admin-cli\");\n"
"RealmResource realmResource = keycloak.realm(\"master\");\n"
"RealmRepresentation realm = realmResource.toRepresentation();\n"
"\n"
"ComponentRepresentation component = new ComponentRepresentation();\n"
"component.setName(\"home\");\n"
"component.setProviderId(\"readonly-property-file\");\n"
"component.setProviderType(\"org.keycloak.storage.UserStorageProvider\");\n"
"component.setParentId(realm.getId());\n"
"component.setConfig(new MultivaluedHashMap());\n"
"component.getConfig().putSingle(\"path\", \"~/users.properties\");\n"
"\n"
"realmResource.components().add(component);\n"
"\n"
"// retrieve a component\n"
"\n"
"List<ComponentRepresentation> components = realmResource.components().query(realm.getId(),\n"
"                                                                    \"org.keycloak.storage.UserStorageProvider\",\n"
"                                                                    \"home\");\n"
"component = components.get(0);\n"
"\n"
"// Update a component\n"
"\n"
"component.getConfig().putSingle(\"path\", \"~/my-users.properties\");\n"
"realmResource.components().component(component.getId()).update(component);\n"
"\n"
"// Remove a component\n"
"\n"
"realmREsource.components().component(component.getId()).remove();"

msgid "Migrating from an earlier user federation SPI"
msgstr "以前のユーザー・フェデレーションSPIからの移行"

msgid ""
"This chapter is only applicable if you have implemented a provider using the"
" earlier (and now removed)        User Federation SPI."
msgstr "この章は、以前の（および現在は削除された）ユーザー・フェデレーションSPIを使用してプロバイダーを実装した場合にのみ適用されます。"

msgid ""
"In Keycloak version 2.4.0 and earlier there was a User Federation SPI. Red "
"Hat Single Sign-On version 7.0, although unsupported, had this earlier SPI "
"available as well. This earlier User Federation SPI has been removed from "
"Keycloak version 2.5.0 and Red Hat Single Sign-On version 7.1. However, if "
"you have written a provider with this earlier SPI, this chapter discusses "
"some strategies you can use to port it."
msgstr ""
"Keycloakバージョン2.4.0以前では、 ユーザー・フェデレーション SPIがありました。Red Hat Single Sign-"
"Onバージョン7.0は、サポートされていませんが、以前のSPIが利用可能でした。この以前のユーザー・フェデレーションSPIは、Keycloakバージョン2.5.0およびRed"
" Hat Single Sign-"
"Onバージョン7.1から削除されました。しかし、この章では、このSPIを使用してプロバイダーを作成した場合の、SPIを移植するためのいくつかの方法について説明します。"

msgid "Import versus non-import"
msgstr "インポート非インポートの比較"

msgid ""
"The earlier User Federation SPI required you to create a local copy of a "
"user in the {project_name}'s database and import information from your "
"external store to the local copy. However, this is no longer a requirement. "
"You can still port your earlier provider as-is, but you should consider "
"whether a non-import strategy might be a better approach."
msgstr ""
"以前のユーザー・フェデレーションSPIでは、{project_name}のデータベース内でユーザーのローカルコピーを作成し、外部ストアからの情報をローカルコピーにインポートする必要がありました。しかし、これはもう要件ではなくなりました。以前のプロバイダーをそのまま移植することもできますが、インポートしない方法の方がより良いアプローチになるかを検討する必要があります。"

msgid "Advantages of the import strategy:"
msgstr "インポートによる方法の利点は、以下のとおりです。"

msgid ""
"{project_name} basically becomes a persistence user cache for your external "
"store. Once the user is imported you'll no longer hit the external store, "
"thus taking load off of it."
msgstr ""
"{project_name}は、基本的に外部ストアの永続ユーザーキャッシュになります。ユーザーがインポートされると、外部ストアにアクセスしなくなり、その負荷が無くなります。"

msgid ""
"If you are moving to {project_name} as your official user store and "
"deprecating the earlier external store, you can slowly migrate applications "
"to use {project_name}. When all applications have been migrated, unlink the "
"imported user, and retire the earlier legacy external store."
msgstr ""
"公式のユーザーストアを{project_name}にし、従来の外部ストアは廃止する場合、アプリケーションを徐々に移行して{project_name}を使用することができます。すべてのアプリケーションが移行されたら、インポートされたユーザーのリンクを解除し、従来のレガシー外部ストアは廃止します。"

msgid ""
"Looking up a user for the first time will require multiple updates to "
"{project_name} database. This can be a big performance loss under load and "
"put a lot of strain on the {project_name} database. The user federated "
"storage approach will only store extra data as needed and might never be "
"used depending on the capabilities of your external store."
msgstr ""
"初回のユーザーの検索では、{project_name}のデータベースを複数回更新する必要があります。これは大きなパフォーマンス低下を招き、{project_name}のデータベースに多くの負担をかけることになります。ユーザー・フェデレーティッド・ストレージのアプローチでは、必要に応じて追加のデータのみが保存されるだけであり、外部ストアの機能によってはまったく使用されない可能性もあります。"

msgid "UserFederationProvider versus UserStorageProvider"
msgstr "UserFederationProviderとUserStorageProviderの比較"

msgid ""
"The first thing to notice is that `UserFederationProvider` was a complete "
"interface. You implemented every method in this interface. However, "
"`UserStorageProvider` has instead broken up this interface into multiple "
"capability interfaces that you implement as needed."
msgstr ""
"最初に注意することは、 `UserFederationProvider` "
"が完全なインターフェイスだったということです。このインターフェイスにはすべてのメソッドを実装しました。ただし、 "
"`UserStorageProvider` "
"では、代わりにこのインターフェイスを、必要に応じて実装可能な複数のケイパビリティー・インターフェイスに分割しています。"

msgid ""
"`UserFederationProvider.getUserByUsername()` and `getUserByEmail()` have "
"exact equivalents in the new SPI. The difference between the two is how you "
"import. If you are going to continue with an import strategy, you no longer "
"call `KeycloakSession.userStorage().addUser()` to create the user locally. "
"Instead you call `KeycloakSession.userLocalStorage().addUser()`. The "
"`userStorage()` method no longer exists."
msgstr ""
"`UserFederationProvider.getUserByUsername()` と `getUserByEmail()` "
"は、新しいSPIに完全に同等のものを持ちます。この両者の違いはインポート方法にあります。インポート・ストラテジーを引き続き使用している場合、ユーザーをローカルで作成するために"
" `KeycloakSession.userStorage().addUser()` を呼び出す必要はありません。その代わりに、 "
"`KeycloakSession.userLocalStorage().addUser()` を呼び出します。 `userStorage()` "
"メソッドは存在しません。"

msgid ""
"The `UserFederationProvider.validateAndProxy()` method has been moved to an "
"optional capability interface, `ImportedUserValidation`. You want to "
"implement this interface if you are porting your earlier provider as-is. "
"Also note that in the earlier SPI, this method was called every time the "
"user was accessed, even if the local user is in the cache. In the later SPI,"
" this method is only called when the local user is loaded from local "
"storage. If the local user is cached, then the "
"`ImportedUserValidation.validate()` method is not called at all."
msgstr ""
"`UserFederationProvider.validateAndProxy()` メソッドは、オプションのケーパビリティー・インターフェイス、 "
"`ImportedUserValidation` "
"に移動されました。以前のプロバイダーをそのまま移植する場合は、このインターフェイスを実装します。また、以前のSPIでは、ローカルユーザーがキャッシュ内にあっても、ユーザーがアクセスされるたびにこのメソッドが呼び出されました。新しいSPIでは、このメソッドはローカルユーザーがローカル・ストレージからロードされたときにのみ呼び出されます。ローカルユーザーがキャッシュされている場合、"
" `ImportedUserValidation.validate()` メソッドはまったく呼び出されません。"

msgid ""
"The `UserFederationProvider.isValid()` method no longer exists in the later "
"SPI."
msgstr "`UserFederationProvider.isValid()` メソッドは、新しいSPIには存在しません。"

msgid ""
"The `UserFederationProvider` methods `synchronizeRegistrations()`, "
"`registerUser()`, and `removeUser()` have been moved to the "
"`UserRegistrationProvider` capability interface. This new interface is "
"optional to implement so if your provider does not support creating and "
"removing users, you don't have to implement it. If your earlier provider had"
" switch to toggle support for registering new users, this is supported in "
"the new SPI, returning `null` from `UserRegistrationProvider.addUser()` if "
"the provider doesn't support adding users."
msgstr ""
"`UserFederationProvider` のメソッド `synchronizeRegistrations()` 、 "
"`registerUser()` 、 `removeUser()` は `UserRegistrationProvider` "
"のケーパビリティー・インターフェイスに移動されました。この新しいインターフェイスは実装するためにオプションです。プロバイダーがユーザーの作成と削除をサポートしていない場合は、実装する必要はありません。以前のプロバイダーが新しいユーザーの登録をサポートするように切り替えた場合、新しいSPIではこれがサポートされ、プロバイダーがユーザーの追加をサポートしていない場合は、"
" `UserRegistrationProvider.addUser()` から `null` が返されます。"

msgid ""
"The earlier `UserFederationProvider` methods centered around credentials are"
" now encapsulated in the `CredentialInputValidator` and "
"`CredentialInputUpdater` interfaces, which are also optional to implement "
"depending on if you support validating or updating credentials.  Credential "
"management used to exist in `UserModel` methods. These also have been moved "
"to the `CredentialInputValidator` and `CredentialInputUpdater` interfaces. "
"One thing to note that if you do not implement the `CredentialInputUpdater` "
"interface, then any credentials provided by your provider can be overridden "
"locally in {project_name} storage. So if you want your credentials to be "
"read-only, implement the `CredentialInputUpdater.updateCredential()` method "
"and return a `ReadOnlyException`."
msgstr ""
"クレデンシャルを中心とした以前の `UserFederationProvider` メソッドは `CredentialInputValidator` と"
" `CredentialInputUpdater` "
"インターフェイスにカプセル化されました。この実装は任意で、クレデンシャルの検証や更新をサポートするかどうかによって異なります。クレデンシャル管理は "
"`UserModel` メソッドに存在しましたが、これらも `CredentialInputValidator` と "
"`CredentialInputUpdater` インターフェイスに移行されました。 `CredentialInputUpdater` "
"インターフェイスを実装しないと、プロバイダーが提供するクレデンシャルは{project_name}ストレージ内でローカルにオーバーライドされる可能性があることに注意してください。したがって、クレデンシャルを読み取り専用にする場合は、"
" `CredentialInputUpdater.updateCredential()` メソッドを実装し、 `ReadOnlyException` "
"を返します。"

msgid ""
"The `UserFederationProvider` query methods such as `searchByAttributes()` "
"and `getGroupMembers()` are now encapsulated in an optional interface "
"`UserQueryProvider`. If you do not implement this interface, then users will"
" not be viewable in the admin console.  You'll still be able to log in "
"though."
msgstr ""
"`searchByAttributes()` や `getGroupMembers()` のような `UserFederationProvider` "
"のクエリーメソッドは、オプションのインターフェイス `UserQueryProvider` "
"にカプセル化されました。このインターフェイスを実装しないと、管理コンソールでユーザーを表示できなくなります。なお、ログインすることはできます。"

msgid "UserFederationProviderFactory versus UserStorageProviderFactory"
msgstr "UserFederationProviderFactoryとUserStorageProviderFactoryの比較"

msgid ""
"The synchronization methods in the earlier SPI are now encapsulated within "
"an optional `ImportSynchronization` interface. If you have implemented "
"synchronization logic, then have your new `UserStorageProviderFactory` "
"implement the `ImportSynchronization` interface."
msgstr ""
"以前のSPIの同期メソッドは、現在、オプションの `ImportSynchronization` "
"インターフェイスにカプセル化されています。同期ロジックを実装している場合は、新しい `UserStorageProviderFactory` に "
"`ImportSynchronization` インターフェイスを実装してください。"

msgid "Upgrading to a new model"
msgstr "新しいモデルへのアップグレード"

msgid ""
"The User Storage SPI instances are stored in a different set of relational "
"tables. {project_name} automatically runs a migration script. If any earlier"
" User Federation providers are deployed for a realm, they are converted to "
"the later storage model as is, including the `id` of the data. This "
"migration will only happen if a User Storage provider exists with the same "
"provider ID (i.e., \"ldap\", \"kerberos\") as the earlier User Federation "
"provider."
msgstr ""
"ユーザーストレージSPIインスタンスは、異なる一連のリレーショナル・テーブルに格納されます。 "
"{project_name}は自動的に移行スクリプトを実行します。レルムに対して以前のユーザー・フェデレーション・プロバイダーがデプロイされている場合、データの"
" `ID` "
"を含め、それ以降のストレージモデルにそのまま変換されます。この移行は、以前のユーザー・フェデレーション・プロバイダーと同じプロバイダーID（\"ldap\"、\"kerberos\"など）を持つユーザー・ストレージ・プロバイダーが存在する場合にのみ発生します。"

msgid "So, knowing this there are different approaches you can take."
msgstr "これを知ることにより、取ることができるさまざまなアプローチがあります。"

msgid ""
"You can remove the earlier provider in your earlier {project_name} "
"deployment. This will remove the local linked copies of all users you "
"imported.  Then, when you upgrade {project_name}, just deploy and configure "
"your new provider for your realm."
msgstr ""
"以前の{project_name}のデプロイメントで、以前のプロバイダーを削除することができます。これにより、インポートした全ユーザーのローカルリンクされたコピーが削除されます。次に、{project_name}をアップグレードするときに、レルム用に新しいプロバイダーをデプロイして設定するだけです。"

msgid ""
"The second option is to write your new provider making sure it has the same "
"provider ID: `UserStorageProviderFactory.getId()`. Make sure this provider "
"is deployed to the server.  Boot the server, and have the built-in migration"
" script convert from the earlier data model to the later data model. In this"
" case all your earlier linked imported users will work and be the same."
msgstr ""
"2つ目のオプションは、プロバイダーIDが同じであることを `UserStorageProviderFactory.getId()` "
"で確認する新しいプロバイダーを実装することです。このプロバイダーがサーバーでデプロイされていることを確認してください。サーバーを起動し、組み込みの移行スクリプトで以前のデータモデルを新しいデータモデルに変換します。この場合、以前にリンクされたインポート済みユーザーは、正常に動作し、すべて同じになります。"

msgid ""
"If you have decided to get rid of the import strategy and rewrite your User "
"Storage provider, we suggest that you remove the earlier provider before "
"upgrading {project_name}. This will remove linked local imported copies of "
"any user you imported."
msgstr ""
"インポートによる方法を廃止してユーザー・ストレージ・プロバイダーを実装し直すことに決めた場合は、{project_name}をアップグレードする前に以前のプロバイダーを削除することをお勧めします。これにより、インポートされたすべてのユーザーのリンクされたローカル・インポート済みのコピーが削除されます。"

msgid "Stream-based interfaces"
msgstr "ストリームベースのインターフェイス"

msgid ""
"Many of the user storage interfaces in {project_name} contain query methods "
"that can return potentially large sets of objects, which might lead to "
"significant impacts in terms of memory consumption and processing time. This"
" is especially true when only a small subset of the objects' internal state "
"is used in the query method's logic."
msgstr ""
"{project_name}のユーザー・ストレージ・インターフェイスの多くには、潜在的に大きなオブジェクトのセットを返す可能性のあるクエリーメソッドが含まれているため、メモリー消費と処理時間の点で重大な影響が生じる可能性があります。これは、オブジェクトの内部状態の小さなサブセットのみがクエリーメソッドのロジックで使用される場合に特に当てはまります。"

msgid ""
"To provide developers with a more efficient alternative to process large "
"data sets in these query methods, a `Streams` sub-interface has been added "
"to user storage interfaces. These `Streams` sub-interfaces replace the "
"original collection-based methods in the super-interfaces with stream-based "
"variants, making the collection-based methods default. The default "
"implementation of a collection-based query method invokes its `Stream` "
"counterpart and collects the result into the proper collection type."
msgstr ""
"これらのクエリーメソッドで大規模なデータセットを処理するためのより効率的な代替手段を開発者に提供するために、ユーザー・ストレージ・インターフェイスに "
"`Streams` サブ・インターフェイスが追加されました。これらの `Streams` "
"サブ・インターフェイスは、スーパー・インターフェイスの元のコレクションベースのメソッドをストリームベースの異なる形に置き換え、コレクション・ベースのメソッドをデフォルトにします。コレクション・ベースのクエリーメソッドのデフォルトの実装は、対応する"
" `Stream` を呼び出し、結果を適切なコレクション・タイプに収集します。"

msgid ""
"The `Streams` sub-interfaces allow for implementations to focus on the "
"stream-based approach for processing sets of data and benefit from the "
"potential memory and performance optimizations of that approach. The "
"interfaces that offer a `Streams` sub-interface to be implemented include a "
"few _<<_provider_capability_interfaces,capability interfaces>>_, all "
"interfaces in the `org.keycloak.storage.federated` package and a few others "
"that might be implemented depending on the scope of the custom storage "
"implementation."
msgstr ""
"`Streams` "
"サブ・インターフェイスにより、実装はデータセットを処理するためのストリームベースのアプローチにフォーカスし、そのアプローチの潜在的なメモリーとパフォーマンスの最適化から利益を得ることができます。実装される"
" `Streams` サブ・インターフェイスを提供するインターフェイスには、いくつかの "
"_<<_provider_capability_interfaces, ケイパビリティー・インターフェイス >>_ （ "
"`org.keycloak.storage.federated` "
"パッケージ内のすべてのインターフェイスと、カスタムストレージ実装のスコープに応じて実装される可能性のあるその他のいくつかのインターフェイス）が含まれます。"

msgid ""
"See this list of the interfaces that offer a `Streams` sub-interface to "
"developers."
msgstr "開発者に `Streams` サブ・インターフェイスを提供するインターフェイスのリストを参照してください。"

msgid "Package"
msgstr "Package"

msgid "Classes"
msgstr "Classes"

msgid "`org.keycloak.credential`"
msgstr "`org.keycloak.credential`"

msgid "`CredentialInputUpdater`(*), `UserCredentialStore`"
msgstr "`CredentialInputUpdater`(*), `UserCredentialStore`"

msgid "`org.keycloak.models`"
msgstr "`org.keycloak.models`"

msgid ""
"`GroupModel`, `RoleMapperModel`, `UserCredentialManager`, `UserModel`, "
"`UserProvider`"
msgstr ""
"`GroupModel` 、 `RoleMapperModel` 、 `UserCredentialManager` 、 `UserModel` 、 "
"`UserProvider`"

msgid "`org.keycloak.models.cache`"
msgstr "`org.keycloak.models.cache`"

msgid "`CachedUserModel`, `UserCache`"
msgstr "`CachedUserModel` 、 `UserCache`"

msgid "`org.keycloak.storage.federated`"
msgstr "`org.keycloak.storage.federated`"

msgid "All interfaces"
msgstr "すべてのインターフェイス"

msgid "`org.keycloak.storage.user`"
msgstr "`org.keycloak.storage.user`"

msgid "`UserQueryProvider`(*)"
msgstr "`UserQueryProvider`(*)"

msgid ""
"(*) indicates the interface is a "
"_<<_provider_capability_interfaces,capability interface>>_"
msgstr ""
"(*) "
"はインターフェイスが_<<_provider_capability_interfaces,ケイパビリティー・インターフェイス>>_であることを示します"

msgid ""
"Custom user storage implementation that want to benefit from the streams "
"approach should simply implement the `Streams` sub-interfaces instead of the"
" original interfaces. For example, the following code uses the `Streams` "
"variant of the `UserQueryProvider` interface:"
msgstr ""
"ストリーム・アプローチの恩恵を受けたいカスタム・ユーザー・ストレージの実装では、元のインターフェイスではなく、単に "
"`Streams`　サブ・インターフェイスを実装する必要があります。たとえば、次のコードは、 `UserQueryProvider` インターフェイスの"
" `Streams` の異形を使用しています。"

msgid ""
"public class CustomQueryProvider extends UserQueryProvider.Streams {\n"
"...\n"
"    @Override\n"
"    Stream<UserModel> getUsersStream(RealmModel realm, Integer firstResult, Integer maxResults) {\n"
"        // custom logic here\n"
"    }\n"
"\n"
"    @Override\n"
"    Stream<UserModel> searchForUserStream(String search, RealmModel realm) {\n"
"        // custom logic here\n"
"    }\n"
"...\n"
"}"
msgstr ""
"public class CustomQueryProvider extends UserQueryProvider.Streams {\n"
"...\n"
"    @Override\n"
"    Stream<UserModel> getUsersStream(RealmModel realm, Integer firstResult, Integer maxResults) {\n"
"        // custom logic here\n"
"    }\n"
"\n"
"    @Override\n"
"    Stream<UserModel> searchForUserStream(String search, RealmModel realm) {\n"
"        // custom logic here\n"
"    }\n"
"...\n"
"}"

msgid "Vault SPI"
msgstr "ボールトSPI"

msgid "Vault provider"
msgstr "ボールト・プロバイダー "

msgid ""
"You can use a vault SPI from `org.keycloak.vault` package to write custom "
"extension for {project_name} to connect to arbitrary vault implementation."
msgstr ""
"{project_name}のカスタム拡張機能を記述し、任意のボールト実装に接続するために、 `org.keycloak.vault` "
"パッケージのボールトSPIを使用できます。"

msgid ""
"The built-in `files-plaintext` provider is an example of the implementation "
"of this SPI. In general the following rules apply:"
msgstr "ビルトインの `files-plaintext` プロバイダーは、このSPIの実装の一例です。一般的に、次のルールが適用されます。"

msgid ""
"To prevent a secret from leaking across realms, you may want to isolate or "
"limit the secrets that can be retrieved by a realm. In that case, your "
"provider should take into account the realm name when looking up secrets, "
"for example by prefixing entries with the realm name. For example, an "
"expression `${vault.key}` would then evaluate generally to different entry "
"names, depending on whether it was used in a realm _A_ or realm _B_. To "
"differentiate between realms, the realm needs to be passed to the created "
"`VaultProvider` instance from `VaultProviderFactory.create()` method where "
"it is available from the `KeycloakSession` parameter."
msgstr ""
"シークレットがレルム間で漏洩するのを防ぐために、レルムによって取得できるシークレットを隔離または制限したい場合があります。その場合、プロバイダーは、たとえば、エントリーにプレフィックスとしてレルム名を付けるなどして、シークレットを検索するときにレルム名を考慮する必要があります。たとえば、式"
" `${vault.key}` は、それがレルム _A_ またはレルム _B_ "
"で使用されたかどうかに応じて、一般的に異なるエントリー名に評価されます。レルムを区別するには、 `KeycloakSession` "
"パラメーターから利用できる `VaultProviderFactory.create()` メソッドから作成された `VaultProvider` "
"インスタンスにレルムを渡す必要があります。"

msgid ""
"The vault provider needs to implement a single method `obtainSecret` that "
"returns a `VaultRawSecret` for the given secret name. That class holds the "
"representation of the secret either in `byte[]` or `ByteBuffer` and is "
"expected to convert between the two upon demand. Note that this buffer would"
" be discarded after usage as explained below."
msgstr ""
"ボールト・プロバイダーは、指定されたシークレット名に対して `VaultRawSecret` を返す単一のメソッド `obtainSecret` "
"を実装する必要があります。このクラスは、 `byte[]` または `ByteBuffer` "
"のいずれかでシークレットの表現を保持し、必要に応じて2つの間で変換することを期待されています。以下で説明するように、このバッファーは使用後に破棄されることに注意してください。"

msgid ""
"Regarding realm separation, all built-in vault provider factories allow the "
"configuration of one or more key resolvers. Represented by the "
"`VaultKeyResolver` interface, a key resolver essentially implements the "
"algorithm or strategy for combining the realm name with the key (as obtained"
" from the `${vault.key}` expression) into the final entry name that will be "
"used to retrieve the secret from the vault. The code that handles this "
"configuration has been extracted into abstract vault provider and vault "
"provider factory classes, so custom implementations that want to offer "
"support for key resolvers may extend these abstract classes instead of the "
"implementing SPI interfaces to inherit the ability to configure the key "
"resolvers that should be tried when retrieving a secret."
msgstr ""
"レルムの分離に関して、すべての組み込みのボールト・プロバイダー・ファクトリーでは、1つ以上のキーリゾルバーを設定できます。 "
"`VaultKeyResolver` インターフェイスで表されるキーリゾルバーは基本的に、レルム名とキー（ `${vault.key}` "
"式から得られる）を組み合わせて、ボールトからシークレットを取得するために使用される最終的なエントリー名を得るアルゴリズムまたは戦略を実装します。この設定を処理するコードは、抽象ボールト・プロバイダーおよびボールト・プロバイダー・ファクトリー・クラスに抽出されているため、キーリゾルバーのサポートを提供するカスタム実装は、SPIインターフェースを実装する代わりにこれらの抽象クラスを拡張して、シークレットを取得するときに試されるキーリゾルバーを設定する機能を継承できます。"

msgid "Consuming values from vault"
msgstr "ボールトから取得した値を消費する"

msgid ""
"The vault contains sensitive data and {project_name} treats the secrets "
"accordingly. When accessing a secret, the secret is obtained from the vault "
"and retained in JVM memory only for the necessary time. Then all possible "
"attempts to discard its content from JVM memory is done. This is achieved by"
" using the vault secrets only within `try`-with-resources statement as "
"outlined below:"
msgstr ""
"ボールトには機密データが含まれており、{project_name}はそれに応じてシークレットを扱います。シークレットにアクセスすると、シークレットはボールトから取得され、必要な時間だけJVMメモリーに保持されます。その後、JVMメモリーからコンテンツを破棄するすべての可能な試行が行われます。これは、以下で概説するように、"
" `try-with-resources` ステートメント内でのみボールト・シークレットを使用することで実現されます。"

msgid ""
"    char[] c;\n"
"    try (VaultCharSecret cSecret = session.vault().getCharSecret(SECRET_NAME)) {\n"
"        // ... use cSecret\n"
"        c = cSecret.getAsArray().orElse(null);\n"
"        // if c != null, it now contains password\n"
"    }\n"
"\n"
"    // if c != null, it now contains garbage"
msgstr ""
"    char[] c;\n"
"    try (VaultCharSecret cSecret = session.vault().getCharSecret(SECRET_NAME)) {\n"
"        // ... use cSecret\n"
"        c = cSecret.getAsArray().orElse(null);\n"
"        // if c != null, it now contains password\n"
"    }\n"
"\n"
"    // if c != null, it now contains garbage"

msgid ""
"The example uses `KeycloakSession.vault()` as the entrypoint for accessing "
"the secrets. Using the `VaultProvider.obtainSecret` method directly is "
"indeed also possible. However the `vault()` method has the benefit of "
"ability to interpret the raw secret (which is generally a byte array) as a "
"character array (via `vault().getCharSecret()`) or a `String` (via "
"`vault().getStringSecret()`) in addition to obtaining the original "
"uninterpreted value (via `vault().getRawSecret()` method)."
msgstr ""
"この例では、シークレットにアクセスするためのエントリー・ポイントとして `KeycloakSession.vault()` を使用しています。 "
"`VaultProvider.obtainSecret` メソッドを直接使用することもできます。しかし、 `vault()` メソッドは、（ "
"`vault().getRawSecret()` メソッドを介して）元の未解釈の値を取得することに加えて、文字配列（ "
"`vault().getStringSecret()` 経由）または `String` （ `vault().getStringSecret()` "
"）で平文のシークレット（通常はバイト配列）を解釈できる利点があります。"

msgid ""
"Note that since `String` objects are immutable, their content cannot be "
"discarded by overriding with random garbage. Even though measures have been "
"taken in the default `VaultStringSecret` implementation to prevent "
"internalizing ``String``s, the secrets stored in `String` objects would live"
" at least to the next GC round. Thus using plain byte and character arrays "
"and buffers is preferable."
msgstr ""
"`String` オブジェクトは不変であるため、ランダムなガーベージでオーバーライドしてもコンテンツを破棄できないことに注意してください。デフォルトの "
"`VaultStringSecret` の実装では ``String`` の内部化を防ぐための対策が講じられていますが、 `String` "
"オブジェクトに保存されたシークレットは少なくとも次のGCラウンドまで存続します。したがって、プレーンなバイト配列と文字配列およびバッファーを使用することをお勧めします。"
